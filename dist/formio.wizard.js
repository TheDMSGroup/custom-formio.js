(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FormioComponents = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _each2 = require('lodash/each');

var _each3 = _interopRequireDefault(_each2);

var _clone2 = require('lodash/clone');

var _clone3 = _interopRequireDefault(_clone2);

var _remove2 = require('lodash/remove');

var _remove3 = _interopRequireDefault(_remove2);

var _assign2 = require('lodash/assign');

var _assign3 = _interopRequireDefault(_assign2);

var _nativePromiseOnly = require('native-promise-only');

var _nativePromiseOnly2 = _interopRequireDefault(_nativePromiseOnly);

var _Base = require('./base/Base');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var FormioComponents = exports.FormioComponents = function (_BaseComponent) {
  _inherits(FormioComponents, _BaseComponent);

  function FormioComponents(component, options, data) {
    _classCallCheck(this, FormioComponents);

    var _this = _possibleConstructorReturn(this, (FormioComponents.__proto__ || Object.getPrototypeOf(FormioComponents)).call(this, component, options, data));

    _this.type = 'components';
    _this.components = [];
    _this.hidden = [];
    _this.beforeNextPageCallback = null;
    return _this;
  }

  _createClass(FormioComponents, [{
    key: 'build',
    value: function build() {
      this.createElement();
      this.addComponents();
    }
  }, {
    key: 'getComponents',
    value: function getComponents() {
      return this.components;
    }

    /**
     * Perform a deep iteration over every component, including those
     * within other container based components.
     *
     * @param {function} cb - Called for every component.
     */

  }, {
    key: 'everyComponent',
    value: function everyComponent(cb) {
      var components = this.getComponents();
      (0, _each3.default)(components, function (component, index) {
        if (component.type === 'components') {
          if (component.everyComponent(cb) === false) {
            return false;
          }
        } else if (cb(component, components, index) === false) {
          return false;
        }
      });
    }

    /**
     * Perform an iteration over each component within this container component.
     *
     * @param {function} cb - Called for each component
     */

  }, {
    key: 'eachComponent',
    value: function eachComponent(cb) {
      (0, _each3.default)(this.getComponents(), function (component, index) {
        if (cb(component, index) === false) {
          return false;
        }
      });
    }

    /**
     * Returns a component provided a key. This performs a deep search within the
     * component tree.
     *
     * @param {string} key - The key of the component to retrieve.
     * @param {function} cb - Called with the component once found.
     * @return {Object} - The component that is located.
     */

  }, {
    key: 'getComponent',
    value: function getComponent(key, cb) {
      var comp = null;
      this.everyComponent(function (component, components) {
        if (component.component.key === key) {
          comp = component;
          if (cb) {
            cb(component, components);
          }
          return false;
        }
      });
      return comp;
    }

    /**
     * Return a component provided the Id of the component.
     *
     * @param {string} id - The Id of the component.
     * @param {function} cb - Called with the component once it is retrieved.
     * @return {Object} - The component retrieved.
     */

  }, {
    key: 'getComponentById',
    value: function getComponentById(id, cb) {
      var comp = null;
      this.everyComponent(function (component, components) {
        if (component.id === id) {
          comp = component;
          if (cb) {
            cb(component, components);
          }
          return false;
        }
      });
      return comp;
    }

    /**
     * Add a new component to the components array.
     *
     * @param {Object} component - The component JSON schema to add.
     * @param {HTMLElement} element - The DOM element to append this child to.
     * @param {Object} data - The submission data object to house the data for this component.
     * @return {BaseComponent} - The created component instance.
     */

  }, {
    key: 'addComponent',
    value: function addComponent(component, element, data) {
      element = element || this.element;
      data = data || this.data;
      var components = require('./index');
      component.row = this.row;
      var comp = components.create(component, this.options, data);
      this.components.push(comp);
      this.setHidden(comp);
      element.appendChild(comp.getElement());
      return comp;
    }

    /**
     * Remove a component from the components array.
     *
     * @param {BaseComponent} component - The component to remove from the components.
     * @param {Array<BaseComponent>} components - An array of components to remove this component from.
     */

  }, {
    key: 'removeComponent',
    value: function removeComponent(component, components) {
      component.destroy();
      var element = component.getElement();
      if (element && element.parentNode) {
        element.parentNode.removeChild(element);
      }
      (0, _remove3.default)(components, { id: component.id });
    }

    /**
     * Removes a component provided the API key of that component.
     *
     * @param {string} key - The API key of the component to remove.
     * @param {function} cb - Called once the component is removed.
     * @return {null}
     */

  }, {
    key: 'removeComponentByKey',
    value: function removeComponentByKey(key, cb) {
      var _this2 = this;

      var comp = this.getComponent(key, function (component, components) {
        _this2.removeComponent(component, components);
        if (cb) {
          cb(component, components);
        }
      });
      if (!comp) {
        if (cb) {
          cb(null);
        }
        return null;
      }
    }

    /**
     * Removes a component provided the Id of the component.
     *
     * @param {string} id - The Id of the component to remove.
     * @param {function} cb - Called when the component is removed.
     * @return {null}
     */

  }, {
    key: 'removeComponentById',
    value: function removeComponentById(id, cb) {
      var _this3 = this;

      var comp = this.getComponentById(id, function (component, components) {
        _this3.removeComponent(component, components);
        if (cb) {
          cb(component, components);
        }
      });
      if (!comp) {
        if (cb) {
          cb(null);
        }
        return null;
      }
    }

    /**
     *
     * @param element
     * @param data
     */

  }, {
    key: 'addComponents',
    value: function addComponents(element, data) {
      var _this4 = this;

      element = element || this.element;
      data = data || this.data;
      (0, _each3.default)(this.component.components, function (component) {
        return _this4.addComponent(component, element, data);
      });
    }
  }, {
    key: 'updateValue',
    value: function updateValue(noValidate) {
      (0, _each3.default)(this.components, function (comp) {
        return comp.updateValue(noValidate);
      });
    }

    /**
     * A more performant way to check the conditions, calculations, and validity of
     * a submission once it has been changed.
     *
     * @param data
     * @param noValidate
     */

  }, {
    key: 'checkData',
    value: function checkData(data, noValidate) {
      (0, _each3.default)(this.getComponents(), function (comp) {
        if (comp.type !== 'formcomponent') {
          comp.checkConditions(data);
          comp.calculateValue(data);
          if (!noValidate) {
            comp.checkValidity(data);
          }
        }
      });
    }
  }, {
    key: 'checkConditions',
    value: function checkConditions(data) {
      var show = _get(FormioComponents.prototype.__proto__ || Object.getPrototypeOf(FormioComponents.prototype), 'checkConditions', this).call(this, data);
      (0, _each3.default)(this.getComponents(), function (comp) {
        show |= comp.checkConditions(data);
      });
      return show;
    }

    /**
     * Allow components to hook into the next page trigger to perform their own logic.
     *
     * @return {*}
     */

  }, {
    key: 'beforeNext',
    value: function beforeNext() {
      var ops = [];
      (0, _each3.default)(this.getComponents(), function (comp) {
        return ops.push(comp.beforeNext());
      });
      return _nativePromiseOnly2.default.all(ops);
    }

    /**
     * Allow components to hook into the submission to provide their own async data.
     *
     * @return {*}
     */

  }, {
    key: 'beforeSubmit',
    value: function beforeSubmit() {
      var ops = [];
      (0, _each3.default)(this.getComponents(), function (comp) {
        return ops.push(comp.beforeSubmit());
      });
      return _nativePromiseOnly2.default.all(ops);
    }
  }, {
    key: 'calculateValue',
    value: function calculateValue(data) {
      _get(FormioComponents.prototype.__proto__ || Object.getPrototypeOf(FormioComponents.prototype), 'calculateValue', this).call(this, data);
      (0, _each3.default)(this.getComponents(), function (comp) {
        return comp.calculateValue(data);
      });
    }
  }, {
    key: 'checkValidity',
    value: function checkValidity(data, dirty) {
      var check = _get(FormioComponents.prototype.__proto__ || Object.getPrototypeOf(FormioComponents.prototype), 'checkValidity', this).call(this, data, dirty);
      (0, _each3.default)(this.getComponents(), function (comp) {
        check &= comp.checkValidity(data, dirty);
      });
      return check;
    }
  }, {
    key: 'destroy',
    value: function destroy(all) {
      var _this5 = this;

      _get(FormioComponents.prototype.__proto__ || Object.getPrototypeOf(FormioComponents.prototype), 'destroy', this).call(this, all);
      var components = (0, _clone3.default)(this.components);
      (0, _each3.default)(components, function (comp) {
        return _this5.removeComponent(comp, _this5.components);
      });
    }
  }, {
    key: 'setHidden',
    value: function setHidden(component) {
      if (component.components && component.components.length) {
        component.hideComponents(this.hidden);
      } else if (component.component.hidden) {
        component.visible = false;
      } else {
        component.visible = !this.hidden || this.hidden.indexOf(component.component.key) === -1;
      }
    }
  }, {
    key: 'hideComponents',
    value: function hideComponents(hidden) {
      var _this6 = this;

      this.hidden = hidden;
      this.eachComponent(function (component) {
        return _this6.setHidden(component);
      });
    }
  }, {
    key: 'getBeforeNextPageCallback',

    // DMS

    value: function getBeforeNextPageCallback() {
      return this.beforeNextPageCallback;
    }

    // DMS

  }, {
    key: 'setBeforeNextPageCallback',
    value: function setBeforeNextPageCallback(beforeNextPageCallback) {
      this.beforeNextPageCallback = beforeNextPageCallback;
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return this.data;
    }
  }, {
    key: 'setValue',
    value: function setValue(value, noUpdate, noValidate) {
      if (!value) {
        return;
      }
      this.value = value;
      (0, _each3.default)(this.getComponents(), function (component) {
        if (component.type === 'button') {
          return;
        }

        //console.dir(component);

        //console.log('setValue' + '.' + 'component.type');
        //console.log(component.type);

        if (component.type === 'components') {
          component.setValue(value, noUpdate, noValidate);
        } else if (value && value.hasOwnProperty(component.component.key)) {
          if (component.type === 'select') {
            //console.log('component is a select');
          } else {
            component.setValue(value[component.component.key], noUpdate);
          }
        } else if (component.component.input) {
          component.setValue(null, noUpdate, true);
        }
      });
    }
  }, {
    key: 'disabled',
    set: function set(disabled) {
      (0, _each3.default)(this.components, function (component) {
        return component.disabled = disabled;
      });
    }
  }, {
    key: 'errors',
    get: function get() {
      var errors = [];
      (0, _each3.default)(this.getComponents(), function (comp) {
        var compErrors = comp.errors;
        if (compErrors.length) {
          errors = errors.concat(compErrors);
        }
      });
      return errors;
    }
  }]);

  return FormioComponents;
}(_Base.BaseComponent);

},{"./base/Base":4,"./index":22,"lodash/assign":219,"lodash/clone":220,"lodash/each":226,"lodash/remove":254,"native-promise-only":261}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Validator = undefined;

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _each2 = require('lodash/each');

var _each3 = _interopRequireDefault(_each2);

var _has2 = require('lodash/has');

var _has3 = _interopRequireDefault(_has2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _jsonLogicJs = require('json-logic-js');

var _jsonLogicJs2 = _interopRequireDefault(_jsonLogicJs);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var Validator = exports.Validator = {
  get: _get3.default,
  each: _each3.default,
  has: _has3.default,
  boolValue: function boolValue(value) {
    if (typeof value === 'boolean') {
      return value;
    } else if (typeof value === 'string') {
      return value.toLowerCase() === 'true';
    } else {
      return !!value;
    }
  },
  empty: function empty(value) {
    return value == null || value.length === 0;
  },
  name: function name(component) {
    return component.label || component.placeholder || component.key;
  },
  checkValidator: function checkValidator(validator, component, setting, value, data, row, t) {
    var result = validator.check.call(this, component, setting, value, data, row);
    if (typeof result === 'string') {
      return result;
    }
    if (!result) {
      return validator.message.call(this, component, setting, t);
    }
    return '';
  },
  validate: function validate(validator, component, value, data, row, t) {
    if (validator.key && (0, _has3.default)(component, validator.key)) {
      var setting = this.get(component, validator.key);
      return this.checkValidator(validator, component, setting, value, data, row, t);
    }
    return this.checkValidator(validator, component, null, value, data, row, t);
  },
  check: function check(validators, component, value, data, row, t) {
    var _this = this;

    var result = '';
    (0, _each3.default)(validators, function (name) {
      if (_this.validators.hasOwnProperty(name)) {
        var validator = _this.validators[name];
        if (component.multiple && (0, _isArray3.default)(value)) {
          (0, _each3.default)(value, function (val) {
            result = _this.validate(validator, component, val, data, row, t);
            if (result) {
              return false;
            }
          });
        } else {
          result = _this.validate(validator, component, value, data, row, t);
        }
        if (result) {
          return false;
        }
      }
    });
    return result;
  },
  validators: {
    required: {
      key: 'validate.required',
      message: function message(component, setting, t) {
        return t('required', { field: this.name(component) });
      },
      check: function check(component, setting, value) {
        var required = Validator.boolValue(setting);
        if (!required) {
          return true;
        }
        return !Validator.empty(value);
      }
    },
    minLength: {
      key: 'validate.minLength',
      message: function message(component, setting, t) {
        return t('minLength', {
          field: this.name(component),
          length: setting - 1
        });
      },
      check: function check(component, setting, value) {
        var minLength = parseInt(setting, 10);
        if (!minLength || typeof value !== 'string') {
          return true;
        }
        return value.length >= minLength;
      }
    },
    maxLength: {
      key: 'validate.maxLength',
      message: function message(component, setting, t) {
        return t('maxLength', {
          field: this.name(component),
          length: setting + 1
        });
      },
      check: function check(component, setting, value) {
        var maxLength = parseInt(setting, 10);
        if (!maxLength || typeof value !== 'string') {
          return true;
        }
        return value.length <= maxLength;
      }
    },
    email: {
      message: function message(component, setting, t) {
        return t('invalid_email', {
          field: this.name(component)
        });
      },
      check: function check(component, setting, value) {
        // From http://stackoverflow.com/questions/46155/validate-email-address-in-javascript
        var re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
        return re.test(value);
      }
    },
    date: {
      message: function message(component, setting, t) {
        return t('invalid_date', {
          field: this.name(component)
        });
      },
      check: function check(component, setting, value) {
        return value !== 'Invalid date';
      }
    },
    pattern: {
      key: 'validate.pattern',
      message: function message(component, setting, t) {
        return t('pattern', {
          field: this.name(component)
        });
      },
      check: function check(component, setting, value) {
        var pattern = setting;
        if (!pattern) {
          return true;
        }
        var regexStr = '^' + pattern + '$';
        var regex = new RegExp(regexStr);
        return regex.test(value);
      }
    },
    json: {
      key: 'validate.json',
      check: function check(component, setting, value, data, row) {
        if (!setting) {
          return true;
        }
        var valid = true;
        try {
          valid = _jsonLogicJs2.default.apply(setting, {
            data: data,
            row: row
          });
        } catch (err) {
          valid = err.message;
        }
        return valid;
      }
    },
    custom: {
      key: 'validate.custom',
      message: function message(component, setting, t) {
        return t('custom', {
          field: this.name(component)
        });
      },
      check: function check(component, setting, value, data, row) {
        if (!setting) {
          return true;
        }
        var valid = true;
        var custom = setting;
        /*eslint-disable no-unused-vars */
        var input = value;
        /*eslint-enable no-unused-vars */
        custom = custom.replace(/({{\s+(.*)\s+}})/, function (match, $1, $2) {
          if ($2.indexOf('data.') === 0) {
            return (0, _get3.default)(data, $2.replace('data.', ''));
          } else if ($2.indexOf('row.') === 0) {
            return (0, _get3.default)(row, $2.replace('row.', ''));
          }

          // Support legacy...
          return (0, _get3.default)(data, $2);
        });

        /* jshint evil: true */
        eval(custom);
        return valid;
      }
    }
  }
};

},{"json-logic-js":69,"lodash/each":226,"lodash/get":229,"lodash/has":230,"lodash/isArray":234}],3:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AddressComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _TextField = require('../textfield/TextField');

var _Base = require('../base/Base');

var _defaultsDeep2 = require('lodash/defaultsDeep');

var _defaultsDeep3 = _interopRequireDefault(_defaultsDeep2);

var _delay2 = require('lodash/delay');

var _delay3 = _interopRequireDefault(_delay2);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var AddressComponent = exports.AddressComponent = function (_TextFieldComponent) {
  _inherits(AddressComponent, _TextFieldComponent);

  function AddressComponent(component, options, data) {
    _classCallCheck(this, AddressComponent);

    var _this = _possibleConstructorReturn(this, (AddressComponent.__proto__ || Object.getPrototypeOf(AddressComponent)).call(this, component, options, data));

    var src = 'https://maps.googleapis.com/maps/api/js?v=3&libraries=places&callback=googleMapsCallback';
    if (component.map && component.map.key) {
      src += '&key=' + component.map.key;
    }
    if (component.map && component.map.region) {
      src += '&region=' + component.map.region;
    }
    _Base.BaseComponent.requireLibrary('googleMaps', 'google.maps.places', src);
    return _this;
  }

  _createClass(AddressComponent, [{
    key: 'setValueAt',
    value: function setValueAt(index, value) {
      this.value = value;
    }
  }, {
    key: 'getValueAt',
    value: function getValueAt(index) {
      return this.value;
    }

    /**
     * Start the autocomplete and the input listeners
     *
     * @param input
     *   The input field
     * @param autoCompleteOptions
     *   The default option for the autocompletion
     */

  }, {
    key: 'autoCompleteInit',
    value: function autoCompleteInit(input, autoCompleteOptions) {
      var _this2 = this;

      // Set attribute autoComplete to off
      input.setAttribute("autocomplete", "off");

      // Init suggestions list
      this.autoCompleteSuggestions = [];

      // Start Google AutocompleteService
      var autoComplete = new google.maps.places.AutocompleteService();

      // Create suggestions container
      var suggestionContainer = document.createElement('div');
      suggestionContainer.classList.add('pac-container', 'pac-logo');
      input.parentNode.appendChild(suggestionContainer);

      // Add listener on input field for input event
      this.addEventListener(input, 'input', function (event) {
        if (input.value) {
          var options = {
            input: input.value
          };
          autoComplete.getPlacePredictions((0, _defaultsDeep3.default)(options, autoCompleteOptions), function (suggestions, status) {
            _this2.autoCompleteDisplaySuggestions(suggestions, status, suggestionContainer, input);
          });
        } else {
          _this2.autoCompleteCleanSuggestions(suggestionContainer);
          suggestionContainer.style.display = 'none';
        }
      });
      // Add listener on input field for blur event
      this.addEventListener(input, 'blur', function (event) {
        // Delay to allow click on suggestion list
        (0, _delay3.default)(function () {
          suggestionContainer.style.display = 'none';
        }, 100);
      });
      // Add listener on input field for focus event
      this.addEventListener(input, 'focus', function (event) {
        if (suggestionContainer.childElementCount) {
          suggestionContainer.style.display = 'block';
        }
      });
      // Add listener on input field for focus event
      this.addEventListener(window, 'resize', function (event) {
        // Set the same width as input field
        suggestionContainer.style.width = input.offsetWidth + 'px';
      });
      // Add listiner on input field for key event
      this.autoCompleteKeyboardListener(suggestionContainer, input);
    }

    /**
     * Add listiner on input field for key event
     *
     * @param suggestionContainer
     *   Suggestions container
     * @param input
     *   Input field to listen
     */

  }, {
    key: 'autoCompleteKeyboardListener',
    value: function autoCompleteKeyboardListener(suggestionContainer, input) {
      var _this3 = this;

      this.autoCompleteKeyCodeListener = function (event) {
        if (input.value) {
          switch (event.keyCode) {
            case 38:
              // UP
              _this3.autoCompleteKeyUpInteraction(suggestionContainer, input);
              break;

            case 40:
              // DOWN
              _this3.autoCompleteKeyDownInteraction(suggestionContainer, input);
              break;

            case 9:
              // TAB
              _this3.autoCompleteKeyValidationInteraction(suggestionContainer, input);
              break;

            case 13:
              // ENTER
              _this3.autoCompleteKeyValidationInteraction(suggestionContainer, input);
              break;
          }
        }
      };

      this.addEventListener(input, 'keydown', this.autoCompleteKeyCodeListener);
    }

    /**
     * Action when key up is trigger
     *
     * @param suggestionContainer
     *   Suggestions container
     * @param input
     *   Input field to listen
     */

  }, {
    key: 'autoCompleteKeyUpInteraction',
    value: function autoCompleteKeyUpInteraction(suggestionContainer, input) {
      var elementSelected = document.querySelector('.pac-item-selected');
      if (!elementSelected) {
        // Returns the bottom of the list.
        return this.autoCompleteListDecorator(suggestionContainer.lastChild, input);
      } else {
        // Transverse the list in reverse order.
        var previousSibling = elementSelected.previousSibling;
        if (previousSibling) {
          this.autoCompleteListDecorator(previousSibling, input);
        } else {
          // Return to input value
          elementSelected.classList.remove('pac-item-selected');
          input.value = this.autoCompleteInputValue;
        }
      }
    }

    /**
     * Action when key down is trigger
     *
     * @param suggestionContainer
     *   Suggestions container
     * @param input
     *   Input field to listen
     */

  }, {
    key: 'autoCompleteKeyDownInteraction',
    value: function autoCompleteKeyDownInteraction(suggestionContainer, input) {
      var elementSelected = document.querySelector('.pac-item-selected');
      if (!elementSelected) {
        // Start at the top of the list.
        if (suggestionContainer.firstChild) {
          return this.autoCompleteListDecorator(suggestionContainer.firstChild, input);
        }
      } else {
        // Transverse the list from top down.
        var nextSibling = elementSelected.nextSibling;
        if (nextSibling) {
          this.autoCompleteListDecorator(nextSibling, input);
        } else {
          // Return to input value
          elementSelected.classList.remove('pac-item-selected');
          input.value = this.autoCompleteInputValue;
        }
      }
    }

    /**
     * Action when validation is trigger
     *
     * @param suggestionContainer
     *   Suggestions container
     * @param input
     *   Input field to listen
     */

  }, {
    key: 'autoCompleteKeyValidationInteraction',
    value: function autoCompleteKeyValidationInteraction(suggestionContainer, input) {
      var elementSelected = document.querySelector('.pac-item-selected');
      if (elementSelected) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.autoCompleteSuggestions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var suggestion = _step.value;

            var content = elementSelected.textContent || elementSelected.innerText;
            if (content === suggestion.description) {
              this.autoCompleteServiceListener(suggestion, suggestionContainer, input);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        elementSelected.classList.remove('pac-item-selected');
      }
    }

    /**
     * Highlight suggestion selected
     *
     * @param item
     *   Item selected in suggestions container
     * @param input
     *   Input field to listen
     */

  }, {
    key: 'autoCompleteListDecorator',
    value: function autoCompleteListDecorator(item, input) {
      var elementSelected = document.querySelector('.pac-item-selected');
      if (elementSelected) {
        elementSelected.classList.remove('pac-item-selected');
      }
      input.value = item.textContent || suggestionContainer.innerText;
      item.classList.add('pac-item-selected');
    }

    /**
     * Filter method to return if the suggestion should be displayed
     *
     * @param data
     *   Data to check
     * @returns {Boolean}
     */

  }, {
    key: 'autoCompleteFilterSuggestion',
    value: function autoCompleteFilterSuggestion(data) {
      try {
        var script = '(function() { var show = true;';
        script += this.component.map.autoCompleteFilter.toString();
        script += '; return show; })()';
        var result = eval(script);
        return result.toString() === 'true';
      } catch (e) {
        console.warn('An error occurred in a custom autoComplete filter statement for component ' + this.component.key, e);
        return true;
      }
    }

    /**
     * Clean suggestions list
     *
     * @param suggestionContainer
     *   Container tag
     */

  }, {
    key: 'autoCompleteCleanSuggestions',
    value: function autoCompleteCleanSuggestions(suggestionContainer) {
      // Clean click listener
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.autoCompleteSuggestions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var suggestion = _step2.value;

          suggestion.item.removeEventListener('click', suggestion.clickListener);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      this.autoCompleteSuggestions = [];

      // Delete current suggestion list
      while (suggestionContainer.firstChild) {
        suggestionContainer.removeChild(suggestionContainer.firstChild);
      }
    }

    /**
     * Display suggestions when API returns value
     *
     * @param suggestions
     *   Suggestions returned
     * @param status
     *   State returned
     * @param suggestionContainer
     *   Suggestions container
     * @param input
     *   Input field to listen
     */

  }, {
    key: 'autoCompleteDisplaySuggestions',
    value: function autoCompleteDisplaySuggestions(suggestions, status, suggestionContainer, input) {

      // Set the same width as input field
      suggestionContainer.style.width = input.offsetWidth + 'px';

      // Set the default input value
      this.autoCompleteInputValue = input.value;

      this.autoCompleteCleanSuggestions(suggestionContainer);
      if (status != google.maps.places.PlacesServiceStatus.OK) {
        suggestionContainer.style.display = 'none';
        return;
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = suggestions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var suggestion = _step3.value;

          if (this.autoCompleteFilterSuggestion(suggestion)) {
            this.autoCompleteSuggestions.push(suggestion);
            this.autoCompleteSuggestionBuilder(suggestion, suggestionContainer, input);
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      if (!suggestionContainer.childElementCount) {
        this.autoCompleteCleanSuggestions(suggestionContainer);
        suggestionContainer.style.display = 'none';
      } else {
        suggestionContainer.style.display = 'block';
      }
    }

    /**
     * Draw a suggestion in the list
     *
     * @param suggestion
     *   Suggestion to draw
     * @param suggestionContainer
     *   Suggestions container
     * @param input
     *   Input field to listen
     */

  }, {
    key: 'autoCompleteSuggestionBuilder',
    value: function autoCompleteSuggestionBuilder(suggestion, suggestionContainer, input) {
      var _this4 = this;

      var item = document.createElement('div');
      item.classList.add('pac-item');

      var itemLogo = document.createElement('span');
      itemLogo.classList.add('pac-icon', 'pac-icon-marker');
      item.appendChild(itemLogo);

      // Draw Main part
      var itemMain = document.createElement('span');
      itemMain.classList.add('pac-item-query');
      if (suggestion.structured_formatting.main_text_matched_substrings) {
        var matches = suggestion.structured_formatting.main_text_matched_substrings;
        for (var k in matches) {
          var part = matches[k];
          if (k == 0 && part.offset > 0) {
            itemMain.appendChild(document.createTextNode(suggestion.structured_formatting.main_text.substring(0, part.offset)));
          }

          var itemBold = document.createElement('span');
          itemBold.classList.add('pac-matched');
          itemBold.appendChild(document.createTextNode(suggestion.structured_formatting.main_text.substring(part.offset, part.offset + part.length)));
          itemMain.appendChild(itemBold);

          if (k == matches.length - 1) {
            var content = suggestion.structured_formatting.main_text.substring(part.offset + part.length);
            if (content.length > 0) {
              itemMain.appendChild(document.createTextNode(content));
            }
          }
        }
      } else {
        itemMain.appendChild(document.createTextNode(suggestion.structured_formatting.main_text));
      }
      item.appendChild(itemMain);

      // Draw secondary part
      if (suggestion.structured_formatting.secondary_text) {
        var itemSecondary = document.createElement('span');
        if (suggestion.structured_formatting.secondary_text_matched_substrings) {
          var _matches = suggestion.structured_formatting.secondary_text_matched_substrings;
          for (var _k in _matches) {
            var _part = _matches[_k];
            if (_k == 0 && _part.offset > 0) {
              itemSecondary.appendChild(document.createTextNode(suggestion.structured_formatting.secondary_text.substring(0, _part.offset)));
            }

            var _itemBold = document.createElement('span');
            _itemBold.classList.add('pac-matched');
            _itemBold.appendChild(document.createTextNode(suggestion.structured_formatting.secondary_text.substring(_part.offset, _part.offset + _part.length)));
            itemSecondary.appendChild(_itemBold);

            if (_k == _matches.length - 1) {
              var _content = suggestion.structured_formatting.secondary_text.substring(_part.offset + _part.length);
              if (_content.length > 0) {
                itemSecondary.appendChild(document.createTextNode(_content));
              }
            }
          }
        } else {
          itemSecondary.appendChild(document.createTextNode(suggestion.structured_formatting.secondary_text));
        }
        item.appendChild(itemSecondary);
      }

      suggestionContainer.appendChild(item);

      var clickListener = function clickListener(event) {
        input.value = suggestion.description;
        _this4.autoCompleteInputValue = suggestion.description;
        _this4.autoCompleteServiceListener(suggestion, suggestionContainer, input);
      };
      suggestion.clickListener = clickListener;
      suggestion.item = item;
      if ('addEventListener' in item) {
        item.addEventListener('click', clickListener, false);
      } else if ('attachEvent' in item) {
        item.attachEvent('onclick', clickListener);
      }
    }

    /**
     * Get detailed information and set it as value
     *
     * @param suggestion
     *   Suggestion to draw
     * @param suggestionContainer
     *   Suggestions container
     * @param input
     *   Input field to listen
     */

  }, {
    key: 'autoCompleteServiceListener',
    value: function autoCompleteServiceListener(suggestion, suggestionContainer, input) {
      var _this5 = this;

      var service = new google.maps.places.PlacesService(input);
      service.getDetails({
        placeId: suggestion.place_id
      }, function (place, status) {
        if (status === google.maps.places.PlacesServiceStatus.OK) {
          _this5.setValue(place);
        }
      });
    }
  }, {
    key: 'addInput',
    value: function addInput(input, container) {
      var _this6 = this;

      _get(AddressComponent.prototype.__proto__ || Object.getPrototypeOf(AddressComponent.prototype), 'addInput', this).call(this, input, container);
      _Base.BaseComponent.libraryReady('googleMaps').then(function () {
        var autoCompleteOptions = {};
        if (_this6.component.map) {
          autoCompleteOptions = _this6.component.map.autoCompleteOptions || {};
          if (autoCompleteOptions.location) {
            autoCompleteOptions.location = new google.maps.LatLng(autoCompleteOptions.location.lat, autoCompleteOptions.location.lng);
          }
        }

        if (_this6.component.map && _this6.component.map.autoCompleteFilter) {
          // Call custom autoComplete to filter suggestions
          _this6.autoCompleteInit(input, autoCompleteOptions);
        } else {
          var autocomplete = new google.maps.places.Autocomplete(input);
          autocomplete.addListener("place_changed", function () {
            return _this6.setValue(autocomplete.getPlace());
          });
        }
      });
    }
  }, {
    key: 'elementInfo',
    value: function elementInfo() {
      var info = _get(AddressComponent.prototype.__proto__ || Object.getPrototypeOf(AddressComponent.prototype), 'elementInfo', this).call(this);
      info.attr.class += ' address-search';
      return info;
    }
  }]);

  return AddressComponent;
}(_TextField.TextFieldComponent);

},{"../base/Base":4,"../textfield/TextField":37,"lodash/defaultsDeep":224,"lodash/delay":225}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _vanilla = require('text-mask-all/vanilla');

var _vanilla2 = _interopRequireDefault(_vanilla);

var _nativePromiseOnly = require('native-promise-only');

var _nativePromiseOnly2 = _interopRequireDefault(_nativePromiseOnly);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _each2 = require('lodash/each');

var _each3 = _interopRequireDefault(_each2);

var _debounce2 = require('lodash/debounce');

var _debounce3 = _interopRequireDefault(_debounce2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _assign2 = require('lodash/assign');

var _assign3 = _interopRequireDefault(_assign2);

var _clone2 = require('lodash/clone');

var _clone3 = _interopRequireDefault(_clone2);

var _i18next = require('i18next');

var _i18next2 = _interopRequireDefault(_i18next);

var _jsonLogicJs = require('json-logic-js');

var _jsonLogicJs2 = _interopRequireDefault(_jsonLogicJs);

var _utils = require('../../utils');

var _utils2 = _interopRequireDefault(_utils);

var _Validator = require('../Validator');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

_i18next2.default.initialized = false;

/**
 * This is the BaseComponent class which all elements within the FormioForm derive from.
 */

var BaseComponent = function () {
  /**
   * Initialize a new BaseComponent.
   *
   * @param {Object} component - The component JSON you wish to initialize.
   * @param {Object} options - The options for this component.
   * @param {Object} data - The global data submission object this component will belong.
   */
  function BaseComponent(component, options, data) {
    _classCallCheck(this, BaseComponent);

    /**
     * The ID of this component. This value is auto-generated when the component is created, but
     * can also be provided from the component.id value passed into the constructor.
     * @type {string}
     */
    this.id = component && component.id ? component.id : Math.random().toString(36).substring(7);

    /**
     * The options for this component.
     * @type {{}}
     */
    this.options = (0, _clone3.default)(options) || {};

    /**
     * The i18n configuration for this component.
     */
    this.options.i18n = this.options.i18n || require('../../locals/en');

    /**
     * The events that are triggered for the whole FormioForm object.
     */
    this.events = this.options.events;

    /**
     * The data object in which this component resides.
     * @type {*}
     */
    this.data = data || {};

    /**
     * The Form.io component JSON schema.
     * @type {*}
     */
    this.component = component || {};

    /**
     * The bounding HTML Element which this component is rendered.
     * @type {null}
     */
    this.element = null;

    /**
     * The HTML Element for the table body. This is relevant for the "multiple" flag on inputs.
     * @type {null}
     */
    this.tbody = null;

    /**
     * The HTMLElement that is assigned to the label of this component.
     * @type {null}
     */
    this.label = null;

    /**
     * The HTMLElement for which the errors are rendered for this component (usually underneath the component).
     * @type {null}
     */
    this.errorElement = null;

    /**
     * The existing error that this component has.
     * @type {string}
     */
    this.error = '';

    /**
     * An array of all of the input HTML Elements that have been added to this component.
     * @type {Array}
     */
    this.inputs = [];

    /**
     * The basic component information which tells the BaseComponent how to render the input element of the components that derive from this class.
     * @type {null}
     */
    this.info = null;

    /**
     * The value of this component
     * @type {*}
     */
    this.value = null;

    /**
     * The row path of this component.
     * @type {number}
     */
    this.row = component ? component.row : '';
    this.row = this.row || '';

    /**
     * Determines if this component is disabled, or not.
     *
     * @type {boolean}
     */
    this._disabled = false;

    /**
     * If this input has been input and provided value.
     *
     * @type {boolean}
     */
    this.pristine = true;

    /**
     * The Input mask instance for this component.
     * @type {InputMask}
     */
    this.inputMask = null;

    this.options.name = this.options.name || 'data';

    /**
     * The validators that are assigned to this component.
     * @type {[string]}
     */
    this.validators = ['required', 'minLength', 'maxLength', 'custom', 'pattern', 'json'];

    /**
     * Used to trigger a new change in this component.
     * @type {function} - Call to trigger a change in this component.
     */
    this.triggerChange = (0, _debounce3.default)(this.onChange.bind(this), 200);

    /**
     * An array of event handlers so that the destry command can deregister them.
     * @type {Array}
     */
    this.eventHandlers = [];

    /**
     * An array of the event listeners so that the destroy command can deregister them.
     * @type {Array}
     */
    this.eventListeners = [];

    if (this.component) {
      this.type = this.component.type;
      if (this.component.input && this.component.key) {
        this.options.name += '[' + this.component.key + ']';
      }

      /**
       * The element information for creating the input element.
       * @type {*}
       */
      this.info = this.elementInfo();
    }
  }

  /**
   * Translate a text using the i18n system.
   *
   * @param {string} text - The i18n identifier.
   * @param {Object} params - The i18n parameters to use for translation.
   */

  _createClass(BaseComponent, [{
    key: 't',
    value: function t(text, params) {
      var message = _i18next2.default.t(text, params);
      return message;
    }

    /**
     * Register for a new event within this component.
     *
     * @example
     * let component = new BaseComponent({
     *   type: 'textfield',
     *   label: 'First Name',
     *   key: 'firstName'
     * });
     * component.on('componentChange', (changed) => {
     *   console.log('this element is changed.');
     * });
     *
     *
     * @param {string} event - The event you wish to register the handler for.
     * @param {function} cb - The callback handler to handle this event.
     * @param {boolean} internal - This is an internal event handler.
     */

  }, {
    key: 'on',
    value: function on(event, cb, internal) {
      if (!this.events) {
        return;
      }
      var type = 'formio.' + event;
      this.eventListeners.push({
        type: type,
        listener: cb,
        internal: internal
      });
      return this.events.on(type, cb);
    }

    /**
     * Emit a new event.
     *
     * @param {string} event - The event to emit.
     * @param {Object} data - The data to emit with the handler.
     */

  }, {
    key: 'emit',
    value: function emit(event, data) {
      this.events.emit('formio.' + event, data);
    }

    /**
     * Returns an HTMLElement icon element.
     *
     * @param {string} name - The name of the icon to retrieve.
     * @returns {HTMLElement} - The icon element.
     */

  }, {
    key: 'getIcon',
    value: function getIcon(name) {
      return this.ce(name + 'Icon', 'i', {
        class: 'glyphicon glyphicon-' + name
      });
    }

    /**
     * Perform the localization initialization.
     * @returns {*}
     */

  }, {
    key: 'localize',
    value: function localize() {
      var _this = this;

      if (_i18next2.default.initialized) {
        return _nativePromiseOnly2.default.resolve(_i18next2.default);
      }
      _i18next2.default.initialized = true;
      return new _nativePromiseOnly2.default(function (resolve, reject) {
        _i18next2.default.init(_this.options.i18n, function (err, t) {
          if (err) {
            return reject(err);
          }
          resolve(_i18next2.default);
        });
      });
    }

    /**
     * Called before a next page is triggered allowing the components
     * to perform special functions.
     *
     * @return {*}
     */

  }, {
    key: 'beforeNext',
    value: function beforeNext() {
      return _nativePromiseOnly2.default.resolve(true);
    }

    /**
     * Called before a submission is triggered allowing the components
     * to perform special async functions.
     *
     * @return {*}
     */

  }, {
    key: 'beforeSubmit',
    value: function beforeSubmit() {
      return _nativePromiseOnly2.default.resolve(true);
    }

    /**
     * Builds the component.
     */

  }, {
    key: 'build',
    value: function build() {
      this.createElement();
      this.createLabel(this.element);
      if (!this.createWrapper()) {
        this.createInput(this.element);
      }

      // Disable if needed.
      if (this.options.readOnly || this.component.disabled) {
        this.disabled = true;
      }

      // Set default values.
      var defaultValue = this.defaultValue;
      if (defaultValue) {
        this.setValue(defaultValue);
      }
    }

    /**
     * Retrieves the CSS class name of this component.
     * @returns {string} - The class name of this component.
     */

  }, {
    key: 'getElement',

    /**
     * Returns the outside wrapping element of this component.
     * @returns {HTMLElement}
     */
    value: function getElement() {
      return this.element;
    }

    /**
     * Create the outside wrapping element for this component.
     * @returns {HTMLElement}
     */

  }, {
    key: 'createElement',
    value: function createElement() {
      this.element = this.ce('element', 'div', {
        id: this.id,
        class: this.className
      });

      if (this.element) {
        // Ensure you can get the component info from the element.
        this.element.component = this.component;
      }

      return this.element;
    }

    /**
     * Create the input wrapping element. For multiple, this may be the table wrapper for the elements.
     * @returns {boolean}
     */

  }, {
    key: 'createWrapper',
    value: function createWrapper() {
      if (!this.component.multiple) {
        return false;
      } else {
        var table = this.ce('wrapper', 'table', {
          class: 'table table-bordered'
        });
        this.tbody = this.ce('wrapperBody', 'tbody');
        table.appendChild(this.tbody);

        // Add a default value.
        if (!this.data[this.component.key] || !this.data[this.component.key].length) {
          this.addNewValue();
        }

        // Build the rows.
        this.buildRows();

        // Add the table to the element.
        this.append(table);
        return true;
      }
    }
  }, {
    key: 'addNewValue',

    /**
     * Adds a new empty value to the data array.
     */
    value: function addNewValue() {
      if (!this.data[this.component.key]) {
        this.data[this.component.key] = [];
      }
      if (!(0, _isArray3.default)(this.data[this.component.key])) {
        this.data[this.component.key] = [this.data[this.component.key]];
      }
      this.data[this.component.key].push(this.defaultValue);
    }

    /**
     * Adds a new empty value to the data array, and add a new row to contain it.
     */

  }, {
    key: 'addValue',
    value: function addValue() {
      this.addNewValue();
      this.buildRows();
    }

    /**
     * Removes a value out of the data array and rebuild the rows.
     * @param {number} index - The index of the data element to remove.
     */

  }, {
    key: 'removeValue',
    value: function removeValue(index) {
      if (this.data.hasOwnProperty(this.component.key)) {
        this.data[this.component.key].splice(index, 1);
      }
      this.buildRows();
    }

    /**
     * Rebuild the rows to contain the values of this component.
     */

  }, {
    key: 'buildRows',
    value: function buildRows() {
      var _this2 = this;

      if (!this.tbody) {
        return;
      }
      this.inputs = [];
      this.tbody.innerHTML = '';
      (0, _each3.default)(this.data[this.component.key], function (value, index) {
        var tr = _this2.ce('row', 'tr');
        var td = _this2.ce('column', 'td');
        _this2.createInput(td);
        tr.appendChild(td);
        var tdAdd = _this2.ce('columnAdd', 'td');
        tdAdd.appendChild(_this2.removeButton(index));
        tr.appendChild(tdAdd);
        _this2.tbody.appendChild(tr);
      });

      var tr = this.ce('rowAdd', 'tr');
      var td = this.ce('addRowColumn', 'td', {
        colspan: '2'
      });
      td.appendChild(this.addButton());
      tr.appendChild(td);
      this.tbody.appendChild(tr);
      if (this.options.readOnly) {
        this.disabled = true;
      }
    }

    /**
     * Adds a new button to add new rows to the multiple input elements.
     * @returns {HTMLElement} - The "Add New" button html element.
     */

  }, {
    key: 'addButton',
    value: function addButton() {
      var _this3 = this;

      var addButton = this.ce('addButton', 'a', {
        class: 'btn btn-primary'
      });
      this.addEventListener(addButton, 'click', function (event) {
        event.preventDefault();
        _this3.addValue();
      });

      var addIcon = this.ce('addIcon', 'span', {
        class: 'glyphicon glyphicon-plus'
      });
      addButton.appendChild(addIcon);
      addButton.appendChild(this.text(this.component.addAnother || ' Add Another'));
      return addButton;
    }

    /**
     * The readible name for this component.
     * @returns {string} - The name of the component.
     */

  }, {
    key: 'removeButton',

    /**
     * Creates a new "remove" row button and returns the html element of that button.
     * @param {number} index - The index of the row that should be removed.
     * @returns {HTMLElement} - The html element of the remove button.
     */
    value: function removeButton(index) {
      var _this4 = this;

      var removeButton = this.ce('removeButton', 'button', {
        type: 'button',
        class: 'btn btn-default',
        tabindex: '-1'
      });

      this.addEventListener(removeButton, 'click', function (event) {
        event.preventDefault();
        _this4.removeValue(index);
      });

      var removeIcon = this.ce('removeIcon', 'span', {
        class: 'glyphicon glyphicon-remove-circle'
      });
      removeButton.appendChild(removeIcon);
      return removeButton;
    }

    /**
     * Create the HTML element for the label of this comonent.
     * @param {HTMLElement} container - The containing element that will comtain this label.
     */

  }, {
    key: 'createLabel',
    value: function createLabel(container) {
      if (!this.component.label || this.options.inputsOnly) {
        return;
      }
      this.label = this.ce('label', 'label', {
        class: 'control-label'
      });
      if (this.info.attr.id) {
        this.label.setAttribute('for', this.info.attr.id);
      }
      this.label.appendChild(this.text(this.component.label));
      container.appendChild(this.label);
    }

    /**
     * Creates a new error element to hold the errors of this element.
     */

  }, {
    key: 'createErrorElement',
    value: function createErrorElement() {
      if (!this.errorContainer) {
        return;
      }
      this.errorElement = this.ce('errors', 'div', {
        class: 'formio-errors'
      });
      this.errorContainer.appendChild(this.errorElement);
    }

    /**
     * Adds a prefix html element.
     *
     * @param {HTMLElement} input - The input element.
     * @param {HTMLElement} inputGroup - The group that will hold this prefix.
     * @returns {HTMLElement} - The html element for this prefix.
     */

  }, {
    key: 'addPrefix',
    value: function addPrefix(input, inputGroup) {
      var prefix = null;
      if (this.component.prefix) {
        prefix = this.ce('prefix', 'div', {
          class: 'input-group-addon'
        });
        prefix.appendChild(this.text(this.component.prefix));
        inputGroup.appendChild(prefix);
      }
      return prefix;
    }

    /**
     * Adds a suffix html element.
     *
     * @param {HTMLElement} input - The input element.
     * @param {HTMLElement} inputGroup - The group that will hold this suffix.
     * @returns {HTMLElement} - The html element for this suffix.
     */

  }, {
    key: 'addSuffix',
    value: function addSuffix(input, inputGroup) {
      var suffix = null;
      if (this.component.suffix) {
        suffix = this.ce('suffix', 'div', {
          class: 'input-group-addon'
        });
        suffix.appendChild(this.text(this.component.suffix));
        inputGroup.appendChild(suffix);
      }
      return suffix;
    }

    /**
     * Adds a new input group to hold the input html elements.
     *
     * @param {HTMLElement} input - The input html element.
     * @param {HTMLElement} container - The containing html element for this group.
     * @returns {HTMLElement} - The input group element.
     */

  }, {
    key: 'addInputGroup',
    value: function addInputGroup(input, container) {
      var inputGroup = null;
      if (this.component.prefix || this.component.suffix) {
        inputGroup = this.ce('inputGroup', 'div', {
          class: 'input-group'
        });
        container.appendChild(inputGroup);
      }
      return inputGroup;
    }

    /**
     * Returns an input mask that is compatible with the input mask library.
     * @param {string} mask - The Form.io input mask.
     * @returns {Array} - The input mask for the mask library.
     */

  }, {
    key: 'getInputMask',
    value: function getInputMask(mask) {
      if (mask instanceof Array) {
        return mask;
      }
      var maskArray = [];
      for (var i = 0; i < mask.length; i++) {
        switch (mask[i]) {
          case '9':
            maskArray.push(/\d/);
            break;
          case 'A':
            maskArray.push(/[a-zA-Z]/);
            break;
          case '*':
            maskArray.push(/[a-zA-Z0-9]/);
            break;
          default:
            maskArray.push(mask[i]);
            break;
        }
      }
      return maskArray;
    }

    /**
     * Creates a new input mask placeholder.
     * @param {HTMLElement} mask - The input mask.
     * @returns {string} - The placeholder that will exist within the input as they type.
     */

  }, {
    key: 'maskPlaceholder',
    value: function maskPlaceholder(mask) {
      return mask.map(function (char) {
        return char instanceof RegExp ? '_' : char;
      }).join('');
    }

    /**
     * Sets the input mask for an input.
     * @param {HTMLElement} input - The html input to apply the mask to.
     */

  }, {
    key: 'setInputMask',
    value: function setInputMask(input) {
      if (input && this.component.inputMask) {
        var mask = this.getInputMask(this.component.inputMask);
        this.inputMask = (0, _vanilla2.default)({
          inputElement: input,
          mask: mask,
          placeholderChar: "\u2000"
        });
        if (!this.component.placeholder) {
          input.setAttribute('placeholder', this.maskPlaceholder(mask));
        }
      }
    }

    /**
     * Creates a new input element.
     * @param {HTMLElement} container - The container which should hold this new input element.
     * @returns {HTMLElement} - Either the input or the group that contains the input.
     */

  }, {
    key: 'createInput',
    value: function createInput(container) {
      var input = this.ce('input', this.info.type, this.info.attr);
      this.setInputMask(input);
      var inputGroup = this.addInputGroup(input, container);
      this.addPrefix(input, inputGroup);
      this.addInput(input, inputGroup || container);
      this.addSuffix(input, inputGroup);
      this.errorContainer = container;
      return inputGroup || input;
    }

    /**
     * Wrapper method to add an event listener to an HTML element.
     *
     * @param obj
     *   The DOM element to add the event to.
     * @param evt
     *   The event name to add.
     * @param func
     *   The callback function to be executed when the listener is triggered.
     */

  }, {
    key: 'addEventListener',
    value: function addEventListener(obj, evt, func) {
      this.eventHandlers.push({ type: evt, func: func });
      if ('addEventListener' in obj) {
        obj.addEventListener(evt, func, false);
      } else if ('attachEvent' in obj) {
        obj.attachEvent('on' + evt, func);
      }
    }

    /**
     * Remove all event handlers.
     */

  }, {
    key: 'destroy',
    value: function destroy(all) {
      var _this5 = this;

      if (this.inputMask) {
        this.inputMask.destroy();
      }
      (0, _each3.default)(this.eventListeners, function (listener) {
        if (all || listener.internal) {
          _this5.events.off(listener.type, listener.listener);
        }
      });
      (0, _each3.default)(this.eventHandlers, function (handler) {
        window.removeEventListener(handler.event, handler.func);
      });
    }

    /**
     * Alias for document.createElement.
     *
     * @param {string} name - The name of the element to create, for templating purposes.
     * @param {string} type - The type of element to create
     * @param {Object} attr - The element attributes to add to the created element.
     *
     * @return {HTMLElement} - The created element.
     */

  }, {
    key: 'ce',
    value: function ce(name, type, attr) {
      // Allow for template overrides.
      var element = document.createElement(type);
      var compType = this.component.type || this.type;
      if (this.options && this.options.template && (this.options.template[compType] && this.options.template[compType][name] || this.options.template.global && this.options.template.global[name])) {
        var template = (0, _get3.default)(this.options, 'template.' + compType + '.' + name) || (0, _get3.default)(this.options, 'template.global.' + name);
        if (typeof template === 'function') {
          var returnElement = template(this, type, attr, element);
          if (returnElement) {
            return returnElement;
          }
        } else {
          // Assign the attributes.
          (0, _assign3.default)(attr, template);
        }
      }
      if (attr) {
        this.attr(element, attr);
      }
      return element;
    }

    /**
     * Alias to create a text node.
     * @param text
     * @returns {Text}
     */

  }, {
    key: 'text',
    value: function text(_text) {
      return document.createTextNode(_text);
    }

    /**
     * Adds an object of attributes onto an element.
     * @param {HtmlElement} element - The element to add the attributes to.
     * @param {Object} attr - The attributes to add to the input element.
     */

  }, {
    key: 'attr',
    value: function attr(element, _attr) {
      (0, _each3.default)(_attr, function (value, key) {
        if (typeof value !== 'undefined') {
          element.setAttribute(key, value);
        }
      });
    }

    /**
     * Adds a class to a DOM element.
     *
     * @param element
     *   The element to add a class to.
     * @param className
     *   The name of the class to add.
     */

  }, {
    key: 'addClass',
    value: function addClass(element, className) {
      var cls = element.getAttribute('class');
      cls += ' ' + className;
      element.setAttribute('class', cls);
    }

    /**
     * Remove a class from a DOM element.
     *
     * @param element
     *   The DOM element to remove the class from.
     * @param className
     *   The name of the class that is to be removed.
     */

  }, {
    key: 'removeClass',
    value: function removeClass(element, className) {
      var cls = element.getAttribute('class');
      cls = cls.replace(className, '');
      element.setAttribute('class', cls);
    }

    /**
     * Check for conditionals and hide/show the element based on those conditions.
     */

  }, {
    key: 'checkConditions',
    value: function checkConditions(data) {
      return this.show(_utils2.default.checkCondition(this.component, this.data, data));
    }

    /**
     * Add a new input error to this element.
     * @param message
     */

  }, {
    key: 'addInputError',
    value: function addInputError(message) {
      if (this.errorElement) {
        var errorMessage = this.ce('errorMessage', 'p', {
          class: 'help-block'
        });
        errorMessage.appendChild(this.text(message));
        this.errorElement.appendChild(errorMessage);
        this.addClass(this.element, 'has-error');
      }
    }

    /**
     * Hide or Show an element.
     *
     * @param show
     */

  }, {
    key: 'show',
    value: function show(_show) {
      var element = this.getElement();
      if (element) {
        if (_show && !this.component.hidden) {
          element.removeAttribute('hidden');
          element.style.visibility = 'visible';
          element.style.position = 'relative';
        } else if (!_show || this.component.hidden) {
          element.setAttribute('hidden', true);
          element.style.visibility = 'hidden';
          element.style.position = 'absolute';
        }
      }
      return _show;
    }
  }, {
    key: 'onChange',
    value: function onChange(noValidate) {
      if (!noValidate) {
        this.pristine = false;
      }
      if (this.events) {
        // DMS

        /*this.emit('componentChange', {
          component: this.component,
          value: this.value,
          validate: !noValidate
        });*/

        if (this.type !== 'textfield' && this.type !== 'email' && this.type !== 'select' || (this.type === 'textfield' || this.type === 'email' || this.type === 'select') && this.error) {
          this.emit('componentChange', {
            component: this.component,
            value: this.value,
            validate: !noValidate
          });
        }
      }
    }
  }, {
    key: 'addInputSubmitListener',
    value: function addInputSubmitListener(input) {
      var _this6 = this;

      this.addEventListener(input, 'keypress', function (event) {
        var key = event.keyCode || event.which;
        if (key == 13) {
          event.preventDefault();
          event.stopPropagation();
          _this6.emit('submitButton');
        }
      });
    }

    /**
     * Add new input element listeners.
     *
     * @param input
     */

  }, {
    key: 'addInputEventListener',
    value: function addInputEventListener(input) {
      var _this7 = this;

      this.addEventListener(input, this.info.changeEvent, function () {
        return _this7.updateValue();
      });
    }

    /**
     * Add a new input to this comonent.
     *
     * @param input
     * @param container
     * @param name
     */

  }, {
    key: 'addInput',
    value: function addInput(input, container, noSet) {
      if (input && container) {
        this.inputs.push(input);
        input = container.appendChild(input);
      }
      this.addInputEventListener(input);
      this.addInputSubmitListener(input);

      // Reset the values of the inputs.
      if (!noSet && this.data && this.data.hasOwnProperty(this.component.key)) {
        this.setValue(this.data[this.component.key], true);
      }
    }

    /**
     * Get the value at a specific index.
     *
     * @param index
     * @returns {*}
     */

  }, {
    key: 'getValueAt',
    value: function getValueAt(index) {
      return this.inputs[index].value;
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      if (!this.component.input) {
        return;
      }
      var values = [];
      for (var i in this.inputs) {
        if (!this.component.multiple) {
          this.value = this.getValueAt(i);
          return this.value;
        }
        values.push(this.getValueAt(i));
      }
      this.value = values;
      return values;
    }
  }, {
    key: 'updateValue',
    value: function updateValue(noValidate) {
      var value = this.data[this.component.key];
      var falsey = !value && value !== null && value !== undefined;
      this.data[this.component.key] = this.getValue();
      var changed = value !== this.data[this.component.key];
      if (!changed) {
        return;
      }
      if (falsey) {
        if (!!this.data[this.component.key]) {
          this.triggerChange(noValidate);
        }
      } else {
        this.triggerChange(noValidate);
      }
    }

    /**
     * Perform a calculated value operation.
     *
     * @param data - The global data object.
     */

  }, {
    key: 'calculateValue',
    value: function calculateValue(data) {
      //console.log('calculateValue');

      if (!this.component.calculateValue) {
        return;
      }

      // If this is a string, then use eval to evalulate it.
      if (typeof this.component.calculateValue === 'string') {
        try {
          var row = this.data;

          // DMS

          //let val = eval('var value = [];' + this.component.calculateValue.toString() + '; return value;');
          var val = eval('var value = [];' + this.component.calculateValue.toString() + ';');

          //console.log('val' + ' = ' + val);

          this.setValue(val);
        } catch (e) {
          /* eslint-disable no-console */
          console.warn('An error occurred calculating a value for ' + this.component.key, e);
          /* eslint-enable no-console */
        }
      } else {
        try {
          var _val = _jsonLogicJs2.default.apply(this.component.calculateValue, {
            data: data,
            row: this.data
          });
          this.setValue(_val);
        } catch (err) {
          /* eslint-disable no-console */
          console.warn('An error occurred calculating a value for ' + this.component.key, e);
          /* eslint-enable no-console */
        }
      }
    }
  }, {
    key: 'checkValidity',
    value: function checkValidity(data, dirty) {
      // No need to check for errors if there is no input or if it is pristine.
      if (!this.component.input || !dirty && this.pristine) {
        return true;
      }

      var message = _Validator.Validator.check(this.validators, this.component, this.getRawValue(), data || this.data, this.data, this.t.bind(this));
      this.setCustomValidity(message);

      // No message, returns true
      return message ? false : true;
    }
  }, {
    key: 'getRawValue',
    value: function getRawValue() {
      return this.data[this.component.key];
    }
  }, {
    key: 'interpolate',
    value: function interpolate(string, data) {
      return _utils2.default.interpolate(string, data);
    }
  }, {
    key: 'setCustomValidity',
    value: function setCustomValidity(message) {
      if (this.errorElement && this.errorContainer) {
        this.errorElement.innerHTML = '';
        try {
          this.errorContainer.removeChild(this.errorElement);
        } catch (err) {}
      }
      this.removeClass(this.element, 'has-error');
      if (message) {
        this.error = {
          component: this.component,
          message: message
        };
        this.emit('componentError', this.error);
        this.createErrorElement();
        this.addInputError(message);
      } else {
        this.error = null;
      }
      (0, _each3.default)(this.inputs, function (input) {
        if (typeof input.setCustomValidity === 'function') {
          input.setCustomValidity(message);
        }
      });
    }

    /**
     * Set the value at a specific index.
     *
     * @param index
     * @param value
     */

  }, {
    key: 'setValueAt',
    value: function setValueAt(index, value) {
      if (value === null || value === undefined) {
        value = this.defaultValue;
      }
      this.inputs[index].value = value;
    }

    /**
     * Set the value of this component.
     * @param value
     */

  }, {
    key: 'setValue',
    value: function setValue(value, noUpdate, noValidate) {
      if (!this.component.input) {
        return;
      }
      this.value = value;
      var isArray = (0, _isArray3.default)(value);
      for (var i in this.inputs) {
        this.setValueAt(i, isArray ? value[i] : value);
      }
      if (!noUpdate) {
        this.updateValue(noValidate);
      }
    }

    /**
     * Return if the component is disabled.
     * @return {boolean}
     */

  }, {
    key: 'selectOptions',
    value: function selectOptions(select, tag, options, defaultValue) {
      var _this8 = this;

      (0, _each3.default)(options, function (option) {
        var attrs = {
          value: option.value
        };
        if (defaultValue !== undefined && option.value === defaultValue) {
          attrs.selected = 'selected';
        }
        var optionElement = _this8.ce(tag, 'option', attrs);
        optionElement.appendChild(_this8.text(option.label));
        select.appendChild(optionElement);
      });
    }
  }, {
    key: 'setSelectValue',
    value: function setSelectValue(select, value) {
      var options = select.querySelectorAll('option');
      (0, _each3.default)(options, function (option) {
        if (option.value === value) {
          option.setAttribute('selected', 'selected');
        } else {
          option.removeAttribute('selected');
        }
      });
      if (select.onchange) {
        select.onchange();
      }
      if (select.onselect) {
        select.onchange();
      }
    }
  }, {
    key: 'clear',
    value: function clear() {
      this.destroy();
      var element = this.getElement();
      if (element) {
        element.innerHTML = '';
      }
    }
  }, {
    key: 'append',
    value: function append(element) {
      if (this.element) {
        this.element.appendChild(element);
      }
    }
  }, {
    key: 'prepend',
    value: function prepend(element) {
      if (this.element && this.element.firstChild) {
        this.element.insertBefore(element, this.element.firstChild);
      }
    }
  }, {
    key: 'removeChild',
    value: function removeChild(element) {
      if (this.element) {
        this.element.removeChild(element);
      }
    }

    /**
     * Get the element information.
     */

  }, {
    key: 'elementInfo',
    value: function elementInfo() {
      var _this9 = this;

      var attributes = {
        name: this.options.name,
        type: this.component.inputType || 'text',
        class: 'form-control'
      };
      (0, _each3.default)({
        tabindex: 'tabindex',
        placeholder: 'placeholder'
      }, function (path, prop) {
        var attrValue = (0, _get3.default)(_this9.component, path);
        if (attrValue) {
          attributes[prop] = attrValue;
        }
      });
      return {
        type: 'input',
        component: this.component,
        changeEvent: 'change',
        attr: attributes
      };
    }
  }, {
    key: 'className',
    get: function get() {
      var className = this.component.input ? 'form-group has-feedback ' : '';
      className += 'formio-component formio-component-' + this.component.type + ' ';
      if (this.component.key) {
        className += 'formio-component-' + this.component.key + ' ';
      }
      if (this.component.customClass) {
        className += this.component.customClass;
      }
      if (this.component.input && this.component.validate && this.component.validate.required) {
        className += ' required';
      }
      return className;
    }
  }, {
    key: 'defaultValue',
    get: function get() {
      var defaultValue = '';
      if (this.component.defaultValue) {
        defaultValue = this.component.defaultValue;
      } else if (this.component.customDefaultValue) {
        if (typeof this.component.customDefaultValue === 'string') {
          try {
            var row = this.data;
            var data = this.data;
            defaultValue = eval('(function(data, row) { var value = "";' + this.component.customDefaultValue.toString() + '; return value; })(data, row)');
          } catch (e) {
            defaultValue = null;
            /* eslint-disable no-console */
            console.warn('An error occurred getting default value for ' + this.component.key, e);
            /* eslint-enable no-console */
          }
        } else {
          try {
            defaultValue = _jsonLogicJs2.default.apply(this.component.customDefaultValue, {
              data: this.data,
              row: this.data
            });
          } catch (err) {
            defaultValue = null;
            /* eslint-disable no-console */
            console.warn('An error occurred calculating a value for ' + this.component.key, e);
            /* eslint-enable no-console */
          }
        }
      }
      return defaultValue;
    }
  }, {
    key: 'name',
    get: function get() {
      return this.component.label || this.component.placeholder || this.component.key;
    }
  }, {
    key: 'visible',
    set: function set(visible) {
      this.show(visible);
    }
  }, {
    key: 'errors',
    get: function get() {
      return this.error ? [this.error] : [];
    }
  }, {
    key: 'disabled',
    get: function get() {
      return this._disabled;
    }

    /**
     * Disable this component.
     *
     * @param {boolean} disabled
     */

    , set: function set(disabled) {
      this._disabled = disabled;
      // Disable all input.
      (0, _each3.default)(this.inputs, function (input) {
        input.disabled = disabled;
        input.setAttribute('disabled', 'disabled');
      });
    }
  }]);

  return BaseComponent;
}();

exports.BaseComponent = BaseComponent;

BaseComponent.externalLibraries = {};
BaseComponent.requireLibrary = function (name, property, src, polling) {
  if (!BaseComponent.externalLibraries.hasOwnProperty(name)) {
    BaseComponent.externalLibraries[name] = {};
    BaseComponent.externalLibraries[name].ready = new _nativePromiseOnly2.default(function (resolve, reject) {
      BaseComponent.externalLibraries[name].resolve = resolve;
      BaseComponent.externalLibraries[name].reject = reject;
    });

    if (!polling && !window[name + 'Callback']) {
      window[name + 'Callback'] = function () {
        this.resolve();
      }.bind(BaseComponent.externalLibraries[name]);
    }

    // See if the plugin already exists.
    var plugin = (0, _get3.default)(window, property);
    if (plugin) {
      BaseComponent.externalLibraries[name].resolve(plugin);
    } else {
      // Add the script to the top page.
      var script = document.createElement('script');
      script.setAttribute('src', src);
      script.setAttribute('type', 'text/javascript');
      script.setAttribute('defer', true);
      script.setAttribute('async', true);
      document.getElementsByTagName('head')[0].appendChild(script);

      // if no callback is provided, then check periodically for the script.
      if (polling) {
        setTimeout(function checkLibrary() {
          var plugin = (0, _get3.default)(window, property);
          if (plugin) {
            BaseComponent.externalLibraries[name].resolve(plugin);
          } else {
            // check again after 200 ms.
            setTimeout(checkLibrary, 200);
          }
        }, 200);
      }
    }
  }
  return BaseComponent.externalLibraries[name].ready;
};

BaseComponent.libraryReady = function (name) {
  if (BaseComponent.externalLibraries.hasOwnProperty(name) && BaseComponent.externalLibraries[name].ready) {
    return BaseComponent.externalLibraries[name].ready;
  }

  return _nativePromiseOnly2.default.reject(name + ' library was not required.');
};

},{"../../locals/en":43,"../../utils":49,"../Validator":2,"i18next":68,"json-logic-js":69,"lodash/assign":219,"lodash/clone":220,"lodash/debounce":223,"lodash/each":226,"lodash/get":229,"lodash/isArray":234,"native-promise-only":261,"text-mask-all/vanilla":267}],5:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ButtonComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _set = function set(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent !== null) {
      set(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }return value;
};

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _Base = require('../base/Base');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var ButtonComponent = exports.ButtonComponent = function (_BaseComponent) {
  _inherits(ButtonComponent, _BaseComponent);

  function ButtonComponent() {
    _classCallCheck(this, ButtonComponent);

    return _possibleConstructorReturn(this, (ButtonComponent.__proto__ || Object.getPrototypeOf(ButtonComponent)).apply(this, arguments));
  }

  _createClass(ButtonComponent, [{
    key: 'elementInfo',
    value: function elementInfo() {
      var info = _get(ButtonComponent.prototype.__proto__ || Object.getPrototypeOf(ButtonComponent.prototype), 'elementInfo', this).call(this);
      info.type = 'button';
      info.attr.type = this.component.action === 'submit' ? 'submit' : 'button';
      info.attr.class = 'btn btn-' + this.component.theme;
      if (this.component.block) {
        info.attr.class += ' btn-block';
      }
      if (this.component.customClass) {
        info.attr.class += ' ' + this.component.customClass;
      }
      return info;
    }
  }, {
    key: 'build',
    value: function build() {
      var _this2 = this;

      this.element = this.ce('element', this.info.type, this.info.attr);
      if (this.component.label) {
        this.label = this.text(this.component.label);
        this.element.appendChild(this.label);
      }
      if (this.component.action === 'submit') {
        this.on('submitButton', function () {
          _this2.loading = true;
          _this2.disabled = true;
        }, true);
        this.on('submitDone', function () {
          _this2.loading = false;
          _this2.disabled = false;
        }, true);
        this.on('error', function () {
          _this2.loading = false;
        }, true);
      }
      this.addEventListener(this.element, 'click', function (event) {
        switch (_this2.component.action) {
          case 'submit':
            event.preventDefault();
            event.stopPropagation();
            _this2.emit('submitButton');
            break;
          case 'event':
            _this2.events.emit(_this2.component.event, _this2.data);
            _this2.emit('customEvent', {
              type: _this2.component.event,
              component: _this2.component,
              data: _this2.data,
              event: event
            });
            break;
          case 'reset':
            _this2.emit('resetForm');
            break;
          case 'oauth':
            console.log('OAuth currently not supported.');
            break;
        }
      });
      if (this.options.readOnly) {
        this.disabled = true;
      }
    }
  }, {
    key: 'loading',
    set: function set(loading) {
      this._loading = loading;
      if (!this.loader && loading) {
        this.loader = this.ce('buttonLoader', 'i', {
          class: 'glyphicon glyphicon-refresh glyphicon-spin button-icon-right'
        });
      }
      if (this.loader) {
        if (loading) {
          this.element.appendChild(this.loader);
        } else {
          this.element.removeChild(this.loader);
        }
      }
    }
  }, {
    key: 'disabled',
    set: function set(disabled) {
      _set(ButtonComponent.prototype.__proto__ || Object.getPrototypeOf(ButtonComponent.prototype), 'disabled', disabled, this);
      this.element.disable = disabled;
    }
  }]);

  return ButtonComponent;
}(_Base.BaseComponent);

},{"../base/Base":4}],6:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ButtonValueComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _set = function set(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent !== null) {
      set(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }return value;
};

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _Base = require('../base/Base');

var _each2 = require('lodash/each');

var _each3 = _interopRequireDefault(_each2);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var ButtonValueComponent = exports.ButtonValueComponent = function (_BaseComponent) {
  _inherits(ButtonValueComponent, _BaseComponent);

  function ButtonValueComponent() {
    _classCallCheck(this, ButtonValueComponent);

    return _possibleConstructorReturn(this, (ButtonValueComponent.__proto__ || Object.getPrototypeOf(ButtonValueComponent)).apply(this, arguments));
  }

  _createClass(ButtonValueComponent, [{
    key: 'elementInfo',
    value: function elementInfo() {
      var info = _get(ButtonValueComponent.prototype.__proto__ || Object.getPrototypeOf(ButtonValueComponent.prototype), 'elementInfo', this).call(this);
      info.type = 'button';
      info.attr.type = this.component.action === 'submit' ? 'submit' : 'button';
      info.attr.class = 'btn btn-' + this.component.theme;
      info.attr.value = this.component.value ? this.component.value : '';

      if (this.component.block) {
        info.attr.class += ' btn-block';
      }
      if (this.component.customClass) {
        info.attr.class += ' ' + this.component.customClass;
      }
      return info;
    }
  }, {
    key: 'build',
    value: function build() {
      var _this2 = this;

      this.element = this.ce('element', this.info.type, this.info.attr);
      if (this.component.label) {
        this.label = this.text(this.component.label);
        this.element.appendChild(this.label);
      }
      if (this.component.action === 'submit') {
        this.on('submitButton', function () {
          _this2.loading = true;
          _this2.disabled = true;
        }, true);
        this.on('submitDone', function () {
          _this2.loading = false;
          _this2.disabled = false;
        }, true);
        this.on('error', function () {
          _this2.loading = false;
        }, true);
      }
      this.addEventListener(this.element, 'click', function (event) {
        switch (_this2.component.action) {
          case 'submit':
            event.preventDefault();
            event.stopPropagation();
            _this2.emit('submitButton');
            _this2.setValue(_this2.component.value);
            break;
          case 'event':
            _this2.events.emit(_this2.component.event, _this2.data);
            _this2.emit('customEvent', {
              type: _this2.component.event,
              component: _this2.component,
              data: _this2.data,
              event: event
            });
            _this2.setValue(_this2.component.value);
            break;
          case 'reset':
            _this2.emit('resetForm');
            break;
          case 'oauth':
            console.log('OAuth currently not supported.');
            break;
        }
      });
      if (this.options.readOnly) {
        this.disabled = true;
      }
    }
  }, {
    key: 'loading',
    set: function set(loading) {
      this._loading = loading;
      if (!this.loader && loading) {
        this.loader = this.ce('buttonLoader', 'i', {
          class: 'glyphicon glyphicon-refresh glyphicon-spin button-icon-right'
        });
      }
      if (this.loader) {
        if (loading) {
          this.element.appendChild(this.loader);
        } else {
          this.element.removeChild(this.loader);
        }
      }
    }
  }, {
    key: 'disabled',
    set: function set(disabled) {
      _set(ButtonValueComponent.prototype.__proto__ || Object.getPrototypeOf(ButtonValueComponent.prototype), 'disabled', disabled, this);
      this.element.disable = disabled;
    }
  }]);

  return ButtonValueComponent;
}(_Base.BaseComponent);

},{"../base/Base":4,"lodash/each":226}],7:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CheckBoxComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _Base = require('../base/Base');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var CheckBoxComponent = exports.CheckBoxComponent = function (_BaseComponent) {
  _inherits(CheckBoxComponent, _BaseComponent);

  function CheckBoxComponent() {
    _classCallCheck(this, CheckBoxComponent);

    return _possibleConstructorReturn(this, (CheckBoxComponent.__proto__ || Object.getPrototypeOf(CheckBoxComponent)).apply(this, arguments));
  }

  _createClass(CheckBoxComponent, [{
    key: 'elementInfo',
    value: function elementInfo() {
      var info = _get(CheckBoxComponent.prototype.__proto__ || Object.getPrototypeOf(CheckBoxComponent.prototype), 'elementInfo', this).call(this);
      info.type = 'input';
      info.changeEvent = 'click';
      info.attr.type = this.component.inputType;
      info.attr.class = '';
      if (this.component.name) {
        info.attr.name = 'data[' + this.component.name + ']';
      }
      info.attr.value = this.component.value ? this.component.value : 0;
      return info;
    }
  }, {
    key: 'build',
    value: function build() {
      if (!this.component.input) {
        return;
      }
      this.createElement();
      this.input = this.createInput(this.element);
      this.createLabel(this.element, this.input);
      if (!this.label) {
        this.addInput(this.input, this.element);
      }
      if (this.options.readOnly) {
        this.disabled = true;
      }
    }
  }, {
    key: 'createElement',
    value: function createElement() {
      var className = this.className;
      if (this.component.label) {
        className += ' checkbox';
      }
      this.element = this.ce('element', 'div', {
        id: this.id,
        class: className
      });
    }
  }, {
    key: 'createLabel',
    value: function createLabel(container, input) {
      if (!this.component.label) {
        return null;
      }
      this.label = this.ce('label', 'label', {
        class: 'control-label'
      });

      // Create the SPAN around the textNode for better style hooks
      this.labelSpan = this.ce('labelSpan', 'span');

      if (this.info.attr.id) {
        this.label.setAttribute('for', this.info.attr.id);
      }
      this.addInput(input, this.label);
      if (!this.options.inputsOnly) {
        // DMS

        //this.labelSpan.appendChild(this.text(this.component.label));
        //this.label.appendChild(this.labelSpan);

        var labelElement = document.createElement('div');
        labelElement.innerHTML = this.component.label;
        this.label.appendChild(labelElement);
      }
      container.appendChild(this.label);
    }
  }, {
    key: 'createInput',
    value: function createInput(container) {
      if (!this.component.input) {
        return;
      }
      var input = this.ce('input', this.info.type, this.info.attr);
      this.errorContainer = container;
      return input;
    }
  }, {
    key: 'addInputEventListener',
    value: function addInputEventListener(input) {
      var _this2 = this;

      this.addEventListener(input, this.info.changeEvent, function () {
        // If this input has a "name", then its other input elements are elsewhere on
        // the form. To get the correct submission object, we need to refresh the whole
        // data object.
        if (_this2.component.name) {
          _this2.emit('refreshData');
        } else {
          _this2.updateValue();
        }
      });
    }
  }, {
    key: 'getValueAt',
    value: function getValueAt(index) {
      return !!this.inputs[index].checked;
    }
  }, {
    key: 'setValue',
    value: function setValue(value, noUpdate, noValidate) {
      this.value = value;
      if (!this.input) {
        return;
      }
      if (value === 'on') {
        this.input.value = 1;
        this.input.checked = 1;
      } else if (value === 'off') {
        this.input.value = 0;
        this.input.checked = 0;
      } else if (value) {
        this.input.value = 1;
        this.input.checked = 1;
      } else {
        this.input.value = 0;
        this.input.checked = 0;
      }
      if (!noUpdate) {
        this.updateValue(noValidate);
      }
    }
  }]);

  return CheckBoxComponent;
}(_Base.BaseComponent);

},{"../base/Base":4}],8:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ColumnComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _Components = require('../Components');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var ColumnComponent = exports.ColumnComponent = function (_FormioComponents) {
  _inherits(ColumnComponent, _FormioComponents);

  function ColumnComponent() {
    _classCallCheck(this, ColumnComponent);

    return _possibleConstructorReturn(this, (ColumnComponent.__proto__ || Object.getPrototypeOf(ColumnComponent)).apply(this, arguments));
  }

  _createClass(ColumnComponent, [{
    key: 'className',
    get: function get() {
      return 'col col-sm-' + this.component.colWidth;
    }
  }]);

  return ColumnComponent;
}(_Components.FormioComponents);

},{"../Components":1}],9:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ColumnsComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _each2 = require('lodash/each');

var _each3 = _interopRequireDefault(_each2);

var _Components = require('../Components');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var ColumnsComponent = exports.ColumnsComponent = function (_FormioComponents) {
  _inherits(ColumnsComponent, _FormioComponents);

  function ColumnsComponent() {
    _classCallCheck(this, ColumnsComponent);

    return _possibleConstructorReturn(this, (ColumnsComponent.__proto__ || Object.getPrototypeOf(ColumnsComponent)).apply(this, arguments));
  }

  _createClass(ColumnsComponent, [{
    key: 'addComponents',
    value: function addComponents() {
      var _this2 = this;

      var colWidth = Math.floor(12 / this.component.columns.length);
      (0, _each3.default)(this.component.columns, function (column) {
        column.type = 'column';
        column.colWidth = colWidth;
        _this2.addComponent(column, _this2.element, _this2.data);
      });
    }
  }, {
    key: 'className',
    get: function get() {
      return 'row';
    }
  }]);

  return ColumnsComponent;
}(_Components.FormioComponents);

},{"../Components":1,"lodash/each":226}],10:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ContainerComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _Components = require('../Components');

var _isObject2 = require('lodash/isObject');

var _isObject3 = _interopRequireDefault(_isObject2);

var _each2 = require('lodash/each');

var _each3 = _interopRequireDefault(_each2);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var ContainerComponent = exports.ContainerComponent = function (_FormioComponents) {
  _inherits(ContainerComponent, _FormioComponents);

  function ContainerComponent(component, options, data) {
    _classCallCheck(this, ContainerComponent);

    var _this = _possibleConstructorReturn(this, (ContainerComponent.__proto__ || Object.getPrototypeOf(ContainerComponent)).call(this, component, options, data));

    _this.type = 'container';
    return _this;
  }

  _createClass(ContainerComponent, [{
    key: 'build',
    value: function build() {
      this.element = this.ce('element', 'div', {
        class: 'formio-container-component'
      });
      if (!this.data[this.component.key]) {
        this.data[this.component.key] = {};
      }
      this.addComponents(this.element, this.data[this.component.key]);
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      var value = {};
      (0, _each3.default)(this.components, function (component) {
        value[component.component.key] = component.getValue();
      });
      return value;
    }
  }, {
    key: 'setValue',
    value: function setValue(value, noUpdate, noValidate) {
      if (!value || !(0, _isObject3.default)(value)) {
        return;
      }
      this.value = value;
      (0, _each3.default)(this.components, function (component) {
        if (component.type === 'components') {
          component.setValue(value, noUpdate, noValidate);
        } else if (value.hasOwnProperty(component.component.key)) {
          component.setValue(value[component.component.key], noUpdate, noValidate);
        }
      });
      if (!noUpdate) {
        this.updateValue(noValidate);
      }
    }
  }]);

  return ContainerComponent;
}(_Components.FormioComponents);

},{"../Components":1,"lodash/each":226,"lodash/isObject":241}],11:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ContentComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _Base = require('../base/Base');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var ContentComponent = exports.ContentComponent = function (_BaseComponent) {
  _inherits(ContentComponent, _BaseComponent);

  function ContentComponent() {
    _classCallCheck(this, ContentComponent);

    return _possibleConstructorReturn(this, (ContentComponent.__proto__ || Object.getPrototypeOf(ContentComponent)).apply(this, arguments));
  }

  _createClass(ContentComponent, [{
    key: 'build',
    value: function build() {
      this.element = this.ce('element', 'div', {
        class: 'form-group'
      });
      this.element.innerHTML = this.interpolate(this.component.html, { data: this.data });
    }
  }]);

  return ContentComponent;
}(_Base.BaseComponent);

},{"../base/Base":4}],12:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CurrencyComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _vanilla = require('text-mask-all/vanilla');

var _vanilla2 = _interopRequireDefault(_vanilla);

var _createNumberMask = require('text-mask-all/addons/dist/createNumberMask');

var _createNumberMask2 = _interopRequireDefault(_createNumberMask);

var _get2 = require('lodash/get');

var _get3 = _interopRequireDefault(_get2);

var _TextField = require('../textfield/TextField');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var CurrencyComponent = exports.CurrencyComponent = function (_TextFieldComponent) {
  _inherits(CurrencyComponent, _TextFieldComponent);

  function CurrencyComponent() {
    _classCallCheck(this, CurrencyComponent);

    return _possibleConstructorReturn(this, (CurrencyComponent.__proto__ || Object.getPrototypeOf(CurrencyComponent)).apply(this, arguments));
  }

  _createClass(CurrencyComponent, [{
    key: 'setInputMask',
    value: function setInputMask(input) {
      this.inputMask = (0, _vanilla2.default)({
        inputElement: input,
        mask: (0, _createNumberMask2.default)({
          prefix: '',
          suffix: '',
          thousandsSeparatorSymbol: (0, _get3.default)(this.component, 'thousandsSeparator', ','),
          decimalSymbol: (0, _get3.default)(this.component, 'decimalSymbol', '.'),
          allowNegative: (0, _get3.default)(this.component, 'allowNegative', false),
          allowDecimal: (0, _get3.default)(this.component, 'allowDecimal', true)
        })
      });
    }
  }]);

  return CurrencyComponent;
}(_TextField.TextFieldComponent);

},{"../textfield/TextField":37,"lodash/get":229,"text-mask-all/addons/dist/createNumberMask":266,"text-mask-all/vanilla":267}],13:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataGridComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _each2 = require('lodash/each');

var _each3 = _interopRequireDefault(_each2);

var _cloneDeep2 = require('lodash/cloneDeep');

var _cloneDeep3 = _interopRequireDefault(_cloneDeep2);

var _clone2 = require('lodash/clone');

var _clone3 = _interopRequireDefault(_clone2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

var _Components = require('../Components');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var DataGridComponent = exports.DataGridComponent = function (_FormioComponents) {
  _inherits(DataGridComponent, _FormioComponents);

  function DataGridComponent(component, options, data) {
    _classCallCheck(this, DataGridComponent);

    var _this = _possibleConstructorReturn(this, (DataGridComponent.__proto__ || Object.getPrototypeOf(DataGridComponent)).call(this, component, options, data));

    _this.type = 'datagrid';
    return _this;
  }

  _createClass(DataGridComponent, [{
    key: 'build',
    value: function build() {
      this.createElement();
      this.createLabel(this.element);
      if (!this.data.hasOwnProperty(this.component.key)) {
        this.addNewValue();
      }
      this.visibleColumns = true;
      this.buildTable();
    }
  }, {
    key: 'buildTable',
    value: function buildTable(data) {
      var _this2 = this;

      data = data || {};
      if (this.tableElement) {
        this.element.removeChild(this.tableElement);
        this.tableElement.innerHTML = '';
      }

      var tableClass = 'table datagrid-table table-bordered form-group formio-data-grid ';
      (0, _each3.default)(['striped', 'bordered', 'hover', 'condensed'], function (prop) {
        if (_this2.component[prop]) {
          tableClass += 'table-' + prop + ' ';
        }
      });
      this.tableElement = this.ce('element', 'table', {
        class: tableClass
      });

      var thead = this.ce('header', 'thead');

      // Build the header.
      var tr = this.ce('headerRow', 'tr');
      (0, _each3.default)(this.component.components, function (comp) {
        if (_this2.visibleColumns === true || _this2.visibleColumns[comp.key]) {
          var _th = _this2.ce('headerColumn', 'th');
          if (comp.validate && comp.validate.required) {
            _th.setAttribute('class', 'field-required');
          }
          var title = comp.label || comp.title;
          if (title) {
            _th.appendChild(_this2.text(title));
          }
          tr.appendChild(_th);
        }
      });
      var th = this.ce('headerExtra', 'th');
      tr.appendChild(th);
      thead.appendChild(tr);
      this.tableElement.appendChild(thead);

      // Create the table body.
      this.tbody = this.ce('table', 'tbody');

      // Build the rows.
      this.buildRows(data);

      // Add the body to the table and to the element.
      this.tableElement.appendChild(this.tbody);
      this.element.appendChild(this.tableElement);
    }
  }, {
    key: 'buildRows',
    value: function buildRows(data) {
      var _this3 = this;

      var components = require('../index');
      this.tbody.innerHTML = '';
      this.rows = [];
      (0, _each3.default)(this.data[this.component.key], function (row, index) {
        var tr = _this3.ce('tableRow', 'tr');
        var cols = {};
        (0, _each3.default)(_this3.component.components, function (col) {
          var column = (0, _cloneDeep3.default)(col);
          column.label = false;
          column.row = _this3.row + '-' + index;
          var options = (0, _clone3.default)(_this3.options);
          options.name += '[' + index + ']';
          var comp = components.create(column, options, row);
          if (row.hasOwnProperty(column.key)) {
            comp.setValue(row[column.key]);
          } else if (comp.type === 'components') {
            comp.setValue(row);
          }
          cols[column.key] = comp;
          if (_this3.visibleColumns === true || _this3.visibleColumns[col.key]) {
            var _td = _this3.ce('tableColumn', 'td');
            _td.appendChild(comp.element);
            tr.appendChild(_td);
            comp.checkConditions(data);
          }
        });
        _this3.rows.push(cols);
        var td = _this3.ce('tableRemoveRow', 'td');
        td.appendChild(_this3.removeButton(index));
        tr.appendChild(td);
        _this3.tbody.appendChild(tr);
      });

      // Add the add button.
      var tr = this.ce('tableAddRow', 'tr');
      var td = this.ce('tableAddColumn', 'td', {
        colspan: this.component.components.length + 1
      });
      td.appendChild(this.addButton());
      tr.appendChild(td);
      this.tbody.appendChild(tr);
    }
  }, {
    key: 'checkConditions',
    value: function checkConditions(data) {
      var _this4 = this;

      var show = _get(DataGridComponent.prototype.__proto__ || Object.getPrototypeOf(DataGridComponent.prototype), 'checkConditions', this).call(this, data);
      var rebuild = false;
      if (this.visibleColumns === true) {
        this.visibleColumns = {};
      }
      (0, _each3.default)(this.component.components, function (col) {
        var showColumn = false;
        (0, _each3.default)(_this4.rows, function (comps) {
          showColumn |= comps[col.key].checkConditions(data);
        });
        if (_this4.visibleColumns[col.key] && !showColumn || !_this4.visibleColumns[col.key] && showColumn) {
          rebuild = true;
        }

        _this4.visibleColumns[col.key] = showColumn;
        show |= showColumn;
      });

      // If a rebuild is needed, then rebuild the table.
      if (rebuild && show) {
        this.buildTable(data);
      }

      // Return if this table should show.
      return show;
    }
  }, {
    key: 'setValue',
    value: function setValue(value, noUpdate, noValidate) {
      if (!value) {
        return;
      }
      if (!(0, _isArray3.default)(value)) {
        return;
      }

      this.value = value;

      // Add needed rows.
      for (var i = this.rows.length; i < value.length; i++) {
        this.addValue();
      }

      (0, _each3.default)(this.rows, function (row, index) {
        if (value.length <= index) {
          return;
        }
        (0, _each3.default)(row, function (col, key) {
          if (col.type === 'components') {
            col.setValue(value[index], noUpdate, noValidate);
          } else if (value[index].hasOwnProperty(key)) {
            col.setValue(value[index][key], noUpdate, noValidate);
          }
        });
      });
    }

    /**
     * Get the value of this component.
     *
     * @returns {*}
     */

  }, {
    key: 'getValue',
    value: function getValue() {
      var values = [];
      (0, _each3.default)(this.rows, function (row) {
        var value = {};
        (0, _each3.default)(row, function (col) {
          if (col && col.component && col.component.key) {
            value[col.component.key] = col.getValue();
          }
        });
        values.push(value);
      });
      return values;
    }
  }, {
    key: 'defaultValue',
    get: function get() {
      return {};
    }
  }]);

  return DataGridComponent;
}(_Components.FormioComponents);

},{"../Components":1,"../index":22,"lodash/clone":220,"lodash/cloneDeep":221,"lodash/each":226,"lodash/isArray":234}],14:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DateTimeComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _set = function set(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent !== null) {
      set(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }return value;
};

var _get2 = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _Base = require('../base/Base');

var _flatpickr = require('flatpickr');

var _flatpickr2 = _interopRequireDefault(_flatpickr);

var _get3 = require('lodash/get');

var _get4 = _interopRequireDefault(_get3);

var _each2 = require('lodash/each');

var _each3 = _interopRequireDefault(_each2);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var DateTimeComponent = exports.DateTimeComponent = function (_BaseComponent) {
  _inherits(DateTimeComponent, _BaseComponent);

  function DateTimeComponent(component, options, data) {
    _classCallCheck(this, DateTimeComponent);

    var _this = _possibleConstructorReturn(this, (DateTimeComponent.__proto__ || Object.getPrototypeOf(DateTimeComponent)).call(this, component, options, data));

    _this.validators.push('date');
    return _this;
  }

  _createClass(DateTimeComponent, [{
    key: 'elementInfo',
    value: function elementInfo() {
      var info = _get2(DateTimeComponent.prototype.__proto__ || Object.getPrototypeOf(DateTimeComponent.prototype), 'elementInfo', this).call(this);
      info.type = 'input';
      info.attr.type = 'text';
      info.changeEvent = 'input';
      this.component.suffix = true;
      return info;
    }

    // This select component can handle multiple items on its own.

  }, {
    key: 'createWrapper',
    value: function createWrapper() {
      return false;
    }
  }, {
    key: 'convertFormat',
    value: function convertFormat(format) {
      // Year conversion.
      format = format.replace(/y/g, 'Y');
      format = format.replace('YYYY', 'Y');
      format = format.replace('YY', 'y');

      // Month conversion.
      format = format.replace('MMMM', 'F');
      format = format.replace(/M/g, 'n');
      format = format.replace('nnn', 'M');
      format = format.replace('nn', 'm');

      // Day in month.
      format = format.replace(/d/g, 'j');
      format = format.replace('jj', 'd');

      // Day in week.
      format = format.replace('EEEE', 'l');
      format = format.replace('EEE', 'D');

      // Hours, minutes, seconds
      format = format.replace('HH', 'H');
      format = format.replace('hh', 'h');
      format = format.replace('mm', 'i');
      format = format.replace('ss', 'S');
      format = format.replace(/a/g, 'K');
      return format;
    }
  }, {
    key: 'addSuffix',
    value: function addSuffix(input, inputGroup) {
      var suffix = this.ce('suffix', 'span', {
        class: 'input-group-addon'
      });
      suffix.appendChild(this.getIcon(this.component.enableDate ? 'calendar' : 'time'));
      inputGroup.appendChild(suffix);
      return suffix;
    }
  }, {
    key: 'addInput',
    value: function addInput(input, container, name) {
      _get2(DateTimeComponent.prototype.__proto__ || Object.getPrototypeOf(DateTimeComponent.prototype), 'addInput', this).call(this, input, container, name);
      input.calendar = new _flatpickr2.default(input, this.config);
    }
  }, {
    key: 'getDate',
    value: function getDate(value) {
      var timestamp = parseInt(value, 10);
      if (!timestamp) {
        // Just default to today.
        return new Date();
      }
      return new Date(timestamp * 1000);
    }
  }, {
    key: 'getRawValue',
    value: function getRawValue() {
      var values = [];
      for (var i in this.inputs) {
        if (!this.component.multiple) {
          return this.getDate(this.inputs[i].value);
        }
        values.push(this.getDate(this.inputs[i].value));
      }
      return values;
    }
  }, {
    key: 'getValueAt',
    value: function getValueAt(index) {
      return this.getDate(this.inputs[index].value).toISOString();
    }
  }, {
    key: 'setValueAt',
    value: function setValueAt(index, value) {
      if (this.inputs[index].calendar) {
        var date = value ? new Date(value) : new Date();
        this.inputs[index].calendar.setDate(date);
      }
    }
  }, {
    key: 'config',
    get: function get() {
      var _this2 = this;

      return {
        altInput: true,
        clickOpens: true,
        enableDate: true,
        mode: this.component.multiple ? 'multiple' : 'single',
        enableTime: (0, _get4.default)(this.component, 'enableTime', true),
        noCalendar: !(0, _get4.default)(this.component, 'enableDate', true),
        altFormat: this.convertFormat((0, _get4.default)(this.component, 'format', '')),
        dateFormat: 'U',
        defaultDate: (0, _get4.default)(this.component, 'defaultDate', ''),
        hourIncrement: (0, _get4.default)(this.component, 'timePicker.hourStep', 1),
        minuteIncrement: (0, _get4.default)(this.component, 'timePicker.minuteStep', 5),
        onChange: function onChange() {
          return _this2.onChange();
        }
      };
    }
  }, {
    key: 'disabled',
    set: function set(disabled) {
      _set(DateTimeComponent.prototype.__proto__ || Object.getPrototypeOf(DateTimeComponent.prototype), 'disabled', disabled, this);
      (0, _each3.default)(this.inputs, function (input) {
        if (input.calendar) {
          input.calendar.redraw();
        }
      });
    }
  }]);

  return DateTimeComponent;
}(_Base.BaseComponent);

},{"../base/Base":4,"flatpickr":52,"lodash/each":226,"lodash/get":229}],15:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DayComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get2 = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _Base = require('../base/Base');

var _get3 = require('lodash/get');

var _get4 = _interopRequireDefault(_get3);

var _each2 = require('lodash/each');

var _each3 = _interopRequireDefault(_each2);

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var DayComponent = exports.DayComponent = function (_BaseComponent) {
  _inherits(DayComponent, _BaseComponent);

  function DayComponent(component, options, data) {
    _classCallCheck(this, DayComponent);

    var _this = _possibleConstructorReturn(this, (DayComponent.__proto__ || Object.getPrototypeOf(DayComponent)).call(this, component, options, data));

    _this.validators.push('date');
    return _this;
  }

  _createClass(DayComponent, [{
    key: 'elementInfo',
    value: function elementInfo() {
      var info = _get2(DayComponent.prototype.__proto__ || Object.getPrototypeOf(DayComponent.prototype), 'elementInfo', this).call(this);
      info.type = 'input';
      info.attr.type = 'hidden';
      info.changeEvent = 'change';
      return info;
    }
  }, {
    key: 'createDayInput',
    value: function createDayInput() {
      var _this2 = this;

      var dayColumn = this.ce('dayColumn', 'div', {
        class: 'form-group col col-xs-3'
      });
      var dayLabel = this.ce('dayLabel', 'label', {
        for: this.component.key + '-day',
        class: (0, _get4.default)(this.component, 'fields.day.required', false) ? 'field-required' : ''
      });
      dayLabel.appendChild(this.text(this.t('day')));
      dayColumn.appendChild(dayLabel);
      this.dayInput = this.ce('dayInput', 'input', {
        class: 'form-control',
        type: 'number',
        step: '1',
        min: '1',
        max: '31',
        placeholder: (0, _get4.default)(this.component, 'fields.day.placeholder', ''),
        id: this.component.key + '-day'
      });
      this.addEventListener(this.dayInput, 'change', function () {
        return _this2.updateValue();
      });
      dayColumn.appendChild(this.dayInput);
      return dayColumn;
    }
  }, {
    key: 'createMonthInput',
    value: function createMonthInput() {
      var monthColumn = this.ce('monthColumn', 'div', {
        class: 'form-group col col-xs-4'
      });
      var monthLabel = this.ce('monthLabel', 'label', {
        for: this.component.key + '-month',
        class: (0, _get4.default)(this.component, 'fields.month.required', false) ? 'field-required' : ''
      });
      monthLabel.appendChild(this.text(this.t('month')));
      monthColumn.appendChild(monthLabel);
      this.monthInput = this.ce('monthInput', 'select', {
        class: 'form-control',
        id: this.component.key + '-month'
      });
      this.selectOptions(this.monthInput, 'monthOption', this.months);
      var self = this;

      // Ensure the day limits match up with the months selected.
      this.monthInput.onchange = function () {
        self.dayInput.max = new Date(self.yearInput.value, this.value, 0).getDate();
        if (self.dayInput.value > self.dayInput.max) {
          self.dayInput.value = self.dayInput.max;
        }
        self.updateValue();
      };
      monthColumn.appendChild(this.monthInput);
      return monthColumn;
    }
  }, {
    key: 'createYearInput',
    value: function createYearInput() {
      var _this3 = this;

      var yearColumn = this.ce('yearColumn', 'div', {
        class: 'form-group col col-xs-5'
      });
      var yearLabel = this.ce('yearLabel', 'label', {
        for: this.component.key + '-year',
        class: (0, _get4.default)(this.component, 'fields.year.required', false) ? 'field-required' : ''
      });
      yearLabel.appendChild(this.text(this.t('year')));
      yearColumn.appendChild(yearLabel);
      this.yearInput = this.ce('yearInput', 'input', {
        class: 'form-control',
        type: 'number',
        step: '1',
        min: '1',
        placeholder: (0, _get4.default)(this.component, 'fields.year.placeholder', ''),
        value: new Date().getFullYear(),
        id: this.component.key + '-year'
      });
      this.addEventListener(this.yearInput, 'change', function () {
        return _this3.updateValue();
      });
      yearColumn.appendChild(this.yearInput);
      return yearColumn;
    }
  }, {
    key: 'createInput',
    value: function createInput(container) {
      var inputGroup = this.ce('inputGroup', 'div', {
        class: 'input-group row'
      });

      var dayColumn = this.createDayInput();
      var monthColumn = this.createMonthInput();
      var yearColumn = this.createYearInput();

      // Add the columns to the day select in the right order.
      if (this.component.dayFirst && !(0, _get4.default)(this.component, 'fields.day.hide', false)) {
        inputGroup.appendChild(dayColumn);
      }
      if (!(0, _get4.default)(this.component, 'fields.month.hide', false)) {
        inputGroup.appendChild(monthColumn);
      }
      if (!this.component.dayFirst && !(0, _get4.default)(this.component, 'fields.day.hide', false)) {
        inputGroup.appendChild(dayColumn);
      }
      if (!(0, _get4.default)(this.component, 'fields.year.hide', false)) {
        inputGroup.appendChild(yearColumn);
      }

      var input = this.ce('input', this.info.type, this.info.attr);
      this.addInput(input, inputGroup);
      this.errorContainer = container;
      container.appendChild(inputGroup);
    }

    /**
     * Set the value at a specific index.
     *
     * @param index
     * @param value
     */

  }, {
    key: 'setValueAt',
    value: function setValueAt(index, value) {
      if (!value) {
        return;
      }
      var parts = value.split('/');
      if (this.component.dayFirst && !(0, _get4.default)(this.component, 'fields.day.hide', false)) {
        this.dayInput.value = parseInt(parts.shift(), 10);
      }
      if (!(0, _get4.default)(this.component, 'fields.month.hide', false)) {
        this.monthInput.value = parseInt(parts.shift(), 10);
      }
      if (!this.component.dayFirst && !(0, _get4.default)(this.component, 'fields.day.hide', false)) {
        this.dayInput.value = parseInt(parts.shift(), 10);
      }
      if (!(0, _get4.default)(this.component, 'fields.year.hide', false)) {
        this.yearInput.value = parseInt(parts.shift(), 10);
      }
    }

    /**
     * Get the format for the value string.
     * @returns {string}
     */

  }, {
    key: 'getRawValue',

    /**
     * Return the raw value.
     *
     * @returns {Date}
     */
    value: function getRawValue() {
      return this.date.format();
    }

    /**
     * Get the value at a specific index.
     *
     * @param index
     * @returns {*}
     */

  }, {
    key: 'getValueAt',
    value: function getValueAt(index) {
      this.inputs[index].value = this.date.format(this.format);
      return this.inputs[index].value;
    }
  }, {
    key: 'months',
    get: function get() {
      if (this._months) {
        return this._months;
      }
      this._months = [{ value: 0, label: (0, _get4.default)(this.component, 'fields.month.placeholder', '') }, { value: 1, label: this.t('january') }, { value: 2, label: this.t('february') }, { value: 3, label: this.t('march') }, { value: 4, label: this.t('april') }, { value: 5, label: this.t('may') }, { value: 6, label: this.t('june') }, { value: 7, label: this.t('july') }, { value: 8, label: this.t('august') }, { value: 9, label: this.t('september') }, { value: 10, label: this.t('october') }, { value: 11, label: this.t('november') }, { value: 12, label: this.t('december') }];
      return this._months;
    }
  }, {
    key: 'format',
    get: function get() {
      var format = '';
      if (this.component.dayFirst && !(0, _get4.default)(this.component, 'fields.day.hide', false)) {
        format += 'D/';
      }
      if (!(0, _get4.default)(this.component, 'fields.month.hide', false)) {
        format += 'M/';
      }
      if (!this.component.dayFirst && !(0, _get4.default)(this.component, 'fields.day.hide', false)) {
        format += 'D/';
      }
      if (!(0, _get4.default)(this.component, 'fields.year.hide', false)) {
        format += 'YYYY';
      }
      return format;
    }

    /**
     * Return the date object for this component.
     * @returns {Date}
     */

  }, {
    key: 'date',
    get: function get() {
      var day = this.dayInput.value;
      var month = this.monthInput.value;
      var year = this.yearInput.value;
      return (0, _moment2.default)([parseInt(year, 10), parseInt(month, 10) - 1, parseInt(day, 10)]);
    }
  }]);

  return DayComponent;
}(_Base.BaseComponent);

},{"../base/Base":4,"lodash/each":226,"lodash/get":229,"moment":260}],16:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EmailComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _TextField = require('../textfield/TextField');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var EmailComponent = exports.EmailComponent = function (_TextFieldComponent) {
  _inherits(EmailComponent, _TextFieldComponent);

  function EmailComponent(component, options, data) {
    _classCallCheck(this, EmailComponent);

    var _this = _possibleConstructorReturn(this, (EmailComponent.__proto__ || Object.getPrototypeOf(EmailComponent)).call(this, component, options, data));

    _this.validators.push('email');
    return _this;
  }

  _createClass(EmailComponent, [{
    key: 'elementInfo',
    value: function elementInfo() {
      var info = _get(EmailComponent.prototype.__proto__ || Object.getPrototypeOf(EmailComponent.prototype), 'elementInfo', this).call(this);
      info.attr.type = 'email';
      return info;
    }
  }]);

  return EmailComponent;
}(_TextField.TextFieldComponent);

},{"../textfield/TextField":37}],17:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FieldsetComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _Components = require('../Components');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var FieldsetComponent = exports.FieldsetComponent = function (_FormioComponents) {
  _inherits(FieldsetComponent, _FormioComponents);

  function FieldsetComponent() {
    _classCallCheck(this, FieldsetComponent);

    return _possibleConstructorReturn(this, (FieldsetComponent.__proto__ || Object.getPrototypeOf(FieldsetComponent)).apply(this, arguments));
  }

  _createClass(FieldsetComponent, [{
    key: 'build',
    value: function build() {
      this.element = this.ce('element', 'fieldset', {
        id: this.id,
        class: this.className + ' form-group'
      });
      if (this.component.legend) {
        var legend = this.ce('legend', 'legend');
        legend.appendChild(this.text(this.component.legend));
        this.element.appendChild(legend);
      }
      this.addComponents(this.element);
    }
  }]);

  return FieldsetComponent;
}(_Components.FormioComponents);

},{"../Components":1}],18:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FormComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _formio = require('../../formio.form');

var _formio2 = _interopRequireDefault(_formio);

var _utils = require('../../utils');

var _utils2 = _interopRequireDefault(_utils);

var _merge2 = require('lodash/merge');

var _merge3 = _interopRequireDefault(_merge2);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var FormComponent = exports.FormComponent = function (_FormioForm) {
  _inherits(FormComponent, _FormioForm);

  function FormComponent(component, options, data) {
    _classCallCheck(this, FormComponent);

    var _this = _possibleConstructorReturn(this, (FormComponent.__proto__ || Object.getPrototypeOf(FormComponent)).call(this, null, options));

    _this.type = 'formcomponent';
    _this.component = component;
    _this.submitted = false;
    _this.data = data;

    // Make sure that if reference is provided, the form must submit.
    if (_this.component.reference) {
      _this.component.submit = true;
    }

    // Build the source based on the root src path.
    if (!component.src && component.path && _this.options.formio) {
      var rootSrc = _this.options.formio.formUrl;
      var parts = rootSrc.split('/');
      parts.pop();
      component.src = parts.join('/') + '/' + component.path;
    }

    // Add the source to this actual submission if the component is a reference.
    if (data[component.key] && _this.component.reference && component.src.indexOf('/submission/') === -1) {
      component.src += '/submission/' + data[component.key]._id;
    }

    // Set the src if the property is provided in the JSON.
    if (component.src) {
      _this.src = component.src;
    }

    // Directly set the submission if it isn't a reference.
    if (data[component.key] && !_this.component.reference) {
      _this.setSubmission(data[component.key]);
    }
    return _this;
  }

  /**
   * Submit the form before the next page is triggered.
   */

  _createClass(FormComponent, [{
    key: 'beforeNext',
    value: function beforeNext() {
      // If we wish to submit the form on next page, then do that here.
      if (this.component.submit) {
        this.submitted = true;
        return this.submit(true);
      } else {
        return _get(FormComponent.prototype.__proto__ || Object.getPrototypeOf(FormComponent.prototype), 'beforeNext', this).call(this);
      }
    }

    /**
     * Submit the form before the whole form is triggered.
     */

  }, {
    key: 'beforeSubmit',
    value: function beforeSubmit() {
      // Before we submit, we need to filter out the references.
      this.data[this.component.key] = this.component.reference ? { _id: this._submission._id } : this._submission;

      // Ensure we submit the form.
      if (this.component.submit && !this.submitted) {
        return this.submit(true);
      } else {
        return _get(FormComponent.prototype.__proto__ || Object.getPrototypeOf(FormComponent.prototype), 'beforeSubmit', this).call(this);
      }
    }
  }, {
    key: 'build',
    value: function build() {
      if (!this.element) {
        this.createElement();
        this.setElement(this.element);
      }

      // Iterate through every component and hide the submit button.
      _utils2.default.eachComponent(this.component.components, function (component) {
        if (component.type === 'button' && component.action === 'submit') {
          component.hidden = true;
        }
      });

      if (!this.data[this.component.key]) {
        this.data[this.component.key] = { data: {} };
      }

      // Add components using the data of the submission.
      this.addComponents(this.element, this.data[this.component.key].data);

      // Set default values.
      var defaultValue = this.defaultValue;
      if (defaultValue) {
        this.setValue(defaultValue);
      }

      // Check conditions for this form.
      this.checkConditions(this.getValue());
    }
  }, {
    key: 'setValue',
    value: function setValue(submission, noUpdate, noValidate) {
      var _this2 = this;

      if (!submission) {
        this.data[this.component.key] = this._submission = { data: {} };
        return;
      }

      if (submission.data) {
        this._submission = (0, _merge3.default)(this.data[this.component.key], submission);
        return _get(FormComponent.prototype.__proto__ || Object.getPrototypeOf(FormComponent.prototype), 'setValue', this).call(this, submission, noUpdate, noValidate);
      } else if (submission._id) {
        this.formio.submissionId = submission._id;
        this.formio.submissionUrl = this.formio.submissionsUrl + '/' + submission._id;
        return this.formReady.then(function () {
          _this2._loading = false;
          _this2.loading = true;
          return _this2.formio.loadSubmission().then(function (result) {
            _this2.loading = false;
            return _this2.setValue(result);
          });
        });
      }
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return this.data[this.component.key];
    }
  }]);

  return FormComponent;
}(_formio2.default);

},{"../../formio.form":40,"../../utils":49,"lodash/merge":250}],19:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GmapComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _Base = require('../base/Base');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var GmapComponent = exports.GmapComponent = function (_BaseComponent) {
  _inherits(GmapComponent, _BaseComponent);

  function GmapComponent(component, options, data) {
    _classCallCheck(this, GmapComponent);

    // Get the source for Google Maps API
    var _this = _possibleConstructorReturn(this, (GmapComponent.__proto__ || Object.getPrototypeOf(GmapComponent)).call(this, component, options, data));

    var src = 'https://maps.googleapis.com/maps/api/js?v=3&libraries=places&callback=googleMapsCallback';
    if (component.map && component.map.key) {
      src += '&key=' + component.map.key;
    }
    if (component.map && component.map.region) {
      src += '&region=' + component.map.region;
    }
    _Base.BaseComponent.requireLibrary('googleMaps', 'google.maps.places', src);
    return _this;
  }

  _createClass(GmapComponent, [{
    key: 'build',
    value: function build() {
      this.element = this.ce('element', 'div', {
        class: 'map-container'
      });
      this.initGoogleMap();
      this.input = this.createInput(this.element);
      this.addInput(this.input, this.element);
      var gmapElement = this.ce('gmapElement', 'div', {
        id: this.component.map.gmapId,
        style: "min-height: 300px; height: calc(100vh - 600px);"
      });
      this.element.appendChild(gmapElement);
    }
  }, {
    key: 'setValue',
    value: function setValue(value, noUpdate) {
      _get(GmapComponent.prototype.__proto__ || Object.getPrototypeOf(GmapComponent.prototype), 'setValue', this).call(this, value, noUpdate, true);
    }
  }, {
    key: 'addInput',
    value: function addInput(input, container) {
      var _this2 = this;

      _get(GmapComponent.prototype.__proto__ || Object.getPrototypeOf(GmapComponent.prototype), 'addInput', this).call(this, input, container);
      var that = this;
      _Base.BaseComponent.libraryReady('googleMaps').then(function () {
        var autocompleteOptions = {};
        if (_this2.component.map) {
          autocompleteOptions = _this2.component.map.autocompleteOptions || {};
        }
        var autocomplete = new google.maps.places.Autocomplete(input, autocompleteOptions);
        autocomplete.addListener('place_changed', function () {
          that.marker.setVisible(false);
          var place = autocomplete.getPlace();
          if (!place.geometry) {
            console.log("Autocomplete's returned place contains no geometry");
            return;
          }

          // If the place has a geometry, then present it on a map.
          if (place.geometry.viewport) {
            that.map.fitBounds(place.geometry.viewport);
          } else {
            that.map.setCenter(place.geometry.location);
            that.map.setZoom(17); // Why 17? Because it looks good.
          }
          that.marker.setIcon( /** @type {google.maps.Icon} */{
            url: place.icon,
            size: new google.maps.Size(71, 71),
            origin: new google.maps.Point(0, 0),
            anchor: new google.maps.Point(17, 34),
            scaledSize: new google.maps.Size(35, 35)
          });
          that.marker.setPosition(place.geometry.location);
          that.marker.setVisible(true);
          var address = '';
          if (place.address_components) {
            address = [place.address_components[0] && place.address_components[0].short_name || '', place.address_components[1] && place.address_components[1].short_name || '', place.address_components[2] && place.address_components[2].short_name || ''].join(' ');
          }
          that.setValue(place.name);
        });
      });
    }
  }, {
    key: 'elementInfo',
    value: function elementInfo() {
      var info = _get(GmapComponent.prototype.__proto__ || Object.getPrototypeOf(GmapComponent.prototype), 'elementInfo', this).call(this);
      info.attr.class += ' Gmap-search';
      return info;
    }
  }, {
    key: 'initGoogleMap',
    value: function initGoogleMap() {
      var _this3 = this;

      _Base.BaseComponent.libraryReady('googleMaps').then(function (result) {
        var defaultLatlng = new google.maps.LatLng(45.5041482, -73.5574125);
        var options = {
          zoom: 19,
          center: defaultLatlng,
          mapTypeId: google.maps.MapTypeId.ROADMAP,
          styles: [{
            "featureType": "poi",
            "stylers": [{
              "visibility": "off"
            }]
          }, {
            "featureType": "transit",
            "stylers": [{
              "visibility": "off"
            }]
          }]
        };

        var mapElement = document.getElementById(_this3.component.map.gmapId);
        if (!mapElement) {
          return;
        }
        _this3.map = new google.maps.Map(mapElement, options);
        _this3.addMarker(defaultLatlng, 'Default Marker', _this3.map);
      });
    }
  }, {
    key: 'addMarker',
    value: function addMarker(latlng, title, map) {
      var that = this;
      this.marker = new google.maps.Marker({
        position: latlng,
        map: map,
        title: title,
        draggable: true
      });
      this.marker.addListener('dragend', function (event) {
        var geocoder = new google.maps.Geocoder();
        var latlng = { lat: parseFloat(event.latLng.lat()), lng: parseFloat(event.latLng.lng()) };
        geocoder.geocode({ 'location': latlng }, function (results, status) {
          if (status === google.maps.GeocoderStatus.OK) {
            if (results[1]) {
              that.setValue(results[0].formatted_address);
            } else {
              console.log('No results found');
            }
          } else {
            console.log('Geocoder failed due to: ' + status);
          }
        });
      });
    }
  }]);

  return GmapComponent;
}(_Base.BaseComponent);

},{"../base/Base":4}],20:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HiddenComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _Base = require('../base/Base');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var HiddenComponent = exports.HiddenComponent = function (_BaseComponent) {
  _inherits(HiddenComponent, _BaseComponent);

  function HiddenComponent() {
    _classCallCheck(this, HiddenComponent);

    return _possibleConstructorReturn(this, (HiddenComponent.__proto__ || Object.getPrototypeOf(HiddenComponent)).apply(this, arguments));
  }

  _createClass(HiddenComponent, [{
    key: 'elementInfo',
    value: function elementInfo() {
      var info = _get(HiddenComponent.prototype.__proto__ || Object.getPrototypeOf(HiddenComponent.prototype), 'elementInfo', this).call(this);
      info.type = 'input';
      info.attr.type = 'hidden';
      info.changeEvent = 'change';
      return info;
    }
  }, {
    key: 'createLabel',
    value: function createLabel(container) {
      return;
    }
  }]);

  return HiddenComponent;
}(_Base.BaseComponent);

},{"../base/Base":4}],21:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HTMLComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _Base = require('../base/Base');

var _each2 = require('lodash/each');

var _each3 = _interopRequireDefault(_each2);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var HTMLComponent = exports.HTMLComponent = function (_BaseComponent) {
  _inherits(HTMLComponent, _BaseComponent);

  function HTMLComponent() {
    _classCallCheck(this, HTMLComponent);

    return _possibleConstructorReturn(this, (HTMLComponent.__proto__ || Object.getPrototypeOf(HTMLComponent)).apply(this, arguments));
  }

  _createClass(HTMLComponent, [{
    key: 'build',
    value: function build() {
      var _this2 = this;

      this.element = this.ce('element', this.component.tag, {
        class: this.component.className
      });
      (0, _each3.default)(this.component.attrs, function (attr) {
        if (attr.attr) {
          _this2.element.setAttribute(attr.attr, attr.value);
        }
      });
      if (this.component.content) {
        this.element.innerHTML = this.component.content;
      }
    }
  }]);

  return HTMLComponent;
}(_Base.BaseComponent);

},{"../base/Base":4,"lodash/each":226}],22:[function(require,module,exports){
'use strict';

var _Address = require('./address/Address');

var _Base = require('./base/Base');

var _Content = require('./content/Content');

var _Container = require('./container/Container');

var _DataGrid = require('./datagrid/DataGrid');

var _DateTime = require('./datetime/DateTime');

var _Day = require('./day/Day');

var _HTML = require('./html/HTML');

var _Hidden = require('./hidden/Hidden');

var _Form = require('./form/Form');

var _TextField = require('./textfield/TextField');

var _PhoneNumber = require('./phonenumber/PhoneNumber');

var _Email = require('./email/Email');

var _Checkbox = require('./checkbox/Checkbox');

var _Currency = require('./currency/Currency');

var _Fieldset = require('./fieldset/Fieldset');

var _Signature = require('./signature/Signature');

var _Select = require('./select/Select');

var _Resource = require('./resource/Resource');

var _TextArea = require('./textarea/TextArea');

var _Button = require('./button/Button');

var _Number = require('./number/Number');

var _Password = require('./password/Password');

var _Panel = require('./panel/Panel');

var _Column = require('./columns/Column');

var _Columns = require('./columns/Columns');

var _Table = require('./table/Table');

var _Unknown = require('./unknown/Unknown');

var _Radio = require('./radio/Radio');

var _SelectBoxes = require('./selectboxes/SelectBoxes');

var _Survey = require('./survey/Survey');

var _Well = require('./well/Well');

var _Gmap = require('./gmap/Gmap');

var _Jornaya = require('./jornaya/Jornaya');

var _ButtonValue = require('./buttonvalue/ButtonValue');

var _Slider = require('./slider/Slider');

module.exports = {
  address: _Address.AddressComponent,
  base: _Base.BaseComponent,
  content: _Content.ContentComponent,
  container: _Container.ContainerComponent,
  datagrid: _DataGrid.DataGridComponent,
  datetime: _DateTime.DateTimeComponent,
  day: _Day.DayComponent,
  htmlelement: _HTML.HTMLComponent,
  hidden: _Hidden.HiddenComponent,
  form: _Form.FormComponent,
  textfield: _TextField.TextFieldComponent,
  phoneNumber: _PhoneNumber.PhoneNumberComponent,
  email: _Email.EmailComponent,
  checkbox: _Checkbox.CheckBoxComponent,
  currency: _Currency.CurrencyComponent,
  fieldset: _Fieldset.FieldsetComponent,
  signature: _Signature.SignatureComponent,
  select: _Select.SelectComponent,
  resource: _Resource.ResourceComponent,
  textarea: _TextArea.TextAreaComponent,
  button: _Button.ButtonComponent,
  number: _Number.NumberComponent,
  password: _Password.PasswordComponent,
  panel: _Panel.PanelComponent,
  column: _Column.ColumnComponent,
  columns: _Columns.ColumnsComponent,
  table: _Table.TableComponent,
  unknown: _Unknown.UnknownComponent,
  radio: _Radio.RadioComponent,
  selectboxes: _SelectBoxes.SelectBoxesComponent,
  survey: _Survey.SurveyComponent,
  well: _Well.WellComponent,
  gmap: _Gmap.GmapComponent,
  jornaya: _Jornaya.JornayaComponent,
  buttonvalue: _ButtonValue.ButtonValueComponent,
  slider: _Slider.SliderComponent,
  create: function create(component, options, data) {
    var comp = null;
    if (!component.type) {
      return null;
    } else if (this.hasOwnProperty(component.type)) {
      comp = new this[component.type](component, options, data);
    } else {
      comp = new _Unknown.UnknownComponent(component, options, data);
    }
    comp.build();
    return comp;
  }
};

},{"./address/Address":3,"./base/Base":4,"./button/Button":5,"./buttonvalue/ButtonValue":6,"./checkbox/Checkbox":7,"./columns/Column":8,"./columns/Columns":9,"./container/Container":10,"./content/Content":11,"./currency/Currency":12,"./datagrid/DataGrid":13,"./datetime/DateTime":14,"./day/Day":15,"./email/Email":16,"./fieldset/Fieldset":17,"./form/Form":18,"./gmap/Gmap":19,"./hidden/Hidden":20,"./html/HTML":21,"./jornaya/Jornaya":23,"./number/Number":24,"./panel/Panel":25,"./password/Password":26,"./phonenumber/PhoneNumber":27,"./radio/Radio":28,"./resource/Resource":29,"./select/Select":30,"./selectboxes/SelectBoxes":31,"./signature/Signature":32,"./slider/Slider":33,"./survey/Survey":34,"./table/Table":35,"./textarea/TextArea":36,"./textfield/TextField":37,"./unknown/Unknown":38,"./well/Well":39}],23:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.JornayaComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _Base = require('../base/Base');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var JornayaComponent = exports.JornayaComponent = function (_BaseComponent) {
  _inherits(JornayaComponent, _BaseComponent);

  function JornayaComponent() {
    _classCallCheck(this, JornayaComponent);

    return _possibleConstructorReturn(this, (JornayaComponent.__proto__ || Object.getPrototypeOf(JornayaComponent)).apply(this, arguments));
  }

  _createClass(JornayaComponent, [{
    key: 'elementInfo',
    value: function elementInfo() {
      var info = _get(JornayaComponent.prototype.__proto__ || Object.getPrototypeOf(JornayaComponent.prototype), 'elementInfo', this).call(this);
      info.type = 'input';
      info.changeEvent = 'click';
      info.attr.type = this.component.inputType;
      info.attr.class = '';
      info.attr.id = 'lead_tcpa_disclosure';
      if (this.component.name) {
        info.attr.name = 'data[' + this.component.name + ']';
      }
      info.attr.value = this.component.value ? this.component.value : 0;
      return info;
    }
  }, {
    key: 'build',
    value: function build() {
      if (!this.component.input) {
        return;
      }
      this.createElement();
      this.input = this.createInput(this.element);
      this.createLabel(this.element, this.input);
      if (!this.label) {
        this.addInput(this.input, this.element);
      }
      if (this.options.readOnly) {
        this.disabled = true;
      }
    }
  }, {
    key: 'createElement',
    value: function createElement() {
      var className = this.className;
      if (this.component.label) {
        className += ' checkbox';
      }
      this.element = this.ce('element', 'div', {
        id: this.id,
        class: className
      });
    }
  }, {
    key: 'createLabel',
    value: function createLabel(container, input) {
      if (!this.component.label) {
        return null;
      }
      this.label = this.ce('label', 'label', {
        class: 'control-label'
      });

      // Create the SPAN around the textNode for better style hooks
      this.labelSpan = this.ce('labelSpan', 'span');

      if (this.info.attr.id) {
        this.label.setAttribute('for', this.info.attr.id);
      }
      this.addInput(input, this.label);
      if (!this.options.inputsOnly) {
        // DMS

        //this.labelSpan.appendChild(this.text(this.component.label));
        //this.label.appendChild(this.labelSpan);

        var labelElement = document.createElement('div');
        labelElement.innerHTML = this.component.label;
        this.label.appendChild(labelElement);
      }
      container.appendChild(this.label);
    }
  }, {
    key: 'createInput',
    value: function createInput(container) {
      if (!this.component.input) {
        return;
      }
      var input = this.ce('input', this.info.type, this.info.attr);
      this.errorContainer = container;
      return input;
    }
  }, {
    key: 'addInputEventListener',
    value: function addInputEventListener(input) {
      var _this2 = this;

      this.addEventListener(input, this.info.changeEvent, function () {
        // If this input has a "name", then its other input elements are elsewhere on
        // the form. To get the correct submission object, we need to refresh the whole
        // data object.
        if (_this2.component.name) {
          _this2.emit('refreshData');
        } else {
          _this2.updateValue();
        }
      });
    }
  }, {
    key: 'getValueAt',
    value: function getValueAt(index) {
      return !!this.inputs[index].checked;
    }
  }, {
    key: 'setValue',
    value: function setValue(value, noUpdate, noValidate) {
      this.value = value;
      if (!this.input) {
        return;
      }
      if (value === 'on') {
        this.input.value = 1;
        this.input.checked = 1;
      } else if (value === 'off') {
        this.input.value = 0;
        this.input.checked = 0;
      } else if (value) {
        this.input.value = 1;
        this.input.checked = 1;
      } else {
        this.input.value = 0;
        this.input.checked = 0;
      }
      if (!noUpdate) {
        this.updateValue(noValidate);
      }
    }
  }]);

  return JornayaComponent;
}(_Base.BaseComponent);

},{"../base/Base":4}],24:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NumberComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _Base = require('../base/Base');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var NumberComponent = exports.NumberComponent = function (_BaseComponent) {
  _inherits(NumberComponent, _BaseComponent);

  function NumberComponent() {
    _classCallCheck(this, NumberComponent);

    return _possibleConstructorReturn(this, (NumberComponent.__proto__ || Object.getPrototypeOf(NumberComponent)).apply(this, arguments));
  }

  _createClass(NumberComponent, [{
    key: 'elementInfo',
    value: function elementInfo() {
      var info = _get(NumberComponent.prototype.__proto__ || Object.getPrototypeOf(NumberComponent.prototype), 'elementInfo', this).call(this);
      info.type = 'input';
      info.attr.type = 'number';
      info.changeEvent = 'input';
      if (this.component.validate) {
        if (this.component.validate.min !== '') {
          info.attr.min = this.component.validate.min;
        }
        if (this.component.validate.max !== '') {
          info.attr.max = this.component.validate.max;
        }
        if (this.component.step !== '') {
          info.attr.step = this.component.validate.step;
        }
      }
      return info;
    }
  }, {
    key: 'getValueAt',
    value: function getValueAt(index) {
      if (!this.inputs.length || !this.inputs[index]) {
        return null;
      }
      var val = this.inputs[index].value;
      if (!val) {
        return null;
      }

      if (this.component.validate && this.component.validate.integer) {
        return parseInt(val, 10);
      } else {
        return parseFloat(val);
      }
    }
  }, {
    key: 'setValueAt',
    value: function setValueAt(index, value) {
      if (this.component.validate && this.component.validate.integer) {
        this.inputs[index].value = parseInt(value, 10);
      } else {
        this.inputs[index].value = parseFloat(value);
      }
    }
  }]);

  return NumberComponent;
}(_Base.BaseComponent);

},{"../base/Base":4}],25:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PanelComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _Components = require('../Components');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var PanelComponent = exports.PanelComponent = function (_FormioComponents) {
  _inherits(PanelComponent, _FormioComponents);

  function PanelComponent() {
    _classCallCheck(this, PanelComponent);

    return _possibleConstructorReturn(this, (PanelComponent.__proto__ || Object.getPrototypeOf(PanelComponent)).apply(this, arguments));
  }

  _createClass(PanelComponent, [{
    key: 'build',
    value: function build() {
      this.element = this.ce('element', 'div', {
        class: 'panel panel-' + this.component.theme
      });
      if (this.component.title) {
        var heading = this.ce('heading', 'div', {
          class: 'panel-heading'
        });
        var title = this.ce('title', 'h3', {
          class: 'panel-title'
        });
        title.appendChild(this.text(this.component.title));
        heading.appendChild(title);
        this.element.appendChild(heading);
      }
      var body = this.ce('body', 'div', {
        class: 'panel-body'
      });
      this.addComponents(body);
      this.element.appendChild(body);
    }
  }]);

  return PanelComponent;
}(_Components.FormioComponents);

},{"../Components":1}],26:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PasswordComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _TextField = require('../textfield/TextField');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var PasswordComponent = exports.PasswordComponent = function (_TextFieldComponent) {
  _inherits(PasswordComponent, _TextFieldComponent);

  function PasswordComponent() {
    _classCallCheck(this, PasswordComponent);

    return _possibleConstructorReturn(this, (PasswordComponent.__proto__ || Object.getPrototypeOf(PasswordComponent)).apply(this, arguments));
  }

  _createClass(PasswordComponent, [{
    key: 'elementInfo',
    value: function elementInfo() {
      var info = _get(PasswordComponent.prototype.__proto__ || Object.getPrototypeOf(PasswordComponent.prototype), 'elementInfo', this).call(this);
      info.attr.type = 'password';
      return info;
    }
  }]);

  return PasswordComponent;
}(_TextField.TextFieldComponent);

},{"../textfield/TextField":37}],27:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PhoneNumberComponent = undefined;

var _TextField = require('../textfield/TextField');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var PhoneNumberComponent = exports.PhoneNumberComponent = function (_TextFieldComponent) {
  _inherits(PhoneNumberComponent, _TextFieldComponent);

  function PhoneNumberComponent() {
    _classCallCheck(this, PhoneNumberComponent);

    return _possibleConstructorReturn(this, (PhoneNumberComponent.__proto__ || Object.getPrototypeOf(PhoneNumberComponent)).apply(this, arguments));
  }

  return PhoneNumberComponent;
}(_TextField.TextFieldComponent);

},{"../textfield/TextField":37}],28:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RadioComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _Base = require('../base/Base');

var _each2 = require('lodash/each');

var _each3 = _interopRequireDefault(_each2);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var RadioComponent = exports.RadioComponent = function (_BaseComponent) {
  _inherits(RadioComponent, _BaseComponent);

  function RadioComponent() {
    _classCallCheck(this, RadioComponent);

    return _possibleConstructorReturn(this, (RadioComponent.__proto__ || Object.getPrototypeOf(RadioComponent)).apply(this, arguments));
  }

  _createClass(RadioComponent, [{
    key: 'elementInfo',
    value: function elementInfo() {
      var info = _get(RadioComponent.prototype.__proto__ || Object.getPrototypeOf(RadioComponent.prototype), 'elementInfo', this).call(this);
      info.type = 'input';
      info.changeEvent = 'click';
      info.attr.class = '';
      return info;
    }
  }, {
    key: 'createInput',
    value: function createInput(container) {
      var _this2 = this;

      var inputGroup = this.ce('inputGroup', 'div', {
        class: 'input-group'
      });
      var inputType = this.component.inputType;
      (0, _each3.default)(this.component.values, function (value) {
        var wrapperClass = _this2.component.inline ? inputType + '-inline' : inputType;
        var labelWrapper = _this2.ce('labelWrapper', 'div', {
          class: wrapperClass
        });
        var label = _this2.ce('label', 'label', {
          class: 'control-label'
        });

        // Create the SPAN around the textNode for better style hooks
        var labelSpan = _this2.ce('labelSpan', 'span');

        // Determine the attributes for this input.
        var inputId = _this2.component.key + _this2.row + '-' + value.value;
        _this2.info.attr.id = inputId;
        _this2.info.attr.value = value.value;
        label.setAttribute('for', _this2.info.attr.id);

        // Create the input.
        var input = _this2.ce('input', 'input');
        (0, _each3.default)(_this2.info.attr, function (value, key) {
          input.setAttribute(key, value);
        });
        _this2.addInput(input, label);

        labelSpan.appendChild(_this2.text(value.label));

        labelWrapper.appendChild(label);
        labelWrapper.appendChild(labelSpan);

        inputGroup.appendChild(labelWrapper);
      });
      container.appendChild(inputGroup);
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      var value = '';
      (0, _each3.default)(this.inputs, function (input) {
        if (input.checked) {
          value = input.value;
        }
      });
      return value;
    }
  }, {
    key: 'setValueAt',
    value: function setValueAt(index, value) {
      if (this.inputs && this.inputs[index]) {
        this.inputs[index].checked = this.inputs[index].value === value;
      }
    }
  }]);

  return RadioComponent;
}(_Base.BaseComponent);

},{"../base/Base":4,"lodash/each":226}],29:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResourceComponent = undefined;

var _Select = require('../select/Select');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var ResourceComponent = exports.ResourceComponent = function (_SelectComponent) {
  _inherits(ResourceComponent, _SelectComponent);

  function ResourceComponent(component, options, data) {
    _classCallCheck(this, ResourceComponent);

    var _this = _possibleConstructorReturn(this, (ResourceComponent.__proto__ || Object.getPrototypeOf(ResourceComponent)).call(this, component, options, data));

    _this.component.dataSrc = 'resource';
    _this.component.data = {
      resource: _this.component.resource
    };
    return _this;
  }

  return ResourceComponent;
}(_Select.SelectComponent);

},{"../select/Select":30}],30:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SelectComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _set = function set(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent !== null) {
      set(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }return value;
};

var _get2 = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _Base = require('../base/Base');

var _choices = require('choices.js');

var _choices2 = _interopRequireDefault(_choices);

var _formio = require('../../formio');

var _formio2 = _interopRequireDefault(_formio);

var _each2 = require('lodash/each');

var _each3 = _interopRequireDefault(_each2);

var _get3 = require('lodash/get');

var _get4 = _interopRequireDefault(_get3);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var SelectComponent = exports.SelectComponent = function (_BaseComponent) {
  _inherits(SelectComponent, _BaseComponent);

  function SelectComponent(component, options, data) {
    _classCallCheck(this, SelectComponent);

    // If they wish to refresh on a value, then add that here.
    var _this = _possibleConstructorReturn(this, (SelectComponent.__proto__ || Object.getPrototypeOf(SelectComponent)).call(this, component, options, data));

    if (_this.component.refreshOn) {
      _this.on('change', function (event) {
        if (_this.component.refreshOn === 'data') {
          _this.updateItems();
        } else if (event.changed.component.key === _this.component.refreshOn) {
          _this.updateItems();
        }
      });
    }
    return _this;
  }

  _createClass(SelectComponent, [{
    key: 'elementInfo',
    value: function elementInfo() {
      var info = _get2(SelectComponent.prototype.__proto__ || Object.getPrototypeOf(SelectComponent.prototype), 'elementInfo', this).call(this);
      info.type = 'select';
      info.changeEvent = 'change';
      return info;
    }
  }, {
    key: 'createWrapper',
    value: function createWrapper() {
      return false;
    }
  }, {
    key: 'itemTemplate',
    value: function itemTemplate(data) {
      return this.component.template ? this.interpolate(this.component.template, { item: data }) : data.label;
    }
  }, {
    key: 'itemValue',
    value: function itemValue(data) {
      return this.component.valueProperty ? (0, _get4.default)(data, this.component.valueProperty) : data;
    }
  }, {
    key: 'setItems',
    value: function setItems(items) {
      var _this2 = this;

      if (!this.choices) {
        return;
      }
      this.choices._clearChoices();

      // If they provided select values, then we need to get them instead.
      if (this.component.selectValues) {
        items = (0, _get4.default)(items, this.component.selectValues);
      }

      // Iterate through each of the items.
      (0, _each3.default)(items, function (item) {

        // Add the choice to the select list.

        // DMS

        //this.choices._addChoice(false, false, this.itemValue(item), this.itemTemplate(item));
        _this2.choices._addChoice(false, item.disabled, _this2.itemValue(item), _this2.itemTemplate(item));
      });

      // If a value is provided, then select it.
      if (this.value) {
        this.setValue(this.value, true);
      }
    }
  }, {
    key: 'loadItems',
    value: function loadItems(url, input, headers, options) {
      var _this3 = this;

      var query = this.component.dataSrc === 'url' ? {} : {
        limit: 100,
        skip: 0
      };

      // Allow for url interpolation.
      url = this.interpolate(url, {
        data: this.data,
        formioBase: _formio2.default.getBaseUrl()
      });

      // Add search capability.
      if (this.component.searchField && input) {
        query[this.component.searchField] = input;
      }

      // Add filter capability
      if (this.component.filter) {
        var filter = this.interpolate(this.component.filter, { data: this.data });
        url += (url.indexOf('?') === -1 ? '?' : '&') + filter;
      }

      // If they wish to return only some fields.
      if (this.component.selectFields) {
        query.select = this.component.selectFields;
      }

      if (!(0, _isEmpty3.default)(query)) {
        // Add the query string.
        url += '?' + _formio2.default.serialize(query);
      }

      // Make the request.
      _formio2.default.request(url, null, null, headers, options).then(function (response) {
        return _this3.setItems(response);
      }).catch(function () {
        return console.warn('Unable to load resources for ' + _this3.component.key);
      });
    }
  }, {
    key: 'updateItems',
    value: function updateItems() {
      switch (this.component.dataSrc) {
        case 'values':
          this.component.valueProperty = 'value';
          this.setItems(this.component.data.values);
          break;
        case 'json':
          try {
            if (typeof this.component.data.json == 'string') {
              this.setItems(JSON.parse(this.component.data.json));
            } else {
              this.setItems(this.component.data.json);
            }
          } catch (err) {
            console.warn('Unable to parse JSON for ' + this.component.key);
          }
          break;
        case 'resource':
          try {
            this.loadItems(_formio2.default.getAppUrl() + '/form/' + this.component.data.resource + '/submission');
          } catch (err) {
            console.warn('Unable to load resources for ' + this.component.key);
          }
          break;
        case 'url':
          this.loadItems(this.component.data.url, null, new Headers(), {
            noToken: true
          });
          break;
      }
    }
  }, {
    key: 'addInput',
    value: function addInput(input, container) {
      _get2(SelectComponent.prototype.__proto__ || Object.getPrototypeOf(SelectComponent.prototype), 'addInput', this).call(this, input, container, true);
      if (this.component.multiple) {
        input.setAttribute('multiple', true);
      }
      var self = this;
      this.choices = new _choices2.default(input, {
        placeholder: !!this.component.placeholder,
        placeholderValue: this.component.placeholder,
        removeItemButton: true,

        // DMS
        searchEnabled: false,
        shouldSort: false,
        removeItems: false,

        itemSelectText: '',
        classNames: {
          containerOuter: 'choices form-group formio-choices',
          containerInner: 'form-control'
        }
      });
      if (this.disabled) {
        this.choices.disable();
      }
      this.updateItems();
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return this.choices.getValue(true);
    }
  }, {
    key: 'setValue',
    value: function setValue(value, noUpdate, noValidate) {
      this.value = value;
      if (value && this.choices) {
        if (this.choices.store) {
          // Search for the choice.
          var choices = this.choices.store.getChoices();
          var foundChoice = choices.find(function (choice) {
            return choice.value === value;
          });

          // If it is not found, then add it.
          if (!foundChoice) {
            this.choices._addChoice(false, false, value, value);
          }
        }

        // Now set the value.
        this.choices.setValueByChoice((0, _isArray3.default)(value) ? value : [value]);
      }
      if (!noUpdate) {
        this.updateValue(noValidate);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      if (this.choices) {
        this.choices.destroy();
      }
    }
  }, {
    key: 'disabled',
    set: function set(disabled) {
      _set(SelectComponent.prototype.__proto__ || Object.getPrototypeOf(SelectComponent.prototype), 'disabled', disabled, this);
      if (!this.choices) {
        return;
      }
      if (disabled) {
        this.choices.disable();
      } else {
        this.choices.enable();
      }
    }
  }]);

  return SelectComponent;
}(_Base.BaseComponent);

},{"../../formio":41,"../base/Base":4,"choices.js":50,"lodash/each":226,"lodash/get":229,"lodash/isArray":234,"lodash/isEmpty":238}],31:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SelectBoxesComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _Radio = require('../radio/Radio');

var _each2 = require('lodash/each');

var _each3 = _interopRequireDefault(_each2);

var _isArray2 = require('lodash/isArray');

var _isArray3 = _interopRequireDefault(_isArray2);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var SelectBoxesComponent = exports.SelectBoxesComponent = function (_RadioComponent) {
  _inherits(SelectBoxesComponent, _RadioComponent);

  function SelectBoxesComponent(component, options, data) {
    _classCallCheck(this, SelectBoxesComponent);

    var _this = _possibleConstructorReturn(this, (SelectBoxesComponent.__proto__ || Object.getPrototypeOf(SelectBoxesComponent)).call(this, component, options, data));

    _this.component.inputType = 'checkbox';
    return _this;
  }

  _createClass(SelectBoxesComponent, [{
    key: 'elementInfo',
    value: function elementInfo() {
      var info = _get(SelectBoxesComponent.prototype.__proto__ || Object.getPrototypeOf(SelectBoxesComponent.prototype), 'elementInfo', this).call(this);
      info.attr.name += '[]';
      info.attr.type = 'checkbox';
      return info;
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      var value = [];
      (0, _each3.default)(this.inputs, function (input) {
        if (input.checked) {
          value.push(input.value);
        }
      });
      return value;
    }

    /**
     * Set the value of this component.
     * @param value
     */

  }, {
    key: 'setValue',
    value: function setValue(value, noUpdate, noValidate) {
      this.value = value;
      var tempValue = [];

      (0, _each3.default)(this.inputs, function (input) {
        if ((0, _isArray3.default)(value)) {
          input.checked = value.indexOf(input.value) !== -1;
        } else {
          input.checked = value[input.value] == undefined ? false : value[input.value];
          tempValue.push(input.value);
        }
      });

      value = (0, _isArray3.default)(value) ? value : tempValue;

      if (!noUpdate) {
        this.updateValue(noValidate);
      }
    }
  }]);

  return SelectBoxesComponent;
}(_Radio.RadioComponent);

},{"../radio/Radio":28,"lodash/each":226,"lodash/isArray":234}],32:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SignatureComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _set = function set(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent !== null) {
      set(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }return value;
};

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _signature_pad = require('signature_pad');

var _signature_pad2 = _interopRequireDefault(_signature_pad);

var _Base = require('../base/Base');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var SignatureComponent = exports.SignatureComponent = function (_BaseComponent) {
  _inherits(SignatureComponent, _BaseComponent);

  function SignatureComponent(component, options, data) {
    _classCallCheck(this, SignatureComponent);

    var _this = _possibleConstructorReturn(this, (SignatureComponent.__proto__ || Object.getPrototypeOf(SignatureComponent)).call(this, component, options, data));

    if (!_this.component.width) {
      _this.component.width = '100%';
    }
    if (!_this.component.height) {
      _this.component.height = '200px';
    }
    return _this;
  }

  _createClass(SignatureComponent, [{
    key: 'elementInfo',
    value: function elementInfo() {
      var info = _get(SignatureComponent.prototype.__proto__ || Object.getPrototypeOf(SignatureComponent.prototype), 'elementInfo', this).call(this);
      info.type = 'input';
      info.attr.type = 'hidden';
      return info;
    }
  }, {
    key: 'setValue',
    value: function setValue(value, noUpdate, noValidate, noSign) {
      _get(SignatureComponent.prototype.__proto__ || Object.getPrototypeOf(SignatureComponent.prototype), 'setValue', this).call(this, value, noUpdate, noValidate);
      if (!noSign && this.signaturePad) {
        this.signaturePad.fromDataURL(value);
      }
    }
  }, {
    key: 'getSignatureImage',
    value: function getSignatureImage() {
      var image = this.ce('image', 'img', {
        style: 'width: ' + this.component.width + ';height: ' + this.component.height
      });
      image.setAttribute('src', this.value);
      return image;
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      _get(SignatureComponent.prototype.__proto__ || Object.getPrototypeOf(SignatureComponent.prototype), 'destroy', this).call(this);
      if (this.signaturePad) {
        this.signaturePad.off();
      }
    }
  }, {
    key: 'build',
    value: function build() {
      var _this2 = this;

      this.element = this.createElement();
      var classNames = this.element.getAttribute('class');
      classNames += ' signature-pad';
      this.element.setAttribute('class', classNames);

      this.input = this.createInput(this.element);
      var padBody = this.ce('pad', 'div', {
        class: 'signature-pad-body',
        style: 'width: ' + this.component.width + ';height: ' + this.component.height
      });

      // Create the refresh button.
      var refresh = this.ce('refresh', 'a', {
        class: 'btn btn-sm btn-default signature-pad-refresh'
      });
      var refreshIcon = this.getIcon('refresh');
      refresh.appendChild(refreshIcon);
      padBody.appendChild(refresh);

      // The signature canvas.
      var canvas = this.ce('canvas', 'canvas', {
        class: 'signature-pad-canvas',
        height: this.component.height
      });
      padBody.appendChild(canvas);
      this.element.appendChild(padBody);

      // Add the footer.
      if (this.component.footer) {
        var footer = this.ce('footer', 'div', {
          class: 'signature-pad-footer'
        });
        footer.appendChild(this.text(this.component.footer));
        this.element.appendChild(footer);
      }

      // Create the signature pad.
      this.signaturePad = new _signature_pad2.default(canvas, {
        minWidth: this.component.minWidth,
        maxWidth: this.component.maxWidth,
        penColor: this.component.penColor,
        backgroundColor: this.component.backgroundColor
      });
      refresh.addEventListener("click", function (event) {
        event.preventDefault();
        _this2.signaturePad.clear();
      });
      this.signaturePad.onEnd = function () {
        return _this2.setValue(_this2.signaturePad.toDataURL(), false, false, true);
      };

      // Ensure the signature is always the size of its container.
      var currentWidth = 0;
      setTimeout(function checkWidth() {
        if (padBody.offsetWidth !== currentWidth) {
          currentWidth = padBody.offsetWidth;
          canvas.width = currentWidth;
          var ctx = canvas.getContext("2d");
          ctx.fillStyle = this.signaturePad.backgroundColor;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        setTimeout(checkWidth.bind(this), 200);
      }.bind(this), 200);

      if (this.options.readOnly) {
        this.disabled = true;
      }
    }
  }, {
    key: 'disabled',
    set: function set(disabled) {
      _set(SignatureComponent.prototype.__proto__ || Object.getPrototypeOf(SignatureComponent.prototype), 'disabled', disabled, this);
      this.element.innerHTML = '';
      this.element.appendChild(this.getSignatureImage());
    }
  }]);

  return SignatureComponent;
}(_Base.BaseComponent);

},{"../base/Base":4,"signature_pad":265}],33:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SliderComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _Base = require('../base/Base');

var _numeral = require('numeral');

var _numeral2 = _interopRequireDefault(_numeral);

var _rangesliderJs = require('rangeslider-js');

var _rangesliderJs2 = _interopRequireDefault(_rangesliderJs);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var SliderComponent = exports.SliderComponent = function (_BaseComponent) {
  _inherits(SliderComponent, _BaseComponent);

  function SliderComponent() {
    _classCallCheck(this, SliderComponent);

    return _possibleConstructorReturn(this, (SliderComponent.__proto__ || Object.getPrototypeOf(SliderComponent)).apply(this, arguments));
  }

  _createClass(SliderComponent, [{
    key: 'build',
    value: function build() {

      this.createElement();

      if (this.component.label) {
        var label = this.ce('label', 'label', {
          class: 'control-label'
        });
        this.element.appendChild(label);
        label.innerText = this.component.label;
      }

      var output = this.ce('div', 'div', { class: 'slider-output', id: 'slider-output' });
      this.element.appendChild(output);

      this.input = this.createInput(this.element);
      if (!this.label) {
        this.addInput(this.input, this.element);
      }

      var sliderLabels = this.ce('div', 'div', { class: 'sliderLabels', id: 'sliderLabels' });
      this.element.appendChild(sliderLabels);
      var minLabel = this.ce('div', 'div', { class: 'minLabel', id: 'minLabel' });
      var maxLabel = this.ce('div', 'div', { class: 'maxLabel', id: 'maxLabel' });

      sliderLabels.appendChild(minLabel);
      sliderLabels.appendChild(maxLabel);
      this.errorContainer = this.element;

      var min = this.component.min;
      var max = this.component.max;
      var step = this.component.step;

      output.innerText = this.input.value === min ? this.toCurrency(this.input.value) + ' or less' : this.input.value === max ? (0, _numeral2.default)(this.input.value).format('$0,0') + ' or more' : (0, _numeral2.default)(this.input.value - step).format('$0,0') + ' - ' + (0, _numeral2.default)(this.input.value).format('$0,0');
      this.input.oninput = function () {
        output.innerText = this.value === min ? (0, _numeral2.default)(this.value).format('$0,0') + ' or less' : this.value === max ? (0, _numeral2.default)(this.value).format('$0,0') + ' or more' : (0, _numeral2.default)(this.value - step).format('$0,0') + ' - ' + (0, _numeral2.default)(this.value).format('$0,0');
      };

      this.setValue(this.input.value);

      minLabel.innerText = this.toCurrency(this.component.min);
      maxLabel.innerText = this.toCurrency(this.component.max);
    }
  }, {
    key: 'createInput',
    value: function createInput(container) {

      var input = this.ce('input', 'input', {
        type: 'range',
        class: 'range-slider__range',
        min: this.component.min,
        max: this.component.max,
        step: this.component.step,
        value: this.component.defaultValue,
        id: 'range-slider'
      });

      return input;
    }
  }, {
    key: 'toCurrency',
    value: function toCurrency(amount) {
      return (0, _numeral2.default)(amount).format('$0,0');
    }
  }, {
    key: 'createElement',
    value: function createElement() {
      var className = this.className;
      if (this.component.label) {
        className += ' range-slider';
      }
      this.element = this.ce('element', 'div', {
        id: this.id,
        class: className
      });
    }
  }]);

  return SliderComponent;
}(_Base.BaseComponent);

},{"../base/Base":4,"numeral":262,"rangeslider-js":263}],34:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SurveyComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _each2 = require('lodash/each');

var _each3 = _interopRequireDefault(_each2);

var _Base = require('../base/Base');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var SurveyComponent = exports.SurveyComponent = function (_BaseComponent) {
  _inherits(SurveyComponent, _BaseComponent);

  function SurveyComponent() {
    _classCallCheck(this, SurveyComponent);

    return _possibleConstructorReturn(this, (SurveyComponent.__proto__ || Object.getPrototypeOf(SurveyComponent)).apply(this, arguments));
  }

  _createClass(SurveyComponent, [{
    key: 'build',
    value: function build() {
      var _this2 = this;

      this.createElement();
      this.createLabel(this.element);
      this.table = this.ce('table', 'table', {
        class: 'table table-striped table-bordered'
      });

      // Build header.
      var thead = this.ce('header', 'thead');
      var thr = this.ce('headerRow', 'tr');
      thr.appendChild(this.ce('headerColumn', 'td'));
      (0, _each3.default)(this.component.values, function (value) {
        var th = _this2.ce('headerColumn', 'th', {
          style: 'text-align: center;'
        });
        th.appendChild(_this2.text(value.label));
        thr.appendChild(th);
      });
      thead.appendChild(thr);
      this.table.appendChild(thead);
      // Build the body.
      var tbody = this.ce('table', 'tbody');
      (0, _each3.default)(this.component.questions, function (question) {
        var tr = _this2.ce('tableRow', 'tr');
        var td = _this2.ce('questionColumn', 'td');
        td.appendChild(_this2.text(question.label));
        tr.appendChild(td);
        (0, _each3.default)(_this2.component.values, function (value) {
          var td = _this2.ce('valueColumn', 'td', {
            style: 'text-align: center;'
          });
          var input = _this2.ce('input', 'input', {
            type: 'radio',
            name: 'data[' + _this2.component.key + '][' + question.value + ']',
            value: value.value,
            id: _this2.id + '-' + question.value + '-' + value.value
          });
          _this2.addInput(input, td);
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
      this.table.appendChild(tbody);
      this.element.appendChild(this.table);
      if (this.options.readOnly) {
        this.disabled = true;
      }
    }
  }, {
    key: 'setValue',
    value: function setValue(value, noUpdate, noValidate) {
      var _this3 = this;

      if (!value) {
        return;
      }
      this.value = value;
      var key = 'data[' + this.component.key + ']';
      (0, _each3.default)(this.component.questions, function (question) {
        (0, _each3.default)(_this3.inputs, function (input) {
          if (input.name === key + '[' + question.value + ']') {
            input.checked = input.value === value[question.value];
          }
        });
      });
      if (!noUpdate) {
        this.updateValue(noValidate);
      }
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      var _this4 = this;

      var value = {};
      var key = 'data[' + this.component.key + ']';
      (0, _each3.default)(this.component.questions, function (question) {
        (0, _each3.default)(_this4.inputs, function (input) {
          if (input.checked && input.name === key + '[' + question.value + ']') {
            value[question.value] = input.value;
            return false;
          }
        });
      });
      return value;
    }
  }]);

  return SurveyComponent;
}(_Base.BaseComponent);

},{"../base/Base":4,"lodash/each":226}],35:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TableComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _each2 = require('lodash/each');

var _each3 = _interopRequireDefault(_each2);

var _Components = require('../Components');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var TableComponent = exports.TableComponent = function (_FormioComponents) {
  _inherits(TableComponent, _FormioComponents);

  function TableComponent() {
    _classCallCheck(this, TableComponent);

    return _possibleConstructorReturn(this, (TableComponent.__proto__ || Object.getPrototypeOf(TableComponent)).apply(this, arguments));
  }

  _createClass(TableComponent, [{
    key: 'build',
    value: function build() {
      var _this2 = this;

      this.element = this.ce('element', 'div', {
        class: 'table-responsive'
      });

      var tableClass = 'table ';
      (0, _each3.default)(['striped', 'bordered', 'hover', 'condensed'], function (prop) {
        if (_this2.component[prop]) {
          tableClass += 'table-' + prop + ' ';
        }
      });
      var table = this.ce('table', 'table', {
        class: tableClass
      });

      // Build the header.
      if (this.component.header && this.component.header.length) {
        var thead = this.ce('header', 'thead');
        var thr = this.ce('headerRow', 'tr');
        (0, _each3.default)(this.component.header, function (header) {
          var th = _this2.ce('headerColumn', 'th');
          th.appendChild(_this2.text(header));
          thr.appendChild(th);
        });
        thead.appendChild(thr);
        table.appendChild(thead);
      }

      // Build the body.
      var tbody = this.ce('table', 'tbody');
      (0, _each3.default)(this.component.rows, function (row) {
        var tr = _this2.ce('tableRow', 'tr');
        (0, _each3.default)(row, function (column) {
          var td = _this2.ce('tableColumn', 'td');
          (0, _each3.default)(column.components, function (comp) {
            _this2.addComponent(comp, td);
          });
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      this.element.appendChild(table);
    }
  }]);

  return TableComponent;
}(_Components.FormioComponents);

},{"../Components":1,"lodash/each":226}],36:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TextAreaComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _TextField = require('../textfield/TextField');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var TextAreaComponent = exports.TextAreaComponent = function (_TextFieldComponent) {
  _inherits(TextAreaComponent, _TextFieldComponent);

  function TextAreaComponent() {
    _classCallCheck(this, TextAreaComponent);

    return _possibleConstructorReturn(this, (TextAreaComponent.__proto__ || Object.getPrototypeOf(TextAreaComponent)).apply(this, arguments));
  }

  _createClass(TextAreaComponent, [{
    key: 'elementInfo',
    value: function elementInfo() {
      var info = _get(TextAreaComponent.prototype.__proto__ || Object.getPrototypeOf(TextAreaComponent.prototype), 'elementInfo', this).call(this);
      info.type = 'textarea';
      if (this.component.rows) {
        info.attr.rows = this.component.rows;
      }
      return info;
    }
  }]);

  return TextAreaComponent;
}(_TextField.TextFieldComponent);

},{"../textfield/TextField":37}],37:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TextFieldComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _Base = require('../base/Base');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var TextFieldComponent = exports.TextFieldComponent = function (_BaseComponent) {
  _inherits(TextFieldComponent, _BaseComponent);

  function TextFieldComponent() {
    _classCallCheck(this, TextFieldComponent);

    return _possibleConstructorReturn(this, (TextFieldComponent.__proto__ || Object.getPrototypeOf(TextFieldComponent)).apply(this, arguments));
  }

  _createClass(TextFieldComponent, [{
    key: 'elementInfo',
    value: function elementInfo() {
      var info = _get(TextFieldComponent.prototype.__proto__ || Object.getPrototypeOf(TextFieldComponent.prototype), 'elementInfo', this).call(this);
      info.type = 'input';
      info.attr.type = 'text';
      info.changeEvent = 'input';
      return info;
    }
  }]);

  return TextFieldComponent;
}(_Base.BaseComponent);

},{"../base/Base":4}],38:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UnknownComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _Base = require('../base/Base');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var UnknownComponent = exports.UnknownComponent = function (_BaseComponent) {
  _inherits(UnknownComponent, _BaseComponent);

  function UnknownComponent() {
    _classCallCheck(this, UnknownComponent);

    return _possibleConstructorReturn(this, (UnknownComponent.__proto__ || Object.getPrototypeOf(UnknownComponent)).apply(this, arguments));
  }

  _createClass(UnknownComponent, [{
    key: 'build',
    value: function build() {
      this.element = this.ce('element', 'div', {
        id: this.id
      });
      this.element.appendChild(this.text('Unknown component: ' + this.component.type));
      return this.element;
    }
  }]);

  return UnknownComponent;
}(_Base.BaseComponent);

},{"../base/Base":4}],39:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WellComponent = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _Components = require('../Components');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var WellComponent = exports.WellComponent = function (_FormioComponents) {
  _inherits(WellComponent, _FormioComponents);

  function WellComponent() {
    _classCallCheck(this, WellComponent);

    return _possibleConstructorReturn(this, (WellComponent.__proto__ || Object.getPrototypeOf(WellComponent)).apply(this, arguments));
  }

  _createClass(WellComponent, [{
    key: 'className',
    get: function get() {
      return 'well formio-component formio-component-well';
    }
  }]);

  return WellComponent;
}(_Components.FormioComponents);

},{"../Components":1}],40:[function(require,module,exports){
(function (global){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FormioForm = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _nativePromiseOnly = require("native-promise-only");

var _nativePromiseOnly2 = _interopRequireDefault(_nativePromiseOnly);

var _formio = require("./formio");

var _formio2 = _interopRequireDefault(_formio);

var _Components = require("./components/Components");

var _debounce2 = require("lodash/debounce");

var _debounce3 = _interopRequireDefault(_debounce2);

var _each2 = require("lodash/each");

var _each3 = _interopRequireDefault(_each2);

var _clone2 = require("lodash/clone");

var _clone3 = _interopRequireDefault(_clone2);

var _assign2 = require("lodash/assign");

var _assign3 = _interopRequireDefault(_assign2);

var _eventemitter = require("eventemitter2");

var _eventemitter2 = _interopRequireDefault(_eventemitter);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * Taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind
 *
 * This is needed for PhantomJS.
 */
if (!Function.prototype.bind) {
  Function.prototype.bind = function (oThis) {
    if (typeof this !== 'function') {
      // closest thing possible to the ECMAScript 5
      // internal IsCallable function
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
    }

    var aArgs = Array.prototype.slice.call(arguments, 1),
        fToBind = this,
        fNOP = function fNOP() {},
        fBound = function fBound() {
      return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
    };

    if (this.prototype) {
      // Function.prototype doesn't have a prototype property
      fNOP.prototype = this.prototype;
    }
    fBound.prototype = new fNOP();

    return fBound;
  };
}

var getOptions = function getOptions(options) {
  options = options || {};
  if (!options.events) {
    options.events = new _eventemitter2.default({
      wildcard: false,
      maxListeners: 0
    });
  }
  return options;
};

/**
 * Renders a Form.io form within the webpage.
 *
 * @example
 * import FormioForm from 'formiojs/form';
 * let form = new FormioForm(document.getElementById('formio'));
 * form.src = 'https://examples.form.io/example';
 */

var FormioForm = exports.FormioForm = function (_FormioComponents) {
  _inherits(FormioForm, _FormioComponents);

  /**
   * Creates a new FormioForm instance.
   *
   * @param {Object} element - The DOM element you wish to render this form within.
   * @param {Object} options - The options to create a new form instance.
   * @param {boolean} options.readOnly - Set this form to readOnly
   * @param {boolean} options.noAlerts - Set to true to disable the alerts dialog.
   * @param {boolean} options.i18n - The translation file for this rendering. @see https://github.com/formio/formio.js/blob/master/src/locals/en.js
   * @param {boolean} options.template - Provides a way to inject custom logic into the creation of every element rendered within the form.
   *
   * @example
   * import FormioForm from 'formiojs/form';
   * let form = new FormioForm(document.getElementById('formio'), {
   *   readOnly: true
   * });
   * form.src = 'https://examples.form.io/example';
   *
   */
  function FormioForm(element, options) {
    _classCallCheck(this, FormioForm);

    /**
     * The type of this element.
     * @type {string}
     */
    var _this = _possibleConstructorReturn(this, (FormioForm.__proto__ || Object.getPrototypeOf(FormioForm)).call(this, null, getOptions(options)));

    _this.type = 'form';
    _this._src = '';
    _this._loading = false;
    _this._submission = {};
    _this._form = null;

    /**
     * The Formio instance for this form.
     * @type {Formio}
     */
    _this.formio = null;

    /**
     * The loader HTML element.
     * @type {HTMLElement}
     */
    _this.loader = null;

    /**
     * The alert HTML element
     * @type {HTMLElement}
     */
    _this.alert = null;

    /**
     * Promise that is triggered when the submission is done loading.
     * @type {Promise}
     */
    _this.onSubmission = null;

    /**
     * Promise that is triggered when the form is done building.
     * @type {Promise}
     */
    _this.onFormBuild = null;

    /**
     * Promise that executes when the form is ready and rendered.
     * @type {Promise}
     *
     * @example
     * let form = new FormioForm(document.getElementById('formio'));
     * form.ready.then(() => {
     *   console.log('The form is ready!');
     * });
     * form.src = 'https://examples.form.io/example';
     */
    _this.formReady = new _nativePromiseOnly2.default(function (resolve, reject) {
      /**
       * Called when the formReady state of this form has been resolved.
       *
       * @type {function}
       */
      _this.formReadyResolve = resolve;

      /**
       * Called when this form could not load and is rejected.
       *
       * @type {function}
       */
      _this.formReadyReject = reject;
    });

    /**
     * Promise that executes when the submission is ready and rendered.
     * @type {Promise}
     *
     * @example
     * let form = new FormioForm(document.getElementById('formio'));
     * form.ready.then(() => {
     *   console.log('The form is ready!');
     * });
     * form.src = 'https://examples.form.io/example';
     */
    _this.submissionReady = new _nativePromiseOnly2.default(function (resolve, reject) {
      /**
       * Called when the formReady state of this form has been resolved.
       *
       * @type {function}
       */
      _this.submissionReadyResolve = resolve;

      /**
       * Called when this form could not load and is rejected.
       *
       * @type {function}
       */
      _this.submissionReadyReject = reject;
    });

    /**
     * Triggers a new submission change after a certain debounce interval.
     *
     * @type {function} - Call then when you wish to trigger a submission change.
     */
    _this.triggerSubmissionChange = (0, _debounce3.default)(_this.onSubmissionChange.bind(_this), 10);

    /**
     * Promise to trigger when the element for this form is established.
     *
     * @type {Promise}
     */
    _this.onElement = new _nativePromiseOnly2.default(function (resolve) {
      /**
       * Called when the element has been resolved.
       *
       * @type {function}
       */
      _this.elementResolve = resolve;
      _this.setElement(element);
    });
    return _this;
  }

  /**
   * Sets the the outside wrapper element of the Form.
   *
   * @param {HTMLElement} element - The element to set as the outside wrapper element for this form.
   */

  _createClass(FormioForm, [{
    key: "setElement",
    value: function setElement(element) {
      var _this2 = this;

      if (!element) {
        return;
      }

      this.element = element;
      var classNames = this.element.getAttribute('class');
      classNames += ' formio-form';
      this.addClass(this.element, classNames);
      this.loading = true;
      this.ready.then(function () {
        return _this2.loading = false;
      }, function () {
        return _this2.loading = false;
      }).catch(function () {
        return _this2.loading = false;
      });
      this.elementResolve(element);
    }

    /**
     * Get the embed source of the form.
     *
     * @returns {string}
     */

  }, {
    key: "setForm",

    /**
     * Sets the JSON schema for the form to be rendered.
     *
     * @example
     * let form = new FormioForm(document.getElementById('formio'));
     * form.setForm({
     *   components: [
     *     {
     *       type: 'textfield',
     *       key: 'firstName',
     *       label: 'First Name',
     *       placeholder: 'Enter your first name.',
     *       input: true
     *     },
     *     {
     *       type: 'textfield',
     *       key: 'lastName',
     *       label: 'Last Name',
     *       placeholder: 'Enter your last name',
     *       input: true
     *     },
     *     {
     *       type: 'button',
     *       action: 'submit',
     *       label: 'Submit',
     *       theme: 'primary'
     *     }
     *   ]
     * });
     *
     * @param {Object} form - The JSON schema of the form @see https://examples.form.io/example for an example JSON schema.
     * @returns {*}
     */
    value: function setForm(form) {
      var _this3 = this;

      if (form.display === 'wizard') {
        console.warn('You need to instantiate the FormioWizard class to use this form as a wizard.');
      }

      if (this.onFormBuild) {
        return this.onFormBuild.then(function () {
          return _this3.createForm(form);
        }, function (err) {
          return _this3.formReadyReject(err);
        }).catch(function (err) {
          return _this3.formReadyReject(err);
        });
      }

      // Set the form object.
      this._form = form;

      // Create the form.
      return this.createForm(form);
    }

    /**
     * Gets the form object.
     *
     * @returns {Object} - The form JSON schema.
     */

  }, {
    key: "setSubmission",

    /**
     * Sets a submission and returns the promise when it is ready.
     * @param submission
     * @return {Promise.<TResult>}
     */
    value: function setSubmission(submission) {
      var _this4 = this;

      return this.onSubmission = this.formReady.then(function () {
        _this4.setValue(submission);
        _this4.submissionReadyResolve();
      }, function (err) {
        return _this4.submissionReadyReject(err);
      }).catch(function (err) {
        return _this4.submissionReadyReject(err);
      });
    }
  }, {
    key: "setValue",
    value: function setValue(submission, noUpdate, noValidate) {
      this._submission = submission || { data: {} };
      return _get(FormioForm.prototype.__proto__ || Object.getPrototypeOf(FormioForm.prototype), "setValue", this).call(this, this._submission.data, noUpdate, noValidate);
    }
  }, {
    key: "getValue",
    value: function getValue() {
      if (!this._submission.data) {
        this._submission.data = {};
      }
      this._submission.data = (0, _assign3.default)(this.data, _get(FormioForm.prototype.__proto__ || Object.getPrototypeOf(FormioForm.prototype), "getValue", this).call(this));
      return this._submission;
    }

    /**
     * Create a new form.
     *
     * @param {Object} form - The form object that is created.
     * @returns {Promise.<TResult>}
     */

  }, {
    key: "createForm",
    value: function createForm(form) {
      var _this5 = this;

      /**
       * {@link BaseComponent.component}
       */
      if (this.component) {
        this.component.components = form.components;
      } else {
        this.component = form;
      }
      return this.onFormBuild = this.render().then(function () {
        _this5.formReadyResolve();
        if (!_this5.onSubmission) {
          _this5.submissionReadyResolve();
        }
        _this5.onFormBuild = null;
      }, function (err) {
        return _this5.formReadyReject(err);
      }).catch(function (err) {
        return _this5.formReadyReject(err);
      });
    }

    /**
     * Render the form within the HTML element.
     * @returns {Promise.<TResult>}
     */

  }, {
    key: "render",
    value: function render() {
      var _this6 = this;

      return this.onElement.then(function () {
        _this6.clear();
        return _this6.localize().then(function () {
          _this6.build();
          _this6.on('resetForm', function () {
            return _this6.reset();
          }, true);
          _this6.on('componentChange', function (changed) {
            return _this6.triggerSubmissionChange(changed);
          }, true);
          _this6.on('refreshData', function () {
            return _this6.updateValue();
          });
          _this6.emit('render');
        });
      });
    }

    /**
     * Sets a new alert to display in the error dialog of the form.
     *
     * @param {string} type - The type of alert to display. "danger", "success", "warning", etc.
     * @param {string} message - The message to show in the alert.
     */

  }, {
    key: "setAlert",
    value: function setAlert(type, message) {
      if (this.options.noAlerts) {
        if (!message) {
          this.emit('error', false);
        }
        return;
      }
      if (this.alert) {
        try {
          this.removeChild(this.alert);
          this.alert = null;
        } catch (err) {}
      }
      if (message) {
        this.alert = this.ce('alert-' + type, 'div', {
          class: 'alert alert-' + type,
          role: 'alert'
        });
        this.alert.innerHTML = message;
      }
      if (!this.alert) {
        return;
      }
      this.prepend(this.alert);
    }

    /**
     * Build the form.
     */

  }, {
    key: "build",
    value: function build() {
      var _this7 = this;

      this.on('submitButton', function () {
        return _this7.submit();
      }, true);
      this.addComponents();
      this.checkConditions(this.getValue());
    }

    /**
     * Show the errors of this form within the alert dialog.
     *
     * @param {Object} error - An optional additional error to display along with the component errors.
     * @returns {*}
     */

  }, {
    key: "showErrors",
    value: function showErrors(error) {
      this.loading = false;
      var errors = this.errors;
      if (error) {
        errors.push(error);
      }
      if (!errors.length) {
        this.setAlert(false);
        return;
      }
      var message = '<p>' + this.t('error') + '</p><ul>';
      (0, _each3.default)(errors, function (err) {
        if (err) {
          var errorMessage = err.message || err;
          message += '<li><strong>' + errorMessage + '</strong></li>';
        }
      });
      message += '</ul>';
      this.setAlert('danger', message);
      this.emit('error', errors);
      return errors;
    }

    /**
     * Called when the submission has completed, or if the submission needs to be sent to an external library.
     *
     * @param {Object} submission - The submission object.
     * @param {boolean} saved - Whether or not this submission was saved to the server.
     * @returns {object} - The submission object.
     */

  }, {
    key: "onSubmit",
    value: function onSubmit(submission, saved) {
      this.loading = false;
      this.setValue(submission);
      this.setAlert('success', '<p>' + this.t('complete') + '</p>');
      this.emit('submit', submission);
      if (saved) {
        this.emit('submitDone', submission);
      }
      return submission;
    }

    /**
     * Called when an error occurs during the submission.
     *
     * @param {Object} error - The error that occured.
     */

  }, {
    key: "onSubmissionError",
    value: function onSubmissionError(error) {
      if (!error) {
        return;
      }

      // Normalize the error.
      if (typeof error === 'string') {
        error = { message: error };
      }

      this.showErrors(error);
    }

    /**
     * Called when the submission has changed in value.
     *
     * @param {Object} changed - The changed value that triggered this event.
     * @param {Object} changed.component - The component that was changed.
     * @param {*} changed.value - The new value of the changed component.
     * @param {boolean} changed.validate - If the change needs to be validated.
     */

  }, {
    key: "onSubmissionChange",
    value: function onSubmissionChange(changed) {
      var value = (0, _clone3.default)(this.submission);
      value.changed = changed;
      this.checkData(value.data, !changed.validate);
      this.emit('change', value);
    }

    /**
     * Resets the submission of a form and restores defaults.
     *
     * @example
     * let form = new FormioForm(document.getElementById('formio'));
     * form.src = 'https://examples.form.io/example';
     * form.submission = {data: {
     *   firstName: 'Joe',
     *   lastName: 'Smith',
     *   email: 'joe@example.com'
     * }};
     *
     * // In two seconds, reset the data in the form.
     * setTimeout(() => form.reset(), 2000);
     */

  }, {
    key: "reset",
    value: function reset() {
      // Reset the submission data.
      this.setSubmission({ data: {} });
    }

    /**
     * Cancels the submission.
     *
     * @alias reset
     */

  }, {
    key: "cancel",
    value: function cancel() {
      this.reset();
    }
  }, {
    key: "executeSubmit",
    value: function executeSubmit() {
      var _this8 = this;

      // DMS
      var comp = null;
      this.everyComponent(function (component) {
        if ((component.component.type === 'checkbox' || component.component.type === 'jornaya') && component.component.validate.required && !component.getValue()) {
          comp = component.component.key;
        }
      });

      if (comp) {
        delete this.submission.data[comp];
      }

      var submission = this.submission;
      if (submission && submission.data && this.checkValidity(submission.data, true)) {
        this.loading = true;
        if (!this.formio) {
          return this.onSubmit(submission, false);
        }
        return this.formio.saveSubmission(submission).then(function (result) {
          return _this8.onSubmit(result, true);
        }, function (err) {
          return _this8.onSubmissionError(err);
        }).catch(function (err) {
          return _this8.onSubmissionError(err);
        });
      } else {
        this.showErrors();
        return _nativePromiseOnly2.default.reject('Invalid Submission');
      }
    }

    /**
     * Submits the form.
     *
     * @example
     * let form = new FormioForm(document.getElementById('formio'));
     * form.src = 'https://examples.form.io/example';
     * form.submission = {data: {
     *   firstName: 'Joe',
     *   lastName: 'Smith',
     *   email: 'joe@example.com'
     * }};
     * form.submit().then((submission) => {
     *   console.log(submission);
     * });
     *
     * @param {boolean} before - If this submission occured from the before handlers.
     *
     * @returns {Promise} - A promise when the form is done submitting.
     */

  }, {
    key: "submit",
    value: function submit(before) {
      var _this9 = this;

      if (!before) {
        return this.beforeSubmit().then(function () {
          return _this9.executeSubmit();
        });
      } else {
        return this.executeSubmit();
      }
    }
  }, {
    key: "src",
    get: function get() {
      return this._src;
    }

    /**
     * Set the Form source, which is typically the Form.io embed URL.
     *
     * @param {string} value - The value of the form embed url.
     *
     * @example
     * let form = new FormioForm(document.getElementById('formio'));
     * form.formReady.then(() => {
     *   console.log('The form is formReady!');
     * });
     * form.src = 'https://examples.form.io/example';
     */

    , set: function set(value) {
      var _this10 = this;

      if (!value || typeof value !== 'string') {
        return;
      }
      this._src = value;
      this.formio = new _formio2.default(value);

      if (this.type === 'form') {
        // Set the options source so this can be passed to other components.
        this.options.src = value;
        this.options.formio = this.formio;
      }

      this.formio.loadForm().then(function (form) {
        return _this10.setForm(form);
      }, function (err) {
        return _this10.formReadyReject(err);
      }).catch(function (err) {
        return _this10.formReadyReject(err);
      });
      if (this.formio.submissionId) {
        this.onSubmission = this.formio.loadSubmission().then(function (submission) {
          return _this10.setSubmission(submission);
        }, function (err) {
          return _this10.submissionReadyReject(err);
        }).catch(function (err) {
          return _this10.submissionReadyReject(err);
        });
      }
    }

    /**
     * Called when both the form and submission have been loaded.
     *
     * @returns {Promise} - The promise to trigger when both form and submission have loaded.
     */

  }, {
    key: "ready",
    get: function get() {
      var _this11 = this;

      return this.formReady.then(function () {
        return _this11.submissionReady;
      });
    }

    /**
     * Returns if this form is loading.
     *
     * @returns {boolean} - TRUE means the form is loading, FALSE otherwise.
     */

  }, {
    key: "loading",
    get: function get() {
      return this._loading;
    }

    /**
     * Set the loading state for this form, and also show the loader spinner.
     *
     * @param {boolean} loading - If this form should be "loading" or not.
     */

    , set: function set(loading) {
      if (this._loading !== loading) {
        this._loading = loading;
        if (!this.loader && loading) {
          this.loader = this.ce('loaderWrapper', 'div', {
            class: 'loader-wrapper'
          });
          var spinner = this.ce('loader', 'div', {
            class: 'loader text-center'
          });
          this.loader.appendChild(spinner);
        }
        if (this.loader) {
          try {
            if (loading) {
              this.prepend(this.loader);
            } else {
              this.removeChild(this.loader);
            }
          } catch (err) {}
        }
      }
    }
  }, {
    key: "form",
    get: function get() {
      return this._form;
    }

    /**
     * Sets the form value.
     *
     * @alias setForm
     * @param {Object} form - The form schema object.
     */

    , set: function set(form) {
      this.setForm(form);
    }

    /**
     * Returns the submission object that was set within this form.
     *
     * @returns {Object}
     */

  }, {
    key: "submission",
    get: function get() {
      return this.getValue();
    }

    /**
     * Sets the submission of a form.
     *
     * @example
     * let form = new FormioForm(document.getElementById('formio'));
     * form.src = 'https://examples.form.io/example';
     * form.submission = {data: {
     *   firstName: 'Joe',
     *   lastName: 'Smith',
     *   email: 'joe@example.com'
     * }};
     *
     * @param {Object} submission - The Form.io submission object.
     */

    , set: function set(submission) {
      this.setSubmission(submission);
    }
  }]);

  return FormioForm;
}(_Components.FormioComponents);

FormioForm.setBaseUrl = _formio2.default.setBaseUrl;
FormioForm.setApiUrl = _formio2.default.setApiUrl;
FormioForm.setAppUrl = _formio2.default.setAppUrl;

/**
 * Embed this form within the current page.
 * @param embed
 */
FormioForm.embed = function (embed) {
  if (!embed || !embed.src) {
    return null;
  }
  var id = embed.id || 'formio-' + Math.random().toString(36).substring(7);
  var className = embed.class || 'formio-form-wrapper';
  var code = embed.styles ? '<link rel="stylesheet" href="' + embed.styles + '">' : '';
  code += '<div id="' + id + '" class="' + className + '"></div>';
  document.write(code);
  var formElement = document.getElementById(id);
  var form = new FormioForm(formElement);
  form.src = embed.src;
  return form;
};

module.exports = global.FormioForm = FormioForm;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./components/Components":1,"./formio":41,"eventemitter2":51,"lodash/assign":219,"lodash/clone":220,"lodash/debounce":223,"lodash/each":226,"native-promise-only":261}],41:[function(require,module,exports){
(function (global){
'use strict';

// Intentionally use native-promise-only here... Other promise libraries (es6-promise)
// duck-punch the global Promise definition which messes up Angular 2 since it
// also duck-punches the global Promise definition. For now, keep native-promise-only.

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Promise = require("native-promise-only");
require('whatwg-fetch');
var EventEmitter = require('eventemitter2').EventEmitter2;
var copy = require('shallow-copy');

/**
 * The Formio interface class.
 *
 *   let formio = new Formio('https://examples.form.io/example');
 */

var Formio = function () {
  function Formio(path) {
    var _this = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Formio);

    // Ensure we have an instance of Formio.
    if (!(this instanceof Formio)) {
      return new Formio(path);
    }

    // Initialize our variables.
    this.base = '';
    this.projectsUrl = '';
    this.projectUrl = '';
    this.projectId = '';
    this.formUrl = '';
    this.formsUrl = '';
    this.formId = '';
    this.submissionsUrl = '';
    this.submissionUrl = '';
    this.submissionId = '';
    this.actionsUrl = '';
    this.actionId = '';
    this.actionUrl = '';
    this.query = '';

    if (options.hasOwnProperty('base')) {
      this.base = options.base;
    } else if (Formio.baseUrl) {
      this.base = Formio.baseUrl;
    } else {
      this.base = window.location.href.match(/http[s]?:\/\/api./)[0];
    }

    if (!path) {
      // Allow user to create new projects if this was instantiated without
      // a url
      this.projectUrl = this.base + '/project';
      this.projectsUrl = this.base + '/project';
      this.projectId = false;
      this.query = '';
      return;
    }

    if (options.hasOwnProperty('project')) {
      this.projectUrl = options.project;
    }

    var project = this.projectUrl || Formio.projectUrl;

    // The baseURL is the same as the projectUrl. This is almost certainly against
    // the Open Source server.
    if (project && this.base === project) {
      this.noProject = true;
      this.projectUrl = this.base;
    }

    // Normalize to an absolute path.
    if (path.indexOf('http') !== 0 && path.indexOf('//') !== 0) {
      path = this.base + path;
    }

    var hostparts = Formio.getUrlParts(path);
    var parts = [];
    var hostName = hostparts[1] + hostparts[2];
    path = hostparts.length > 3 ? hostparts[3] : '';
    var queryparts = path.split('?');
    if (queryparts.length > 1) {
      path = queryparts[0];
      this.query = '?' + queryparts[1];
    }

    // Register a specific path.
    var registerPath = function registerPath(name, base) {
      _this[name + 'sUrl'] = base + '/' + name;
      var regex = new RegExp('\/' + name + '\/([^/]+)');
      if (path.search(regex) !== -1) {
        parts = path.match(regex);
        _this[name + 'Url'] = parts ? base + parts[0] : '';
        _this[name + 'Id'] = parts.length > 1 ? parts[1] : '';
        base += parts[0];
      }
      return base;
    };

    // Register an array of items.
    var registerItems = function registerItems(items, base, staticBase) {
      for (var i in items) {
        if (items.hasOwnProperty(i)) {
          var item = items[i];
          if (item instanceof Array) {
            registerItems(item, base, true);
          } else {
            var newBase = registerPath(item, base);
            base = staticBase ? base : newBase;
          }
        }
      }
    };

    if (!this.projectUrl || this.projectUrl === this.base) {
      this.projectUrl = hostName;
    }

    if (!this.noProject) {
      // Determine the projectUrl and projectId
      if (path.search(/(^|\/)(project)($|\/)/) !== -1) {
        // Get project id as project/:projectId.
        registerItems(['project'], hostName);
      } else if (hostName === this.base) {
        // Get project id as first part of path (subdirectory).
        if (hostparts.length > 3 && path.split('/').length > 1) {
          var pathParts = path.split('/');
          pathParts.shift(); // Throw away the first /.
          this.projectId = pathParts.shift();
          path = '/' + pathParts.join('/');
          this.projectUrl = hostName + '/' + this.projectId;
        }
      } else {
        // Get project id from subdomain.
        if (hostparts.length > 2 && (hostparts[2].split('.').length > 2 || hostName.indexOf('localhost') !== -1)) {
          this.projectUrl = hostName;
          this.projectId = hostparts[2].split('.')[0];
        }
      }
      this.projectsUrl = this.projectsUrl || this.base + '/project';
    }

    // Configure Form urls and form ids.
    if (path.search(/(^|\/)(project|form)($|\/)/) !== -1) {
      registerItems(['form', ['submission', 'action']], this.projectUrl);
    } else {
      var subRegEx = new RegExp('\/(submission|action)($|\/.*)');
      var subs = path.match(subRegEx);
      this.pathType = subs && subs.length > 1 ? subs[1] : '';
      path = path.replace(subRegEx, '');
      path = path.replace(/\/$/, '');
      this.formsUrl = this.projectUrl + '/form';
      this.formUrl = this.projectUrl + path;
      this.formId = path.replace(/^\/+|\/+$/g, '');
      var items = ['submission', 'action'];
      for (var i in items) {
        if (items.hasOwnProperty(i)) {
          var item = items[i];
          this[item + 'sUrl'] = this.projectUrl + path + '/' + item;
          if (this.pathType === item && subs.length > 2 && subs[2]) {
            this[item + 'Id'] = subs[2].replace(/^\/+|\/+$/g, '');
            this[item + 'Url'] = this.projectUrl + path + subs[0];
          }
        }
      }
    }

    // Set the app url if it is not set.
    if (!Formio.projectUrlSet) {
      Formio.projectUrl = this.projectUrl;
    }
  }

  _createClass(Formio, [{
    key: 'delete',
    value: function _delete(type, opts) {
      var _id = type + 'Id';
      var _url = type + 'Url';
      if (!this[_id]) {
        Promise.reject('Nothing to delete');
      }
      Formio.cache = {};
      return this.makeRequest(type, this[_url], 'delete', null, opts);
    }
  }, {
    key: 'index',
    value: function index(type, query, opts) {
      var _url = type + 'Url';
      query = query || '';
      if (query && (typeof query === 'undefined' ? 'undefined' : _typeof(query)) === 'object') {
        query = '?' + Formio.serialize(query.params);
      }
      return this.makeRequest(type, this[_url] + query, 'get', null, opts);
    }
  }, {
    key: 'save',
    value: function save(type, data, opts) {
      var _id = type + 'Id';
      var _url = type + 'Url';
      var method = this[_id] || data._id ? 'put' : 'post';
      var reqUrl = this[_id] ? this[_url] : this[type + 'sUrl'];
      if (!this[_id] && data._id && method === 'put' && reqUrl.indexOf(data._id) === -1) {
        reqUrl += '/' + data._id;
      }
      Formio.cache = {};
      return this.makeRequest(type, reqUrl + this.query, method, data, opts);
    }
  }, {
    key: 'load',
    value: function load(type, query, opts) {
      var _id = type + 'Id';
      var _url = type + 'Url';
      if (query && (typeof query === 'undefined' ? 'undefined' : _typeof(query)) === 'object') {
        query = Formio.serialize(query.params);
      }
      if (query) {
        query = this.query ? this.query + '&' + query : '?' + query;
      } else {
        query = this.query;
      }
      if (!this[_id]) {
        return Promise.reject('Missing ' + _id);
      }
      return this.makeRequest(type, this[_url] + query, 'get', null, opts);
    }
  }, {
    key: 'makeRequest',
    value: function makeRequest(type, url, method, data, opts) {
      method = (method || 'GET').toUpperCase();
      if (!opts || (typeof opts === 'undefined' ? 'undefined' : _typeof(opts)) !== 'object') {
        opts = {};
      }

      var requestArgs = {
        formio: this,
        type: type,
        url: url,
        method: method,
        data: data,
        opts: opts
      };

      var request = Formio.pluginWait('preRequest', requestArgs).then(function () {
        return Formio.pluginGet('request', requestArgs).then(function (result) {
          if (result === null || result === undefined) {
            return Formio.request(url, method, data, opts.header, opts);
          }
          return result;
        });
      });

      return Formio.pluginAlter('wrapRequestPromise', request, requestArgs);
    }
  }, {
    key: 'loadProject',
    value: function loadProject(query, opts) {
      return this.load('project', query, opts);
    }
  }, {
    key: 'saveProject',
    value: function saveProject(data, opts) {
      return this.save('project', data, opts);
    }
  }, {
    key: 'deleteProject',
    value: function deleteProject(opts) {
      return this.delete('project', opts);
    }
  }, {
    key: 'loadForm',
    value: function loadForm(query, opts) {
      return this.load('form', query, opts);
    }
  }, {
    key: 'saveForm',
    value: function saveForm(data, opts) {
      return this.save('form', data, opts);
    }
  }, {
    key: 'deleteForm',
    value: function deleteForm(opts) {
      return this.delete('form', opts);
    }
  }, {
    key: 'loadForms',
    value: function loadForms(query, opts) {
      return this.index('forms', query, opts);
    }
  }, {
    key: 'loadSubmission',
    value: function loadSubmission(query, opts) {
      return this.load('submission', query, opts);
    }
  }, {
    key: 'saveSubmission',
    value: function saveSubmission(data, opts) {
      return this.save('submission', data, opts);
    }
  }, {
    key: 'deleteSubmission',
    value: function deleteSubmission(opts) {
      return this.delete('submission', opts);
    }
  }, {
    key: 'loadSubmissions',
    value: function loadSubmissions(query, opts) {
      return this.index('submissions', query, opts);
    }
  }, {
    key: 'loadAction',
    value: function loadAction(query, opts) {
      return this.load('action', query, opts);
    }
  }, {
    key: 'saveAction',
    value: function saveAction(data, opts) {
      return this.save('action', data, opts);
    }
  }, {
    key: 'deleteAction',
    value: function deleteAction(opts) {
      return this.delete('action', opts);
    }
  }, {
    key: 'loadActions',
    value: function loadActions(query, opts) {
      return this.index('actions', query, opts);
    }
  }, {
    key: 'availableActions',
    value: function availableActions() {
      return this.makeRequest('availableActions', this.formUrl + '/actions');
    }
  }, {
    key: 'actionInfo',
    value: function actionInfo(name) {
      return this.makeRequest('actionInfo', this.formUrl + '/actions/' + name);
    }

    /**
     * Returns a temporary authentication token for single purpose token generation.
     */

  }, {
    key: 'getTempToken',
    value: function getTempToken(expire, allowed) {
      var token = Formio.getToken();
      if (!token) {
        return Promise.reject('You must be authenticated to generate a temporary auth token.');
      }
      return this.makeRequest('tempToken', this.projectUrl + '/token', 'GET', null, {
        header: new Headers({
          'x-expire': expire,
          'x-allow': allowed
        })
      });
    }
  }, {
    key: 'uploadFile',
    value: function uploadFile(storage, file, fileName, dir, progressCallback, url) {
      var requestArgs = {
        provider: storage,
        method: 'upload',
        file: file,
        fileName: fileName,
        dir: dir
      };
      var request = Formio.pluginWait('preRequest', requestArgs).then(function () {
        return Formio.pluginGet('fileRequest', requestArgs).then(function (result) {
          if (storage && (result === null || result === undefined)) {
            if (Formio.providers.storage.hasOwnProperty(storage)) {
              var provider = new Formio.providers.storage[storage](this);
              return provider.uploadFile(file, fileName, dir, progressCallback, url);
            } else {
              throw 'Storage provider not found';
            }
          }
          return result || { url: '' };
        }.bind(this));
      }.bind(this));

      return Formio.pluginAlter('wrapFileRequestPromise', request, requestArgs);
    }
  }, {
    key: 'downloadFile',
    value: function downloadFile(file) {
      var requestArgs = {
        method: 'download',
        file: file
      };

      var request = Formio.pluginWait('preRequest', requestArgs).then(function () {
        return Formio.pluginGet('fileRequest', requestArgs).then(function (result) {
          if (file.storage && (result === null || result === undefined)) {
            if (Formio.providers.storage.hasOwnProperty(file.storage)) {
              var provider = new Formio.providers.storage[file.storage](this);
              return provider.downloadFile(file);
            } else {
              throw 'Storage provider not found';
            }
          }
          return result || { url: '' };
        }.bind(this));
      }.bind(this));

      return Formio.pluginAlter('wrapFileRequestPromise', request, requestArgs);
    }
  }], [{
    key: 'loadProjects',
    value: function loadProjects(query, opts) {
      query = query || '';
      if ((typeof query === 'undefined' ? 'undefined' : _typeof(query)) === 'object') {
        query = '?' + serialize(query.params);
      }
      return Formio.makeStaticRequest(Formio.baseUrl + '/project' + query);
    }
  }, {
    key: 'getUrlParts',
    value: function getUrlParts(url) {
      var regex = '^(http[s]?:\\/\\/)';
      if (this.base && url.indexOf(this.base) === 0) {
        regex += '(' + this.base.replace(/^http[s]?:\/\//, '') + ')';
      } else {
        regex += '([^/]+)';
      }
      regex += '($|\\/.*)';
      return url.match(new RegExp(regex));
    }
  }, {
    key: 'serialize',
    value: function serialize(obj) {
      var str = [];
      for (var p in obj) {
        if (obj.hasOwnProperty(p)) {
          str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
        }
      }return str.join("&");
    }
  }, {
    key: 'makeStaticRequest',
    value: function makeStaticRequest(url, method, data, opts) {
      method = (method || 'GET').toUpperCase();
      if (!opts || (typeof opts === 'undefined' ? 'undefined' : _typeof(opts)) !== 'object') {
        opts = {};
      }
      var requestArgs = {
        url: url,
        method: method,
        data: data
      };

      var request = Formio.pluginWait('preRequest', requestArgs).then(function () {
        return Formio.pluginGet('staticRequest', requestArgs).then(function (result) {
          if (result === null || result === undefined) {
            return Formio.request(url, method, data, opts.header, opts);
          }
          return result;
        });
      });

      return Formio.pluginAlter('wrapStaticRequestPromise', request, requestArgs);
    }
  }, {
    key: 'request',
    value: function request(url, method, data, header, opts) {
      if (!url) {
        return Promise.reject('No url provided');
      }
      method = (method || 'GET').toUpperCase();

      // For reverse compatibility, if they provided the ignoreCache parameter,
      // then change it back to the options format where that is a parameter.
      if (typeof opts === 'boolean') {
        opts = { ignoreCache: opts };
      }
      if (!opts || (typeof opts === 'undefined' ? 'undefined' : _typeof(opts)) !== 'object') {
        opts = {};
      }

      var cacheKey = btoa(url);

      return new Promise(function (resolve, reject) {
        // Get the cached promise to save multiple loads.
        if (!opts.ignoreCache && method === 'GET' && Formio.cache.hasOwnProperty(cacheKey)) {
          return resolve(Formio.cache[cacheKey]);
        }

        var requestToken = '';
        resolve(new Promise(function (resolve, reject) {
          // Set up and fetch request
          var headers = header || new Headers({
            'Accept': 'application/json',
            'Content-type': 'application/json; charset=UTF-8'
          });
          var token = Formio.getToken();
          if (token && !opts.noToken) {
            headers.append('x-jwt-token', token);
          }

          var options = {
            method: method,
            headers: headers,
            mode: 'cors'
          };
          if (data) {
            options.body = JSON.stringify(data);
          }

          requestToken = headers.get('x-jwt-token');
          resolve(fetch(url, options));
        }).catch(function (err) {
          err.message = 'Could not connect to API server (' + err.message + ')';
          err.networkError = true;
          throw err;
        }).then(function (response) {
          if (!response.ok) {
            if (response.status === 440) {
              Formio.setToken(null);
              Formio.events.emit('formio.sessionExpired', response.body);
            } else if (response.status === 401) {
              Formio.events.emit('formio.unauthorized', response.body);
            }
            // Parse and return the error as a rejected promise to reject this promise
            return (response.headers.get('content-type').indexOf('application/json') !== -1 ? response.json() : response.text()).then(function (error) {
              throw error;
            });
          }

          // Handle fetch results
          var token = response.headers.get('x-jwt-token');

          // In some strange cases, the fetch library will return an x-jwt-token without sending
          // one to the server. This has even been debugged on the server to verify that no token
          // was introduced with the request, but the response contains a token. This is an Invalid
          // case where we do not send an x-jwt-token and get one in return for any GET request.
          var tokenIntroduced = false;
          if (method === 'GET' && !requestToken && token && url.indexOf('token=') === -1 && url.indexOf('x-jwt-token=' === -1)) {
            console.warn('Token was introduced in request.');
            tokenIntroduced = true;
          }

          if (response.status >= 200 && response.status < 300 && token && token !== '' && !tokenIntroduced) {
            Formio.setToken(token);
          }
          // 204 is no content. Don't try to .json() it.
          if (response.status === 204) {
            return {};
          }
          return (response.headers.get('content-type').indexOf('application/json') !== -1 ? response.json() : response.text()).then(function (result) {
            // Add some content-range metadata to the result here
            var range = response.headers.get('content-range');
            if (range && (typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object') {
              range = range.split('/');
              if (range[0] !== '*') {
                var skipLimit = range[0].split('-');
                result.skip = Number(skipLimit[0]);
                result.limit = skipLimit[1] - skipLimit[0] + 1;
              }
              result.serverCount = range[1] === '*' ? range[1] : Number(range[1]);
            }

            if (!opts.getHeaders) {
              return result;
            }

            var headers = {};
            response.headers.forEach(function (item, key) {
              headers[key] = item;
            });

            return new Promise(function (resolve, reject) {
              resolve({ result: result, headers: headers });
            });
          });
        }).catch(function (err) {
          if (err === 'Bad Token') {
            Formio.setToken(null);
            Formio.events.emit('formio.badToken', err);
          }
          if (Formio.cache.hasOwnProperty(cacheKey)) {
            // Remove failed promises from cache
            delete Formio.cache[cacheKey];
          }
          // Propagate error so client can handle accordingly
          throw err;
        }));
      }).then(function (result) {
        // Save the cache
        if (method === 'GET') {
          Formio.cache[cacheKey] = Promise.resolve(result);
        }

        // Shallow copy result so modifications don't end up in cache
        if (Array.isArray(result)) {
          var resultCopy = result.map(copy);
          resultCopy.skip = result.skip;
          resultCopy.limit = result.limit;
          resultCopy.serverCount = result.serverCount;
          return resultCopy;
        }
        return copy(result);
      });
    }
  }, {
    key: 'setToken',
    value: function setToken(token) {
      token = token || '';
      if (token === this.token) {
        return;
      }
      this.token = token;
      if (!token) {
        Formio.setUser(null);
        // iOS in private browse mode will throw an error but we can't detect ahead of time that we are in private mode.
        try {
          return localStorage.removeItem('formioToken');
        } catch (err) {
          return;
        }
      }
      // iOS in private browse mode will throw an error but we can't detect ahead of time that we are in private mode.
      try {
        localStorage.setItem('formioToken', token);
      } catch (err) {
        // Do nothing.
      }
      return Formio.currentUser(); // Run this so user is updated if null
    }
  }, {
    key: 'getToken',
    value: function getToken() {
      if (this.token) {
        return this.token;
      }
      try {
        var token = localStorage.getItem('formioToken') || '';
        this.token = token;
        return token;
      } catch (e) {
        return '';
      }
    }
  }, {
    key: 'setUser',
    value: function setUser(user) {
      if (!user) {
        this.setToken(null);
        // iOS in private browse mode will throw an error but we can't detect ahead of time that we are in private mode.
        try {
          return localStorage.removeItem('formioUser');
        } catch (err) {
          return;
        }
      }
      // iOS in private browse mode will throw an error but we can't detect ahead of time that we are in private mode.
      try {
        localStorage.setItem('formioUser', JSON.stringify(user));
      } catch (err) {
        // Do nothing.
      }
    }
  }, {
    key: 'getUser',
    value: function getUser() {
      try {
        return JSON.parse(localStorage.getItem('formioUser') || null);
      } catch (e) {
        return;
      }
    }
  }, {
    key: 'setBaseUrl',
    value: function setBaseUrl(url) {
      Formio.baseUrl = url;
      if (!Formio.projectUrlSet) {
        Formio.projectUrl = url;
      }
    }
  }, {
    key: 'getBaseUrl',
    value: function getBaseUrl() {
      return Formio.baseUrl;
    }
  }, {
    key: 'setApiUrl',
    value: function setApiUrl(url) {
      return Formio.setBaseUrl(url);
    }
  }, {
    key: 'getApiUrl',
    value: function getApiUrl() {
      return Formio.getBaseUrl();
    }
  }, {
    key: 'setAppUrl',
    value: function setAppUrl(url) {
      console.warn('Formio.setAppUrl() is deprecated. Use Formio.setProjectUrl instead.');
      Formio.projectUrl = url;
      Formio.projectUrlSet = true;
    }
  }, {
    key: 'setProjectUrl',
    value: function setProjectUrl(url) {
      Formio.projectUrl = url;
      Formio.projectUrlSet = true;
    }
  }, {
    key: 'getAppUrl',
    value: function getAppUrl() {
      console.warn('Formio.getAppUrl() is deprecated. Use Formio.getProjectUrl instead.');
      return Formio.projectUrl;
    }
  }, {
    key: 'getProjectUrl',
    value: function getProjectUrl() {
      return Formio.projectUrl;
    }
  }, {
    key: 'clearCache',
    value: function clearCache() {
      Formio.cache = {};
    }
  }, {
    key: 'noop',
    value: function noop() {}
  }, {
    key: 'identity',
    value: function identity(value) {
      return value;
    }
  }, {
    key: 'deregisterPlugin',
    value: function deregisterPlugin(plugin) {
      var beforeLength = Formio.plugins.length;
      Formio.plugins = Formio.plugins.filter(function (p) {
        if (p !== plugin && p.__name !== plugin) return true;
        (p.deregister || Formio.noop).call(p, Formio);
        return false;
      });
      return beforeLength !== Formio.plugins.length;
    }
  }, {
    key: 'registerPlugin',
    value: function registerPlugin(plugin, name) {
      Formio.plugins.push(plugin);
      Formio.plugins.sort(function (a, b) {
        return (b.priority || 0) - (a.priority || 0);
      });
      plugin.__name = name;
      (plugin.init || Formio.noop).call(plugin, Formio);
    }
  }, {
    key: 'getPlugin',
    value: function getPlugin(name) {
      return Formio.plugins.reduce(function (result, plugin) {
        if (result) return result;
        if (plugin.__name === name) return plugin;
      }, null);
    }
  }, {
    key: 'pluginWait',
    value: function pluginWait(pluginFn) {
      var args = [].slice.call(arguments, 1);
      return Promise.all(Formio.plugins.map(function (plugin) {
        return (plugin[pluginFn] || Formio.noop).apply(plugin, args);
      }));
    }
  }, {
    key: 'pluginGet',
    value: function pluginGet(pluginFn) {
      var args = [].slice.call(arguments, 0);
      var callPlugin = function callPlugin(index, pluginFn) {
        var plugin = Formio.plugins[index];
        if (!plugin) return Promise.resolve(null);
        return Promise.resolve((plugin && plugin[pluginFn] || Formio.noop).apply(plugin, [].slice.call(arguments, 2))).then(function (result) {
          if (result !== null && result !== undefined) return result;
          return callPlugin.apply(null, [index + 1].concat(args));
        });
      };
      return callPlugin.apply(null, [0].concat(args));
    }
  }, {
    key: 'pluginAlter',
    value: function pluginAlter(pluginFn, value) {
      var args = [].slice.call(arguments, 2);
      return Formio.plugins.reduce(function (value, plugin) {
        return (plugin[pluginFn] || Formio.identity).apply(plugin, [value].concat(args));
      }, value);
    }
  }, {
    key: 'currentUser',
    value: function currentUser() {
      var url = Formio.baseUrl + '/current';
      var user = this.getUser();
      if (user) {
        return Formio.pluginAlter('wrapStaticRequestPromise', Promise.resolve(user), {
          url: url,
          method: 'GET'
        });
      }
      var token = this.getToken();
      if (!token) {
        return Formio.pluginAlter('wrapStaticRequestPromise', Promise.resolve(null), {
          url: url,
          method: 'GET'
        });
      }
      return Formio.makeStaticRequest(url).then(function (response) {
        Formio.setUser(response);
        return response;
      });
    }
  }, {
    key: 'logout',
    value: function logout() {
      Formio.setToken(null);
      Formio.setUser(null);
      Formio.clearCache();
      return Formio.makeStaticRequest(Formio.baseUrl + '/logout');
    }

    /**
     * Attach an HTML form to Form.io.
     *
     * @param form
     */

  }, {
    key: 'form',
    value: function form(_form, options, done) {
      // Fix the parameters.
      if (!done && typeof options === 'function') {
        done = options;
        options = {};
      }

      done = done || function () {
        console.log(arguments);
      };
      options = options || {};

      // IF they provide a jquery object, then select the element.
      if (_form.jquery) {
        _form = _form[0];
      }
      if (!_form) {
        return done('Invalid Form');
      }

      var getAction = function getAction() {
        return options.form || _form.getAttribute('action');
      };

      /**
       * Returns the current submission object.
       * @returns {{data: {}}}
       */
      var getSubmission = function getSubmission() {
        var submission = { data: {} };
        var setValue = function setValue(path, value) {
          var isArray = path.substr(-2) === '[]';
          if (isArray) {
            path = path.replace('[]', '');
          }
          var paths = path.replace(/\[|\]\[/g, '.').replace(/\]$/g, '').split('.');
          var current = submission;
          while (path = paths.shift()) {
            if (!paths.length) {
              if (isArray) {
                if (!current[path]) {
                  current[path] = [];
                }
                current[path].push(value);
              } else {
                current[path] = value;
              }
            } else {
              if (!current[path]) {
                current[path] = {};
              }
              current = current[path];
            }
          }
        };

        // Get the form data from this form.
        var formData = new FormData(_form);
        var entries = formData.entries();
        var entry = null;
        while (entry = entries.next().value) {
          setValue(entry[0], entry[1]);
        }
        return submission;
      };

      // Submits the form.
      var submit = function submit(event) {
        if (event) {
          event.preventDefault();
        }
        var action = getAction();
        if (!action) {
          return;
        }
        new Formio(action).saveSubmission(getSubmission()).then(function (sub) {
          done(null, sub);
        }, done);
      };

      // Attach formio to the provided form.
      if (_form.attachEvent) {
        _form.attachEvent('submit', submit);
      } else {
        _form.addEventListener('submit', submit);
      }

      return {
        submit: submit,
        getAction: getAction,
        getSubmission: getSubmission
      };
    }
  }, {
    key: 'fieldData',
    value: function fieldData(data, component) {
      if (!data) {
        return '';
      }
      if (!component || !component.key) {
        return data;
      }
      if (component.key.indexOf('.') !== -1) {
        var value = data;
        var parts = component.key.split('.');
        var key = '';
        for (var i = 0; i < parts.length; i++) {
          key = parts[i];

          // Handle nested resources
          if (value.hasOwnProperty('_id')) {
            value = value.data;
          }

          // Return if the key is not found on the value.
          if (!value.hasOwnProperty(key)) {
            return;
          }

          // Convert old single field data in submissions to multiple
          if (key === parts[parts.length - 1] && component.multiple && !Array.isArray(value[key])) {
            value[key] = [value[key]];
          }

          // Set the value of this key.
          value = value[key];
        }
        return value;
      } else {
        // Convert old single field data in submissions to multiple
        if (component.multiple && !Array.isArray(data[component.key])) {
          data[component.key] = [data[component.key]];
        }
        return data[component.key];
      }
    }
  }]);

  return Formio;
}();

// Define all the static properties.


exports.Formio = Formio;
Formio.baseUrl = 'https://api.form.io';
Formio.projectUrl = Formio.baseUrl;
Formio.projectUrlSet = false;
Formio.plugins = [];
Formio.cache = {};
Formio.providers = require('./providers');
Formio.events = new EventEmitter({
  wildcard: false,
  maxListeners: 0
});

module.exports = global.Formio = Formio;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./providers":44,"eventemitter2":51,"native-promise-only":261,"shallow-copy":264,"whatwg-fetch":268}],42:[function(require,module,exports){
(function (global){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FormioWizard = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _nativePromiseOnly = require('native-promise-only');

var _nativePromiseOnly2 = _interopRequireDefault(_nativePromiseOnly);

var _formio = require('./formio.form');

var _formio2 = _interopRequireDefault(_formio);

var _formio3 = require('./formio');

var _formio4 = _interopRequireDefault(_formio3);

var _each = require('lodash/each');

var _each2 = _interopRequireDefault(_each);

var _clone = require('lodash/clone');

var _clone2 = _interopRequireDefault(_clone);

var _jsonLogicJs = require('json-logic-js');

var _jsonLogicJs2 = _interopRequireDefault(_jsonLogicJs);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var FormioWizard = exports.FormioWizard = function (_FormioForm) {
  _inherits(FormioWizard, _FormioForm);

  function FormioWizard(element, options) {
    _classCallCheck(this, FormioWizard);

    var _this = _possibleConstructorReturn(this, (FormioWizard.__proto__ || Object.getPrototypeOf(FormioWizard)).call(this, element, options));

    _this.pages = [];
    _this.page = 0;
    _this.history = [];
    _this.allComponents = {};
    _this._nextPage = 1;
    _this.buttons = [];

    // DMS

    _this.wizardNav = false;
    return _this;
  }

  _createClass(FormioWizard, [{
    key: 'setPage',
    value: function setPage(num) {
      var _this2 = this;

      if (num >= 0 && num < this.pages.length) {
        this.page = num;
        this.buttons = [];
        var page = this.currentPage();
        this.buttons = page.buttons;
        return _get(FormioWizard.prototype.__proto__ || Object.getPrototypeOf(FormioWizard.prototype), 'setForm', this).call(this, this.currentPage()).then(function () {
          // Save the components for when we finally submit.
          _this2.allComponents[_this2.page] = (0, _clone2.default)(_this2.components);
        });
      }
      return _nativePromiseOnly2.default.reject('Page not found');
    }
  }, {
    key: 'getNextPage',
    value: function getNextPage(data, currentPage) {
      var form = this.pages[currentPage];
      // Check conditional nextPage
      if (form) {
        var page = ++currentPage;
        if (form.nextPage) {
          // Allow for script execution.
          if (typeof form.nextPage === 'string') {
            try {
              eval(form.nextPage.toString());
              if (!isNaN(parseInt(page, 10)) && isFinite(page)) {
                return page;
              }
              if (typeof page !== 'string') {
                return page;
              }

              // Assume they passed back the key of the page to go to.
              return this.getPageIndexByKey(page);
            } catch (e) {
              console.warn('An error occurred in a custom nextPage function statement for component ' + form.key, e);
              return page;
            }
          }
          // Or use JSON Logic.
          else {
              var result = _jsonLogicJs2.default.apply(form.nextPage, {
                data: data,
                page: page,
                form: form
              });
              var newPage = parseInt(result, 10);
              if (!isNaN(parseInt(newPage, 10)) && isFinite(newPage)) {
                return newPage;
              }

              return this.getPageIndexByKey(result);
            }
        }

        return page;
      }

      return null;
    }
  }, {
    key: 'getPreviousPage',
    value: function getPreviousPage() {
      var prev = this.history.pop();
      if (typeof prev !== 'undefined') {
        return prev;
      }

      return this.page - 1;
    }

    // DMS

  }, {
    key: 'nextPage',
    value: function nextPage() {
      var _this3 = this;

      // DMS

      for (var i = 0; i < this.components.length; i++) {
        if (this.components[i].type === 'checkbox' && this.components[i].component.validate.required && (this.components[i].value === null || !this.components[i].value)) {
          delete this.submission.data[this.components[i].component.key];
        }

        i++;
      }

      // Validate the form builed, before go to the next page
      if (this.checkValidity(this.submission.data, true)) {
        // DMS

        if (this.beforeNextPageCallback) {
          this.beforeNextPageCallback(this, this.submission.data, this.nextPageWithValidation);
        } else {
          this.checkData(this.submission.data, true);
          return this.beforeNext().then(function () {
            _this3.history.push(_this3.page);
            return _this3.setPage(_this3.getNextPage(_this3.submission.data, _this3.page)).then(function () {
              _this3._nextPage = _this3.getNextPage(_this3.submission.data, _this3.page);
              _this3.emit('nextPage', { page: _this3.page, submission: _this3.submission });
            });
          });
        }
      } else {
        return _nativePromiseOnly2.default.reject(this.showErrors());
      }
    }

    // DMS

  }, {
    key: 'nextPageWithValidation',
    value: function nextPageWithValidation(thisInstance, additionalFieldsValidationData) {
      //console.log('nextPageWithValidation');

      //console.log('----- ----- ----- ----- -----');
      //console.log(thisInstance);

      //console.log('additionalFieldsValidationData:');
      //console.dir(additionalFieldsValidationData);

      //console.log('----- ----- ----- ----- -----');

      var proceedToNextPage = false;

      // If no data given, then proceed to the next page.
      if (typeof additionalFieldsValidationData === 'undefined') {
        proceedToNextPage = true;
      }

      if (additionalFieldsValidationData) {
        var currentKey;

        (function () {
          var currentObj = void 0;

          var valid = void 0;
          var message = void 0;

          var allValid = 1;

          for (currentKey in additionalFieldsValidationData) {
            currentObj = additionalFieldsValidationData[currentKey];

            valid = currentObj.valid;
            message = currentObj.message;

            if (!valid) {
              thisInstance.getComponent(currentKey, function (component) {
                component.createErrorElement();
                component.addInputError(message);
              });

              allValid = 0;
            }
          }

          if (allValid) {
            proceedToNextPage = true;
          }
        })();
      }

      //console.log('proceedToNextPage' + ' = ' + proceedToNextPage);

      if (proceedToNextPage) {
        thisInstance.checkData(thisInstance.submission.data, true);

        return thisInstance.beforeNext().then(function () {
          thisInstance.history.push(thisInstance.page);

          return thisInstance.setPage(thisInstance.getNextPage(thisInstance.submission.data, thisInstance.page)).then(function () {
            thisInstance._nextPage = thisInstance.getNextPage(thisInstance.submission.data, thisInstance.page);
            thisInstance.emit('nextPage', { page: thisInstance.page, submission: thisInstance.submission });
          });
        });
      } else {
        return _nativePromiseOnly2.default.reject(thisInstance.showErrors());
      }
    }
  }, {
    key: 'prevPage',
    value: function prevPage() {
      var _this4 = this;

      var prevPage = this.getPreviousPage();
      return this.setPage(prevPage).then(function () {
        _this4.emit('prevPage', { page: _this4.page, submission: _this4.submission });
      });
    }
  }, {
    key: 'cancel',
    value: function cancel() {
      _get(FormioWizard.prototype.__proto__ || Object.getPrototypeOf(FormioWizard.prototype), 'cancel', this).call(this);
      this.history = [];
      return this.setPage(0);
    }
  }, {
    key: 'getPageIndexByKey',
    value: function getPageIndexByKey(key) {
      var pageIndex = 0;
      (0, _each2.default)(this.pages, function (_page, index) {
        if (_page.key === key) {
          pageIndex = index;
          return false;
        }
      });
      return pageIndex;
    }
  }, {
    key: 'getPage',
    value: function getPage(pageNum) {
      if (pageNum >= 0 && pageNum < this.pages.length) {
        return this.pages[pageNum];
      }
      return this.pages.length ? this.pages[0] : { components: [] };
    }
  }, {
    key: 'currentPage',
    value: function currentPage() {
      return this.getPage(this.page);
    }
  }, {
    key: 'setForm',
    value: function setForm(form) {
      var _this5 = this;

      this.pages = [];
      this.buttons = [];

      // DMS

      this.wizardNav = false;

      if (form.enableNavigation) {
        this.wizardNav = true;
      }

      (0, _each2.default)(form.components, function (component) {
        if (component.type === 'panel') {
          _this5.pages.push(component);
        } else if (component.key) {
          _this5.allComponents[component.key] = _this5.addComponent(component, _this5.element, _this5.data);
        }
      });
      return this.setPage(this.page);
    }
  }, {
    key: 'build',
    value: function build() {
      this.createWizardHeader();
      _get(FormioWizard.prototype.__proto__ || Object.getPrototypeOf(FormioWizard.prototype), 'build', this).call(this);
      this.createWizardNav();
    }
  }, {
    key: 'hasButton',
    value: function hasButton(name) {
      if (name === 'previous') {
        return this.page > 0;
      }
      var nextPage = this.getNextPage(this.submission.data, this.page);
      if (name === 'next') {
        return nextPage !== null && nextPage < this.pages.length;
      }
      if (name === 'submit') {
        return nextPage === null || this.page === this.pages.length - 1;
      }
      return true;
    }
  }, {
    key: 'createWizardHeader',
    value: function createWizardHeader() {
      var _this6 = this;

      // DMS

      if (!this.wizardNav) {
        return;
      }

      var currentPage = this.currentPage();
      currentPage.breadcrumb = currentPage.breadcrumb || 'default';
      if (currentPage.breadcrumb.toLowerCase() === 'none') {
        return;
      }
      this.wizardHeader = this.ce('wizardHeader', 'ul', {
        class: 'pagination'
      });

      var showHistory = currentPage.breadcrumb.toLowerCase() === 'history';
      (0, _each2.default)(this.pages, function (page, i) {
        // See if this page is in our history.
        if (showHistory && _this6.page !== i && _this6.history.indexOf(i) === -1) {
          return;
        }

        var pageButton = _this6.ce('pageButton', 'li', {
          class: i === _this6.page ? 'active' : '',
          style: i === _this6.page ? '' : 'cursor: pointer;'
        });

        // Navigate to the page as they click on it.
        if (_this6.page !== i) {
          _this6.addEventListener(pageButton, 'click', function (event) {
            event.preventDefault();
            _this6.setPage(i);
          });
        }

        var pageLabel = _this6.ce('pageLabel', 'span');
        var pageTitle = i === _this6.page || showHistory ? page.title : i + 1;
        if (!pageTitle) {
          pageTitle = i + 1;
        }
        pageLabel.appendChild(_this6.text(pageTitle));
        pageButton.appendChild(pageLabel);
        _this6.wizardHeader.appendChild(pageButton);
      });

      this.element.appendChild(this.wizardHeader);
    }
  }, {
    key: 'onSubmissionChange',
    value: function onSubmissionChange(changed) {
      _get(FormioWizard.prototype.__proto__ || Object.getPrototypeOf(FormioWizard.prototype), 'onSubmissionChange', this).call(this, changed);

      // Update Wizard Nav
      var nextPage = this.getNextPage(this.submission.data, this.page);
      if (this._nextPage != nextPage) {
        this.element.removeChild(this.wizardNav);
        this.createWizardNav();
        this.emit('updateWizardNav', { oldpage: this._nextPage, newpage: nextPage, submission: this.submission });
        this._nextPage = nextPage;
      }
    }
  }, {
    key: 'createWizardNav',
    value: function createWizardNav() {
      var _this7 = this;

      this.wizardNav = this.ce('wizardNav', 'ul', {
        class: 'list-inline'
      });

      // DMS

      /*each([
        {name: 'cancel',    method: 'cancel',   class: 'btn btn-default'},
        {name: 'previous',  method: 'prevPage', class: 'btn btn-primary'},
        {name: 'next',      method: 'nextPage', class: 'btn btn-primary'},
        {name: 'submit',    method: 'submit',   class: 'btn btn-primary'}
      ], (button) => {
        if (!this.hasButton(button.name)) {
          return;
        }
        let buttonWrapper = this.ce('wizardNavButton', 'li');
        let buttonProp = button.name + 'Button';
        this[buttonProp] = this.ce(buttonProp, 'button', {
          class: button.class + ' btn-wizard-nav-' + button.name
        });
        this[buttonProp].appendChild(this.text(this.t(button.name)));
        this.addEventListener(this[buttonProp], 'click', (event) => {
          event.preventDefault();
          this[button.method]();
        });
        buttonWrapper.appendChild(this[buttonProp]);
        this.wizardNav.appendChild(buttonWrapper);
      });*/

      if (this.buttons) {
        (0, _each2.default)(this.buttons, function (button) {
          if (!_this7.hasButton(button.name)) {
            return;
          }

          var buttonWrapper = _this7.ce('wizardNavButton', 'li');
          var buttonProp = button.name + 'Button';

          _this7[buttonProp] = _this7.ce(buttonProp, 'button', {
            class: button.class
          });

          if (button.custom) {
            _this7[buttonProp].appendChild(_this7.text(_this7.t(button.custom)));
          } else {
            _this7[buttonProp].appendChild(_this7.text(_this7.t(button.name)));
          }

          _this7.addEventListener(_this7[buttonProp], 'click', function (event) {
            event.preventDefault();
            _this7[button.method]();
          });

          buttonWrapper.appendChild(_this7[buttonProp]);

          _this7.wizardNav.appendChild(buttonWrapper);
        });
      } else {
        (0, _each2.default)([{ name: 'cancel', method: 'cancel', class: 'btn btn-default' }, { name: 'previous', method: 'prevPage', class: 'btn btn-primary' }, { name: 'next', method: 'nextPage', class: 'btn btn-primary' }, { name: 'submit', method: 'submit', class: 'btn btn-primary' }], function (button) {
          if (!_this7.hasButton(button.name)) {
            return;
          }

          var buttonWrapper = _this7.ce('wizardNavButton', 'li');
          var buttonProp = button.name + 'Button';

          _this7[buttonProp] = _this7.ce(buttonProp, 'button', {
            class: button.class
          });

          _this7[buttonProp].appendChild(_this7.text(_this7.t(button.name)));

          _this7.addEventListener(_this7[buttonProp], 'click', function (event) {
            event.preventDefault();
            _this7[button.method]();
          });

          buttonWrapper.appendChild(_this7[buttonProp]);
          _this7.wizardNav.appendChild(buttonWrapper);
        });
      }

      // Add the wizard navigation
      this.element.appendChild(this.wizardNav);
    }
  }, {
    key: 'getComponents',
    value: function getComponents() {
      // Set the components based on all components.
      var components = [];
      (0, _each2.default)(this.allComponents, function (comps) {
        components = components.concat(comps);
      });
      return components;
    }
  }]);

  return FormioWizard;
}(_formio2.default);

FormioWizard.setBaseUrl = _formio4.default.setBaseUrl;
FormioWizard.setApiUrl = _formio4.default.setApiUrl;
FormioWizard.setAppUrl = _formio4.default.setAppUrl;

module.exports = global.FormioWizard = FormioWizard;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./formio":41,"./formio.form":40,"json-logic-js":69,"lodash/clone":220,"lodash/each":226,"native-promise-only":261}],43:[function(require,module,exports){
'use strict';

module.exports = {
  lng: 'en',
  resources: {
    en: {
      translation: {
        complete: 'Submission Complete',
        error: 'Please fix the following errors before submitting.',
        required: '{{field}} is required',
        minLength: '{{field}} must be longer than {{length}} characters.',
        maxLength: '{{field}} must be shorter than {{length}} characters.',
        invalid_email: '{{field}} must be a valid email.',
        invalid_regex: '{{field}} does not match the pattern {{regex}}.',
        invalid_date: '{{field}} is not a valid date.',
        month: 'Month',
        day: 'Day',
        year: 'Year',
        january: 'January',
        february: 'February',
        march: 'March',
        april: 'April',
        may: 'May',
        june: 'June',
        july: 'July',
        august: 'August',
        september: 'September',
        october: 'October',
        november: 'November',
        december: 'December',
        next: 'Next',
        previous: 'Previous',
        cancel: 'Cancel',
        submit: 'Submit Form'
      }
    }
  }
};

},{}],44:[function(require,module,exports){
'use strict';

module.exports = {
  storage: require('./storage')
};

},{"./storage":46}],45:[function(require,module,exports){
'use strict';

var Promise = require("native-promise-only");
var dropbox = function dropbox(formio) {
  return {
    uploadFile: function uploadFile(file, fileName, dir, progressCallback) {
      return new Promise(function (resolve, reject) {
        // Send the file with data.
        var xhr = new XMLHttpRequest();

        if (typeof progressCallback === 'function') {
          xhr.upload.onprogress = progressCallback;
        }

        var fd = new FormData();
        fd.append('name', fileName);
        fd.append('dir', dir);
        fd.append('file', file);

        // Fire on network error.
        xhr.onerror = function (err) {
          err.networkError = true;
          reject(err);
        };

        xhr.onload = function () {
          if (xhr.status >= 200 && xhr.status < 300) {
            var response = JSON.parse(xhr.response);
            response.storage = 'dropbox';
            response.size = file.size;
            response.type = file.type;
            response.url = response.path_lower;
            resolve(response);
          } else {
            reject(xhr.response || 'Unable to upload file');
          }
        };

        xhr.onabort = function (err) {
          reject(err);
        };

        xhr.open('POST', formio.formUrl + '/storage/dropbox');
        var token = false;
        try {
          token = localStorage.getItem('formioToken');
        } catch (e) {
          // Swallow error.
        }
        if (token) {
          xhr.setRequestHeader('x-jwt-token', token);
        }
        xhr.send(fd);
      });
    },
    downloadFile: function downloadFile(file) {
      var token = false;
      try {
        token = localStorage.getItem('formioToken');
      } catch (e) {
        // Swallow error.
      }
      file.url = formio.formUrl + '/storage/dropbox?path_lower=' + file.path_lower + (token ? '&x-jwt-token=' + token : '');
      return Promise.resolve(file);
    }
  };
};

dropbox.title = 'Dropbox';
module.exports = dropbox;

},{"native-promise-only":261}],46:[function(require,module,exports){
'use strict';

module.exports = {
  dropbox: require('./dropbox.js'),
  s3: require('./s3.js'),
  url: require('./url.js')
};

},{"./dropbox.js":45,"./s3.js":47,"./url.js":48}],47:[function(require,module,exports){
'use strict';

var Promise = require("native-promise-only");
var s3 = function s3(formio) {
  return {
    uploadFile: function uploadFile(file, fileName, dir, progressCallback) {
      return new Promise(function (resolve, reject) {
        // Send the pre response to sign the upload.
        var pre = new XMLHttpRequest();

        var prefd = new FormData();
        prefd.append('name', fileName);
        prefd.append('size', file.size);
        prefd.append('type', file.type);

        // This only fires on a network error.
        pre.onerror = function (err) {
          err.networkError = true;
          reject(err);
        };

        pre.onabort = function (err) {
          reject(err);
        };

        pre.onload = function () {
          if (pre.status >= 200 && pre.status < 300) {
            var response = JSON.parse(pre.response);

            // Send the file with data.
            var xhr = new XMLHttpRequest();

            if (typeof progressCallback === 'function') {
              xhr.upload.onprogress = progressCallback;
            }

            response.data.fileName = fileName;
            response.data.key += dir + fileName;

            var fd = new FormData();
            for (var key in response.data) {
              fd.append(key, response.data[key]);
            }
            fd.append('file', file);

            // Fire on network error.
            xhr.onerror = function (err) {
              err.networkError = true;
              reject(err);
            };

            xhr.onload = function () {
              if (xhr.status >= 200 && xhr.status < 300) {
                resolve({
                  storage: 's3',
                  name: fileName,
                  bucket: response.bucket,
                  key: response.data.key,
                  url: response.url + response.data.key,
                  acl: response.data.acl,
                  size: file.size,
                  type: file.type
                });
              } else {
                reject(xhr.response || 'Unable to upload file');
              }
            };

            xhr.onabort = function (err) {
              reject(err);
            };

            xhr.open('POST', response.url);

            xhr.send(fd);
          } else {
            reject(pre.response || 'Unable to sign file');
          }
        };

        pre.open('POST', formio.formUrl + '/storage/s3');

        pre.setRequestHeader('Accept', 'application/json');
        pre.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
        var token = false;
        try {
          token = localStorage.getItem('formioToken');
        } catch (e) {
          // swallow error.
        }
        if (token) {
          pre.setRequestHeader('x-jwt-token', token);
        }

        pre.send(JSON.stringify({
          name: fileName,
          size: file.size,
          type: file.type
        }));
      });
    },
    downloadFile: function downloadFile(file) {
      if (file.acl !== 'public-read') {
        return formio.makeRequest('file', formio.formUrl + '/storage/s3?bucket=' + file.bucket + '&key=' + file.key, 'GET');
      } else {
        return Promise.resolve(file);
      }
    }
  };
};

s3.title = 'S3';
module.exports = s3;

},{"native-promise-only":261}],48:[function(require,module,exports){
'use strict';

var Promise = require("native-promise-only");
var url = function url(formio) {
  return {
    title: 'Url',
    name: 'url',
    uploadFile: function uploadFile(file, fileName, dir, progressCallback, url) {
      return new Promise(function (resolve, reject) {
        var data = {
          dir: dir,
          name: fileName,
          file: file
        };

        // Send the file with data.
        var xhr = new XMLHttpRequest();

        if (typeof progressCallback === 'function') {
          xhr.upload.onprogress = progressCallback;
        }

        var fd = new FormData();
        for (var key in data) {
          fd.append(key, data[key]);
        }

        xhr.onload = function () {
          if (xhr.status >= 200 && xhr.status < 300) {
            // Need to test if xhr.response is decoded or not.
            var respData = {};
            try {
              respData = typeof xhr.response === 'string' ? JSON.parse(xhr.response) : {};
              respData = respData && respData.data ? respData.data : {};
            } catch (err) {
              respData = {};
            }

            resolve({
              storage: 'url',
              name: fileName,
              url: xhr.responseURL + '/' + fileName,
              size: file.size,
              type: file.type,
              data: respData
            });
          } else {
            reject(xhr.response || 'Unable to upload file');
          }
        };

        // Fire on network error.
        xhr.onerror = function () {
          reject(xhr);
        };

        xhr.onabort = function () {
          reject(xhr);
        };

        xhr.open('POST', url);
        var token = localStorage.getItem('formioToken');
        if (token) {
          xhr.setRequestHeader('x-jwt-token', token);
        }
        xhr.send(fd);
      });
    },
    downloadFile: function downloadFile(file) {
      // Return the original as there is nothing to do.
      return Promise.resolve(file);
    }
  };
};

url.title = 'Url';
module.exports = url;

},{"native-promise-only":261}],49:[function(require,module,exports){
'use strict';

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _jsonLogicJs = require('json-logic-js');

var _jsonLogicJs2 = _interopRequireDefault(_jsonLogicJs);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _get = require('lodash/get');

module.exports = {
  /**
   * Determine if a component is a layout component or not.
   *
   * @param {Object} component
   *   The component to check.
   *
   * @returns {Boolean}
   *   Whether or not the component is a layout component.
   */
  isLayoutComponent: function isLayoutComponent(component) {
    return component.columns && Array.isArray(component.columns) || component.rows && Array.isArray(component.rows) || component.components && Array.isArray(component.components) ? true : false;
  },

  /**
   * Iterate through each component within a form.
   *
   * @param {Object} components
   *   The components to iterate.
   * @param {Function} fn
   *   The iteration function to invoke for each component.
   * @param {Boolean} includeAll
   *   Whether or not to include layout components.
   * @param {String} path
   *   The current data path of the element. Example: data.user.firstName
   */
  eachComponent: function eachComponent(components, fn, includeAll, path) {
    if (!components) return;
    path = path || '';
    components.forEach(function (component) {
      var hasColumns = component.columns && Array.isArray(component.columns);
      var hasRows = component.rows && Array.isArray(component.rows);
      var hasComps = component.components && Array.isArray(component.components);
      var noRecurse = false;
      var newPath = component.key ? path ? path + '.' + component.key : component.key : '';

      if (includeAll || component.tree || !hasColumns && !hasRows && !hasComps) {
        noRecurse = fn(component, newPath);
      }

      var subPath = function subPath() {
        if (component.key && (component.type === 'datagrid' || component.type === 'container')) {
          return newPath;
        }
        return path;
      };

      if (!noRecurse) {
        if (hasColumns) {
          component.columns.forEach(function (column) {
            eachComponent(column.components, fn, includeAll, subPath());
          });
        } else if (hasRows) {
          [].concat.apply([], component.rows).forEach(function (row) {
            eachComponent(row.components, fn, includeAll, subPath());
          });
        } else if (hasComps) {
          eachComponent(component.components, fn, includeAll, subPath());
        }
      }
    });
  },

  /**
   * Get a component by its key
   *
   * @param {Object} components
   *   The components to iterate.
   * @param {String} key
   *   The key of the component to get.
   *
   * @returns {Object}
   *   The component that matches the given key, or undefined if not found.
   */
  getComponent: function getComponent(components, key) {
    var result;
    module.exports.eachComponent(components, function (component) {
      if (component.key === key) {
        result = component;
      }
    });
    return result;
  },

  /**
   * Flatten the form components for data manipulation.
   *
   * @param {Object} components
   *   The components to iterate.
   * @param {Boolean} includeAll
   *   Whether or not to include layout components.
   *
   * @returns {Object}
   *   The flattened components map.
   */
  flattenComponents: function flattenComponents(components, includeAll) {
    var flattened = {};
    module.exports.eachComponent(components, function (component, path) {
      flattened[path] = component;
    }, includeAll);
    return flattened;
  },

  /**
   * Returns if this component has a conditional statement.
   *
   * @param component - The component JSON schema.
   *
   * @returns {boolean} - TRUE - This component has a conditional, FALSE - No conditional provided.
   */
  hasCondition: function hasCondition(component) {
    return component.hasOwnProperty('customConditional') && component.customConditional || component.hasOwnProperty('conditional') && component.conditional && component.conditional.when || component.hasOwnProperty('conditional') && component.conditional && component.conditional.json;
  },

  /**
   * Checks the conditions for a provided component and data.
   *
   * @param component
   *   The component to check for the condition.
   * @param row
   *   The data within a row
   * @param data
   *   The full submission data.
   *
   * @returns {boolean}
   */
  checkCondition: function checkCondition(component, row, data) {
    if (component.hasOwnProperty('customConditional') && component.customConditional) {
      try {
        var script = '(function() { var show = true;';
        script += component.customConditional.toString();
        script += '; return show; })()';
        var result = eval(script);
        return result.toString() === 'true';
      } catch (e) {
        console.warn('An error occurred in a custom conditional statement for component ' + component.key, e);
        return true;
      }
    } else if (component.hasOwnProperty('conditional') && component.conditional && component.conditional.when) {
      var cond = component.conditional;
      var value = null;
      if (row) {
        value = this.getValue({ data: row }, cond.when);
      }
      if (data && (value === null || typeof value === 'undefined')) {
        value = this.getValue({ data: data }, cond.when);
      }
      // FOR-400 - Fix issue where falsey values were being evaluated as show=true
      if (value === null || typeof value === 'undefined') {
        return false;
      }
      // Special check for selectboxes component.
      if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.hasOwnProperty(cond.eq)) {
        return value[cond.eq].toString() === cond.show.toString();
      }
      // FOR-179 - Check for multiple values.
      if (value instanceof Array && value.indexOf(cond.eq) !== -1) {
        return cond.show.toString() === 'true';
      }

      return value.toString() === cond.eq.toString() === (cond.show.toString() === 'true');
    } else if (component.hasOwnProperty('conditional') && component.conditional && component.conditional.json) {
      return _jsonLogicJs2.default.apply(component.conditional.json, {
        data: data,
        row: row
      });
    }

    // Default to show.
    return true;
  },

  /**
   * Get the value for a component key, in the given submission.
   *
   * @param {Object} submission
   *   A submission object to search.
   * @param {String} key
   *   A for components API key to search for.
   */
  getValue: function getValue(submission, key) {
    var data = submission.data || {};

    var search = function search(data) {
      var i;
      var value;

      if (!data) {
        return null;
      }

      if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && !(data instanceof Array)) {
        if (data.hasOwnProperty(key)) {
          return data[key];
        }

        var keys = Object.keys(data);
        for (i = 0; i < keys.length; i++) {
          if (_typeof(data[keys[i]]) === 'object') {
            value = search(data[keys[i]]);
          }

          if (value) {
            return value;
          }
        }
      }
    };

    return search(data);
  },

  /**
   * Interpolate a string and add data replacements.
   *
   * @param string
   * @param data
   * @returns {XML|string|*|void}
   */
  interpolate: function interpolate(string, data) {
    return string.replace(/\{\{\s*([^\s]*)\s*\}\}/g, function (match, token) {
      return _get(data, token);
    });
  }
};

},{"json-logic-js":69,"lodash/get":229}],50:[function(require,module,exports){
/*! choices.js v2.8.12 | (c) 2017 Josh Johnson | https://github.com/jshjohnson/Choices#readme */ 
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.Choices=t():e.Choices=t()}(this,function(){return function(e){function t(n){if(i[n])return i[n].exports;var s=i[n]={exports:{},id:n,loaded:!1};return e[n].call(s.exports,s,s.exports,t),s.loaded=!0,s.exports}var i={};return t.m=e,t.c=i,t.p="/assets/scripts/dist/",t(0)}([function(e,t,i){e.exports=i(1)},function(e,t,i){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function s(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function r(e){if(Array.isArray(e)){for(var t=0,i=Array(e.length);t<e.length;t++)i[t]=e[t];return i}return Array.from(e)}function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}var a=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}(),c=i(2),l=n(c),h=i(3),u=n(h),d=i(4),f=n(d),p=i(30),v=i(31);i(32);var m=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"[data-choice]",i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(o(this,e),(0,v.isType)("String",t)){var n=document.querySelectorAll(t);if(n.length>1)for(var s=1;s<n.length;s++){var r=n[s];new e(r,i)}}var a={silent:!1,items:[],choices:[],renderChoiceLimit:-1,maxItemCount:-1,addItems:!0,removeItems:!0,removeItemButton:!1,editItems:!1,duplicateItems:!0,delimiter:",",paste:!0,searchEnabled:!0,searchChoices:!0,searchFloor:1,searchResultLimit:4,searchFields:["label","value"],position:"auto",resetScrollPosition:!0,regexFilter:null,shouldSort:!0,shouldSortItems:!1,sortFilter:v.sortByAlpha,placeholder:!0,placeholderValue:null,prependValue:null,appendValue:null,renderSelectedChoices:"auto",loadingText:"Loading...",noResultsText:"No results found",noChoicesText:"No choices to choose from",itemSelectText:"Press to select",addItemText:function(e){return'Press Enter to add <b>"'+e+'"</b>'},maxItemText:function(e){return"Only "+e+" values can be added."},uniqueItemText:"Only unique values can be added.",classNames:{containerOuter:"choices",containerInner:"choices__inner",input:"choices__input",inputCloned:"choices__input--cloned",list:"choices__list",listItems:"choices__list--multiple",listSingle:"choices__list--single",listDropdown:"choices__list--dropdown",item:"choices__item",itemSelectable:"choices__item--selectable",itemDisabled:"choices__item--disabled",itemChoice:"choices__item--choice",placeholder:"choices__placeholder",group:"choices__group",groupHeading:"choices__heading",button:"choices__button",activeState:"is-active",focusState:"is-focused",openState:"is-open",disabledState:"is-disabled",highlightedState:"is-highlighted",hiddenState:"is-hidden",flippedState:"is-flipped",loadingState:"is-loading"},fuseOptions:{include:"score"},callbackOnInit:null,callbackOnCreateTemplates:null};if(this.idNames={itemChoice:"item-choice"},this.config=(0,v.extend)(a,i),"auto"!==this.config.renderSelectedChoices&&"always"!==this.config.renderSelectedChoices&&(this.config.silent||console.warn("renderSelectedChoices: Possible values are 'auto' and 'always'. Falling back to 'auto'."),this.config.renderSelectedChoices="auto"),this.store=new f.default(this.render),this.initialised=!1,this.currentState={},this.prevState={},this.currentValue="",this.element=t,this.passedElement=(0,v.isType)("String",t)?document.querySelector(t):t,this.isTextElement="text"===this.passedElement.type,this.isSelectOneElement="select-one"===this.passedElement.type,this.isSelectMultipleElement="select-multiple"===this.passedElement.type,this.isSelectElement=this.isSelectOneElement||this.isSelectMultipleElement,this.isValidElementType=this.isTextElement||this.isSelectElement,this.isIe11=!(!navigator.userAgent.match(/Trident/)||!navigator.userAgent.match(/rv[ :]11/)),this.isScrollingOnIe=!1,!this.passedElement)return void(this.config.silent||console.error("Passed element not found"));this.config.shouldSortItems===!0&&this.isSelectOneElement&&(this.config.silent||console.warn("shouldSortElements: Type of passed element is 'select-one', falling back to false.")),this.highlightPosition=0,this.canSearch=this.config.searchEnabled,this.presetChoices=this.config.choices,this.presetItems=this.config.items,this.passedElement.value&&(this.presetItems=this.presetItems.concat(this.passedElement.value.split(this.config.delimiter))),this.baseId=(0,v.generateId)(this.passedElement,"choices-"),this.render=this.render.bind(this),this._onFocus=this._onFocus.bind(this),this._onBlur=this._onBlur.bind(this),this._onKeyUp=this._onKeyUp.bind(this),this._onKeyDown=this._onKeyDown.bind(this),this._onClick=this._onClick.bind(this),this._onTouchMove=this._onTouchMove.bind(this),this._onTouchEnd=this._onTouchEnd.bind(this),this._onMouseDown=this._onMouseDown.bind(this),this._onMouseOver=this._onMouseOver.bind(this),this._onPaste=this._onPaste.bind(this),this._onInput=this._onInput.bind(this),this.wasTap=!0;var c="classList"in document.documentElement;c||this.config.silent||console.error("Choices: Your browser doesn't support Choices");var l=(0,v.isElement)(this.passedElement)&&this.isValidElementType;if(l){if("active"===this.passedElement.getAttribute("data-choice"))return;this.init()}else this.config.silent||console.error("Incompatible input passed")}return a(e,[{key:"init",value:function(){if(this.initialised!==!0){var e=this.config.callbackOnInit;this.initialised=!0,this._createTemplates(),this._createInput(),this.store.subscribe(this.render),this.render(),this._addEventListeners(),e&&(0,v.isType)("Function",e)&&e.call(this)}}},{key:"destroy",value:function(){if(this.initialised!==!1){this._removeEventListeners(),this.passedElement.classList.remove(this.config.classNames.input,this.config.classNames.hiddenState),this.passedElement.removeAttribute("tabindex");var e=this.passedElement.getAttribute("data-choice-orig-style");Boolean(e)?(this.passedElement.removeAttribute("data-choice-orig-style"),this.passedElement.setAttribute("style",e)):this.passedElement.removeAttribute("style"),this.passedElement.removeAttribute("aria-hidden"),this.passedElement.removeAttribute("data-choice"),this.passedElement.value=this.passedElement.value,this.containerOuter.parentNode.insertBefore(this.passedElement,this.containerOuter),this.containerOuter.parentNode.removeChild(this.containerOuter),this.clearStore(),this.config.templates=null,this.initialised=!1}}},{key:"renderGroups",value:function(e,t,i){var n=this,s=i||document.createDocumentFragment(),r=this.config.sortFilter;return this.config.shouldSort&&e.sort(r),e.forEach(function(e){var i=t.filter(function(t){return n.isSelectOneElement?t.groupId===e.id:t.groupId===e.id&&!t.selected});if(i.length>=1){var r=n._getTemplate("choiceGroup",e);s.appendChild(r),n.renderChoices(i,s,!0)}}),s}},{key:"renderChoices",value:function(e,t){var i=this,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],s=t||document.createDocumentFragment(),r=this.config,o=r.renderSelectedChoices,a=r.searchResultLimit,c=r.renderChoiceLimit,l=this.isSearching?v.sortByScore:this.config.sortFilter,h=function(e){var t="auto"!==o||(i.isSelectOneElement||!e.selected);if(t){var n=i._getTemplate("choice",e);s.appendChild(n)}},u=e;"auto"!==o||this.isSelectOneElement||(u=e.filter(function(e){return!e.selected})),(this.config.shouldSort||this.isSearching)&&u.sort(l);var d=u.length;this.isSearching?d=Math.min(a,u.length-1):c>0&&!n&&(d=Math.min(c,u.length-1));for(var f=0;f<d;f++)h(u[f]);return s}},{key:"renderItems",value:function(e){var t=this,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=i||document.createDocumentFragment();if(this.config.shouldSortItems&&!this.isSelectOneElement&&e.sort(this.config.sortFilter),this.isTextElement){var s=this.store.getItemsReducedToValues(e),r=s.join(this.config.delimiter);this.passedElement.setAttribute("value",r),this.passedElement.value=r}else{var o=document.createDocumentFragment();e.forEach(function(e){var i=t._getTemplate("option",e);o.appendChild(i)}),this.passedElement.innerHTML="",this.passedElement.appendChild(o)}return e.forEach(function(e){var i=t._getTemplate("item",e);n.appendChild(i)}),n}},{key:"render",value:function(){if(this.currentState=this.store.getState(),this.currentState!==this.prevState){if((this.currentState.choices!==this.prevState.choices||this.currentState.groups!==this.prevState.groups||this.currentState.items!==this.prevState.items)&&this.isSelectElement){var e=this.store.getGroupsFilteredByActive(),t=this.store.getChoicesFilteredByActive(),i=document.createDocumentFragment();this.choiceList.innerHTML="",this.config.resetScrollPosition&&(this.choiceList.scrollTop=0),e.length>=1&&this.isSearching!==!0?i=this.renderGroups(e,t,i):t.length>=1&&(i=this.renderChoices(t,i));var n=this.store.getItemsFilteredByActive(),s=this._canAddItem(n,this.input.value);if(i.childNodes&&i.childNodes.length>0)s.response?(this.choiceList.appendChild(i),this._highlightChoice()):this.choiceList.appendChild(this._getTemplate("notice",s.notice));else{var r=void 0,o=void 0;this.isSearching?(o=(0,v.isType)("Function",this.config.noResultsText)?this.config.noResultsText():this.config.noResultsText,r=this._getTemplate("notice",o)):(o=(0,v.isType)("Function",this.config.noChoicesText)?this.config.noChoicesText():this.config.noChoicesText,r=this._getTemplate("notice",o)),this.choiceList.appendChild(r)}}if(this.currentState.items!==this.prevState.items){var a=this.store.getItemsFilteredByActive();if(a){var c=this.renderItems(a);this.itemList.innerHTML="",c.childNodes&&this.itemList.appendChild(c)}}this.prevState=this.currentState}}},{key:"highlightItem",value:function(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(!e)return this;var i=e.id,n=e.groupId,s=n>=0?this.store.getGroupById(n):null;return this.store.dispatch((0,p.highlightItem)(i,!0)),t&&(s&&s.value?(0,v.triggerEvent)(this.passedElement,"highlightItem",{id:i,value:e.value,label:e.label,groupValue:s.value}):(0,v.triggerEvent)(this.passedElement,"highlightItem",{id:i,value:e.value,label:e.label})),this}},{key:"unhighlightItem",value:function(e){if(!e)return this;var t=e.id,i=e.groupId,n=i>=0?this.store.getGroupById(i):null;return this.store.dispatch((0,p.highlightItem)(t,!1)),n&&n.value?(0,v.triggerEvent)(this.passedElement,"unhighlightItem",{id:t,value:e.value,label:e.label,groupValue:n.value}):(0,v.triggerEvent)(this.passedElement,"unhighlightItem",{id:t,value:e.value,label:e.label}),this}},{key:"highlightAll",value:function(){var e=this,t=this.store.getItems();return t.forEach(function(t){e.highlightItem(t)}),this}},{key:"unhighlightAll",value:function(){var e=this,t=this.store.getItems();return t.forEach(function(t){e.unhighlightItem(t)}),this}},{key:"removeItemsByValue",value:function(e){var t=this;if(!e||!(0,v.isType)("String",e))return this;var i=this.store.getItemsFilteredByActive();return i.forEach(function(i){i.value===e&&t._removeItem(i)}),this}},{key:"removeActiveItems",value:function(e){var t=this,i=this.store.getItemsFilteredByActive();return i.forEach(function(i){i.active&&e!==i.id&&t._removeItem(i)}),this}},{key:"removeHighlightedItems",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],i=this.store.getItemsFilteredByActive();return i.forEach(function(i){i.highlighted&&i.active&&(e._removeItem(i),t&&e._triggerChange(i.value))}),this}},{key:"showDropdown",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=document.body,i=document.documentElement,n=Math.max(t.scrollHeight,t.offsetHeight,i.clientHeight,i.scrollHeight,i.offsetHeight);this.containerOuter.classList.add(this.config.classNames.openState),this.containerOuter.setAttribute("aria-expanded","true"),this.dropdown.classList.add(this.config.classNames.activeState),this.dropdown.setAttribute("aria-expanded","true");var s=this.dropdown.getBoundingClientRect(),r=Math.ceil(s.top+window.scrollY+this.dropdown.offsetHeight),o=!1;return"auto"===this.config.position?o=r>=n:"top"===this.config.position&&(o=!0),o&&this.containerOuter.classList.add(this.config.classNames.flippedState),e&&this.canSearch&&document.activeElement!==this.input&&this.input.focus(),(0,v.triggerEvent)(this.passedElement,"showDropdown",{}),this}},{key:"hideDropdown",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=this.containerOuter.classList.contains(this.config.classNames.flippedState);return this.containerOuter.classList.remove(this.config.classNames.openState),this.containerOuter.setAttribute("aria-expanded","false"),this.dropdown.classList.remove(this.config.classNames.activeState),this.dropdown.setAttribute("aria-expanded","false"),t&&this.containerOuter.classList.remove(this.config.classNames.flippedState),e&&this.canSearch&&document.activeElement===this.input&&this.input.blur(),(0,v.triggerEvent)(this.passedElement,"hideDropdown",{}),this}},{key:"toggleDropdown",value:function(){var e=this.dropdown.classList.contains(this.config.classNames.activeState);return e?this.hideDropdown():this.showDropdown(!0),this}},{key:"getValue",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],i=this.store.getItemsFilteredByActive(),n=[];return i.forEach(function(i){e.isTextElement?n.push(t?i.value:i):i.active&&n.push(t?i.value:i)}),this.isSelectOneElement?n[0]:n}},{key:"setValue",value:function(e){var t=this;if(this.initialised===!0){var i=[].concat(r(e)),n=function(e){var i=(0,v.getType)(e);if("Object"===i){if(!e.value)return;t.isTextElement?t._addItem(e.value,e.label,e.id,void 0,e.customProperties,null):t._addChoice(e.value,e.label,!0,!1,-1,e.customProperties,null)}else"String"===i&&(t.isTextElement?t._addItem(e):t._addChoice(e,e,!0,!1,-1,null))};i.length>1?i.forEach(function(e){n(e)}):n(i[0])}return this}},{key:"setValueByChoice",value:function(e){var t=this;if(!this.isTextElement){var i=this.store.getChoices(),n=(0,v.isType)("Array",e)?e:[e];n.forEach(function(e){var n=i.find(function(t){return t.value===e});n?n.selected?t.config.silent||console.warn("Attempting to select choice already selected"):t._addItem(n.value,n.label,n.id,n.groupId,n.customProperties,n.keyCode):t.config.silent||console.warn("Attempting to select choice that does not exist")})}return this}},{key:"setChoices",value:function(e,t,i){var n=this,s=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(this.initialised===!0&&this.isSelectElement){if(!(0,v.isType)("Array",e)||!t)return this;s&&this._clearChoices(),e&&e.length&&(this.containerOuter.classList.remove(this.config.classNames.loadingState),e.forEach(function(e){e.choices?n._addGroup(e,e.id||null,t,i):n._addChoice(e[t],e[i],e.selected,e.disabled,void 0,e.customProperties,null)}))}return this}},{key:"clearStore",value:function(){return this.store.dispatch((0,p.clearAll)()),this}},{key:"clearInput",value:function(){return this.input.value&&(this.input.value=""),this.isSelectOneElement||this._setInputWidth(),!this.isTextElement&&this.config.searchEnabled&&(this.isSearching=!1,this.store.dispatch((0,p.activateChoices)(!0))),this}},{key:"enable",value:function(){this.passedElement.disabled=!1;var e=this.containerOuter.classList.contains(this.config.classNames.disabledState);return this.initialised&&e&&(this._addEventListeners(),this.passedElement.removeAttribute("disabled"),this.input.removeAttribute("disabled"),this.containerOuter.classList.remove(this.config.classNames.disabledState),this.containerOuter.removeAttribute("aria-disabled"),this.isSelectOneElement&&this.containerOuter.setAttribute("tabindex","0")),this}},{key:"disable",value:function(){this.passedElement.disabled=!0;var e=!this.containerOuter.classList.contains(this.config.classNames.disabledState);return this.initialised&&e&&(this._removeEventListeners(),this.passedElement.setAttribute("disabled",""),this.input.setAttribute("disabled",""),this.containerOuter.classList.add(this.config.classNames.disabledState),this.containerOuter.setAttribute("aria-disabled","true"),this.isSelectOneElement&&this.containerOuter.setAttribute("tabindex","-1")),this}},{key:"ajax",value:function(e){var t=this;return this.initialised===!0&&this.isSelectElement&&(requestAnimationFrame(function(){t._handleLoadingState(!0)}),e(this._ajaxCallback())),this}},{key:"_triggerChange",value:function(e){e&&(0,v.triggerEvent)(this.passedElement,"change",{value:e})}},{key:"_handleButtonAction",value:function(e,t){if(e&&t&&this.config.removeItems&&this.config.removeItemButton){var i=t.parentNode.getAttribute("data-id"),n=e.find(function(e){return e.id===parseInt(i,10)});if(this._removeItem(n),this._triggerChange(n.value),this.isSelectOneElement){var s=!!this.config.placeholder&&(this.config.placeholderValue||this.passedElement.getAttribute("placeholder"));if(s){var r=this._getTemplate("placeholder",s);this.itemList.appendChild(r)}}}}},{key:"_handleItemAction",value:function(e,t){var i=this,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(e&&t&&this.config.removeItems&&!this.isSelectOneElement){var s=t.getAttribute("data-id");e.forEach(function(e){e.id!==parseInt(s,10)||e.highlighted?n||e.highlighted&&i.unhighlightItem(e):i.highlightItem(e)}),document.activeElement!==this.input&&this.input.focus()}}},{key:"_handleChoiceAction",value:function(e,t){if(e&&t){var i=t.getAttribute("data-id"),n=this.store.getChoiceById(i),s=e[0]&&e[0].keyCode?e[0].keyCode:null,r=this.dropdown.classList.contains(this.config.classNames.activeState);if(n.keyCode=s,(0,v.triggerEvent)(this.passedElement,"choice",{choice:n}),n&&!n.selected&&!n.disabled){var o=this._canAddItem(e,n.value);o.response&&(this._addItem(n.value,n.label,n.id,n.groupId,n.customProperties,n.keyCode),this._triggerChange(n.value))}this.clearInput(),r&&this.isSelectOneElement&&(this.hideDropdown(),this.containerOuter.focus())}}},{key:"_handleBackspace",value:function(e){if(this.config.removeItems&&e){var t=e[e.length-1],i=e.some(function(e){return e.highlighted});this.config.editItems&&!i&&t?(this.input.value=t.value,this._setInputWidth(),this._removeItem(t),this._triggerChange(t.value)):(i||this.highlightItem(t,!1),this.removeHighlightedItems(!0))}}},{key:"_canAddItem",value:function(e,t){var i=!0,n=(0,v.isType)("Function",this.config.addItemText)?this.config.addItemText(t):this.config.addItemText;(this.isSelectMultipleElement||this.isTextElement)&&this.config.maxItemCount>0&&this.config.maxItemCount<=e.length&&(i=!1,n=(0,v.isType)("Function",this.config.maxItemText)?this.config.maxItemText(this.config.maxItemCount):this.config.maxItemText),this.isTextElement&&this.config.addItems&&i&&this.config.regexFilter&&(i=this._regexFilter(t));var s=!e.some(function(e){return(0,v.isType)("String",t)?e.value===t.trim():e.value===t});return s||this.config.duplicateItems||this.isSelectOneElement||!i||(i=!1,n=(0,v.isType)("Function",this.config.uniqueItemText)?this.config.uniqueItemText(t):this.config.uniqueItemText),{response:i,notice:n}}},{key:"_handleLoadingState",value:function(){var e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=this.itemList.querySelector("."+this.config.classNames.placeholder);if(e)this.containerOuter.classList.add(this.config.classNames.loadingState),this.containerOuter.setAttribute("aria-busy","true"),this.isSelectOneElement?t?t.innerHTML=this.config.loadingText:(t=this._getTemplate("placeholder",this.config.loadingText),this.itemList.appendChild(t)):this.input.placeholder=this.config.loadingText;else{this.containerOuter.classList.remove(this.config.classNames.loadingState);var i=!!this.config.placeholder&&(this.config.placeholderValue||this.passedElement.getAttribute("placeholder"));this.isSelectOneElement?t.innerHTML=i||"":this.input.placeholder=i||""}}},{key:"_ajaxCallback",value:function(){var e=this;return function(t,i,n){if(t&&i){var s=(0,v.isType)("Object",t)?[t]:t;s&&(0,v.isType)("Array",s)&&s.length?(e._handleLoadingState(!1),s.forEach(function(t){if(t.choices){var s=t.id||null;e._addGroup(t,s,i,n)}else e._addChoice(t[i],t[n],t.selected,t.disabled,void 0,t.customProperties,null)})):e._handleLoadingState(!1),e.containerOuter.removeAttribute("aria-busy")}}}},{key:"_searchChoices",value:function(e){var t=(0,v.isType)("String",e)?e.trim():e,i=(0,v.isType)("String",this.currentValue)?this.currentValue.trim():this.currentValue;if(t.length>=1&&t!==i+" "){var n=this.store.getChoicesFilteredBySelectable(),s=t,r=(0,v.isType)("Array",this.config.searchFields)?this.config.searchFields:[this.config.searchFields],o=Object.assign(this.config.fuseOptions,{keys:r}),a=new l.default(n,o),c=a.search(s);return this.currentValue=t,this.highlightPosition=0,this.isSearching=!0,this.store.dispatch((0,p.filterChoices)(c)),c.length}return 0}},{key:"_handleSearch",value:function(e){if(e){var t=this.store.getChoices(),i=t.some(function(e){return!e.active});if(this.input===document.activeElement)if(e&&e.length>=this.config.searchFloor){var n=0;this.config.searchChoices&&(n=this._searchChoices(e)),(0,v.triggerEvent)(this.passedElement,"search",{value:e,resultCount:n})}else i&&(this.isSearching=!1,this.store.dispatch((0,p.activateChoices)(!0)))}}},{key:"_addEventListeners",value:function(){document.addEventListener("keyup",this._onKeyUp),document.addEventListener("keydown",this._onKeyDown),document.addEventListener("click",this._onClick),document.addEventListener("touchmove",this._onTouchMove),document.addEventListener("touchend",this._onTouchEnd),document.addEventListener("mousedown",this._onMouseDown),document.addEventListener("mouseover",this._onMouseOver),this.isSelectOneElement&&(this.containerOuter.addEventListener("focus",this._onFocus),this.containerOuter.addEventListener("blur",this._onBlur)),this.input.addEventListener("input",this._onInput),this.input.addEventListener("paste",this._onPaste),this.input.addEventListener("focus",this._onFocus),this.input.addEventListener("blur",this._onBlur)}},{key:"_removeEventListeners",value:function(){document.removeEventListener("keyup",this._onKeyUp),document.removeEventListener("keydown",this._onKeyDown),document.removeEventListener("click",this._onClick),document.removeEventListener("touchmove",this._onTouchMove),document.removeEventListener("touchend",this._onTouchEnd),document.removeEventListener("mousedown",this._onMouseDown),document.removeEventListener("mouseover",this._onMouseOver),this.isSelectOneElement&&(this.containerOuter.removeEventListener("focus",this._onFocus),this.containerOuter.removeEventListener("blur",this._onBlur)),this.input.removeEventListener("input",this._onInput),this.input.removeEventListener("paste",this._onPaste),this.input.removeEventListener("focus",this._onFocus),this.input.removeEventListener("blur",this._onBlur)}},{key:"_setInputWidth",value:function(){if(this.config.placeholderValue||this.passedElement.getAttribute("placeholder")&&this.config.placeholder){var e=!!this.config.placeholder&&(this.config.placeholderValue||this.passedElement.getAttribute("placeholder"));this.input.value&&this.input.value.length>=e.length/1.25&&(this.input.style.width=(0,v.getWidthOfInput)(this.input))}else this.input.style.width=(0,v.getWidthOfInput)(this.input)}},{key:"_onKeyDown",value:function(e){var t,i=this;if(e.target===this.input||this.containerOuter.contains(e.target)){var n=e.target,r=this.store.getItemsFilteredByActive(),o=this.input===document.activeElement,a=this.dropdown.classList.contains(this.config.classNames.activeState),c=this.itemList&&this.itemList.children,l=String.fromCharCode(e.keyCode),h=46,u=8,d=13,f=65,p=27,m=38,g=40,y=33,b=34,E=e.ctrlKey||e.metaKey;this.isTextElement||!/[a-zA-Z0-9-_ ]/.test(l)||a||this.showDropdown(!0),this.canSearch=this.config.searchEnabled;var _=function(){E&&c&&(i.canSearch=!1,i.config.removeItems&&!i.input.value&&i.input===document.activeElement&&i.highlightAll())},S=function(){if(i.isTextElement&&n.value){var t=i.input.value,s=i._canAddItem(r,t);s.response&&(a&&i.hideDropdown(),i._addItem(t),i._triggerChange(t),i.clearInput())}if(n.hasAttribute("data-button")&&(i._handleButtonAction(r,n),e.preventDefault()),a){e.preventDefault();var o=i.dropdown.querySelector("."+i.config.classNames.highlightedState);o&&(r[0]&&(r[0].keyCode=d),i._handleChoiceAction(r,o))}else i.isSelectOneElement&&(a||(i.showDropdown(!0),e.preventDefault()))},I=function(){a&&(i.toggleDropdown(),i.containerOuter.focus())},w=function(){if(a||i.isSelectOneElement){a||i.showDropdown(!0),i.canSearch=!1;var t=e.keyCode===g||e.keyCode===b?1:-1,n=e.metaKey||e.keyCode===b||e.keyCode===y,s=void 0;if(n)s=t>0?Array.from(i.dropdown.querySelectorAll("[data-choice-selectable]")).pop():i.dropdown.querySelector("[data-choice-selectable]");else{var r=i.dropdown.querySelector("."+i.config.classNames.highlightedState);s=r?(0,v.getAdjacentEl)(r,"[data-choice-selectable]",t):i.dropdown.querySelector("[data-choice-selectable]")}s&&((0,v.isScrolledIntoView)(s,i.choiceList,t)||i._scrollToChoice(s,t),i._highlightChoice(s)),e.preventDefault()}},T=function(){!o||e.target.value||i.isSelectOneElement||(i._handleBackspace(r),e.preventDefault())},A=(t={},s(t,f,_),s(t,d,S),s(t,p,I),s(t,m,w),s(t,y,w),s(t,g,w),s(t,b,w),s(t,u,T),s(t,h,T),t);A[e.keyCode]&&A[e.keyCode]()}}},{key:"_onKeyUp",value:function(e){if(e.target===this.input){var t=this.input.value,i=this.store.getItemsFilteredByActive(),n=this._canAddItem(i,t);if(this.isTextElement){var s=this.dropdown.classList.contains(this.config.classNames.activeState);if(t){if(n.notice){var r=this._getTemplate("notice",n.notice);this.dropdown.innerHTML=r.outerHTML}n.response===!0?s||this.showDropdown():!n.notice&&s&&this.hideDropdown()}else s&&this.hideDropdown()}else{var o=46,a=8;e.keyCode!==o&&e.keyCode!==a||e.target.value?this.canSearch&&n.response&&this._handleSearch(this.input.value):!this.isTextElement&&this.isSearching&&(this.isSearching=!1,this.store.dispatch((0,p.activateChoices)(!0)))}this.canSearch=this.config.searchEnabled}}},{key:"_onInput",value:function(){this.isSelectOneElement||this._setInputWidth()}},{key:"_onTouchMove",value:function(){this.wasTap===!0&&(this.wasTap=!1)}},{key:"_onTouchEnd",value:function(e){var t=e.target||e.touches[0].target,i=this.dropdown.classList.contains(this.config.classNames.activeState);this.wasTap===!0&&this.containerOuter.contains(t)&&(t!==this.containerOuter&&t!==this.containerInner||this.isSelectOneElement||(this.isTextElement?document.activeElement!==this.input&&this.input.focus():i||this.showDropdown(!0)),e.stopPropagation()),this.wasTap=!0}},{key:"_onMouseDown",value:function(e){var t=e.target;if(t===this.choiceList&&this.isIe11&&(this.isScrollingOnIe=!0),this.containerOuter.contains(t)&&t!==this.input){var i=void 0,n=this.store.getItemsFilteredByActive(),s=e.shiftKey;(i=(0,v.findAncestorByAttrName)(t,"data-button"))?this._handleButtonAction(n,i):(i=(0,v.findAncestorByAttrName)(t,"data-item"))?this._handleItemAction(n,i,s):(i=(0,v.findAncestorByAttrName)(t,"data-choice"))&&this._handleChoiceAction(n,i),e.preventDefault()}}},{key:"_onClick",value:function(e){var t=e.target,i=this.dropdown.classList.contains(this.config.classNames.activeState),n=this.store.getItemsFilteredByActive();if(this.containerOuter.contains(t))t.hasAttribute("data-button")&&this._handleButtonAction(n,t),i?this.isSelectOneElement&&t!==this.input&&!this.dropdown.contains(t)&&this.hideDropdown(!0):this.isTextElement?document.activeElement!==this.input&&this.input.focus():this.canSearch?this.showDropdown(!0):(this.showDropdown(),this.containerOuter.focus());else{var s=n.some(function(e){return e.highlighted});s&&this.unhighlightAll(),this.containerOuter.classList.remove(this.config.classNames.focusState),i&&this.hideDropdown()}}},{key:"_onMouseOver",value:function(e){(e.target===this.dropdown||this.dropdown.contains(e.target))&&e.target.hasAttribute("data-choice")&&this._highlightChoice(e.target)}},{key:"_onPaste",value:function(e){e.target!==this.input||this.config.paste||e.preventDefault()}},{key:"_onFocus",value:function(e){var t=this,i=e.target;if(this.containerOuter.contains(i)){var n=this.dropdown.classList.contains(this.config.classNames.activeState),s={text:function(){i===t.input&&t.containerOuter.classList.add(t.config.classNames.focusState)},"select-one":function(){t.containerOuter.classList.add(t.config.classNames.focusState),i===t.input&&(n||t.showDropdown())},"select-multiple":function(){i===t.input&&(t.containerOuter.classList.add(t.config.classNames.focusState),n||t.showDropdown(!0))}};s[this.passedElement.type]()}}},{key:"_onBlur",value:function(e){var t=this,i=e.target;if(this.containerOuter.contains(i)&&!this.isScrollingOnIe){var n=this.store.getItemsFilteredByActive(),s=this.dropdown.classList.contains(this.config.classNames.activeState),r=n.some(function(e){return e.highlighted}),o={text:function(){i===t.input&&(t.containerOuter.classList.remove(t.config.classNames.focusState),r&&t.unhighlightAll(),s&&t.hideDropdown())},"select-one":function(){t.containerOuter.classList.remove(t.config.classNames.focusState),i===t.containerOuter&&s&&!t.canSearch&&t.hideDropdown(),i===t.input&&s&&t.hideDropdown()},"select-multiple":function(){i===t.input&&(t.containerOuter.classList.remove(t.config.classNames.focusState),s&&t.hideDropdown(),r&&t.unhighlightAll())}};o[this.passedElement.type]()}else this.isScrollingOnIe=!1,this.input.focus()}},{key:"_regexFilter",value:function(e){if(!e)return!1;var t=this.config.regexFilter,i=new RegExp(t.source,"i");return i.test(e)}},{key:"_scrollToChoice",value:function(e,t){var i=this;if(e){var n=this.choiceList.offsetHeight,s=e.offsetHeight,r=e.offsetTop+s,o=this.choiceList.scrollTop+n,a=t>0?this.choiceList.scrollTop+r-o:e.offsetTop,c=function e(){var n=4,s=i.choiceList.scrollTop,r=!1,o=void 0,c=void 0;t>0?(o=(a-s)/n,c=o>1?o:1,i.choiceList.scrollTop=s+c,s<a&&(r=!0)):(o=(s-a)/n,c=o>1?o:1,i.choiceList.scrollTop=s-c,s>a&&(r=!0)),r&&requestAnimationFrame(function(i){e(i,a,t)})};requestAnimationFrame(function(e){c(e,a,t)})}}},{key:"_highlightChoice",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,i=Array.from(this.dropdown.querySelectorAll("[data-choice-selectable]")),n=t;if(i&&i.length){var s=Array.from(this.dropdown.querySelectorAll("."+this.config.classNames.highlightedState));s.forEach(function(t){t.classList.remove(e.config.classNames.highlightedState),t.setAttribute("aria-selected","false")}),n?this.highlightPosition=i.indexOf(n):(n=i.length>this.highlightPosition?i[this.highlightPosition]:i[i.length-1],n||(n=i[0])),n.classList.add(this.config.classNames.highlightedState),n.setAttribute("aria-selected","true"),this.containerOuter.setAttribute("aria-activedescendant",n.id),this.input.setAttribute("aria-activedescendant",n.id)}}},{key:"_addItem",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,o=(0,v.isType)("String",e)?e.trim():e,a=r,c=this.store.getItems(),l=t||o,h=parseInt(i,10)||-1,u=n>=0?this.store.getGroupById(n):null,d=c?c.length+1:1;return this.config.prependValue&&(o=this.config.prependValue+o.toString()),this.config.appendValue&&(o+=this.config.appendValue.toString()),this.store.dispatch((0,p.addItem)(o,l,d,h,n,s,a)),this.isSelectOneElement&&this.removeActiveItems(d),u&&u.value?(0,v.triggerEvent)(this.passedElement,"addItem",{id:d,value:o,label:l,groupValue:u.value,keyCode:a}):(0,v.triggerEvent)(this.passedElement,"addItem",{id:d,value:o,label:l,keyCode:a}),this}},{key:"_removeItem",value:function(e){if(!e||!(0,v.isType)("Object",e))return this;var t=e.id,i=e.value,n=e.label,s=e.choiceId,r=e.groupId,o=r>=0?this.store.getGroupById(r):null;
return this.store.dispatch((0,p.removeItem)(t,s)),o&&o.value?(0,v.triggerEvent)(this.passedElement,"removeItem",{id:t,value:i,label:n,groupValue:o.value}):(0,v.triggerEvent)(this.passedElement,"removeItem",{id:t,value:i,label:n}),this}},{key:"_addChoice",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:-1,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;if("undefined"!=typeof e&&null!==e){var a=this.store.getChoices(),c=t||e,l=a?a.length+1:1,h=this.baseId+"-"+this.idNames.itemChoice+"-"+l;this.store.dispatch((0,p.addChoice)(e,c,l,s,n,h,r,o)),i&&this._addItem(e,c,l,void 0,r,o)}}},{key:"_clearChoices",value:function(){this.store.dispatch((0,p.clearChoices)())}},{key:"_addGroup",value:function(e,t){var i=this,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"value",s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"label",r=(0,v.isType)("Object",e)?e.choices:Array.from(e.getElementsByTagName("OPTION")),o=t?t:Math.floor((new Date).valueOf()*Math.random()),a=!!e.disabled&&e.disabled;r?(this.store.dispatch((0,p.addGroup)(e.label,o,!0,a)),r.forEach(function(e){var t=e.disabled||e.parentNode&&e.parentNode.disabled,r=(0,v.isType)("Object",e)?e[s]:e.innerHTML;i._addChoice(e[n],r,e.selected,t,o,e.customProperties)})):this.store.dispatch((0,p.addGroup)(e.label,e.id,!1,e.disabled))}},{key:"_getTemplate",value:function(e){if(!e)return null;for(var t=this.config.templates,i=arguments.length,n=Array(i>1?i-1:0),s=1;s<i;s++)n[s-1]=arguments[s];return t[e].apply(t,n)}},{key:"_createTemplates",value:function(){var e=this,t=this.config.classNames,i={containerOuter:function(i){return(0,v.strToEl)('\n          <div\n            class="'+t.containerOuter+'"\n            '+(e.isSelectElement?e.config.searchEnabled?'role="combobox" aria-autocomplete="list"':'role="listbox"':"")+'\n            data-type="'+e.passedElement.type+'"\n            '+(e.isSelectOneElement?'tabindex="0"':"")+'\n            aria-haspopup="true"\n            aria-expanded="false"\n            dir="'+i+'"\n            >\n          </div>\n        ')},containerInner:function(){return(0,v.strToEl)('\n          <div class="'+t.containerInner+'"></div>\n        ')},itemList:function(){var i,n=(0,u.default)(t.list,(i={},s(i,t.listSingle,e.isSelectOneElement),s(i,t.listItems,!e.isSelectOneElement),i));return(0,v.strToEl)('\n          <div class="'+n+'"></div>\n        ')},placeholder:function(e){return(0,v.strToEl)('\n          <div class="'+t.placeholder+'">\n            '+e+"\n          </div>\n        ")},item:function(i){var n,r=(0,u.default)(t.item,(n={},s(n,t.highlightedState,i.highlighted),s(n,t.itemSelectable,!i.highlighted),n));if(e.config.removeItemButton){var o;return r=(0,u.default)(t.item,(o={},s(o,t.highlightedState,i.highlighted),s(o,t.itemSelectable,!i.disabled),o)),(0,v.strToEl)('\n            <div\n              class="'+r+'"\n              data-item\n              data-id="'+i.id+'"\n              data-value="'+i.value+'"\n              data-deletable\n              '+(i.active?'aria-selected="true"':"")+"\n              "+(i.disabled?'aria-disabled="true"':"")+"\n              >\n              "+i.label+'<!--\n           --><button\n                type="button"\n                class="'+t.button+'"\n                data-button\n                aria-label="Remove item: \''+i.value+"'\"\n                >\n                Remove item\n              </button>\n            </div>\n          ")}return(0,v.strToEl)('\n          <div\n            class="'+r+'"\n            data-item\n            data-id="'+i.id+'"\n            data-value="'+i.value+'"\n            '+(i.active?'aria-selected="true"':"")+"\n            "+(i.disabled?'aria-disabled="true"':"")+"\n            >\n            "+i.label+"\n          </div>\n        ")},choiceList:function(){return(0,v.strToEl)('\n          <div\n            class="'+t.list+'"\n            dir="ltr"\n            role="listbox"\n            '+(e.isSelectOneElement?"":'aria-multiselectable="true"')+"\n            >\n          </div>\n        ")},choiceGroup:function(e){var i=(0,u.default)(t.group,s({},t.itemDisabled,e.disabled));return(0,v.strToEl)('\n          <div\n            class="'+i+'"\n            data-group\n            data-id="'+e.id+'"\n            data-value="'+e.value+'"\n            role="group"\n            '+(e.disabled?'aria-disabled="true"':"")+'\n            >\n            <div class="'+t.groupHeading+'">'+e.value+"</div>\n          </div>\n        ")},choice:function(i){var n,r=(0,u.default)(t.item,t.itemChoice,(n={},s(n,t.itemDisabled,i.disabled),s(n,t.itemSelectable,!i.disabled),n));return(0,v.strToEl)('\n          <div\n            class="'+r+'"\n            data-select-text="'+e.config.itemSelectText+'"\n            data-choice\n            data-id="'+i.id+'"\n            data-value="'+i.value+'"\n            '+(i.disabled?'data-choice-disabled aria-disabled="true"':"data-choice-selectable")+'\n            id="'+i.elementId+'"\n            '+(i.groupId>0?'role="treeitem"':'role="option"')+"\n            >\n            "+i.label+"\n          </div>\n        ")},input:function(){var e=(0,u.default)(t.input,t.inputCloned);return(0,v.strToEl)('\n          <input\n            type="text"\n            class="'+e+'"\n            autocomplete="off"\n            autocapitalize="off"\n            spellcheck="false"\n            role="textbox"\n            aria-autocomplete="list"\n            >\n        ')},dropdown:function(){var e=(0,u.default)(t.list,t.listDropdown);return(0,v.strToEl)('\n          <div\n            class="'+e+'"\n            aria-expanded="false"\n            >\n          </div>\n        ')},notice:function(e){var i=(0,u.default)(t.item,t.itemChoice);return(0,v.strToEl)('\n          <div class="'+i+'">\n            '+e+"\n          </div>\n        ")},option:function(e){return(0,v.strToEl)('\n          <option value="'+e.value+'" selected>'+e.label+"</option>\n        ")}},n=this.config.callbackOnCreateTemplates,r={};n&&(0,v.isType)("Function",n)&&(r=n.call(this,v.strToEl)),this.config.templates=(0,v.extend)(i,r)}},{key:"_createInput",value:function(){var e=this,t=this.passedElement.getAttribute("dir")||"ltr",i=this._getTemplate("containerOuter",t),n=this._getTemplate("containerInner"),s=this._getTemplate("itemList"),r=this._getTemplate("choiceList"),o=this._getTemplate("input"),a=this._getTemplate("dropdown"),c=!!this.config.placeholder&&(this.config.placeholderValue||this.passedElement.getAttribute("placeholder"));this.containerOuter=i,this.containerInner=n,this.input=o,this.choiceList=r,this.itemList=s,this.dropdown=a,this.passedElement.classList.add(this.config.classNames.input,this.config.classNames.hiddenState),this.passedElement.tabIndex="-1";var l=this.passedElement.getAttribute("style");if(Boolean(l)&&this.passedElement.setAttribute("data-choice-orig-style",l),this.passedElement.setAttribute("style","display:none;"),this.passedElement.setAttribute("aria-hidden","true"),this.passedElement.setAttribute("data-choice","active"),(0,v.wrap)(this.passedElement,n),(0,v.wrap)(n,i),c&&(o.placeholder=c,this.isSelectOneElement||(o.style.width=(0,v.getWidthOfInput)(o))),this.config.addItems||this.disable(),i.appendChild(n),i.appendChild(a),n.appendChild(s),this.isTextElement||a.appendChild(r),this.isSelectMultipleElement||this.isTextElement?n.appendChild(o):this.canSearch&&a.insertBefore(o,a.firstChild),this.isSelectElement){var h=Array.from(this.passedElement.getElementsByTagName("OPTGROUP"));if(this.highlightPosition=0,this.isSearching=!1,h&&h.length)h.forEach(function(t){e._addGroup(t,t.id||null)});else{var u=Array.from(this.passedElement.options),d=this.config.sortFilter,f=this.presetChoices;u.forEach(function(e){f.push({value:e.value,label:e.innerHTML,selected:e.selected,disabled:e.disabled||e.parentNode.disabled})}),this.config.shouldSort&&f.sort(d);var p=f.some(function(e){return e.selected});f.forEach(function(t,i){e.isSelectOneElement?p||!p&&i>0?e._addChoice(t.value,t.label,t.selected,t.disabled,void 0,t.customProperties):e._addChoice(t.value,t.label,!0,!1,void 0,t.customProperties):e._addChoice(t.value,t.label,t.selected,t.disabled,void 0,t.customProperties)})}}else this.isTextElement&&this.presetItems.forEach(function(t){var i=(0,v.getType)(t);if("Object"===i){if(!t.value)return;e._addItem(t.value,t.label,t.id,void 0,t.customProperties)}else"String"===i&&e._addItem(t)})}}]),e}();e.exports=m},function(e,t,i){!function(t){"use strict";function i(){console.log.apply(console,arguments)}function n(e,t){var i;this.list=e,this.options=t=t||{};for(i in a)a.hasOwnProperty(i)&&("boolean"==typeof a[i]?this.options[i]=i in t?t[i]:a[i]:this.options[i]=t[i]||a[i])}function s(e,t,i){var n,o,a,c,l,h;if(t){if(a=t.indexOf("."),a!==-1?(n=t.slice(0,a),o=t.slice(a+1)):n=t,c=e[n],null!==c&&void 0!==c)if(o||"string"!=typeof c&&"number"!=typeof c)if(r(c))for(l=0,h=c.length;l<h;l++)s(c[l],o,i);else o&&s(c,o,i);else i.push(c)}else i.push(e);return i}function r(e){return"[object Array]"===Object.prototype.toString.call(e)}function o(e,t){t=t||{},this.options=t,this.options.location=t.location||o.defaultOptions.location,this.options.distance="distance"in t?t.distance:o.defaultOptions.distance,this.options.threshold="threshold"in t?t.threshold:o.defaultOptions.threshold,this.options.maxPatternLength=t.maxPatternLength||o.defaultOptions.maxPatternLength,this.pattern=t.caseSensitive?e:e.toLowerCase(),this.patternLen=e.length,this.patternLen<=this.options.maxPatternLength&&(this.matchmask=1<<this.patternLen-1,this.patternAlphabet=this._calculatePatternAlphabet())}var a={id:null,caseSensitive:!1,include:[],shouldSort:!0,searchFn:o,sortFn:function(e,t){return e.score-t.score},getFn:s,keys:[],verbose:!1,tokenize:!1,matchAllTokens:!1,tokenSeparator:/ +/g,minMatchCharLength:1,findAllMatches:!1};n.VERSION="2.7.3",n.prototype.set=function(e){return this.list=e,e},n.prototype.search=function(e){this.options.verbose&&i("\nSearch term:",e,"\n"),this.pattern=e,this.results=[],this.resultMap={},this._keyMap=null,this._prepareSearchers(),this._startSearch(),this._computeScore(),this._sort();var t=this._format();return t},n.prototype._prepareSearchers=function(){var e=this.options,t=this.pattern,i=e.searchFn,n=t.split(e.tokenSeparator),s=0,r=n.length;if(this.options.tokenize)for(this.tokenSearchers=[];s<r;s++)this.tokenSearchers.push(new i(n[s],e));this.fullSeacher=new i(t,e)},n.prototype._startSearch=function(){var e,t,i,n,s=this.options,r=s.getFn,o=this.list,a=o.length,c=this.options.keys,l=c.length,h=null;if("string"==typeof o[0])for(i=0;i<a;i++)this._analyze("",o[i],i,i);else for(this._keyMap={},i=0;i<a;i++)for(h=o[i],n=0;n<l;n++){if(e=c[n],"string"!=typeof e){if(t=1-e.weight||1,this._keyMap[e.name]={weight:t},e.weight<=0||e.weight>1)throw new Error("Key weight has to be > 0 and <= 1");e=e.name}else this._keyMap[e]={weight:1};this._analyze(e,r(h,e,[]),h,i)}},n.prototype._analyze=function(e,t,n,s){var o,a,c,l,h,u,d,f,p,v,m,g,y,b,E,_=this.options,S=!1;if(void 0!==t&&null!==t){a=[];var I=0;if("string"==typeof t){if(o=t.split(_.tokenSeparator),_.verbose&&i("---------\nKey:",e),this.options.tokenize){for(b=0;b<this.tokenSearchers.length;b++){for(f=this.tokenSearchers[b],_.verbose&&i("Pattern:",f.pattern),p=[],g=!1,E=0;E<o.length;E++){v=o[E],m=f.search(v);var w={};m.isMatch?(w[v]=m.score,S=!0,g=!0,a.push(m.score)):(w[v]=1,this.options.matchAllTokens||a.push(1)),p.push(w)}g&&I++,_.verbose&&i("Token scores:",p)}for(l=a[0],u=a.length,b=1;b<u;b++)l+=a[b];l/=u,_.verbose&&i("Token score average:",l)}d=this.fullSeacher.search(t),_.verbose&&i("Full text score:",d.score),h=d.score,void 0!==l&&(h=(h+l)/2),_.verbose&&i("Score average:",h),y=!this.options.tokenize||!this.options.matchAllTokens||I>=this.tokenSearchers.length,_.verbose&&i("Check Matches",y),(S||d.isMatch)&&y&&(c=this.resultMap[s],c?c.output.push({key:e,score:h,matchedIndices:d.matchedIndices}):(this.resultMap[s]={item:n,output:[{key:e,score:h,matchedIndices:d.matchedIndices}]},this.results.push(this.resultMap[s])))}else if(r(t))for(b=0;b<t.length;b++)this._analyze(e,t[b],n,s)}},n.prototype._computeScore=function(){var e,t,n,s,r,o,a,c,l,h=this._keyMap,u=this.results;for(this.options.verbose&&i("\n\nComputing score:\n"),e=0;e<u.length;e++){for(n=0,s=u[e].output,r=s.length,c=1,t=0;t<r;t++)o=s[t].score,a=h?h[s[t].key].weight:1,l=o*a,1!==a?c=Math.min(c,l):(n+=l,s[t].nScore=l);1===c?u[e].score=n/r:u[e].score=c,this.options.verbose&&i(u[e])}},n.prototype._sort=function(){var e=this.options;e.shouldSort&&(e.verbose&&i("\n\nSorting...."),this.results.sort(e.sortFn))},n.prototype._format=function(){var e,t,n,s,r=this.options,o=r.getFn,a=[],c=this.results,l=r.include;for(r.verbose&&i("\n\nOutput:\n\n",c),n=r.id?function(e){c[e].item=o(c[e].item,r.id,[])[0]}:function(){},s=function(e){var t,i,n,s,r,o=c[e];if(l.length>0){if(t={item:o.item},l.indexOf("matches")!==-1)for(n=o.output,t.matches=[],i=0;i<n.length;i++)s=n[i],r={indices:s.matchedIndices},s.key&&(r.key=s.key),t.matches.push(r);l.indexOf("score")!==-1&&(t.score=c[e].score)}else t=o.item;return t},e=0,t=c.length;e<t;e++)n(e),a.push(s(e));return a},o.defaultOptions={location:0,distance:100,threshold:.6,maxPatternLength:32},o.prototype._calculatePatternAlphabet=function(){var e={},t=0;for(t=0;t<this.patternLen;t++)e[this.pattern.charAt(t)]=0;for(t=0;t<this.patternLen;t++)e[this.pattern.charAt(t)]|=1<<this.pattern.length-t-1;return e},o.prototype._bitapScore=function(e,t){var i=e/this.patternLen,n=Math.abs(this.options.location-t);return this.options.distance?i+n/this.options.distance:n?1:i},o.prototype.search=function(e){var t,i,n,s,r,o,a,c,l,h,u,d,f,p,v,m,g,y,b,E,_,S,I,w=this.options;if(e=w.caseSensitive?e:e.toLowerCase(),this.pattern===e)return{isMatch:!0,score:0,matchedIndices:[[0,e.length-1]]};if(this.patternLen>w.maxPatternLength){if(y=e.match(new RegExp(this.pattern.replace(w.tokenSeparator,"|"))),b=!!y)for(_=[],t=0,S=y.length;t<S;t++)I=y[t],_.push([e.indexOf(I),I.length-1]);return{isMatch:b,score:b?.5:1,matchedIndices:_}}for(s=w.findAllMatches,r=w.location,n=e.length,o=w.threshold,a=e.indexOf(this.pattern,r),E=[],t=0;t<n;t++)E[t]=0;for(a!=-1&&(o=Math.min(this._bitapScore(0,a),o),a=e.lastIndexOf(this.pattern,r+this.patternLen),a!=-1&&(o=Math.min(this._bitapScore(0,a),o))),a=-1,m=1,g=[],h=this.patternLen+n,t=0;t<this.patternLen;t++){for(c=0,l=h;c<l;)this._bitapScore(t,r+l)<=o?c=l:h=l,l=Math.floor((h-c)/2+c);for(h=l,u=Math.max(1,r-l+1),d=s?n:Math.min(r+l,n)+this.patternLen,f=Array(d+2),f[d+1]=(1<<t)-1,i=d;i>=u;i--)if(v=this.patternAlphabet[e.charAt(i-1)],v&&(E[i-1]=1),f[i]=(f[i+1]<<1|1)&v,0!==t&&(f[i]|=(p[i+1]|p[i])<<1|1|p[i+1]),f[i]&this.matchmask&&(m=this._bitapScore(t,i-1),m<=o)){if(o=m,a=i-1,g.push(a),a<=r)break;u=Math.max(1,2*r-a)}if(this._bitapScore(t+1,r)>o)break;p=f}return _=this._getMatchedIndices(E),{isMatch:a>=0,score:0===m?.001:m,matchedIndices:_}},o.prototype._getMatchedIndices=function(e){for(var t,i=[],n=-1,s=-1,r=0,o=e.length;r<o;r++)t=e[r],t&&n===-1?n=r:t||n===-1||(s=r-1,s-n+1>=this.options.minMatchCharLength&&i.push([n,s]),n=-1);return e[r-1]&&r-1-n+1>=this.options.minMatchCharLength&&i.push([n,r-1]),i},e.exports=n}(this)},function(e,t,i){var n,s;!function(){"use strict";function i(){for(var e=[],t=0;t<arguments.length;t++){var n=arguments[t];if(n){var s=typeof n;if("string"===s||"number"===s)e.push(n);else if(Array.isArray(n))e.push(i.apply(null,n));else if("object"===s)for(var o in n)r.call(n,o)&&n[o]&&e.push(o)}}return e.join(" ")}var r={}.hasOwnProperty;"undefined"!=typeof e&&e.exports?e.exports=i:(n=[],s=function(){return i}.apply(t,n),!(void 0!==s&&(e.exports=s)))}()},function(e,t,i){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function s(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var r=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}(),o=i(5),a=i(26),c=n(a),l=function(){function e(){s(this,e),this.store=(0,o.createStore)(c.default,window.devToolsExtension?window.devToolsExtension():void 0)}return r(e,[{key:"getState",value:function(){return this.store.getState()}},{key:"dispatch",value:function(e){this.store.dispatch(e)}},{key:"subscribe",value:function(e){this.store.subscribe(e)}},{key:"getItems",value:function(){var e=this.store.getState();return e.items}},{key:"getItemsFilteredByActive",value:function(){var e=this.getItems(),t=e.filter(function(e){return e.active===!0},[]);return t}},{key:"getItemsReducedToValues",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.getItems(),t=e.reduce(function(e,t){return e.push(t.value),e},[]);return t}},{key:"getChoices",value:function(){var e=this.store.getState();return e.choices}},{key:"getChoicesFilteredByActive",value:function(){var e=this.getChoices(),t=e.filter(function(e){return e.active===!0},[]);return t}},{key:"getChoicesFilteredBySelectable",value:function(){var e=this.getChoices(),t=e.filter(function(e){return e.disabled!==!0},[]);return t}},{key:"getChoiceById",value:function(e){if(e){var t=this.getChoicesFilteredByActive(),i=t.find(function(t){return t.id===parseInt(e,10)});return i}return!1}},{key:"getGroups",value:function(){var e=this.store.getState();return e.groups}},{key:"getGroupsFilteredByActive",value:function(){var e=this.getGroups(),t=this.getChoices(),i=e.filter(function(e){var i=e.active===!0&&e.disabled===!1,n=t.some(function(e){return e.active===!0&&e.disabled===!1});return i&&n},[]);return i}},{key:"getGroupById",value:function(e){var t=this.getGroups(),i=t.find(function(t){return t.id===e});return i}}]),e}();t.default=l,e.exports=l},function(e,t,i){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0,t.compose=t.applyMiddleware=t.bindActionCreators=t.combineReducers=t.createStore=void 0;var s=i(6),r=n(s),o=i(21),a=n(o),c=i(23),l=n(c),h=i(24),u=n(h),d=i(25),f=n(d),p=i(22);n(p);t.createStore=r.default,t.combineReducers=a.default,t.bindActionCreators=l.default,t.applyMiddleware=u.default,t.compose=f.default},function(e,t,i){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function s(e,t,i){function n(){g===m&&(g=m.slice())}function r(){return v}function a(e){if("function"!=typeof e)throw new Error("Expected listener to be a function.");var t=!0;return n(),g.push(e),function(){if(t){t=!1,n();var i=g.indexOf(e);g.splice(i,1)}}}function h(e){if(!(0,o.default)(e))throw new Error("Actions must be plain objects. Use custom middleware for async actions.");if("undefined"==typeof e.type)throw new Error('Actions may not have an undefined "type" property. Have you misspelled a constant?');if(y)throw new Error("Reducers may not dispatch actions.");try{y=!0,v=p(v,e)}finally{y=!1}for(var t=m=g,i=0;i<t.length;i++)t[i]();return e}function u(e){if("function"!=typeof e)throw new Error("Expected the nextReducer to be a function.");p=e,h({type:l.INIT})}function d(){var e,t=a;return e={subscribe:function(e){function i(){e.next&&e.next(r())}if("object"!=typeof e)throw new TypeError("Expected the observer to be an object.");i();var n=t(i);return{unsubscribe:n}}},e[c.default]=function(){return this},e}var f;if("function"==typeof t&&"undefined"==typeof i&&(i=t,t=void 0),"undefined"!=typeof i){if("function"!=typeof i)throw new Error("Expected the enhancer to be a function.");return i(s)(e,t)}if("function"!=typeof e)throw new Error("Expected the reducer to be a function.");var p=e,v=t,m=[],g=m,y=!1;return h({type:l.INIT}),f={dispatch:h,subscribe:a,getState:r,replaceReducer:u},f[c.default]=d,f}t.__esModule=!0,t.ActionTypes=void 0,t.default=s;var r=i(7),o=n(r),a=i(17),c=n(a),l=t.ActionTypes={INIT:"@@redux/INIT"}},function(e,t,i){function n(e){if(!o(e)||s(e)!=a)return!1;var t=r(e);if(null===t)return!0;var i=u.call(t,"constructor")&&t.constructor;return"function"==typeof i&&i instanceof i&&h.call(i)==d}var s=i(8),r=i(14),o=i(16),a="[object Object]",c=Function.prototype,l=Object.prototype,h=c.toString,u=l.hasOwnProperty,d=h.call(Object);e.exports=n},function(e,t,i){function n(e){return null==e?void 0===e?c:a:l&&l in Object(e)?r(e):o(e)}var s=i(9),r=i(12),o=i(13),a="[object Null]",c="[object Undefined]",l=s?s.toStringTag:void 0;e.exports=n},function(e,t,i){var n=i(10),s=n.Symbol;e.exports=s},function(e,t,i){var n=i(11),s="object"==typeof self&&self&&self.Object===Object&&self,r=n||s||Function("return this")();e.exports=r},function(e,t){(function(t){var i="object"==typeof t&&t&&t.Object===Object&&t;e.exports=i}).call(t,function(){return this}())},function(e,t,i){function n(e){var t=o.call(e,c),i=e[c];try{e[c]=void 0;var n=!0}catch(e){}var s=a.call(e);return n&&(t?e[c]=i:delete e[c]),s}var s=i(9),r=Object.prototype,o=r.hasOwnProperty,a=r.toString,c=s?s.toStringTag:void 0;e.exports=n},function(e,t){function i(e){return s.call(e)}var n=Object.prototype,s=n.toString;e.exports=i},function(e,t,i){var n=i(15),s=n(Object.getPrototypeOf,Object);e.exports=s},function(e,t){function i(e,t){return function(i){return e(t(i))}}e.exports=i},function(e,t){function i(e){return null!=e&&"object"==typeof e}e.exports=i},function(e,t,i){e.exports=i(18)},function(e,t,i){(function(e,n){"use strict";function s(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0});var r,o=i(20),a=s(o);r="undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof e?e:n;var c=(0,a.default)(r);t.default=c}).call(t,function(){return this}(),i(19)(e))},function(e,t){e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children=[],e.webpackPolyfill=1),e}},function(e,t){"use strict";function i(e){var t,i=e.Symbol;return"function"==typeof i?i.observable?t=i.observable:(t=i("observable"),i.observable=t):t="@@observable",t}Object.defineProperty(t,"__esModule",{value:!0}),t.default=i},function(e,t,i){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function s(e,t){var i=t&&t.type,n=i&&'"'+i.toString()+'"'||"an action";return"Given action "+n+', reducer "'+e+'" returned undefined. To ignore an action, you must explicitly return the previous state.'}function r(e){Object.keys(e).forEach(function(t){var i=e[t],n=i(void 0,{type:a.ActionTypes.INIT});if("undefined"==typeof n)throw new Error('Reducer "'+t+'" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined.');var s="@@redux/PROBE_UNKNOWN_ACTION_"+Math.random().toString(36).substring(7).split("").join(".");if("undefined"==typeof i(void 0,{type:s}))throw new Error('Reducer "'+t+'" returned undefined when probed with a random type. '+("Don't try to handle "+a.ActionTypes.INIT+' or other actions in "redux/*" ')+"namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined.")})}function o(e){for(var t=Object.keys(e),i={},n=0;n<t.length;n++){var o=t[n];"function"==typeof e[o]&&(i[o]=e[o])}var a,c=Object.keys(i);try{r(i)}catch(e){a=e}return function(){var e=arguments.length<=0||void 0===arguments[0]?{}:arguments[0],t=arguments[1];if(a)throw a;for(var n=!1,r={},o=0;o<c.length;o++){var l=c[o],h=i[l],u=e[l],d=h(u,t);if("undefined"==typeof d){var f=s(l,t);throw new Error(f)}r[l]=d,n=n||d!==u}return n?r:e}}t.__esModule=!0,t.default=o;var a=i(6),c=i(7),l=(n(c),i(22));n(l)},function(e,t){"use strict";function i(e){"undefined"!=typeof console&&"function"==typeof console.error&&console.error(e);try{throw new Error(e)}catch(e){}}t.__esModule=!0,t.default=i},function(e,t){"use strict";function i(e,t){return function(){return t(e.apply(void 0,arguments))}}function n(e,t){if("function"==typeof e)return i(e,t);if("object"!=typeof e||null===e)throw new Error("bindActionCreators expected an object or a function, instead received "+(null===e?"null":typeof e)+'. Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');for(var n=Object.keys(e),s={},r=0;r<n.length;r++){var o=n[r],a=e[o];"function"==typeof a&&(s[o]=i(a,t))}return s}t.__esModule=!0,t.default=n},function(e,t,i){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function s(){for(var e=arguments.length,t=Array(e),i=0;i<e;i++)t[i]=arguments[i];return function(e){return function(i,n,s){var o=e(i,n,s),c=o.dispatch,l=[],h={getState:o.getState,dispatch:function(e){return c(e)}};return l=t.map(function(e){return e(h)}),c=a.default.apply(void 0,l)(o.dispatch),r({},o,{dispatch:c})}}}t.__esModule=!0;var r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var i=arguments[t];for(var n in i)Object.prototype.hasOwnProperty.call(i,n)&&(e[n]=i[n])}return e};t.default=s;var o=i(25),a=n(o)},function(e,t){"use strict";function i(){for(var e=arguments.length,t=Array(e),i=0;i<e;i++)t[i]=arguments[i];if(0===t.length)return function(e){return e};if(1===t.length)return t[0];var n=t[t.length-1],s=t.slice(0,-1);return function(){return s.reduceRight(function(e,t){return t(e)},n.apply(void 0,arguments))}}t.__esModule=!0,t.default=i},function(e,t,i){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0});var s=i(5),r=i(27),o=n(r),a=i(28),c=n(a),l=i(29),h=n(l),u=(0,s.combineReducers)({items:o.default,groups:c.default,choices:h.default}),d=function(e,t){var i=e;return"CLEAR_ALL"===t.type&&(i=void 0),u(i,t)};t.default=d},function(e,t){"use strict";function i(e){if(Array.isArray(e)){for(var t=0,i=Array(e.length);t<e.length;t++)i[t]=e[t];return i}return Array.from(e)}Object.defineProperty(t,"__esModule",{value:!0});var n=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments[1];switch(t.type){case"ADD_ITEM":var n=[].concat(i(e),[{id:t.id,choiceId:t.choiceId,groupId:t.groupId,value:t.value,label:t.label,active:!0,highlighted:!1,customProperties:t.customProperties,keyCode:null}]);return n.map(function(e){return e.highlighted&&(e.highlighted=!1),e});case"REMOVE_ITEM":return e.map(function(e){return e.id===t.id&&(e.active=!1),e});case"HIGHLIGHT_ITEM":return e.map(function(e){return e.id===t.id&&(e.highlighted=t.highlighted),e});default:return e}};t.default=n},function(e,t){"use strict";function i(e){if(Array.isArray(e)){for(var t=0,i=Array(e.length);t<e.length;t++)i[t]=e[t];return i}return Array.from(e)}Object.defineProperty(t,"__esModule",{value:!0});var n=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments[1];switch(t.type){case"ADD_GROUP":return[].concat(i(e),[{id:t.id,value:t.value,active:t.active,disabled:t.disabled}]);case"CLEAR_CHOICES":return e.groups=[];default:return e}};t.default=n},function(e,t){"use strict";function i(e){if(Array.isArray(e)){for(var t=0,i=Array(e.length);t<e.length;t++)i[t]=e[t];return i}return Array.from(e)}Object.defineProperty(t,"__esModule",{value:!0});var n=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments[1];switch(t.type){case"ADD_CHOICE":return[].concat(i(e),[{id:t.id,elementId:t.elementId,groupId:t.groupId,value:t.value,label:t.label||t.value,disabled:t.disabled||!1,selected:!1,active:!0,score:9999,customProperties:t.customProperties,keyCode:null}]);case"ADD_ITEM":var n=e;return t.activateOptions&&(n=e.map(function(e){return e.active=t.active,e})),t.choiceId>-1&&(n=e.map(function(e){return e.id===parseInt(t.choiceId,10)&&(e.selected=!0),e})),n;case"REMOVE_ITEM":return t.choiceId>-1?e.map(function(e){return e.id===parseInt(t.choiceId,10)&&(e.selected=!1),e}):e;case"FILTER_CHOICES":var s=t.results,r=e.map(function(e){return e.active=s.some(function(t){return t.item.id===e.id&&(e.score=t.score,!0)}),e});return r;case"ACTIVATE_CHOICES":return e.map(function(e){return e.active=t.active,e});case"CLEAR_CHOICES":return e.choices=[];default:return e}};t.default=n},function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.addItem=function(e,t,i,n,s,r,o){return{type:"ADD_ITEM",value:e,label:t,id:i,choiceId:n,groupId:s,customProperties:r,keyCode:o}},t.removeItem=function(e,t){return{type:"REMOVE_ITEM",id:e,choiceId:t}},t.highlightItem=function(e,t){return{type:"HIGHLIGHT_ITEM",id:e,highlighted:t}},t.addChoice=function(e,t,i,n,s,r,o,a){return{type:"ADD_CHOICE",value:e,label:t,id:i,groupId:n,disabled:s,elementId:r,customProperties:o,keyCode:a}},t.filterChoices=function(e){return{type:"FILTER_CHOICES",results:e}},t.activateChoices=function(){var e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return{type:"ACTIVATE_CHOICES",active:e}},t.clearChoices=function(){return{type:"CLEAR_CHOICES"}},t.addGroup=function(e,t,i,n){return{type:"ADD_GROUP",value:e,id:t,active:i,disabled:n}},t.clearAll=function(){return{type:"CLEAR_ALL"}}},function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n=(t.capitalise=function(e){return e.replace(/\w\S*/g,function(e){return e.charAt(0).toUpperCase()+e.substr(1).toLowerCase()})},t.generateChars=function(e){for(var t="",i=0;i<e;i++){var n=a(0,36);t+=n.toString(36)}return t}),s=(t.generateId=function(e,t){var i=e.id||e.name&&e.name+"-"+n(2)||n(4);return i=i.replace(/(:|\.|\[|\]|,)/g,""),i=t+i},t.getType=function(e){return Object.prototype.toString.call(e).slice(8,-1)}),r=t.isType=function(e,t){var i=s(t);return void 0!==t&&null!==t&&i===e},o=(t.isNode=function(e){return"object"===("undefined"==typeof Node?"undefined":i(Node))?e instanceof Node:e&&"object"===("undefined"==typeof e?"undefined":i(e))&&"number"==typeof e.nodeType&&"string"==typeof e.nodeName},t.isElement=function(e){return"object"===("undefined"==typeof HTMLElement?"undefined":i(HTMLElement))?e instanceof HTMLElement:e&&"object"===("undefined"==typeof e?"undefined":i(e))&&null!==e&&1===e.nodeType&&"string"==typeof e.nodeName},t.extend=function e(){for(var t={},i=arguments.length,n=function(i){for(var n in i)Object.prototype.hasOwnProperty.call(i,n)&&(r("Object",i[n])?t[n]=e(!0,t[n],i[n]):t[n]=i[n])},s=0;s<i;s++){var o=arguments[s];r("Object",o)&&n(o)}return t},t.whichTransitionEvent=function(){var e,t=document.createElement("fakeelement"),i={transition:"transitionend",OTransition:"oTransitionEnd",MozTransition:"transitionend",WebkitTransition:"webkitTransitionEnd"};for(e in i)if(void 0!==t.style[e])return i[e]},t.whichAnimationEvent=function(){var e,t=document.createElement("fakeelement"),i={animation:"animationend",OAnimation:"oAnimationEnd",MozAnimation:"animationend",WebkitAnimation:"webkitAnimationEnd"};for(e in i)if(void 0!==t.style[e])return i[e]}),a=(t.getParentsUntil=function(e,t,i){for(var n=[];e&&e!==document;e=e.parentNode){if(t){var s=t.charAt(0);if("."===s&&e.classList.contains(t.substr(1)))break;if("#"===s&&e.id===t.substr(1))break;if("["===s&&e.hasAttribute(t.substr(1,t.length-1)))break;if(e.tagName.toLowerCase()===t)break}if(i){var r=i.charAt(0);"."===r&&e.classList.contains(i.substr(1))&&n.push(e),"#"===r&&e.id===i.substr(1)&&n.push(e),"["===r&&e.hasAttribute(i.substr(1,i.length-1))&&n.push(e),e.tagName.toLowerCase()===i&&n.push(e)}else n.push(e)}return 0===n.length?null:n},t.wrap=function(e,t){return t=t||document.createElement("div"),e.nextSibling?e.parentNode.insertBefore(t,e.nextSibling):e.parentNode.appendChild(t),t.appendChild(e)},t.getSiblings=function(e){for(var t=[],i=e.parentNode.firstChild;i;i=i.nextSibling)1===i.nodeType&&i!==e&&t.push(i);
return t},t.findAncestor=function(e,t){for(;(e=e.parentElement)&&!e.classList.contains(t););return e},t.findAncestorByAttrName=function(e,t){for(var i=e;i;){if(i.hasAttribute(t))return i;i=i.parentElement}return null},t.debounce=function(e,t,i){var n;return function(){var s=this,r=arguments,o=function(){n=null,i||e.apply(s,r)},a=i&&!n;clearTimeout(n),n=setTimeout(o,t),a&&e.apply(s,r)}},t.getElemDistance=function(e){var t=0;if(e.offsetParent)do t+=e.offsetTop,e=e.offsetParent;while(e);return t>=0?t:0},t.getElementOffset=function(e,t){var i=t;return i>1&&(i=1),i>0&&(i=0),Math.max(e.offsetHeight*i)},t.getAdjacentEl=function(e,t){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(e&&t){var n=e.parentNode.parentNode,s=Array.from(n.querySelectorAll(t)),r=s.indexOf(e),o=i>0?1:-1;return s[r+o]}},t.getScrollPosition=function(e){return"bottom"===e?Math.max((window.scrollY||window.pageYOffset)+(window.innerHeight||document.documentElement.clientHeight)):window.scrollY||window.pageYOffset},t.isInView=function(e,t,i){return this.getScrollPosition(t)>this.getElemDistance(e)+this.getElementOffset(e,i)},t.isScrolledIntoView=function(e,t){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(e){var n=void 0;return n=i>0?t.scrollTop+t.offsetHeight>=e.offsetTop+e.offsetHeight:e.offsetTop>=t.scrollTop}},t.stripHTML=function(e){var t=document.createElement("DIV");return t.innerHTML=e,t.textContent||t.innerText||""},t.addAnimation=function(e,t){var i=o(),n=function n(){e.classList.remove(t),e.removeEventListener(i,n,!1)};e.classList.add(t),e.addEventListener(i,n,!1)},t.getRandomNumber=function(e,t){return Math.floor(Math.random()*(t-e)+e)}),c=t.strToEl=function(){var e=document.createElement("div");return function(t){var i=t.trim(),n=void 0;for(e.innerHTML=i,n=e.children[0];e.firstChild;)e.removeChild(e.firstChild);return n}}();t.getWidthOfInput=function(e){var t=e.value||e.placeholder,i=e.offsetWidth;if(t){var n=c("<span>"+t+"</span>");n.style.position="absolute",n.style.padding="0",n.style.top="-9999px",n.style.left="-9999px",n.style.width="auto",n.style.whiteSpace="pre",document.body.appendChild(n),t&&n.offsetWidth!==e.offsetWidth&&(i=n.offsetWidth+4),document.body.removeChild(n)}return i+"px"},t.sortByAlpha=function(e,t){var i=(e.label||e.value).toLowerCase(),n=(t.label||t.value).toLowerCase();return i<n?-1:i>n?1:0},t.sortByScore=function(e,t){return e.score-t.score},t.triggerEvent=function(e,t){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,n=new CustomEvent(t,{detail:i,bubbles:!0,cancelable:!0});return e.dispatchEvent(n)}},function(e,t){"use strict";!function(){function e(e,t){t=t||{bubbles:!1,cancelable:!1,detail:void 0};var i=document.createEvent("CustomEvent");return i.initCustomEvent(e,t.bubbles,t.cancelable,t.detail),i}Array.from||(Array.from=function(){var e=Object.prototype.toString,t=function(t){return"function"==typeof t||"[object Function]"===e.call(t)},i=function(e){var t=Number(e);return isNaN(t)?0:0!==t&&isFinite(t)?(t>0?1:-1)*Math.floor(Math.abs(t)):t},n=Math.pow(2,53)-1,s=function(e){var t=i(e);return Math.min(Math.max(t,0),n)};return function(e){var i=this,n=Object(e);if(null==e)throw new TypeError("Array.from requires an array-like object - not null or undefined");var r,o=arguments.length>1?arguments[1]:void 0;if("undefined"!=typeof o){if(!t(o))throw new TypeError("Array.from: when provided, the second argument must be a function");arguments.length>2&&(r=arguments[2])}for(var a,c=s(n.length),l=t(i)?Object(new i(c)):new Array(c),h=0;h<c;)a=n[h],o?l[h]="undefined"==typeof r?o(a,h):o.call(r,a,h):l[h]=a,h+=1;return l.length=c,l}}()),Array.prototype.find||(Array.prototype.find=function(e){if(null==this)throw new TypeError("Array.prototype.find called on null or undefined");if("function"!=typeof e)throw new TypeError("predicate must be a function");for(var t,i=Object(this),n=i.length>>>0,s=arguments[1],r=0;r<n;r++)if(t=i[r],e.call(s,t,r,i))return t}),e.prototype=window.Event.prototype,window.CustomEvent=e}()}])});

},{}],51:[function(require,module,exports){
/*!
 * EventEmitter2
 * https://github.com/hij1nx/EventEmitter2
 *
 * Copyright (c) 2013 hij1nx
 * Licensed under the MIT license.
 */
;!function(undefined) {

  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  };
  var defaultMaxListeners = 10;

  function init() {
    this._events = {};
    if (this._conf) {
      configure.call(this, this._conf);
    }
  }

  function configure(conf) {
    if (conf) {
      this._conf = conf;

      conf.delimiter && (this.delimiter = conf.delimiter);
      this._events.maxListeners = conf.maxListeners !== undefined ? conf.maxListeners : defaultMaxListeners;
      conf.wildcard && (this.wildcard = conf.wildcard);
      conf.newListener && (this.newListener = conf.newListener);
      conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);

      if (this.wildcard) {
        this.listenerTree = {};
      }
    } else {
      this._events.maxListeners = defaultMaxListeners;
    }
  }

  function logPossibleMemoryLeak(count, eventName) {
    var errorMsg = '(node) warning: possible EventEmitter memory ' +
        'leak detected. %d listeners added. ' +
        'Use emitter.setMaxListeners() to increase limit.';

    if(this.verboseMemoryLeak){
      errorMsg += ' Event name: %s.';
      console.error(errorMsg, count, eventName);
    } else {
      console.error(errorMsg, count);
    }

    if (console.trace){
      console.trace();
    }
  }

  function EventEmitter(conf) {
    this._events = {};
    this.newListener = false;
    this.verboseMemoryLeak = false;
    configure.call(this, conf);
  }
  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property

  //
  // Attention, function return type now is array, always !
  // It has zero elements if no any matches found and one or more
  // elements (leafs) if there are matches
  //
  function searchListenerTree(handlers, type, tree, i) {
    if (!tree) {
      return [];
    }
    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,
        typeLength = type.length, currentType = type[i], nextType = type[i+1];
    if (i === typeLength && tree._listeners) {
      //
      // If at the end of the event(s) list and the tree has listeners
      // invoke those listeners.
      //
      if (typeof tree._listeners === 'function') {
        handlers && handlers.push(tree._listeners);
        return [tree];
      } else {
        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {
          handlers && handlers.push(tree._listeners[leaf]);
        }
        return [tree];
      }
    }

    if ((currentType === '*' || currentType === '**') || tree[currentType]) {
      //
      // If the event emitted is '*' at this part
      // or there is a concrete match at this patch
      //
      if (currentType === '*') {
        for (branch in tree) {
          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));
          }
        }
        return listeners;
      } else if(currentType === '**') {
        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));
        if(endReached && tree._listeners) {
          // The next element has a _listeners, add it to the handlers.
          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));
        }

        for (branch in tree) {
          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
            if(branch === '*' || branch === '**') {
              if(tree[branch]._listeners && !endReached) {
                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));
              }
              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
            } else if(branch === nextType) {
              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));
            } else {
              // No match on this one, shift into the tree but not in the type array.
              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
            }
          }
        }
        return listeners;
      }

      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));
    }

    xTree = tree['*'];
    if (xTree) {
      //
      // If the listener tree will allow any match for this part,
      // then recursively explore all branches of the tree
      //
      searchListenerTree(handlers, type, xTree, i+1);
    }

    xxTree = tree['**'];
    if(xxTree) {
      if(i < typeLength) {
        if(xxTree._listeners) {
          // If we have a listener on a '**', it will catch all, so add its handler.
          searchListenerTree(handlers, type, xxTree, typeLength);
        }

        // Build arrays of matching next branches and others.
        for(branch in xxTree) {
          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {
            if(branch === nextType) {
              // We know the next element will match, so jump twice.
              searchListenerTree(handlers, type, xxTree[branch], i+2);
            } else if(branch === currentType) {
              // Current node matches, move into the tree.
              searchListenerTree(handlers, type, xxTree[branch], i+1);
            } else {
              isolatedBranch = {};
              isolatedBranch[branch] = xxTree[branch];
              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);
            }
          }
        }
      } else if(xxTree._listeners) {
        // We have reached the end and still on a '**'
        searchListenerTree(handlers, type, xxTree, typeLength);
      } else if(xxTree['*'] && xxTree['*']._listeners) {
        searchListenerTree(handlers, type, xxTree['*'], typeLength);
      }
    }

    return listeners;
  }

  function growListenerTree(type, listener) {

    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();

    //
    // Looks for two consecutive '**', if so, don't add the event at all.
    //
    for(var i = 0, len = type.length; i+1 < len; i++) {
      if(type[i] === '**' && type[i+1] === '**') {
        return;
      }
    }

    var tree = this.listenerTree;
    var name = type.shift();

    while (name !== undefined) {

      if (!tree[name]) {
        tree[name] = {};
      }

      tree = tree[name];

      if (type.length === 0) {

        if (!tree._listeners) {
          tree._listeners = listener;
        }
        else {
          if (typeof tree._listeners === 'function') {
            tree._listeners = [tree._listeners];
          }

          tree._listeners.push(listener);

          if (
            !tree._listeners.warned &&
            this._events.maxListeners > 0 &&
            tree._listeners.length > this._events.maxListeners
          ) {
            tree._listeners.warned = true;
            logPossibleMemoryLeak.call(this, tree._listeners.length, name);
          }
        }
        return true;
      }
      name = type.shift();
    }
    return true;
  }

  // By default EventEmitters will print a warning if more than
  // 10 listeners are added to it. This is a useful default which
  // helps finding memory leaks.
  //
  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.

  EventEmitter.prototype.delimiter = '.';

  EventEmitter.prototype.setMaxListeners = function(n) {
    if (n !== undefined) {
      this._events || init.call(this);
      this._events.maxListeners = n;
      if (!this._conf) this._conf = {};
      this._conf.maxListeners = n;
    }
  };

  EventEmitter.prototype.event = '';

  EventEmitter.prototype.once = function(event, fn) {
    this.many(event, 1, fn);
    return this;
  };

  EventEmitter.prototype.many = function(event, ttl, fn) {
    var self = this;

    if (typeof fn !== 'function') {
      throw new Error('many only accepts instances of Function');
    }

    function listener() {
      if (--ttl === 0) {
        self.off(event, listener);
      }
      fn.apply(this, arguments);
    }

    listener._origin = fn;

    this.on(event, listener);

    return self;
  };

  EventEmitter.prototype.emit = function() {

    this._events || init.call(this);

    var type = arguments[0];

    if (type === 'newListener' && !this.newListener) {
      if (!this._events.newListener) {
        return false;
      }
    }

    var al = arguments.length;
    var args,l,i,j;
    var handler;

    if (this._all && this._all.length) {
      handler = this._all.slice();
      if (al > 3) {
        args = new Array(al);
        for (j = 0; j < al; j++) args[j] = arguments[j];
      }

      for (i = 0, l = handler.length; i < l; i++) {
        this.event = type;
        switch (al) {
        case 1:
          handler[i].call(this, type);
          break;
        case 2:
          handler[i].call(this, type, arguments[1]);
          break;
        case 3:
          handler[i].call(this, type, arguments[1], arguments[2]);
          break;
        default:
          handler[i].apply(this, args);
        }
      }
    }

    if (this.wildcard) {
      handler = [];
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
    } else {
      handler = this._events[type];
      if (typeof handler === 'function') {
        this.event = type;
        switch (al) {
        case 1:
          handler.call(this);
          break;
        case 2:
          handler.call(this, arguments[1]);
          break;
        case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;
        default:
          args = new Array(al - 1);
          for (j = 1; j < al; j++) args[j - 1] = arguments[j];
          handler.apply(this, args);
        }
        return true;
      } else if (handler) {
        // need to make copy of handlers because list can change in the middle
        // of emit call
        handler = handler.slice();
      }
    }

    if (handler && handler.length) {
      if (al > 3) {
        args = new Array(al - 1);
        for (j = 1; j < al; j++) args[j - 1] = arguments[j];
      }
      for (i = 0, l = handler.length; i < l; i++) {
        this.event = type;
        switch (al) {
        case 1:
          handler[i].call(this);
          break;
        case 2:
          handler[i].call(this, arguments[1]);
          break;
        case 3:
          handler[i].call(this, arguments[1], arguments[2]);
          break;
        default:
          handler[i].apply(this, args);
        }
      }
      return true;
    } else if (!this._all && type === 'error') {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }

    return !!this._all;
  };

  EventEmitter.prototype.emitAsync = function() {

    this._events || init.call(this);

    var type = arguments[0];

    if (type === 'newListener' && !this.newListener) {
        if (!this._events.newListener) { return Promise.resolve([false]); }
    }

    var promises= [];

    var al = arguments.length;
    var args,l,i,j;
    var handler;

    if (this._all) {
      if (al > 3) {
        args = new Array(al);
        for (j = 1; j < al; j++) args[j] = arguments[j];
      }
      for (i = 0, l = this._all.length; i < l; i++) {
        this.event = type;
        switch (al) {
        case 1:
          promises.push(this._all[i].call(this, type));
          break;
        case 2:
          promises.push(this._all[i].call(this, type, arguments[1]));
          break;
        case 3:
          promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
          break;
        default:
          promises.push(this._all[i].apply(this, args));
        }
      }
    }

    if (this.wildcard) {
      handler = [];
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
    } else {
      handler = this._events[type];
    }

    if (typeof handler === 'function') {
      this.event = type;
      switch (al) {
      case 1:
        promises.push(handler.call(this));
        break;
      case 2:
        promises.push(handler.call(this, arguments[1]));
        break;
      case 3:
        promises.push(handler.call(this, arguments[1], arguments[2]));
        break;
      default:
        args = new Array(al - 1);
        for (j = 1; j < al; j++) args[j - 1] = arguments[j];
        promises.push(handler.apply(this, args));
      }
    } else if (handler && handler.length) {
      if (al > 3) {
        args = new Array(al - 1);
        for (j = 1; j < al; j++) args[j - 1] = arguments[j];
      }
      for (i = 0, l = handler.length; i < l; i++) {
        this.event = type;
        switch (al) {
        case 1:
          promises.push(handler[i].call(this));
          break;
        case 2:
          promises.push(handler[i].call(this, arguments[1]));
          break;
        case 3:
          promises.push(handler[i].call(this, arguments[1], arguments[2]));
          break;
        default:
          promises.push(handler[i].apply(this, args));
        }
      }
    } else if (!this._all && type === 'error') {
      if (arguments[1] instanceof Error) {
        return Promise.reject(arguments[1]); // Unhandled 'error' event
      } else {
        return Promise.reject("Uncaught, unspecified 'error' event.");
      }
    }

    return Promise.all(promises);
  };

  EventEmitter.prototype.on = function(type, listener) {
    if (typeof type === 'function') {
      this.onAny(type);
      return this;
    }

    if (typeof listener !== 'function') {
      throw new Error('on only accepts instances of Function');
    }
    this._events || init.call(this);

    // To avoid recursion in the case that type == "newListeners"! Before
    // adding it to the listeners, first emit "newListeners".
    this.emit('newListener', type, listener);

    if (this.wildcard) {
      growListenerTree.call(this, type, listener);
      return this;
    }

    if (!this._events[type]) {
      // Optimize the case of one listener. Don't need the extra array object.
      this._events[type] = listener;
    }
    else {
      if (typeof this._events[type] === 'function') {
        // Change to array.
        this._events[type] = [this._events[type]];
      }

      // If we've already got an array, just append.
      this._events[type].push(listener);

      // Check for listener leak
      if (
        !this._events[type].warned &&
        this._events.maxListeners > 0 &&
        this._events[type].length > this._events.maxListeners
      ) {
        this._events[type].warned = true;
        logPossibleMemoryLeak.call(this, this._events[type].length, type);
      }
    }

    return this;
  };

  EventEmitter.prototype.onAny = function(fn) {
    if (typeof fn !== 'function') {
      throw new Error('onAny only accepts instances of Function');
    }

    if (!this._all) {
      this._all = [];
    }

    // Add the function to the event listener collection.
    this._all.push(fn);
    return this;
  };

  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  EventEmitter.prototype.off = function(type, listener) {
    if (typeof listener !== 'function') {
      throw new Error('removeListener only takes instances of Function');
    }

    var handlers,leafs=[];

    if(this.wildcard) {
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
    }
    else {
      // does not use listeners(), so no side effect of creating _events[type]
      if (!this._events[type]) return this;
      handlers = this._events[type];
      leafs.push({_listeners:handlers});
    }

    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {
      var leaf = leafs[iLeaf];
      handlers = leaf._listeners;
      if (isArray(handlers)) {

        var position = -1;

        for (var i = 0, length = handlers.length; i < length; i++) {
          if (handlers[i] === listener ||
            (handlers[i].listener && handlers[i].listener === listener) ||
            (handlers[i]._origin && handlers[i]._origin === listener)) {
            position = i;
            break;
          }
        }

        if (position < 0) {
          continue;
        }

        if(this.wildcard) {
          leaf._listeners.splice(position, 1);
        }
        else {
          this._events[type].splice(position, 1);
        }

        if (handlers.length === 0) {
          if(this.wildcard) {
            delete leaf._listeners;
          }
          else {
            delete this._events[type];
          }
        }

        this.emit("removeListener", type, listener);

        return this;
      }
      else if (handlers === listener ||
        (handlers.listener && handlers.listener === listener) ||
        (handlers._origin && handlers._origin === listener)) {
        if(this.wildcard) {
          delete leaf._listeners;
        }
        else {
          delete this._events[type];
        }

        this.emit("removeListener", type, listener);
      }
    }

    function recursivelyGarbageCollect(root) {
      if (root === undefined) {
        return;
      }
      var keys = Object.keys(root);
      for (var i in keys) {
        var key = keys[i];
        var obj = root[key];
        if ((obj instanceof Function) || (typeof obj !== "object") || (obj === null))
          continue;
        if (Object.keys(obj).length > 0) {
          recursivelyGarbageCollect(root[key]);
        }
        if (Object.keys(obj).length === 0) {
          delete root[key];
        }
      }
    }
    recursivelyGarbageCollect(this.listenerTree);

    return this;
  };

  EventEmitter.prototype.offAny = function(fn) {
    var i = 0, l = 0, fns;
    if (fn && this._all && this._all.length > 0) {
      fns = this._all;
      for(i = 0, l = fns.length; i < l; i++) {
        if(fn === fns[i]) {
          fns.splice(i, 1);
          this.emit("removeListenerAny", fn);
          return this;
        }
      }
    } else {
      fns = this._all;
      for(i = 0, l = fns.length; i < l; i++)
        this.emit("removeListenerAny", fns[i]);
      this._all = [];
    }
    return this;
  };

  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;

  EventEmitter.prototype.removeAllListeners = function(type) {
    if (arguments.length === 0) {
      !this._events || init.call(this);
      return this;
    }

    if (this.wildcard) {
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);

      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {
        var leaf = leafs[iLeaf];
        leaf._listeners = null;
      }
    }
    else if (this._events) {
      this._events[type] = null;
    }
    return this;
  };

  EventEmitter.prototype.listeners = function(type) {
    if (this.wildcard) {
      var handlers = [];
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
      return handlers;
    }

    this._events || init.call(this);

    if (!this._events[type]) this._events[type] = [];
    if (!isArray(this._events[type])) {
      this._events[type] = [this._events[type]];
    }
    return this._events[type];
  };

  EventEmitter.prototype.listenerCount = function(type) {
    return this.listeners(type).length;
  };

  EventEmitter.prototype.listenersAny = function() {

    if(this._all) {
      return this._all;
    }
    else {
      return [];
    }

  };

  if (typeof define === 'function' && define.amd) {
     // AMD. Register as an anonymous module.
    define(function() {
      return EventEmitter;
    });
  } else if (typeof exports === 'object') {
    // CommonJS
    module.exports = EventEmitter;
  }
  else {
    // Browser global.
    window.EventEmitter2 = EventEmitter;
  }
}();

},{}],52:[function(require,module,exports){
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! flatpickr v2.6.3, @license MIT */
function Flatpickr(element, config) {
	var self = this;

	self._ = {};
	self._.afterDayAnim = afterDayAnim;
	self.changeMonth = changeMonth;
	self.changeYear = changeYear;
	self.clear = clear;
	self.close = close;
	self._createElement = createElement;
	self.destroy = destroy;
	self.isEnabled = isEnabled;
	self.jumpToDate = jumpToDate;
	self.open = open;
	self.redraw = redraw;
	self.set = set;
	self.setDate = setDate;
	self.toggle = toggle;

	function init() {
		self.element = self.input = element;
		self.instanceConfig = config || {};
		self.parseDate = Flatpickr.prototype.parseDate.bind(self);
		self.formatDate = Flatpickr.prototype.formatDate.bind(self);

		setupFormats();
		parseConfig();
		setupLocale();
		setupInputs();
		setupDates();
		setupHelperFunctions();

		self.isOpen = false;

		self.isMobile = !self.config.disableMobile && !self.config.inline && self.config.mode === "single" && !self.config.disable.length && !self.config.enable.length && !self.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

		if (!self.isMobile) build();

		bindEvents();

		if (self.selectedDates.length || self.config.noCalendar) {
			if (self.config.enableTime) {
				setHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj || self.config.minDate : null);
			}
			updateValue();
		}

		if (self.config.weekNumbers) {
			self.calendarContainer.style.width = self.daysContainer.offsetWidth + self.weekWrapper.offsetWidth + "px";
		}

		self.showTimeInput = self.selectedDates.length > 0 || self.config.noCalendar;

		if (!self.isMobile) positionCalendar();

		triggerEvent("Ready");
	}

	/**
  * Binds a function to the current flatpickr instance
  * @param {Function} fn the function
  * @return {Function} the function bound to the instance
  */
	function bindToInstance(fn) {
		return fn.bind(self);
	}

	/**
  * The handler for all events targeting the time inputs
  * @param {Event} e the event - "input", "wheel", "increment", etc
  */
	function updateTime(e) {
		if (self.config.noCalendar && !self.selectedDates.length)
			// picking time only
			self.selectedDates = [self.now];

		timeWrapper(e);

		if (!self.selectedDates.length) return;

		if (!self.minDateHasTime || e.type !== "input" || e.target.value.length >= 2) {
			setHoursFromInputs();
			updateValue();
		} else {
			setTimeout(function () {
				setHoursFromInputs();
				updateValue();
			}, 1000);
		}
	}

	/**
  * Syncs the selected date object time with user's time input
  */
	function setHoursFromInputs() {
		if (!self.config.enableTime) return;

		var hours = (parseInt(self.hourElement.value, 10) || 0) % (self.amPM ? 12 : 24),
		    minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60,
		    seconds = self.config.enableSeconds ? (parseInt(self.secondElement.value, 10) || 0) % 60 : 0;

		if (self.amPM !== undefined) hours = hours % 12 + 12 * (self.amPM.textContent === "PM");

		if (self.minDateHasTime && compareDates(self.latestSelectedDateObj, self.config.minDate) === 0) {

			hours = Math.max(hours, self.config.minDate.getHours());
			if (hours === self.config.minDate.getHours()) minutes = Math.max(minutes, self.config.minDate.getMinutes());
		}

		if (self.maxDateHasTime && compareDates(self.latestSelectedDateObj, self.config.maxDate) === 0) {
			hours = Math.min(hours, self.config.maxDate.getHours());
			if (hours === self.config.maxDate.getHours()) minutes = Math.min(minutes, self.config.maxDate.getMinutes());
		}

		setHours(hours, minutes, seconds);
	}

	/**
  * Syncs time input values with a date
  * @param {Date} dateObj the date to sync with
  */
	function setHoursFromDate(dateObj) {
		var date = dateObj || self.latestSelectedDateObj;

		if (date) setHours(date.getHours(), date.getMinutes(), date.getSeconds());
	}

	/**
  * Sets the hours, minutes, and optionally seconds
  * of the latest selected date object and the
  * corresponding time inputs
  * @param {Number} hours the hour. whether its military
  *                 or am-pm gets inferred from config
  * @param {Number} minutes the minutes
  * @param {Number} seconds the seconds (optional)
  */
	function setHours(hours, minutes, seconds) {
		if (self.selectedDates.length) {
			self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
		}

		if (!self.config.enableTime || self.isMobile) return;

		self.hourElement.value = self.pad(!self.config.time_24hr ? (12 + hours) % 12 + 12 * (hours % 12 === 0) : hours);

		self.minuteElement.value = self.pad(minutes);

		if (!self.config.time_24hr) self.amPM.textContent = hours >= 12 ? "PM" : "AM";

		if (self.config.enableSeconds === true) self.secondElement.value = self.pad(seconds);
	}

	/**
  * Handles the year input and incrementing events
  * @param {Event} event the keyup or increment event
  */
	function onYearInput(event) {
		var year = event.target.value;
		if (event.delta) year = (parseInt(year) + event.delta).toString();

		if (year.length === 4 || event.key === "Enter") {
			self.currentYearElement.blur();
			if (!/[^\d]/.test(year)) changeYear(year);
		}
	}

	/**
  * Essentially addEventListener + tracking
  * @param {Element} element the element to addEventListener to
  * @param {String} event the event name
  * @param {Function} handler the event handler
  */
	function bind(element, event, handler) {
		if (event instanceof Array) return event.forEach(function (ev) {
			return bind(element, ev, handler);
		});

		if (element instanceof Array) return element.forEach(function (el) {
			return bind(el, event, handler);
		});

		element.addEventListener(event, handler);
		self._handlers.push({ element: element, event: event, handler: handler });
	}

	/**
  * A mousedown handler which mimics click.
  * Minimizes latency, since we don't need to wait for mouseup in most cases.
  * Also, avoids handling right clicks.
  *
  * @param {Function} handler the event handler
  */
	function onClick(handler) {
		return function (evt) {
			return evt.which === 1 && handler(evt);
		};
	}

	/**
  * Adds all the necessary event listeners
  */
	function bindEvents() {
		self._handlers = [];
		self._animationLoop = [];
		if (self.config.wrap) {
			["open", "close", "toggle", "clear"].forEach(function (evt) {
				Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function (el) {
					return bind(el, "mousedown", onClick(self[evt]));
				});
			});
		}

		if (self.isMobile) return setupMobile();

		self.debouncedResize = debounce(onResize, 50);
		self.triggerChange = function () {
			triggerEvent("Change");
		};
		self.debouncedChange = debounce(self.triggerChange, 300);

		if (self.config.mode === "range" && self.daysContainer) bind(self.daysContainer, "mouseover", function (e) {
			return onMouseOver(e.target);
		});

		bind(window.document.body, "keydown", onKeyDown);

		if (!self.config.static) bind(self._input, "keydown", onKeyDown);

		if (!self.config.inline && !self.config.static) bind(window, "resize", self.debouncedResize);

		if (window.ontouchstart !== undefined) bind(window.document, "touchstart", documentClick);

		bind(window.document, "mousedown", onClick(documentClick));
		bind(self._input, "blur", documentClick);

		if (self.config.clickOpens === true) bind(self._input, "focus", self.open);

		if (!self.config.noCalendar) {
			self.monthNav.addEventListener("wheel", function (e) {
				return e.preventDefault();
			});
			bind(self.monthNav, "wheel", debounce(onMonthNavScroll, 10));
			bind(self.monthNav, "mousedown", onClick(onMonthNavClick));

			bind(self.monthNav, ["keyup", "increment"], onYearInput);
			bind(self.daysContainer, "mousedown", onClick(selectDate));

			if (self.config.animate) {
				bind(self.daysContainer, ["webkitAnimationEnd", "animationend"], animateDays);
				bind(self.monthNav, ["webkitAnimationEnd", "animationend"], animateMonths);
			}
		}

		if (self.config.enableTime) {
			var selText = function selText(e) {
				return e.target.select();
			};
			bind(self.timeContainer, ["wheel", "input", "increment"], updateTime);
			bind(self.timeContainer, "mousedown", onClick(timeIncrement));

			bind(self.timeContainer, ["wheel", "increment"], self.debouncedChange);
			bind(self.timeContainer, "input", self.triggerChange);

			bind([self.hourElement, self.minuteElement], "focus", selText);

			if (self.secondElement !== undefined) bind(self.secondElement, "focus", function () {
				return self.secondElement.select();
			});

			if (self.amPM !== undefined) {
				bind(self.amPM, "mousedown", onClick(function (e) {
					updateTime(e);
					self.triggerChange(e);
				}));
			}
		}
	}

	function processPostDayAnimation() {
		for (var i = self._animationLoop.length; i--;) {
			self._animationLoop[i]();
			self._animationLoop.splice(i, 1);
		}
	}

	/**
  * Removes the day container that slided out of view
  * @param {Event} e the animation event
  */
	function animateDays(e) {
		if (self.daysContainer.childNodes.length > 1) {
			switch (e.animationName) {
				case "fpSlideLeft":
					self.daysContainer.lastChild.classList.remove("slideLeftNew");
					self.daysContainer.removeChild(self.daysContainer.firstChild);
					self.days = self.daysContainer.firstChild;
					processPostDayAnimation();

					break;

				case "fpSlideRight":
					self.daysContainer.firstChild.classList.remove("slideRightNew");
					self.daysContainer.removeChild(self.daysContainer.lastChild);
					self.days = self.daysContainer.firstChild;
					processPostDayAnimation();

					break;

				default:
					break;
			}
		}
	}

	/**
  * Removes the month element that animated out of view
  * @param {Event} e the animation event
  */
	function animateMonths(e) {
		switch (e.animationName) {
			case "fpSlideLeftNew":
			case "fpSlideRightNew":
				self.navigationCurrentMonth.classList.remove("slideLeftNew");
				self.navigationCurrentMonth.classList.remove("slideRightNew");
				var nav = self.navigationCurrentMonth;

				while (nav.nextSibling && /curr/.test(nav.nextSibling.className)) {
					self.monthNav.removeChild(nav.nextSibling);
				}while (nav.previousSibling && /curr/.test(nav.previousSibling.className)) {
					self.monthNav.removeChild(nav.previousSibling);
				}self.oldCurMonth = null;
				break;
		}
	}

	/**
  * Set the calendar view to a particular date.
  * @param {Date} jumpDate the date to set the view to
  */
	function jumpToDate(jumpDate) {
		jumpDate = jumpDate ? self.parseDate(jumpDate) : self.latestSelectedDateObj || (self.config.minDate > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate < self.now ? self.config.maxDate : self.now);

		try {
			self.currentYear = jumpDate.getFullYear();
			self.currentMonth = jumpDate.getMonth();
		} catch (e) {
			/* istanbul ignore next */
			console.error(e.stack);
			/* istanbul ignore next */
			console.warn("Invalid date supplied: " + jumpDate);
		}

		self.redraw();
	}

	/**
  * The up/down arrow handler for time inputs
  * @param {Event} e the click event
  */
	function timeIncrement(e) {
		if (~e.target.className.indexOf("arrow")) incrementNumInput(e, e.target.classList.contains("arrowUp") ? 1 : -1);
	}

	/**
  * Increments/decrements the value of input associ-
  * ated with the up/down arrow by dispatching an
  * "increment" event on the input.
  *
  * @param {Event} e the click event
  * @param {Number} delta the diff (usually 1 or -1)
  * @param {Element} inputElem the input element
  */
	function incrementNumInput(e, delta, inputElem) {
		var input = inputElem || e.target.parentNode.childNodes[0];
		var event = createEvent("increment");
		event.delta = delta;
		input.dispatchEvent(event);
	}

	function createNumberInput(inputClassName) {
		var wrapper = createElement("div", "numInputWrapper"),
		    numInput = createElement("input", "numInput " + inputClassName),
		    arrowUp = createElement("span", "arrowUp"),
		    arrowDown = createElement("span", "arrowDown");

		numInput.type = "text";
		numInput.pattern = "\\d*";

		wrapper.appendChild(numInput);
		wrapper.appendChild(arrowUp);
		wrapper.appendChild(arrowDown);

		return wrapper;
	}

	function build() {
		var fragment = window.document.createDocumentFragment();
		self.calendarContainer = createElement("div", "flatpickr-calendar");
		self.calendarContainer.tabIndex = -1;

		if (!self.config.noCalendar) {
			fragment.appendChild(buildMonthNav());
			self.innerContainer = createElement("div", "flatpickr-innerContainer");

			if (self.config.weekNumbers) self.innerContainer.appendChild(buildWeeks());

			self.rContainer = createElement("div", "flatpickr-rContainer");
			self.rContainer.appendChild(buildWeekdays());

			if (!self.daysContainer) {
				self.daysContainer = createElement("div", "flatpickr-days");
				self.daysContainer.tabIndex = -1;
			}

			buildDays();
			self.rContainer.appendChild(self.daysContainer);

			self.innerContainer.appendChild(self.rContainer);
			fragment.appendChild(self.innerContainer);
		}

		if (self.config.enableTime) fragment.appendChild(buildTime());

		toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
		toggleClass(self.calendarContainer, "animate", self.config.animate);

		self.calendarContainer.appendChild(fragment);

		var customAppend = self.config.appendTo && self.config.appendTo.nodeType;

		if (self.config.inline || self.config.static) {
			self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");

			if (self.config.inline && !customAppend) {
				return self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);
			}

			if (self.config.static) {
				var wrapper = createElement("div", "flatpickr-wrapper");
				self.element.parentNode.insertBefore(wrapper, self.element);
				wrapper.appendChild(self.element);

				if (self.altInput) wrapper.appendChild(self.altInput);

				wrapper.appendChild(self.calendarContainer);
				return;
			}
		}

		(customAppend ? self.config.appendTo : window.document.body).appendChild(self.calendarContainer);
	}

	function createDay(className, date, dayNumber, i) {
		var dateIsEnabled = isEnabled(date, true),
		    dayElement = createElement("span", "flatpickr-day " + className, date.getDate());

		dayElement.dateObj = date;
		dayElement.$i = i;
		dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));

		if (compareDates(date, self.now) === 0) {
			self.todayDateElem = dayElement;
			dayElement.classList.add("today");
		}

		if (dateIsEnabled) {
			dayElement.tabIndex = -1;
			if (isDateSelected(date)) {
				dayElement.classList.add("selected");
				self.selectedDateElem = dayElement;
				if (self.config.mode === "range") {
					toggleClass(dayElement, "startRange", compareDates(date, self.selectedDates[0]) === 0);

					toggleClass(dayElement, "endRange", compareDates(date, self.selectedDates[1]) === 0);
				}
			}
		} else {
			dayElement.classList.add("disabled");
			if (self.selectedDates[0] && date > self.minRangeDate && date < self.selectedDates[0]) self.minRangeDate = date;else if (self.selectedDates[0] && date < self.maxRangeDate && date > self.selectedDates[0]) self.maxRangeDate = date;
		}

		if (self.config.mode === "range") {
			if (isDateInRange(date) && !isDateSelected(date)) dayElement.classList.add("inRange");

			if (self.selectedDates.length === 1 && (date < self.minRangeDate || date > self.maxRangeDate)) dayElement.classList.add("notAllowed");
		}

		if (self.config.weekNumbers && className !== "prevMonthDay" && dayNumber % 7 === 1) {
			self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='disabled flatpickr-day'>" + self.config.getWeek(date) + "</span>");
		}

		triggerEvent("DayCreate", dayElement);

		return dayElement;
	}

	function focusOnDay(currentIndex, offset) {
		var newIndex = currentIndex + offset || 0,
		    targetNode = currentIndex !== undefined ? self.days.childNodes[newIndex] : self.selectedDateElem || self.todayDateElem || self.days.childNodes[0],
		    focus = function focus() {
			targetNode = targetNode || self.days.childNodes[newIndex];
			targetNode.focus();

			if (self.config.mode === "range") onMouseOver(targetNode);
		};

		if (targetNode === undefined && offset !== 0) {
			if (offset > 0) {
				self.changeMonth(1);
				newIndex = newIndex % 42;
			} else if (offset < 0) {
				self.changeMonth(-1);
				newIndex += 42;
			}

			return afterDayAnim(focus);
		}

		focus();
	}

	function afterDayAnim(fn) {
		if (self.config.animate === true) return self._animationLoop.push(fn);
		fn();
	}

	function buildDays(delta) {
		var firstOfMonth = (new Date(self.currentYear, self.currentMonth, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7,
		    isRangeMode = self.config.mode === "range";

		self.prevMonthDays = self.utils.getDaysinMonth((self.currentMonth - 1 + 12) % 12);
		self.selectedDateElem = undefined;
		self.todayDateElem = undefined;

		var daysInMonth = self.utils.getDaysinMonth(),
		    days = window.document.createDocumentFragment();

		var dayNumber = self.prevMonthDays + 1 - firstOfMonth,
		    dayIndex = 0;

		if (self.config.weekNumbers && self.weekNumbers.firstChild) self.weekNumbers.textContent = "";

		if (isRangeMode) {
			// const dateLimits = self.config.enable.length || self.config.disable.length || self.config.mixDate || self.config.maxDate;
			self.minRangeDate = new Date(self.currentYear, self.currentMonth - 1, dayNumber);
			self.maxRangeDate = new Date(self.currentYear, self.currentMonth + 1, (42 - firstOfMonth) % daysInMonth);
		}

		// prepend days from the ending of previous month
		for (; dayNumber <= self.prevMonthDays; dayNumber++, dayIndex++) {
			days.appendChild(createDay("prevMonthDay", new Date(self.currentYear, self.currentMonth - 1, dayNumber), dayNumber, dayIndex));
		}

		// Start at 1 since there is no 0th day
		for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
			days.appendChild(createDay("", new Date(self.currentYear, self.currentMonth, dayNumber), dayNumber, dayIndex));
		}

		// append days from the next month
		for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth; dayNum++, dayIndex++) {
			days.appendChild(createDay("nextMonthDay", new Date(self.currentYear, self.currentMonth + 1, dayNum % daysInMonth), dayNum, dayIndex));
		}

		if (isRangeMode && self.selectedDates.length === 1 && days.childNodes[0]) {
			self._hidePrevMonthArrow = self._hidePrevMonthArrow || self.minRangeDate > days.childNodes[0].dateObj;

			self._hideNextMonthArrow = self._hideNextMonthArrow || self.maxRangeDate < new Date(self.currentYear, self.currentMonth + 1, 1);
		} else updateNavigationCurrentMonth();

		var dayContainer = createElement("div", "dayContainer");
		dayContainer.appendChild(days);

		if (!self.config.animate || delta === undefined) clearNode(self.daysContainer);else {
			while (self.daysContainer.childNodes.length > 1) {
				self.daysContainer.removeChild(self.daysContainer.firstChild);
			}
		}

		if (delta >= 0) self.daysContainer.appendChild(dayContainer);else self.daysContainer.insertBefore(dayContainer, self.daysContainer.firstChild);

		self.days = self.daysContainer.firstChild;
		return self.daysContainer;
	}

	function clearNode(node) {
		while (node.firstChild) {
			node.removeChild(node.firstChild);
		}
	}

	function buildMonthNav() {
		var monthNavFragment = window.document.createDocumentFragment();
		self.monthNav = createElement("div", "flatpickr-month");

		self.prevMonthNav = createElement("span", "flatpickr-prev-month");
		self.prevMonthNav.innerHTML = self.config.prevArrow;

		self.currentMonthElement = createElement("span", "cur-month");
		self.currentMonthElement.title = self.l10n.scrollTitle;

		var yearInput = createNumberInput("cur-year");
		self.currentYearElement = yearInput.childNodes[0];
		self.currentYearElement.title = self.l10n.scrollTitle;

		if (self.config.minDate) self.currentYearElement.min = self.config.minDate.getFullYear();

		if (self.config.maxDate) {
			self.currentYearElement.max = self.config.maxDate.getFullYear();

			self.currentYearElement.disabled = self.config.minDate && self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
		}

		self.nextMonthNav = createElement("span", "flatpickr-next-month");
		self.nextMonthNav.innerHTML = self.config.nextArrow;

		self.navigationCurrentMonth = createElement("span", "flatpickr-current-month");
		self.navigationCurrentMonth.appendChild(self.currentMonthElement);
		self.navigationCurrentMonth.appendChild(yearInput);

		monthNavFragment.appendChild(self.prevMonthNav);
		monthNavFragment.appendChild(self.navigationCurrentMonth);
		monthNavFragment.appendChild(self.nextMonthNav);
		self.monthNav.appendChild(monthNavFragment);

		Object.defineProperty(self, "_hidePrevMonthArrow", {
			get: function get() {
				return this.__hidePrevMonthArrow;
			},
			set: function set(bool) {
				if (this.__hidePrevMonthArrow !== bool) self.prevMonthNav.style.display = bool ? "none" : "block";
				this.__hidePrevMonthArrow = bool;
			}
		});

		Object.defineProperty(self, "_hideNextMonthArrow", {
			get: function get() {
				return this.__hideNextMonthArrow;
			},
			set: function set(bool) {
				if (this.__hideNextMonthArrow !== bool) self.nextMonthNav.style.display = bool ? "none" : "block";
				this.__hideNextMonthArrow = bool;
			}
		});

		updateNavigationCurrentMonth();

		return self.monthNav;
	}

	function buildTime() {
		self.calendarContainer.classList.add("hasTime");
		if (self.config.noCalendar) self.calendarContainer.classList.add("noCalendar");
		self.timeContainer = createElement("div", "flatpickr-time");
		self.timeContainer.tabIndex = -1;
		var separator = createElement("span", "flatpickr-time-separator", ":");

		var hourInput = createNumberInput("flatpickr-hour");
		self.hourElement = hourInput.childNodes[0];

		var minuteInput = createNumberInput("flatpickr-minute");
		self.minuteElement = minuteInput.childNodes[0];

		self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;

		self.hourElement.value = self.pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getHours() : self.config.defaultHour);

		self.minuteElement.value = self.pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getMinutes() : self.config.defaultMinute);

		self.hourElement.step = self.config.hourIncrement;
		self.minuteElement.step = self.config.minuteIncrement;

		self.hourElement.min = self.config.time_24hr ? 0 : 1;
		self.hourElement.max = self.config.time_24hr ? 23 : 12;

		self.minuteElement.min = 0;
		self.minuteElement.max = 59;

		self.hourElement.title = self.minuteElement.title = self.l10n.scrollTitle;

		self.timeContainer.appendChild(hourInput);
		self.timeContainer.appendChild(separator);
		self.timeContainer.appendChild(minuteInput);

		if (self.config.time_24hr) self.timeContainer.classList.add("time24hr");

		if (self.config.enableSeconds) {
			self.timeContainer.classList.add("hasSeconds");

			var secondInput = createNumberInput("flatpickr-second");
			self.secondElement = secondInput.childNodes[0];

			self.secondElement.value = self.latestSelectedDateObj ? self.pad(self.latestSelectedDateObj.getSeconds()) : "00";

			self.secondElement.step = self.minuteElement.step;
			self.secondElement.min = self.minuteElement.min;
			self.secondElement.max = self.minuteElement.max;

			self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
			self.timeContainer.appendChild(secondInput);
		}

		if (!self.config.time_24hr) {
			// add self.amPM if appropriate
			self.amPM = createElement("span", "flatpickr-am-pm", ["AM", "PM"][self.hourElement.value > 11 | 0]);
			self.amPM.title = self.l10n.toggleTitle;
			self.amPM.tabIndex = -1;
			self.timeContainer.appendChild(self.amPM);
		}

		return self.timeContainer;
	}

	function buildWeekdays() {
		if (!self.weekdayContainer) self.weekdayContainer = createElement("div", "flatpickr-weekdays");

		var firstDayOfWeek = self.l10n.firstDayOfWeek;
		var weekdays = self.l10n.weekdays.shorthand.slice();

		if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
			weekdays = [].concat(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
		}

		self.weekdayContainer.innerHTML = "\n\t\t<span class=flatpickr-weekday>\n\t\t\t" + weekdays.join("</span><span class=flatpickr-weekday>") + "\n\t\t</span>\n\t\t";

		return self.weekdayContainer;
	}

	/* istanbul ignore next */
	function buildWeeks() {
		self.calendarContainer.classList.add("hasWeeks");
		self.weekWrapper = createElement("div", "flatpickr-weekwrapper");
		self.weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
		self.weekNumbers = createElement("div", "flatpickr-weeks");
		self.weekWrapper.appendChild(self.weekNumbers);

		return self.weekWrapper;
	}

	function changeMonth(value, is_offset, animate) {
		is_offset = is_offset === undefined || is_offset;
		var delta = is_offset ? value : value - self.currentMonth;
		var skipAnimations = !self.config.animate || animate === false;

		if (delta < 0 && self._hidePrevMonthArrow || delta > 0 && self._hideNextMonthArrow) return;

		self.currentMonth += delta;

		if (self.currentMonth < 0 || self.currentMonth > 11) {
			self.currentYear += self.currentMonth > 11 ? 1 : -1;
			self.currentMonth = (self.currentMonth + 12) % 12;

			triggerEvent("YearChange");
		}

		buildDays(!skipAnimations ? delta : undefined);

		if (skipAnimations) {
			triggerEvent("MonthChange");
			return updateNavigationCurrentMonth();
		}

		// remove possible remnants from clicking too fast
		var nav = self.navigationCurrentMonth;
		if (delta < 0) {
			while (nav.nextSibling && /curr/.test(nav.nextSibling.className)) {
				self.monthNav.removeChild(nav.nextSibling);
			}
		} else if (delta > 0) {
			while (nav.previousSibling && /curr/.test(nav.previousSibling.className)) {
				self.monthNav.removeChild(nav.previousSibling);
			}
		}

		self.oldCurMonth = self.navigationCurrentMonth;

		self.navigationCurrentMonth = self.monthNav.insertBefore(self.oldCurMonth.cloneNode(true), delta > 0 ? self.oldCurMonth.nextSibling : self.oldCurMonth);

		if (delta > 0) {
			self.daysContainer.firstChild.classList.add("slideLeft");
			self.daysContainer.lastChild.classList.add("slideLeftNew");

			self.oldCurMonth.classList.add("slideLeft");
			self.navigationCurrentMonth.classList.add("slideLeftNew");
		} else if (delta < 0) {
			self.daysContainer.firstChild.classList.add("slideRightNew");
			self.daysContainer.lastChild.classList.add("slideRight");

			self.oldCurMonth.classList.add("slideRight");
			self.navigationCurrentMonth.classList.add("slideRightNew");
		}

		self.currentMonthElement = self.navigationCurrentMonth.firstChild;
		self.currentYearElement = self.navigationCurrentMonth.lastChild.childNodes[0];

		updateNavigationCurrentMonth();
		self.oldCurMonth.firstChild.textContent = self.utils.monthToStr(self.currentMonth - delta);

		triggerEvent("MonthChange");

		if (document.activeElement && document.activeElement.$i) {
			var index = document.activeElement.$i;
			afterDayAnim(function () {
				focusOnDay(index, 0);
			});
		}
	}

	function clear(triggerChangeEvent) {
		self.input.value = "";

		if (self.altInput) self.altInput.value = "";

		if (self.mobileInput) self.mobileInput.value = "";

		self.selectedDates = [];
		self.latestSelectedDateObj = undefined;
		self.showTimeInput = false;

		self.redraw();

		if (triggerChangeEvent !== false)
			// triggerChangeEvent is true (default) or an Event
			triggerEvent("Change");
	}

	function close() {
		self.isOpen = false;

		if (!self.isMobile) {
			self.calendarContainer.classList.remove("open");
			self._input.classList.remove("active");
		}

		triggerEvent("Close");
	}

	function destroy() {
		for (var i = self._handlers.length; i--;) {
			var h = self._handlers[i];
			h.element.removeEventListener(h.event, h.handler);
		}

		self._handlers = [];

		if (self.mobileInput) {
			if (self.mobileInput.parentNode) self.mobileInput.parentNode.removeChild(self.mobileInput);
			self.mobileInput = null;
		} else if (self.calendarContainer && self.calendarContainer.parentNode) self.calendarContainer.parentNode.removeChild(self.calendarContainer);

		if (self.altInput) {
			self.input.type = "text";
			if (self.altInput.parentNode) self.altInput.parentNode.removeChild(self.altInput);
			delete self.altInput;
		}

		if (self.input) {
			self.input.type = self.input._type;
			self.input.classList.remove("flatpickr-input");
			self.input.removeAttribute("readonly");
			self.input.value = "";
		}

		["_showTimeInput", "latestSelectedDateObj", "_hideNextMonthArrow", "_hidePrevMonthArrow", "__hideNextMonthArrow", "__hidePrevMonthArrow", "isMobile", "isOpen", "selectedDateElem", "minDateHasTime", "maxDateHasTime", "days", "daysContainer", "_input", "_positionElement", "innerContainer", "rContainer", "monthNav", "todayDateElem", "calendarContainer", "weekdayContainer", "prevMonthNav", "nextMonthNav", "currentMonthElement", "currentYearElement", "navigationCurrentMonth", "selectedDateElem", "config"].forEach(function (k) {
			return delete self[k];
		});
	}

	function isCalendarElem(elem) {
		if (self.config.appendTo && self.config.appendTo.contains(elem)) return true;

		return self.calendarContainer.contains(elem);
	}

	function documentClick(e) {
		if (self.isOpen && !self.config.inline) {
			var isCalendarElement = isCalendarElem(e.target);
			var isInput = e.target === self.input || e.target === self.altInput || self.element.contains(e.target) ||
			// web components
			e.path && e.path.indexOf && (~e.path.indexOf(self.input) || ~e.path.indexOf(self.altInput));

			var lostFocus = e.type === "blur" ? isInput && e.relatedTarget && !isCalendarElem(e.relatedTarget) : !isInput && !isCalendarElement;

			if (lostFocus) {
				e.preventDefault();
				self.close();

				if (self.config.mode === "range" && self.selectedDates.length === 1) {
					self.clear(false);
					self.redraw();
				}
			}
		}
	}

	function changeYear(newYear) {
		if (!newYear || self.currentYearElement.min && newYear < self.currentYearElement.min || self.currentYearElement.max && newYear > self.currentYearElement.max) return;

		var newYearNum = parseInt(newYear, 10),
		    isNewYear = self.currentYear !== newYearNum;

		self.currentYear = newYearNum || self.currentYear;

		if (self.config.maxDate && self.currentYear === self.config.maxDate.getFullYear()) {
			self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
		} else if (self.config.minDate && self.currentYear === self.config.minDate.getFullYear()) {
			self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
		}

		if (isNewYear) {
			self.redraw();
			triggerEvent("YearChange");
		}
	}

	function isEnabled(date, timeless) {
		if (self.config.minDate && compareDates(date, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0 || self.config.maxDate && compareDates(date, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0) return false;

		if (!self.config.enable.length && !self.config.disable.length) return true;

		var dateToCheck = self.parseDate(date, null, true); // timeless

		var bool = self.config.enable.length > 0,
		    array = bool ? self.config.enable : self.config.disable;

		for (var i = 0, d; i < array.length; i++) {
			d = array[i];

			if (d instanceof Function && d(dateToCheck)) // disabled by function
				return bool;else if (d instanceof Date && d.getTime() === dateToCheck.getTime())
				// disabled by date
				return bool;else if (typeof d === "string" && self.parseDate(d, null, true).getTime() === dateToCheck.getTime())
				// disabled by date string
				return bool;else if ( // disabled by range
			(typeof d === "undefined" ? "undefined" : _typeof(d)) === "object" && d.from && d.to && dateToCheck >= d.from && dateToCheck <= d.to) return bool;
		}

		return !bool;
	}

	function onKeyDown(e) {
		var isInput = e.target === self._input;
		var calendarElem = isCalendarElem(e.target);
		var allowInput = self.config.allowInput;
		var allowKeydown = self.isOpen && (!allowInput || !isInput);
		var allowInlineKeydown = self.config.inline && isInput && !allowInput;

		if (e.key === "Enter" && allowInput && isInput) {
			self.setDate(self._input.value, true, e.target === self.altInput ? self.config.altFormat : self.config.dateFormat);
			return e.target.blur();
		} else if (calendarElem || allowKeydown || allowInlineKeydown) {
			var isTimeObj = self.timeContainer && self.timeContainer.contains(e.target);
			switch (e.key) {
				case "Enter":
					if (isTimeObj) updateValue();else selectDate(e);

					break;

				case "Escape":
					// escape
					e.preventDefault();
					self.close();
					break;

				case "ArrowLeft":
				case "ArrowRight":
					if (!isTimeObj) {
						e.preventDefault();

						if (self.daysContainer) {
							var _delta = e.key === "ArrowRight" ? 1 : -1;

							if (!e.ctrlKey) focusOnDay(e.target.$i, _delta);else changeMonth(_delta, true);
						} else if (self.config.enableTime && !isTimeObj) self.hourElement.focus();
					}

					break;

				case "ArrowUp":
				case "ArrowDown":
					e.preventDefault();
					var delta = e.key === "ArrowDown" ? 1 : -1;

					if (self.daysContainer) {
						if (e.ctrlKey) {
							changeYear(self.currentYear - delta);
							focusOnDay(e.target.$i, 0);
						} else if (!isTimeObj) focusOnDay(e.target.$i, delta * 7);
					} else if (self.config.enableTime) {
						if (!isTimeObj) self.hourElement.focus();
						updateTime(e);
					}

					break;

				case "Tab":
					if (e.target === self.hourElement) {
						e.preventDefault();
						self.minuteElement.select();
					} else if (e.target === self.minuteElement && (self.secondElement || self.amPM)) {
						e.preventDefault();
						(self.secondElement || self.amPM).focus();
					} else if (e.target === self.secondElement) {
						e.preventDefault();
						self.amPM.focus();
					}

					break;

				case "a":
					if (e.target === self.amPM) {
						self.amPM.textContent = "AM";
						setHoursFromInputs();
						updateValue();
					}
					break;

				case "p":
					if (e.target === self.amPM) {
						self.amPM.textContent = "PM";
						setHoursFromInputs();
						updateValue();
					}
					break;

				default:
					break;

			}

			triggerEvent("KeyDown", e);
		}
	}

	function onMouseOver(elem) {
		if (self.selectedDates.length !== 1 || !elem.classList.contains("flatpickr-day")) return;

		var hoverDate = elem.dateObj,
		    initialDate = self.parseDate(self.selectedDates[0], null, true),
		    rangeStartDate = Math.min(hoverDate.getTime(), self.selectedDates[0].getTime()),
		    rangeEndDate = Math.max(hoverDate.getTime(), self.selectedDates[0].getTime()),
		    containsDisabled = false;

		for (var t = rangeStartDate; t < rangeEndDate; t += self.utils.duration.DAY) {
			if (!isEnabled(new Date(t))) {
				containsDisabled = true;
				break;
			}
		}

		var _loop = function _loop(timestamp, i) {
			var outOfRange = timestamp < self.minRangeDate.getTime() || timestamp > self.maxRangeDate.getTime(),
			    dayElem = self.days.childNodes[i];

			if (outOfRange) {
				self.days.childNodes[i].classList.add("notAllowed");
				["inRange", "startRange", "endRange"].forEach(function (c) {
					dayElem.classList.remove(c);
				});
				return "continue";
			} else if (containsDisabled && !outOfRange) return "continue";

			["startRange", "inRange", "endRange", "notAllowed"].forEach(function (c) {
				dayElem.classList.remove(c);
			});

			var minRangeDate = Math.max(self.minRangeDate.getTime(), rangeStartDate),
			    maxRangeDate = Math.min(self.maxRangeDate.getTime(), rangeEndDate);

			elem.classList.add(hoverDate < self.selectedDates[0] ? "startRange" : "endRange");

			if (initialDate < hoverDate && timestamp === initialDate.getTime()) dayElem.classList.add("startRange");else if (initialDate > hoverDate && timestamp === initialDate.getTime()) dayElem.classList.add("endRange");

			if (timestamp >= minRangeDate && timestamp <= maxRangeDate) dayElem.classList.add("inRange");
		};

		for (var timestamp = self.days.childNodes[0].dateObj.getTime(), i = 0; i < 42; i++, timestamp += self.utils.duration.DAY) {
			var _ret = _loop(timestamp, i);

			if (_ret === "continue") continue;
		}
	}

	function onResize() {
		if (self.isOpen && !self.config.static && !self.config.inline) positionCalendar();
	}

	function open(e) {
		if (self.isMobile) {
			if (e) {
				e.preventDefault();
				e.target.blur();
			}

			setTimeout(function () {
				self.mobileInput.click();
			}, 0);

			triggerEvent("Open");
			return;
		}

		if (self.isOpen || self._input.disabled || self.config.inline) return;

		self.isOpen = true;
		self.calendarContainer.classList.add("open");
		positionCalendar();
		self._input.classList.add("active");

		triggerEvent("Open");
	}

	function minMaxDateSetter(type) {
		return function (date) {
			var dateObj = self.config["_" + type + "Date"] = self.parseDate(date);

			var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];
			var isValidDate = date && dateObj instanceof Date;

			if (isValidDate) {
				self[type + "DateHasTime"] = dateObj.getHours() || dateObj.getMinutes() || dateObj.getSeconds();
			}

			if (self.selectedDates) {
				self.selectedDates = self.selectedDates.filter(function (d) {
					return isEnabled(d);
				});
				if (!self.selectedDates.length && type === "min") setHoursFromDate(dateObj);
				updateValue();
			}

			if (self.daysContainer) {
				redraw();

				if (isValidDate) self.currentYearElement[type] = dateObj.getFullYear();else self.currentYearElement.removeAttribute(type);

				self.currentYearElement.disabled = inverseDateObj && dateObj && inverseDateObj.getFullYear() === dateObj.getFullYear();
			}
		};
	}

	function parseConfig() {
		var boolOpts = ["utc", "wrap", "weekNumbers", "allowInput", "clickOpens", "time_24hr", "enableTime", "noCalendar", "altInput", "shorthandCurrentMonth", "inline", "static", "enableSeconds", "disableMobile"];

		var hooks = ["onChange", "onClose", "onDayCreate", "onKeyDown", "onMonthChange", "onOpen", "onParseConfig", "onReady", "onValueUpdate", "onYearChange"];

		self.config = Object.create(Flatpickr.defaultConfig);

		var userConfig = _extends({}, self.instanceConfig, JSON.parse(JSON.stringify(self.element.dataset || {})));

		self.config.parseDate = userConfig.parseDate;
		self.config.formatDate = userConfig.formatDate;

		_extends(self.config, userConfig);

		if (!userConfig.dateFormat && userConfig.enableTime) {
			self.config.dateFormat = self.config.noCalendar ? "H:i" + (self.config.enableSeconds ? ":S" : "") : Flatpickr.defaultConfig.dateFormat + " H:i" + (self.config.enableSeconds ? ":S" : "");
		}

		if (userConfig.altInput && userConfig.enableTime && !userConfig.altFormat) {
			self.config.altFormat = self.config.noCalendar ? "h:i" + (self.config.enableSeconds ? ":S K" : " K") : Flatpickr.defaultConfig.altFormat + (" h:i" + (self.config.enableSeconds ? ":S" : "") + " K");
		}

		Object.defineProperty(self.config, "minDate", {
			get: function get() {
				return this._minDate;
			},
			set: minMaxDateSetter("min")
		});

		Object.defineProperty(self.config, "maxDate", {
			get: function get() {
				return this._maxDate;
			},
			set: minMaxDateSetter("max")
		});

		self.config.minDate = userConfig.minDate;
		self.config.maxDate = userConfig.maxDate;

		for (var i = 0; i < boolOpts.length; i++) {
			self.config[boolOpts[i]] = self.config[boolOpts[i]] === true || self.config[boolOpts[i]] === "true";
		}for (var _i = hooks.length; _i--;) {
			if (self.config[hooks[_i]] !== undefined) {
				self.config[hooks[_i]] = arrayify(self.config[hooks[_i]] || []).map(bindToInstance);
			}
		}

		for (var _i2 = 0; _i2 < self.config.plugins.length; _i2++) {
			var pluginConf = self.config.plugins[_i2](self) || {};
			for (var key in pluginConf) {

				if (self.config[key] instanceof Array || ~hooks.indexOf(key)) {
					self.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self.config[key]);
				} else if (typeof userConfig[key] === "undefined") self.config[key] = pluginConf[key];
			}
		}

		triggerEvent("ParseConfig");
	}

	function setupLocale() {
		if (_typeof(self.config.locale) !== "object" && typeof Flatpickr.l10ns[self.config.locale] === "undefined") console.warn("flatpickr: invalid locale " + self.config.locale);

		self.l10n = _extends(Object.create(Flatpickr.l10ns.default), _typeof(self.config.locale) === "object" ? self.config.locale : self.config.locale !== "default" ? Flatpickr.l10ns[self.config.locale] || {} : {});
	}

	function positionCalendar() {
		if (self.calendarContainer === undefined) return;

		var calendarHeight = self.calendarContainer.offsetHeight,
		    calendarWidth = self.calendarContainer.offsetWidth,
		    configPos = self.config.position,
		    inputBounds = self._positionElement.getBoundingClientRect(),
		    distanceFromBottom = window.innerHeight - inputBounds.bottom,
		    showOnTop = configPos === "above" || configPos !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;

		var top = window.pageYOffset + inputBounds.top + (!showOnTop ? self._positionElement.offsetHeight + 2 : -calendarHeight - 2);

		toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
		toggleClass(self.calendarContainer, "arrowBottom", showOnTop);

		if (self.config.inline) return;

		var left = window.pageXOffset + inputBounds.left;
		var right = window.document.body.offsetWidth - inputBounds.right;
		var rightMost = left + calendarWidth > window.document.body.offsetWidth;

		toggleClass(self.calendarContainer, "rightMost", rightMost);

		if (self.config.static) return;

		self.calendarContainer.style.top = top + "px";

		if (!rightMost) {
			self.calendarContainer.style.left = left + "px";
			self.calendarContainer.style.right = "auto";
		} else {
			self.calendarContainer.style.left = "auto";
			self.calendarContainer.style.right = right + "px";
		}
	}

	function redraw() {
		if (self.config.noCalendar || self.isMobile) return;

		buildWeekdays();
		updateNavigationCurrentMonth();
		buildDays();
	}

	function selectDate(e) {
		e.preventDefault();
		e.stopPropagation();

		if (!e.target.classList.contains("flatpickr-day") || e.target.classList.contains("disabled") || e.target.classList.contains("notAllowed")) return;

		var selectedDate = self.latestSelectedDateObj = new Date(e.target.dateObj.getTime());

		var shouldChangeMonth = selectedDate.getMonth() !== self.currentMonth && self.config.mode !== "range";

		self.selectedDateElem = e.target;

		if (self.config.mode === "single") self.selectedDates = [selectedDate];else if (self.config.mode === "multiple") {
			var selectedIndex = isDateSelected(selectedDate);
			if (selectedIndex) self.selectedDates.splice(selectedIndex, 1);else self.selectedDates.push(selectedDate);
		} else if (self.config.mode === "range") {
			if (self.selectedDates.length === 2) self.clear();

			self.selectedDates.push(selectedDate);

			// unless selecting same date twice, sort ascendingly
			if (compareDates(selectedDate, self.selectedDates[0], true) !== 0) self.selectedDates.sort(function (a, b) {
				return a.getTime() - b.getTime();
			});
		}

		setHoursFromInputs();

		if (shouldChangeMonth) {
			var isNewYear = self.currentYear !== selectedDate.getFullYear();
			self.currentYear = selectedDate.getFullYear();
			self.currentMonth = selectedDate.getMonth();

			if (isNewYear) triggerEvent("YearChange");

			triggerEvent("MonthChange");
		}

		buildDays();

		if (self.minDateHasTime && self.config.enableTime && compareDates(selectedDate, self.config.minDate) === 0) setHoursFromDate(self.config.minDate);

		updateValue();

		if (self.config.enableTime) setTimeout(function () {
			return self.showTimeInput = true;
		}, 50);

		if (self.config.mode === "range") {
			if (self.selectedDates.length === 1) {
				onMouseOver(e.target);

				self._hidePrevMonthArrow = self._hidePrevMonthArrow || self.minRangeDate > self.days.childNodes[0].dateObj;

				self._hideNextMonthArrow = self._hideNextMonthArrow || self.maxRangeDate < new Date(self.currentYear, self.currentMonth + 1, 1);
			} else updateNavigationCurrentMonth();
		}

		triggerEvent("Change");

		// maintain focus
		if (!shouldChangeMonth) focusOnDay(e.target.$i, 0);else afterDayAnim(function () {
			return self.selectedDateElem.focus();
		});

		if (self.config.enableTime) setTimeout(function () {
			return self.hourElement.select();
		}, 451);

		if (self.config.closeOnSelect) {
			var single = self.config.mode === "single" && !self.config.enableTime;
			var range = self.config.mode === "range" && self.selectedDates.length === 2 && !self.config.enableTime;

			if (single || range) self.close();
		}
	}

	function set(option, value) {
		self.config[option] = value;
		self.redraw();
		jumpToDate();
	}

	function setSelectedDate(inputDate, format) {
		if (inputDate instanceof Array) self.selectedDates = inputDate.map(function (d) {
			return self.parseDate(d, format);
		});else if (inputDate instanceof Date || !isNaN(inputDate)) self.selectedDates = [self.parseDate(inputDate, format)];else if (inputDate && inputDate.substring) {
			switch (self.config.mode) {
				case "single":
					self.selectedDates = [self.parseDate(inputDate, format)];
					break;

				case "multiple":
					self.selectedDates = inputDate.split("; ").map(function (date) {
						return self.parseDate(date, format);
					});
					break;

				case "range":
					self.selectedDates = inputDate.split(self.l10n.rangeSeparator).map(function (date) {
						return self.parseDate(date, format);
					});

					break;

				default:
					break;
			}
		}

		self.selectedDates = self.selectedDates.filter(function (d) {
			return d instanceof Date && isEnabled(d, false);
		});

		self.selectedDates.sort(function (a, b) {
			return a.getTime() - b.getTime();
		});
	}

	function setDate(date, triggerChange, format) {
		if (!date) return self.clear(triggerChange);

		setSelectedDate(date, format);

		self.showTimeInput = self.selectedDates.length > 0;
		self.latestSelectedDateObj = self.selectedDates[0];

		self.redraw();
		jumpToDate();

		setHoursFromDate();
		updateValue(triggerChange);

		if (triggerChange) triggerEvent("Change");
	}

	function setupDates() {
		function parseDateRules(arr) {
			for (var i = arr.length; i--;) {
				if (typeof arr[i] === "string" || +arr[i]) arr[i] = self.parseDate(arr[i], null, true);else if (arr[i] && arr[i].from && arr[i].to) {
					arr[i].from = self.parseDate(arr[i].from);
					arr[i].to = self.parseDate(arr[i].to);
				}
			}

			return arr.filter(function (x) {
				return x;
			}); // remove falsy values
		}

		self.selectedDates = [];
		self.now = new Date();

		if (self.config.disable.length) self.config.disable = parseDateRules(self.config.disable);

		if (self.config.enable.length) self.config.enable = parseDateRules(self.config.enable);

		var preloadedDate = self.config.defaultDate || self.input.value;
		if (preloadedDate) setSelectedDate(preloadedDate, self.config.dateFormat);

		var initialDate = self.selectedDates.length ? self.selectedDates[0] : self.config.minDate && self.config.minDate.getTime() > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate.getTime() < self.now ? self.config.maxDate : self.now;

		self.currentYear = initialDate.getFullYear();
		self.currentMonth = initialDate.getMonth();

		if (self.selectedDates.length) self.latestSelectedDateObj = self.selectedDates[0];

		self.minDateHasTime = self.config.minDate && (self.config.minDate.getHours() || self.config.minDate.getMinutes() || self.config.minDate.getSeconds());

		self.maxDateHasTime = self.config.maxDate && (self.config.maxDate.getHours() || self.config.maxDate.getMinutes() || self.config.maxDate.getSeconds());

		Object.defineProperty(self, "latestSelectedDateObj", {
			get: function get() {
				return self._selectedDateObj || self.selectedDates[self.selectedDates.length - 1];
			},
			set: function set(date) {
				self._selectedDateObj = date;
			}
		});

		if (!self.isMobile) {
			Object.defineProperty(self, "showTimeInput", {
				get: function get() {
					return self._showTimeInput;
				},
				set: function set(bool) {
					self._showTimeInput = bool;
					if (self.calendarContainer) toggleClass(self.calendarContainer, "showTimeInput", bool);
					positionCalendar();
				}
			});
		}
	}

	function setupHelperFunctions() {
		self.utils = {
			duration: {
				DAY: 86400000
			},
			getDaysinMonth: function getDaysinMonth(month, yr) {
				month = typeof month === "undefined" ? self.currentMonth : month;

				yr = typeof yr === "undefined" ? self.currentYear : yr;

				if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0)) return 29;

				return self.l10n.daysInMonth[month];
			},
			monthToStr: function monthToStr(monthNumber, shorthand) {
				shorthand = typeof shorthand === "undefined" ? self.config.shorthandCurrentMonth : shorthand;

				return self.l10n.months[(shorthand ? "short" : "long") + "hand"][monthNumber];
			}
		};
	}

	/* istanbul ignore next */
	function setupFormats() {
		["D", "F", "J", "M", "W", "l"].forEach(function (f) {
			self.formats[f] = Flatpickr.prototype.formats[f].bind(self);
		});

		self.revFormat.F = Flatpickr.prototype.revFormat.F.bind(self);
		self.revFormat.M = Flatpickr.prototype.revFormat.M.bind(self);
	}

	function setupInputs() {
		self.input = self.config.wrap ? self.element.querySelector("[data-input]") : self.element;

		/* istanbul ignore next */
		if (!self.input) return console.warn("Error: invalid input element specified", self.input);

		self.input._type = self.input.type;
		self.input.type = "text";

		self.input.classList.add("flatpickr-input");
		self._input = self.input;

		if (self.config.altInput) {
			// replicate self.element
			self.altInput = createElement(self.input.nodeName, self.input.className + " " + self.config.altInputClass);
			self._input = self.altInput;
			self.altInput.placeholder = self.input.placeholder;
			self.altInput.disabled = self.input.disabled;
			self.altInput.type = "text";
			self.input.type = "hidden";

			if (!self.config.static && self.input.parentNode) self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
		}

		if (!self.config.allowInput) self._input.setAttribute("readonly", "readonly");

		self._positionElement = self.config.positionElement || self._input;
	}

	function setupMobile() {
		var inputType = self.config.enableTime ? self.config.noCalendar ? "time" : "datetime-local" : "date";

		self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
		self.mobileInput.step = "any";
		self.mobileInput.tabIndex = 1;
		self.mobileInput.type = inputType;
		self.mobileInput.disabled = self.input.disabled;
		self.mobileInput.placeholder = self.input.placeholder;

		self.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";

		if (self.selectedDates.length) {
			self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
		}

		if (self.config.minDate) self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");

		if (self.config.maxDate) self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");

		self.input.type = "hidden";
		if (self.config.altInput) self.altInput.type = "hidden";

		try {
			self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
		} catch (e) {
			//
		}

		self.mobileInput.addEventListener("change", function (e) {
			self.setDate(e.target.value, false, self.mobileFormatStr);
			triggerEvent("Change");
			triggerEvent("Close");
		});
	}

	function toggle() {
		if (self.isOpen) return self.close();
		self.open();
	}

	function triggerEvent(event, data) {
		var hooks = self.config["on" + event];

		if (hooks !== undefined && hooks.length > 0) {
			for (var i = 0; hooks[i] && i < hooks.length; i++) {
				hooks[i](self.selectedDates, self.input.value, self, data);
			}
		}

		if (event === "Change") {
			self.input.dispatchEvent(createEvent("change"));

			// many front-end frameworks bind to the input event
			self.input.dispatchEvent(createEvent("input"));
		}
	}

	/**
  * Creates an Event, normalized across browsers
  * @param {String} name the event name, e.g. "click"
  * @return {Event} the created event
  */
	function createEvent(name) {
		if (self._supportsEvents) return new Event(name, { bubbles: true });

		self._[name + "Event"] = document.createEvent("Event");
		self._[name + "Event"].initEvent(name, true, true);
		return self._[name + "Event"];
	}

	function isDateSelected(date) {
		for (var i = 0; i < self.selectedDates.length; i++) {
			if (compareDates(self.selectedDates[i], date) === 0) return "" + i;
		}

		return false;
	}

	function isDateInRange(date) {
		if (self.config.mode !== "range" || self.selectedDates.length < 2) return false;
		return compareDates(date, self.selectedDates[0]) >= 0 && compareDates(date, self.selectedDates[1]) <= 0;
	}

	function updateNavigationCurrentMonth() {
		if (self.config.noCalendar || self.isMobile || !self.monthNav) return;

		self.currentMonthElement.textContent = self.utils.monthToStr(self.currentMonth) + " ";
		self.currentYearElement.value = self.currentYear;

		self._hidePrevMonthArrow = self.config.minDate && (self.currentYear === self.config.minDate.getFullYear() ? self.currentMonth <= self.config.minDate.getMonth() : self.currentYear < self.config.minDate.getFullYear());

		self._hideNextMonthArrow = self.config.maxDate && (self.currentYear === self.config.maxDate.getFullYear() ? self.currentMonth + 1 > self.config.maxDate.getMonth() : self.currentYear > self.config.maxDate.getFullYear());
	}

	/**
  * Updates the values of inputs associated with the calendar
  * @return {void}
  */
	function updateValue(triggerChange) {
		if (!self.selectedDates.length) return self.clear(triggerChange);

		if (self.isMobile) {
			self.mobileInput.value = self.selectedDates.length ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr) : "";
		}

		var joinChar = self.config.mode !== "range" ? "; " : self.l10n.rangeSeparator;

		self.input.value = self.selectedDates.map(function (dObj) {
			return self.formatDate(dObj, self.config.dateFormat);
		}).join(joinChar);

		if (self.config.altInput) {
			self.altInput.value = self.selectedDates.map(function (dObj) {
				return self.formatDate(dObj, self.config.altFormat);
			}).join(joinChar);
		}
		triggerEvent("ValueUpdate");
	}

	function mouseDelta(e) {
		return Math.max(-1, Math.min(1, e.wheelDelta || -e.deltaY));
	}

	function onMonthNavScroll(e) {
		e.preventDefault();
		var isYear = self.currentYearElement.parentNode.contains(e.target);

		if (e.target === self.currentMonthElement || isYear) {

			var delta = mouseDelta(e);

			if (isYear) {
				changeYear(self.currentYear + delta);
				e.target.value = self.currentYear;
			} else self.changeMonth(delta, true, false);
		}
	}

	function onMonthNavClick(e) {
		var isPrevMonth = self.prevMonthNav.contains(e.target);
		var isNextMonth = self.nextMonthNav.contains(e.target);

		if (isPrevMonth || isNextMonth) changeMonth(isPrevMonth ? -1 : 1);else if (e.target === self.currentYearElement) {
			e.preventDefault();
			self.currentYearElement.select();
		} else if (e.target.className === "arrowUp") self.changeYear(self.currentYear + 1);else if (e.target.className === "arrowDown") self.changeYear(self.currentYear - 1);
	}

	/**
  * Creates an HTMLElement with given tag, class, and textual content
  * @param {String} tag the HTML tag
  * @param {String} className the new element's class name
  * @param {String} content The new element's text content
  * @return {HTMLElement} the created HTML element
  */
	function createElement(tag, className, content) {
		var e = window.document.createElement(tag);
		className = className || "";
		content = content || "";

		e.className = className;

		if (content !== undefined) e.textContent = content;

		return e;
	}

	function arrayify(obj) {
		if (obj instanceof Array) return obj;
		return [obj];
	}

	function toggleClass(elem, className, bool) {
		if (bool) return elem.classList.add(className);
		elem.classList.remove(className);
	}

	/* istanbul ignore next */
	function debounce(func, wait, immediate) {
		var timeout = void 0;
		return function () {
			var context = this,
			    args = arguments;
			clearTimeout(timeout);
			timeout = setTimeout(function () {
				timeout = null;
				if (!immediate) func.apply(context, args);
			}, wait);
			if (immediate && !timeout) func.apply(context, args);
		};
	}

	/**
  * Compute the difference in dates, measured in ms
  * @param {Date} date1
  * @param {Date} date2
  * @param {Boolean} timeless whether to reset times of both dates to 00:00
  * @return {Number} the difference in ms
  */
	function compareDates(date1, date2, timeless) {
		if (!(date1 instanceof Date) || !(date2 instanceof Date)) return false;

		if (timeless !== false) {
			return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
		}

		return date1.getTime() - date2.getTime();
	}

	function timeWrapper(e) {
		e.preventDefault();

		var isKeyDown = e.type === "keydown",
		    isWheel = e.type === "wheel",
		    isIncrement = e.type === "increment",
		    input = e.target;

		if (self.amPM && e.target === self.amPM) return e.target.textContent = ["AM", "PM"][e.target.textContent === "AM" | 0];

		var min = Number(input.min),
		    max = Number(input.max),
		    step = Number(input.step),
		    curValue = parseInt(input.value, 10),
		    delta = e.delta || (!isKeyDown ? Math.max(-1, Math.min(1, e.wheelDelta || -e.deltaY)) || 0 : e.which === 38 ? 1 : -1);

		var newValue = curValue + step * delta;

		if (typeof input.value !== "undefined" && input.value.length === 2) {
			var isHourElem = input === self.hourElement,
			    isMinuteElem = input === self.minuteElement;

			if (newValue < min) {
				newValue = max + newValue + !isHourElem + (isHourElem && !self.amPM);

				if (isMinuteElem) incrementNumInput(null, -1, self.hourElement);
			} else if (newValue > max) {
				newValue = input === self.hourElement ? newValue - max - !self.amPM : min;

				if (isMinuteElem) incrementNumInput(null, 1, self.hourElement);
			}

			if (self.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) self.amPM.textContent = self.amPM.textContent === "PM" ? "AM" : "PM";

			input.value = self.pad(newValue);
		}
	}

	init();
	return self;
}

/* istanbul ignore next */
Flatpickr.defaultConfig = {
	mode: "single",

	position: "auto",

	animate: window.navigator.userAgent.indexOf("MSIE") === -1,

	/* if true, dates will be parsed, formatted, and displayed in UTC.
 preloading date strings w/ timezones is recommended but not necessary */
	utc: false,

	// wrap: see https://chmln.github.io/flatpickr/examples/#flatpickr-external-elements
	wrap: false,

	// enables week numbers
	weekNumbers: false,

	// allow manual datetime input
	allowInput: false,

	/*
 	clicking on input opens the date(time)picker.
 	disable if you wish to open the calendar manually with .open()
 */
	clickOpens: true,

	/*
 	closes calendar after date selection,
 	unless 'mode' is 'multiple' or enableTime is true
 */
	closeOnSelect: true,

	// display time picker in 24 hour mode
	time_24hr: false,

	// enables the time picker functionality
	enableTime: false,

	// noCalendar: true will hide the calendar. use for a time picker along w/ enableTime
	noCalendar: false,

	// more date format chars at https://chmln.github.io/flatpickr/#dateformat
	dateFormat: "Y-m-d",

	// date format used in aria-label for days
	ariaDateFormat: "F j, Y",

	// altInput - see https://chmln.github.io/flatpickr/#altinput
	altInput: false,

	// the created altInput element will have this class.
	altInputClass: "form-control input",

	// same as dateFormat, but for altInput
	altFormat: "F j, Y", // defaults to e.g. June 10, 2016

	// defaultDate - either a datestring or a date object. used for datetimepicker"s initial value
	defaultDate: null,

	// the minimum date that user can pick (inclusive)
	minDate: null,

	// the maximum date that user can pick (inclusive)
	maxDate: null,

	// dateparser that transforms a given string to a date object
	parseDate: null,

	// dateformatter that transforms a given date object to a string, according to passed format
	formatDate: null,

	getWeek: function getWeek(givenDate) {
		var date = new Date(givenDate.getTime());
		var onejan = new Date(date.getFullYear(), 0, 1);
		return Math.ceil(((date - onejan) / 86400000 + onejan.getDay() + 1) / 7);
	},


	// see https://chmln.github.io/flatpickr/#disable
	enable: [],

	// see https://chmln.github.io/flatpickr/#disable
	disable: [],

	// display the short version of month names - e.g. Sep instead of September
	shorthandCurrentMonth: false,

	// displays calendar inline. see https://chmln.github.io/flatpickr/#inline-calendar
	inline: false,

	// position calendar inside wrapper and next to the input element
	// leave at false unless you know what you"re doing
	"static": false,

	// DOM node to append the calendar to in *static* mode
	appendTo: null,

	// code for previous/next icons. this is where you put your custom icon code e.g. fontawesome
	prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
	nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",

	// enables seconds in the time picker
	enableSeconds: false,

	// step size used when scrolling/incrementing the hour element
	hourIncrement: 1,

	// step size used when scrolling/incrementing the minute element
	minuteIncrement: 5,

	// initial value in the hour element
	defaultHour: 12,

	// initial value in the minute element
	defaultMinute: 0,

	// disable native mobile datetime input support
	disableMobile: false,

	// default locale
	locale: "default",

	plugins: [],

	// called every time calendar is closed
	onClose: undefined, // function (dateObj, dateStr) {}

	// onChange callback when user selects a date or time
	onChange: undefined, // function (dateObj, dateStr) {}

	// called for every day element
	onDayCreate: undefined,

	// called every time the month is changed
	onMonthChange: undefined,

	// called every time calendar is opened
	onOpen: undefined, // function (dateObj, dateStr) {}

	// called after the configuration has been parsed
	onParseConfig: undefined,

	// called after calendar is ready
	onReady: undefined, // function (dateObj, dateStr) {}

	// called after input value updated
	onValueUpdate: undefined,

	// called every time the year is changed
	onYearChange: undefined,

	onKeyDown: undefined
};

/* istanbul ignore next */
Flatpickr.l10ns = {
	en: {
		weekdays: {
			shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
			longhand: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
		},
		months: {
			shorthand: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
			longhand: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
		},
		daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
		firstDayOfWeek: 0,
		ordinal: function ordinal(nth) {
			var s = nth % 100;
			if (s > 3 && s < 21) return "th";
			switch (s % 10) {
				case 1:
					return "st";
				case 2:
					return "nd";
				case 3:
					return "rd";
				default:
					return "th";
			}
		},
		rangeSeparator: " to ",
		weekAbbreviation: "Wk",
		scrollTitle: "Scroll to increment",
		toggleTitle: "Click to toggle"
	}
};

Flatpickr.l10ns.default = Object.create(Flatpickr.l10ns.en);
Flatpickr.localize = function (l10n) {
	return _extends(Flatpickr.l10ns.default, l10n || {});
};
Flatpickr.setDefaults = function (config) {
	return _extends(Flatpickr.defaultConfig, config || {});
};

Flatpickr.prototype = {
	formats: {
		// get the date in UTC
		Z: function Z(date) {
			return date.toISOString();
		},

		// weekday name, short, e.g. Thu
		D: function D(date) {
			return this.l10n.weekdays.shorthand[this.formats.w(date)];
		},

		// full month name e.g. January
		F: function F(date) {
			return this.utils.monthToStr(this.formats.n(date) - 1, false);
		},

		// padded hour 1-12
		G: function G(date) {
			return Flatpickr.prototype.pad(Flatpickr.prototype.formats.h(date));
		},

		// hours with leading zero e.g. 03
		H: function H(date) {
			return Flatpickr.prototype.pad(date.getHours());
		},

		// day (1-30) with ordinal suffix e.g. 1st, 2nd
		J: function J(date) {
			return date.getDate() + this.l10n.ordinal(date.getDate());
		},

		// AM/PM
		K: function K(date) {
			return date.getHours() > 11 ? "PM" : "AM";
		},

		// shorthand month e.g. Jan, Sep, Oct, etc
		M: function M(date) {
			return this.utils.monthToStr(date.getMonth(), true);
		},

		// seconds 00-59
		S: function S(date) {
			return Flatpickr.prototype.pad(date.getSeconds());
		},

		// unix timestamp
		U: function U(date) {
			return date.getTime() / 1000;
		},

		W: function W(date) {
			return this.config.getWeek(date);
		},

		// full year e.g. 2016
		Y: function Y(date) {
			return date.getFullYear();
		},

		// day in month, padded (01-30)
		d: function d(date) {
			return Flatpickr.prototype.pad(date.getDate());
		},

		// hour from 1-12 (am/pm)
		h: function h(date) {
			return date.getHours() % 12 ? date.getHours() % 12 : 12;
		},

		// minutes, padded with leading zero e.g. 09
		i: function i(date) {
			return Flatpickr.prototype.pad(date.getMinutes());
		},

		// day in month (1-30)
		j: function j(date) {
			return date.getDate();
		},

		// weekday name, full, e.g. Thursday
		l: function l(date) {
			return this.l10n.weekdays.longhand[date.getDay()];
		},

		// padded month number (01-12)
		m: function m(date) {
			return Flatpickr.prototype.pad(date.getMonth() + 1);
		},

		// the month number (1-12)
		n: function n(date) {
			return date.getMonth() + 1;
		},

		// seconds 0-59
		s: function s(date) {
			return date.getSeconds();
		},

		// number of the day of the week
		w: function w(date) {
			return date.getDay();
		},

		// last two digits of year e.g. 16 for 2016
		y: function y(date) {
			return String(date.getFullYear()).substring(2);
		}
	},

	/**
  * Formats a given Date object into a string based on supplied format
  * @param {Date} dateObj the date object
  * @param {String} frmt a string composed of formatting tokens e.g. "Y-m-d"
  * @return {String} The textual representation of the date e.g. 2017-02-03
  */
	formatDate: function formatDate(dateObj, frmt) {
		var _this = this;

		if (this.config !== undefined && this.config.formatDate !== undefined) return this.config.formatDate(dateObj, frmt);

		return frmt.split("").map(function (c, i, arr) {
			return _this.formats[c] && arr[i - 1] !== "\\" ? _this.formats[c](dateObj) : c !== "\\" ? c : "";
		}).join("");
	},


	revFormat: {
		D: function D() {},
		F: function F(dateObj, monthName) {
			dateObj.setMonth(this.l10n.months.longhand.indexOf(monthName));
		},
		G: function G(dateObj, hour) {
			dateObj.setHours(parseFloat(hour));
		},
		H: function H(dateObj, hour) {
			dateObj.setHours(parseFloat(hour));
		},
		J: function J(dateObj, day) {
			dateObj.setDate(parseFloat(day));
		},
		K: function K(dateObj, amPM) {
			var hours = dateObj.getHours();

			if (hours !== 12) dateObj.setHours(hours % 12 + 12 * /pm/i.test(amPM));
		},
		M: function M(dateObj, shortMonth) {
			dateObj.setMonth(this.l10n.months.shorthand.indexOf(shortMonth));
		},
		S: function S(dateObj, seconds) {
			dateObj.setSeconds(seconds);
		},
		U: function U(dateObj, unixSeconds) {
			return new Date(parseFloat(unixSeconds) * 1000);
		},

		W: function W(dateObj, weekNumber) {
			weekNumber = parseInt(weekNumber);
			return new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0, 0);
		},
		Y: function Y(dateObj, year) {
			dateObj.setFullYear(year);
		},
		Z: function Z(dateObj, ISODate) {
			return new Date(ISODate);
		},

		d: function d(dateObj, day) {
			dateObj.setDate(parseFloat(day));
		},
		h: function h(dateObj, hour) {
			dateObj.setHours(parseFloat(hour));
		},
		i: function i(dateObj, minutes) {
			dateObj.setMinutes(parseFloat(minutes));
		},
		j: function j(dateObj, day) {
			dateObj.setDate(parseFloat(day));
		},
		l: function l() {},
		m: function m(dateObj, month) {
			dateObj.setMonth(parseFloat(month) - 1);
		},
		n: function n(dateObj, month) {
			dateObj.setMonth(parseFloat(month) - 1);
		},
		s: function s(dateObj, seconds) {
			dateObj.setSeconds(parseFloat(seconds));
		},
		w: function w() {},
		y: function y(dateObj, year) {
			dateObj.setFullYear(2000 + parseFloat(year));
		}
	},

	tokenRegex: {
		D: "(\\w+)",
		F: "(\\w+)",
		G: "(\\d\\d|\\d)",
		H: "(\\d\\d|\\d)",
		J: "(\\d\\d|\\d)\\w+",
		K: "(\\w+)",
		M: "(\\w+)",
		S: "(\\d\\d|\\d)",
		U: "(.+)",
		W: "(\\d\\d|\\d)",
		Y: "(\\d{4})",
		Z: "(.+)",
		d: "(\\d\\d|\\d)",
		h: "(\\d\\d|\\d)",
		i: "(\\d\\d|\\d)",
		j: "(\\d\\d|\\d)",
		l: "(\\w+)",
		m: "(\\d\\d|\\d)",
		n: "(\\d\\d|\\d)",
		s: "(\\d\\d|\\d)",
		w: "(\\d\\d|\\d)",
		y: "(\\d{2})"
	},

	pad: function pad(number) {
		return ("0" + number).slice(-2);
	},

	/**
  * Parses a date(+time) string into a Date object
  * @param {String} date the date string, e.g. 2017-02-03 14:45
  * @param {String} givenFormat the date format, e.g. Y-m-d H:i
  * @param {Boolean} timeless whether to reset the time of Date object
  * @return {Date} the parsed Date object
  */
	parseDate: function parseDate(date, givenFormat, timeless) {
		if (!date) return null;

		var date_orig = date;

		if (date instanceof Date) {
			date = new Date(date.getTime()); // create a copy
			date.fp_isUTC = date_orig.fp_isUTC;
		} else if (date.toFixed !== undefined) // timestamp
			date = new Date(date);else {
			// date string
			var format = givenFormat || (this.config || Flatpickr.defaultConfig).dateFormat;
			date = String(date).trim();

			if (date === "today") {
				date = new Date();
				timeless = true;
			} else if (/Z$/.test(date) || /GMT$/.test(date)) // datestrings w/ timezone
				date = new Date(date);else if (this.config && this.config.parseDate) date = this.config.parseDate(date, format);else {
				var parsedDate = !this.config || !this.config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));

				var matched = void 0;

				for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
					var token = format[i];
					var isBackSlash = token === "\\";
					var escaped = format[i - 1] === "\\" || isBackSlash;

					if (this.tokenRegex[token] && !escaped) {
						regexStr += this.tokenRegex[token];
						var match = new RegExp(regexStr).exec(date);
						if (match && (matched = true)) {
							parsedDate = this.revFormat[token](parsedDate, match[++matchIndex]) || parsedDate;
						}
					} else if (!isBackSlash) regexStr += "."; // don't really care
				}

				date = matched ? parsedDate : null;
			}
		}

		/* istanbul ignore next */
		if (!(date instanceof Date)) {
			console.warn("flatpickr: invalid date " + date_orig);
			console.info(this.element);
			return null;
		}

		if (this.config && this.config.utc && !date.fp_isUTC) date = date.fp_toUTC();

		if (timeless === true) date.setHours(0, 0, 0, 0);

		return date;
	}
};

/* istanbul ignore next */
function _flatpickr(nodeList, config) {
	var nodes = Array.prototype.slice.call(nodeList); // static list
	var instances = [];
	for (var i = 0; i < nodes.length; i++) {
		try {
			nodes[i]._flatpickr = new Flatpickr(nodes[i], config || {});
			instances.push(nodes[i]._flatpickr);
		} catch (e) {
			console.warn(e, e.stack);
		}
	}

	return instances.length === 1 ? instances[0] : instances;
}

/* istanbul ignore next */
if (typeof HTMLElement !== "undefined") {
	// browser env
	HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
		return _flatpickr(this, config);
	};

	HTMLElement.prototype.flatpickr = function (config) {
		return _flatpickr([this], config);
	};
}

/* istanbul ignore next */
function flatpickr(selector, config) {
	return _flatpickr(window.document.querySelectorAll(selector), config);
}

/* istanbul ignore next */
if (typeof jQuery !== "undefined") {
	jQuery.fn.flatpickr = function (config) {
		return _flatpickr(this, config);
	};
}

Date.prototype.fp_incr = function (days) {
	return new Date(this.getFullYear(), this.getMonth(), this.getDate() + parseInt(days, 10));
};

Date.prototype.fp_isUTC = false;
Date.prototype.fp_toUTC = function () {
	var newDate = new Date(this.getUTCFullYear(), this.getUTCMonth(), this.getUTCDate(), this.getUTCHours(), this.getUTCMinutes(), this.getUTCSeconds());

	newDate.fp_isUTC = true;
	return newDate;
};

if (typeof module !== "undefined") module.exports = Flatpickr;
},{}],53:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _EventEmitter2 = require('./EventEmitter');

var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function remove(arr, what) {
  var found = arr.indexOf(what);

  while (found !== -1) {
    arr.splice(found, 1);
    found = arr.indexOf(what);
  }
}

var Connector = function (_EventEmitter) {
  _inherits(Connector, _EventEmitter);

  function Connector(backend, store, services) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, Connector);

    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

    _this.backend = backend;
    _this.store = store;
    _this.services = services;
    _this.options = options;
    _this.logger = _logger2.default.create('backendConnector');

    _this.state = {};
    _this.queue = [];

    _this.backend && _this.backend.init && _this.backend.init(services, options.backend, options);
    return _this;
  }

  Connector.prototype.queueLoad = function queueLoad(languages, namespaces, callback) {
    var _this2 = this;

    // find what needs to be loaded
    var toLoad = [],
        pending = [],
        toLoadLanguages = [],
        toLoadNamespaces = [];

    languages.forEach(function (lng) {
      var hasAllNamespaces = true;

      namespaces.forEach(function (ns) {
        var name = lng + '|' + ns;

        if (_this2.store.hasResourceBundle(lng, ns)) {
          _this2.state[name] = 2; // loaded
        } else if (_this2.state[name] < 0) {
          // nothing to do for err
        } else if (_this2.state[name] === 1) {
          if (pending.indexOf(name) < 0) pending.push(name);
        } else {
          _this2.state[name] = 1; // pending

          hasAllNamespaces = false;

          if (pending.indexOf(name) < 0) pending.push(name);
          if (toLoad.indexOf(name) < 0) toLoad.push(name);
          if (toLoadNamespaces.indexOf(ns) < 0) toLoadNamespaces.push(ns);
        }
      });

      if (!hasAllNamespaces) toLoadLanguages.push(lng);
    });

    if (toLoad.length || pending.length) {
      this.queue.push({
        pending: pending,
        loaded: {},
        errors: [],
        callback: callback
      });
    }

    return {
      toLoad: toLoad,
      pending: pending,
      toLoadLanguages: toLoadLanguages,
      toLoadNamespaces: toLoadNamespaces
    };
  };

  Connector.prototype.loaded = function loaded(name, err, data) {
    var _this3 = this;

    var _name$split = name.split('|'),
        _name$split2 = _slicedToArray(_name$split, 2),
        lng = _name$split2[0],
        ns = _name$split2[1];

    if (err) this.emit('failedLoading', lng, ns, err);

    if (data) {
      this.store.addResourceBundle(lng, ns, data);
    }

    // set loaded
    this.state[name] = err ? -1 : 2;
    // callback if ready
    this.queue.forEach(function (q) {
      utils.pushPath(q.loaded, [lng], ns);
      remove(q.pending, name);

      if (err) q.errors.push(err);

      if (q.pending.length === 0 && !q.done) {
        _this3.emit('loaded', q.loaded);
        q.errors.length ? q.callback(q.errors) : q.callback();
        q.done = true;
      }
    });

    // remove done load requests
    this.queue = this.queue.filter(function (q) {
      return !q.done;
    });
  };

  Connector.prototype.read = function read(lng, ns, fcName, tried, wait, callback) {
    var _this4 = this;

    if (!tried) tried = 0;
    if (!wait) wait = 250;

    if (!lng.length) return callback(null, {}); // noting to load

    this.backend[fcName](lng, ns, function (err, data) {
      if (err && data /* = retryFlag */ && tried < 5) {
        setTimeout(function () {
          _this4.read.call(_this4, lng, ns, fcName, ++tried, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data);
    });
  };

  Connector.prototype.load = function load(languages, namespaces, callback) {
    var _this5 = this;

    if (!this.backend) {
      this.logger.warn('No backend was added via i18next.use. Will not load resources.');
      return callback && callback();
    }
    var options = _extends({}, this.backend.options, this.options.backend);

    if (typeof languages === 'string') languages = this.services.languageUtils.toResolveHierarchy(languages);
    if (typeof namespaces === 'string') namespaces = [namespaces];

    var toLoad = this.queueLoad(languages, namespaces, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length) callback(); // nothing to load and no pendings...callback now
      return; // pendings will trigger callback
    }

    // load with multi-load
    if (options.allowMultiLoading && this.backend.readMulti) {
      this.read(toLoad.toLoadLanguages, toLoad.toLoadNamespaces, 'readMulti', null, null, function (err, data) {
        if (err) _this5.logger.warn('loading namespaces ' + toLoad.toLoadNamespaces.join(', ') + ' for languages ' + toLoad.toLoadLanguages.join(', ') + ' via multiloading failed', err);
        if (!err && data) _this5.logger.log('loaded namespaces ' + toLoad.toLoadNamespaces.join(', ') + ' for languages ' + toLoad.toLoadLanguages.join(', ') + ' via multiloading', data);

        toLoad.toLoad.forEach(function (name) {
          var _name$split3 = name.split('|'),
              _name$split4 = _slicedToArray(_name$split3, 2),
              l = _name$split4[0],
              n = _name$split4[1];

          var bundle = utils.getPath(data, [l, n]);
          if (bundle) {
            _this5.loaded(name, err, bundle);
          } else {
            var _err = 'loading namespace ' + n + ' for language ' + l + ' via multiloading failed';
            _this5.loaded(name, _err);
            _this5.logger.error(_err);
          }
        });
      });
    }

    // load one by one
    else {
        (function () {
          var readOne = function readOne(name) {
            var _this6 = this;

            var _name$split5 = name.split('|'),
                _name$split6 = _slicedToArray(_name$split5, 2),
                lng = _name$split6[0],
                ns = _name$split6[1];

            this.read(lng, ns, 'read', null, null, function (err, data) {
              if (err) _this6.logger.warn('loading namespace ' + ns + ' for language ' + lng + ' failed', err);
              if (!err && data) _this6.logger.log('loaded namespace ' + ns + ' for language ' + lng, data);

              _this6.loaded(name, err, data);
            });
          };

          ;

          toLoad.toLoad.forEach(function (name) {
            readOne.call(_this5, name);
          });
        })();
      }
  };

  Connector.prototype.reload = function reload(languages, namespaces) {
    var _this7 = this;

    if (!this.backend) {
      this.logger.warn('No backend was added via i18next.use. Will not load resources.');
    }
    var options = _extends({}, this.backend.options, this.options.backend);

    if (typeof languages === 'string') languages = this.services.languageUtils.toResolveHierarchy(languages);
    if (typeof namespaces === 'string') namespaces = [namespaces];

    // load with multi-load
    if (options.allowMultiLoading && this.backend.readMulti) {
      this.read(languages, namespaces, 'readMulti', null, null, function (err, data) {
        if (err) _this7.logger.warn('reloading namespaces ' + namespaces.join(', ') + ' for languages ' + languages.join(', ') + ' via multiloading failed', err);
        if (!err && data) _this7.logger.log('reloaded namespaces ' + namespaces.join(', ') + ' for languages ' + languages.join(', ') + ' via multiloading', data);

        languages.forEach(function (l) {
          namespaces.forEach(function (n) {
            var bundle = utils.getPath(data, [l, n]);
            if (bundle) {
              _this7.loaded(l + '|' + n, err, bundle);
            } else {
              var _err2 = 'reloading namespace ' + n + ' for language ' + l + ' via multiloading failed';
              _this7.loaded(l + '|' + n, _err2);
              _this7.logger.error(_err2);
            }
          });
        });
      });
    }

    // load one by one
    else {
        (function () {
          var readOne = function readOne(name) {
            var _this8 = this;

            var _name$split7 = name.split('|'),
                _name$split8 = _slicedToArray(_name$split7, 2),
                lng = _name$split8[0],
                ns = _name$split8[1];

            this.read(lng, ns, 'read', null, null, function (err, data) {
              if (err) _this8.logger.warn('reloading namespace ' + ns + ' for language ' + lng + ' failed', err);
              if (!err && data) _this8.logger.log('reloaded namespace ' + ns + ' for language ' + lng, data);

              _this8.loaded(name, err, data);
            });
          };

          ;

          languages.forEach(function (l) {
            namespaces.forEach(function (n) {
              readOne.call(_this7, l + '|' + n);
            });
          });
        })();
      }
  };

  Connector.prototype.saveMissing = function saveMissing(languages, namespace, key, fallbackValue) {
    if (this.backend && this.backend.create) this.backend.create(languages, namespace, key, fallbackValue);

    // write to store to avoid resending
    if (!languages || !languages[0]) return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  };

  return Connector;
}(_EventEmitter3.default);

exports.default = Connector;
},{"./EventEmitter":55,"./logger":65,"./utils":67}],54:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _EventEmitter2 = require('./EventEmitter');

var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var Connector = function (_EventEmitter) {
  _inherits(Connector, _EventEmitter);

  function Connector(cache, store, services) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, Connector);

    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

    _this.cache = cache;
    _this.store = store;
    _this.services = services;
    _this.options = options;
    _this.logger = _logger2.default.create('cacheConnector');

    _this.cache && _this.cache.init && _this.cache.init(services, options.cache, options);
    return _this;
  }

  Connector.prototype.load = function load(languages, namespaces, callback) {
    var _this2 = this;

    if (!this.cache) return callback && callback();
    var options = _extends({}, this.cache.options, this.options.cache);

    if (typeof languages === 'string') languages = this.services.languageUtils.toResolveHierarchy(languages);
    if (typeof namespaces === 'string') namespaces = [namespaces];

    if (options.enabled) {
      this.cache.load(languages, function (err, data) {
        if (err) _this2.logger.error('loading languages ' + languages.join(', ') + ' from cache failed', err);
        if (data) {
          for (var l in data) {
            for (var n in data[l]) {
              if (n === 'i18nStamp') continue;
              var bundle = data[l][n];
              if (bundle) _this2.store.addResourceBundle(l, n, bundle);
            }
          }
        }
        if (callback) callback();
      });
    } else {
      if (callback) callback();
    }
  };

  Connector.prototype.save = function save() {
    if (this.cache && this.options.cache && this.options.cache.enabled) this.cache.save(this.store.data);
  };

  return Connector;
}(_EventEmitter3.default);

exports.default = Connector;
},{"./EventEmitter":55,"./logger":65,"./utils":67}],55:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EventEmitter = function () {
	function EventEmitter() {
		_classCallCheck(this, EventEmitter);

		this.observers = {};
	}

	EventEmitter.prototype.on = function on(events, listener) {
		var _this = this;

		events.split(' ').forEach(function (event) {
			_this.observers[event] = _this.observers[event] || [];
			_this.observers[event].push(listener);
		});
	};

	EventEmitter.prototype.off = function off(event, listener) {
		var _this2 = this;

		if (!this.observers[event]) {
			return;
		}

		this.observers[event].forEach(function () {
			if (!listener) {
				delete _this2.observers[event];
			} else {
				var index = _this2.observers[event].indexOf(listener);
				if (index > -1) {
					_this2.observers[event].splice(index, 1);
				}
			}
		});
	};

	EventEmitter.prototype.emit = function emit(event) {
		for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			args[_key - 1] = arguments[_key];
		}

		if (this.observers[event]) {
			var cloned = [].concat(this.observers[event]);
			cloned.forEach(function (observer) {
				observer.apply(undefined, args);
			});
		}

		if (this.observers['*']) {
			var _cloned = [].concat(this.observers['*']);
			_cloned.forEach(function (observer) {
				var _ref;

				observer.apply(observer, (_ref = [event]).concat.apply(_ref, args));
			});
		}
	};

	return EventEmitter;
}();

exports.default = EventEmitter;
},{}],56:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Interpolator = function () {
  function Interpolator() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Interpolator);

    this.logger = _logger2.default.create('interpolator');

    this.init(options, true);
  }

  Interpolator.prototype.init = function init() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var reset = arguments[1];

    if (reset) {
      this.options = options;
      this.format = options.interpolation && options.interpolation.format || function (value) {
        return value;
      };
      this.escape = options.interpolation && options.interpolation.escape || utils.escape;
    }
    if (!options.interpolation) options.interpolation = { escapeValue: true };

    var iOpts = options.interpolation;

    this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;

    this.prefix = iOpts.prefix ? utils.regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';
    this.suffix = iOpts.suffix ? utils.regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';
    this.formatSeparator = iOpts.formatSeparator ? utils.regexEscape(iOpts.formatSeparator) : iOpts.formatSeparator || ',';

    this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';
    this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';

    this.nestingPrefix = iOpts.nestingPrefix ? utils.regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || utils.regexEscape('$t(');
    this.nestingSuffix = iOpts.nestingSuffix ? utils.regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || utils.regexEscape(')');

    // the regexp
    this.resetRegExp();
  };

  Interpolator.prototype.reset = function reset() {
    if (this.options) this.init(this.options);
  };

  Interpolator.prototype.resetRegExp = function resetRegExp() {
    // the regexp
    var regexpStr = this.prefix + '(.+?)' + this.suffix;
    this.regexp = new RegExp(regexpStr, 'g');

    var regexpUnescapeStr = this.prefix + this.unescapePrefix + '(.+?)' + this.unescapeSuffix + this.suffix;
    this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');

    var nestingRegexpStr = this.nestingPrefix + '(.+?)' + this.nestingSuffix;
    this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');
  };

  Interpolator.prototype.interpolate = function interpolate(str, data, lng) {
    var _this = this;

    var match = void 0,
        value = void 0;

    function regexSafe(val) {
      return val.replace(/\$/g, '$$$$');
    }

    var handleFormat = function handleFormat(key) {
      if (key.indexOf(_this.formatSeparator) < 0) return utils.getPath(data, key);

      var p = key.split(_this.formatSeparator);
      var k = p.shift().trim();
      var f = p.join(_this.formatSeparator).trim();

      return _this.format(utils.getPath(data, k), f, lng);
    };

    this.resetRegExp();

    // unescape if has unescapePrefix/Suffix
    while (match = this.regexpUnescape.exec(str)) {
      var _value = handleFormat(match[1].trim());
      str = str.replace(match[0], _value);
      this.regexpUnescape.lastIndex = 0;
    }

    // regular escape on demand
    while (match = this.regexp.exec(str)) {
      value = handleFormat(match[1].trim());
      if (typeof value !== 'string') value = utils.makeString(value);
      if (!value) {
        this.logger.warn('missed to pass in variable ' + match[1] + ' for interpolating ' + str);
        value = '';
      }
      value = this.escapeValue ? regexSafe(this.escape(value)) : regexSafe(value);
      str = str.replace(match[0], value);
      this.regexp.lastIndex = 0;
    }
    return str;
  };

  Interpolator.prototype.nest = function nest(str, fc) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var match = void 0,
        value = void 0;

    var clonedOptions = JSON.parse(JSON.stringify(options));
    clonedOptions.applyPostProcessor = false; // avoid post processing on nested lookup

    function regexSafe(val) {
      return val.replace(/\$/g, '$$$$');
    }

    // if value is something like "myKey": "lorem $(anotherKey, { "count": {{aValueInOptions}} })"
    function handleHasOptions(key) {
      if (key.indexOf(',') < 0) return key;

      var p = key.split(',');
      key = p.shift();
      var optionsString = p.join(',');
      optionsString = this.interpolate(optionsString, clonedOptions);
      optionsString = optionsString.replace(/'/g, '"');

      try {
        clonedOptions = JSON.parse(optionsString);
      } catch (e) {
        this.logger.error('failed parsing options string in nesting for key ' + key, e);
      }

      return key;
    }

    // regular escape on demand
    while (match = this.nestingRegexp.exec(str)) {
      value = fc(handleHasOptions.call(this, match[1].trim()), clonedOptions);
      if (typeof value !== 'string') value = utils.makeString(value);
      if (!value) {
        this.logger.warn('missed to pass in variable ' + match[1] + ' for interpolating ' + str);
        value = '';
      }
      // Nested keys should not be escaped by default #854
      // value = this.escapeValue ? regexSafe(utils.escape(value)) : regexSafe(value);
      str = str.replace(match[0], value);
      this.regexp.lastIndex = 0;
    }
    return str;
  };

  return Interpolator;
}();

exports.default = Interpolator;
},{"./logger":65,"./utils":67}],57:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

var LanguageUtil = function () {
  function LanguageUtil(options) {
    _classCallCheck(this, LanguageUtil);

    this.options = options;

    this.whitelist = this.options.whitelist || false;
    this.logger = _logger2.default.create('languageUtils');
  }

  LanguageUtil.prototype.getLanguagePartFromCode = function getLanguagePartFromCode(code) {
    if (code.indexOf('-') < 0) return code;

    var specialCases = ['NB-NO', 'NN-NO', 'nb-NO', 'nn-NO', 'nb-no', 'nn-no'];
    var p = code.split('-');
    return this.formatLanguageCode(specialCases.indexOf(code) > -1 ? p[1].toLowerCase() : p[0]);
  };

  LanguageUtil.prototype.getScriptPartFromCode = function getScriptPartFromCode(code) {
    if (code.indexOf('-') < 0) return null;

    var p = code.split('-');
    if (p.length === 2) return null;
    p.pop();
    return this.formatLanguageCode(p.join('-'));
  };

  LanguageUtil.prototype.getLanguagePartFromCode = function getLanguagePartFromCode(code) {
    if (code.indexOf('-') < 0) return code;

    var specialCases = ['NB-NO', 'NN-NO', 'nb-NO', 'nn-NO', 'nb-no', 'nn-no'];
    var p = code.split('-');
    return this.formatLanguageCode(specialCases.indexOf(code) > -1 ? p[1].toLowerCase() : p[0]);
  };

  LanguageUtil.prototype.formatLanguageCode = function formatLanguageCode(code) {
    // http://www.iana.org/assignments/language-tags/language-tags.xhtml
    if (typeof code === 'string' && code.indexOf('-') > -1) {
      var specialCases = ['hans', 'hant', 'latn', 'cyrl', 'cans', 'mong', 'arab'];
      var p = code.split('-');

      if (this.options.lowerCaseLng) {
        p = p.map(function (part) {
          return part.toLowerCase();
        });
      } else if (p.length === 2) {
        p[0] = p[0].toLowerCase();
        p[1] = p[1].toUpperCase();

        if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
      } else if (p.length === 3) {
        p[0] = p[0].toLowerCase();

        // if lenght 2 guess it's a country
        if (p[1].length === 2) p[1] = p[1].toUpperCase();
        if (p[0] !== 'sgn' && p[2].length === 2) p[2] = p[2].toUpperCase();

        if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
        if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());
      }

      return p.join('-');
    } else {
      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
    }
  };

  LanguageUtil.prototype.isWhitelisted = function isWhitelisted(code, exactMatch) {
    if (this.options.load === 'languageOnly' || this.options.nonExplicitWhitelist && !exactMatch) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.whitelist || !this.whitelist.length || this.whitelist.indexOf(code) > -1 ? true : false;
  };

  LanguageUtil.prototype.getFallbackCodes = function getFallbackCodes(fallbacks, code) {
    if (!fallbacks) return [];
    if (typeof fallbacks === 'string') fallbacks = [fallbacks];
    if (Object.prototype.toString.apply(fallbacks) === '[object Array]') return fallbacks;

    // asume we have an object defining fallbacks
    var found = fallbacks[code];
    if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found) found = fallbacks[this.formatLanguageCode(code)];
    if (!found) found = fallbacks.default;

    return found || [];
  };

  LanguageUtil.prototype.toResolveHierarchy = function toResolveHierarchy(code, fallbackCode) {
    var _this = this;

    var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);

    var codes = [];
    var addCode = function addCode(code) {
      var exactMatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!code) return;
      if (_this.isWhitelisted(code, exactMatch)) {
        codes.push(code);
      } else {
        _this.logger.warn('rejecting non-whitelisted language code: ' + code);
      }
    };

    if (typeof code === 'string' && code.indexOf('-') > -1) {
      if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code), true);
      if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code), true);
      if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));
    } else if (typeof code === 'string') {
      addCode(this.formatLanguageCode(code));
    }

    fallbackCodes.forEach(function (fc) {
      if (codes.indexOf(fc) < 0) addCode(_this.formatLanguageCode(fc));
    });

    return codes;
  };

  return LanguageUtil;
}();

;

exports.default = LanguageUtil;
},{"./logger":65}],58:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// definition http://translate.sourceforge.net/wiki/l10n/pluralforms
/* eslint-disable */
var sets = [{ lngs: ['ach', 'ak', 'am', 'arn', 'br', 'fil', 'gun', 'ln', 'mfe', 'mg', 'mi', 'oc', 'tg', 'ti', 'tr', 'uz', 'wa'], nr: [1, 2], fc: 1 }, { lngs: ['af', 'an', 'ast', 'az', 'bg', 'bn', 'ca', 'da', 'de', 'dev', 'el', 'en', 'eo', 'es', 'es_ar', 'et', 'eu', 'fi', 'fo', 'fur', 'fy', 'gl', 'gu', 'ha', 'he', 'hi', 'hu', 'hy', 'ia', 'it', 'kn', 'ku', 'lb', 'mai', 'ml', 'mn', 'mr', 'nah', 'nap', 'nb', 'ne', 'nl', 'nn', 'no', 'nso', 'pa', 'pap', 'pms', 'ps', 'pt', 'pt_br', 'rm', 'sco', 'se', 'si', 'so', 'son', 'sq', 'sv', 'sw', 'ta', 'te', 'tk', 'ur', 'yo'], nr: [1, 2], fc: 2 }, { lngs: ['ay', 'bo', 'cgg', 'fa', 'id', 'ja', 'jbo', 'ka', 'kk', 'km', 'ko', 'ky', 'lo', 'ms', 'sah', 'su', 'th', 'tt', 'ug', 'vi', 'wo', 'zh'], nr: [1], fc: 3 }, { lngs: ['be', 'bs', 'dz', 'hr', 'ru', 'sr', 'uk'], nr: [1, 2, 5], fc: 4 }, { lngs: ['ar'], nr: [0, 1, 2, 3, 11, 100], fc: 5 }, { lngs: ['cs', 'sk'], nr: [1, 2, 5], fc: 6 }, { lngs: ['csb', 'pl'], nr: [1, 2, 5], fc: 7 }, { lngs: ['cy'], nr: [1, 2, 3, 8], fc: 8 }, { lngs: ['fr'], nr: [1, 2], fc: 9 }, { lngs: ['ga'], nr: [1, 2, 3, 7, 11], fc: 10 }, { lngs: ['gd'], nr: [1, 2, 3, 20], fc: 11 }, { lngs: ['is'], nr: [1, 2], fc: 12 }, { lngs: ['jv'], nr: [0, 1], fc: 13 }, { lngs: ['kw'], nr: [1, 2, 3, 4], fc: 14 }, { lngs: ['lt'], nr: [1, 2, 10], fc: 15 }, { lngs: ['lv'], nr: [1, 2, 0], fc: 16 }, { lngs: ['mk'], nr: [1, 2], fc: 17 }, { lngs: ['mnk'], nr: [0, 1, 2], fc: 18 }, { lngs: ['mt'], nr: [1, 2, 11, 20], fc: 19 }, { lngs: ['or'], nr: [2, 1], fc: 2 }, { lngs: ['ro'], nr: [1, 2, 20], fc: 20 }, { lngs: ['sl'], nr: [5, 1, 2, 3], fc: 21 }];

var _rulesPluralsTypes = {
  1: function _(n) {
    return Number(n > 1);
  },
  2: function _(n) {
    return Number(n != 1);
  },
  3: function _(n) {
    return 0;
  },
  4: function _(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  5: function _(n) {
    return Number(n === 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
  },
  6: function _(n) {
    return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
  },
  7: function _(n) {
    return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  8: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
  },
  9: function _(n) {
    return Number(n >= 2);
  },
  10: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
  },
  11: function _(n) {
    return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
  },
  12: function _(n) {
    return Number(n % 10 != 1 || n % 100 == 11);
  },
  13: function _(n) {
    return Number(n !== 0);
  },
  14: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
  },
  15: function _(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  16: function _(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
  },
  17: function _(n) {
    return Number(n == 1 || n % 10 == 1 ? 0 : 1);
  },
  18: function _(n) {
    return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
  },
  19: function _(n) {
    return Number(n == 1 ? 0 : n === 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
  },
  20: function _(n) {
    return Number(n == 1 ? 0 : n === 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
  },
  21: function _(n) {
    return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
  }
};
/* eslint-enable */

function createRules() {
  var l,
      rules = {};
  sets.forEach(function (set) {
    set.lngs.forEach(function (l) {
      return rules[l] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  });
  return rules;
}

var PluralResolver = function () {
  function PluralResolver(languageUtils) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, PluralResolver);

    this.languageUtils = languageUtils;
    this.options = options;

    this.logger = _logger2.default.create('pluralResolver');

    this.rules = createRules();
  }

  PluralResolver.prototype.addRule = function addRule(lng, obj) {
    this.rules[lng] = obj;
  };

  PluralResolver.prototype.getRule = function getRule(code) {
    return this.rules[this.languageUtils.getLanguagePartFromCode(code)];
  };

  PluralResolver.prototype.needsPlural = function needsPlural(code) {
    var rule = this.getRule(code);

    return rule && rule.numbers.length <= 1 ? false : true;
  };

  PluralResolver.prototype.getSuffix = function getSuffix(code, count) {
    var _this = this;

    var rule = this.getRule(code);

    if (rule) {
      var _ret = function () {
        if (rule.numbers.length === 1) return {
            v: ''
          }; // only singular

        var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
        var suffix = rule.numbers[idx];

        // special treatment for lngs only having singular and plural
        if (rule.numbers.length === 2 && rule.numbers[0] === 1) {
          if (suffix === 2) {
            suffix = 'plural';
          } else if (suffix === 1) {
            suffix = '';
          }
        }

        var returnSuffix = function returnSuffix() {
          return _this.options.prepend && suffix.toString() ? _this.options.prepend + suffix.toString() : suffix.toString();
        };

        // COMPATIBILITY JSON
        // v1
        if (_this.options.compatibilityJSON === 'v1') {
          if (suffix === 1) return {
              v: ''
            };
          if (typeof suffix === 'number') return {
              v: '_plural_' + suffix.toString()
            };
          return {
            v: returnSuffix()
          };
        }
        // v2
        else if (_this.options.compatibilityJSON === 'v2' || rule.numbers.length === 2 && rule.numbers[0] === 1) {
            return {
              v: returnSuffix()
            };
          }
          // v3 - gettext index
          else if (rule.numbers.length === 2 && rule.numbers[0] === 1) {
              return {
                v: returnSuffix()
              };
            }
        return {
          v: _this.options.prepend && idx.toString() ? _this.options.prepend + idx.toString() : idx.toString()
        };
      }();

      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
    } else {
      this.logger.warn('no plural rule found for: ' + code);
      return '';
    }
  };

  return PluralResolver;
}();

;

exports.default = PluralResolver;
},{"./logger":65}],59:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _EventEmitter2 = require('./EventEmitter');

var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var ResourceStore = function (_EventEmitter) {
  _inherits(ResourceStore, _EventEmitter);

  function ResourceStore() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { ns: ['translation'], defaultNS: 'translation' };

    _classCallCheck(this, ResourceStore);

    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

    _this.data = data;
    _this.options = options;
    return _this;
  }

  ResourceStore.prototype.addNamespaces = function addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  };

  ResourceStore.prototype.removeNamespaces = function removeNamespaces(ns) {
    var index = this.options.ns.indexOf(ns);
    if (index > -1) {
      this.options.ns.splice(index, 1);
    }
  };

  ResourceStore.prototype.getResource = function getResource(lng, ns, key) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    var keySeparator = options.keySeparator || this.options.keySeparator;
    if (keySeparator === undefined) keySeparator = '.';

    var path = [lng, ns];
    if (key && typeof key !== 'string') path = path.concat(key);
    if (key && typeof key === 'string') path = path.concat(keySeparator ? key.split(keySeparator) : key);

    if (lng.indexOf('.') > -1) {
      path = lng.split('.');
    }

    return utils.getPath(this.data, path);
  };

  ResourceStore.prototype.addResource = function addResource(lng, ns, key, value) {
    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : { silent: false };

    var keySeparator = this.options.keySeparator;
    if (keySeparator === undefined) keySeparator = '.';

    var path = [lng, ns];
    if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);

    if (lng.indexOf('.') > -1) {
      path = lng.split('.');
      value = ns;
      ns = path[1];
    }

    this.addNamespaces(ns);

    utils.setPath(this.data, path, value);

    if (!options.silent) this.emit('added', lng, ns, key, value);
  };

  ResourceStore.prototype.addResources = function addResources(lng, ns, resources) {
    for (var m in resources) {
      if (typeof resources[m] === 'string') this.addResource(lng, ns, m, resources[m], { silent: true });
    }
    this.emit('added', lng, ns, resources);
  };

  ResourceStore.prototype.addResourceBundle = function addResourceBundle(lng, ns, resources, deep, overwrite) {
    var path = [lng, ns];
    if (lng.indexOf('.') > -1) {
      path = lng.split('.');
      deep = resources;
      resources = ns;
      ns = path[1];
    }

    this.addNamespaces(ns);

    var pack = utils.getPath(this.data, path) || {};

    if (deep) {
      utils.deepExtend(pack, resources, overwrite);
    } else {
      pack = _extends({}, pack, resources);
    }

    utils.setPath(this.data, path, pack);

    this.emit('added', lng, ns, resources);
  };

  ResourceStore.prototype.removeResourceBundle = function removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }
    this.removeNamespaces(ns);

    this.emit('removed', lng, ns);
  };

  ResourceStore.prototype.hasResourceBundle = function hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== undefined;
  };

  ResourceStore.prototype.getResourceBundle = function getResourceBundle(lng, ns) {
    if (!ns) ns = this.options.defaultNS;

    // TODO: COMPATIBILITY remove extend in v2.1.0
    if (this.options.compatibilityAPI === 'v1') return _extends({}, this.getResource(lng, ns));

    return this.getResource(lng, ns);
  };

  ResourceStore.prototype.toJSON = function toJSON() {
    return this.data;
  };

  return ResourceStore;
}(_EventEmitter3.default);

exports.default = ResourceStore;
},{"./EventEmitter":55,"./utils":67}],60:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _EventEmitter2 = require('./EventEmitter');

var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);

var _postProcessor = require('./postProcessor');

var _postProcessor2 = _interopRequireDefault(_postProcessor);

var _v = require('./compatibility/v1');

var compat = _interopRequireWildcard(_v);

var _utils = require('./utils');

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var Translator = function (_EventEmitter) {
  _inherits(Translator, _EventEmitter);

  function Translator(services) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Translator);

    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

    utils.copy(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector'], services, _this);

    _this.options = options;
    _this.logger = _logger2.default.create('translator');
    return _this;
  }

  Translator.prototype.changeLanguage = function changeLanguage(lng) {
    if (lng) this.language = lng;
  };

  Translator.prototype.exists = function exists(key) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { interpolation: {} };

    if (this.options.compatibilityAPI === 'v1') {
      options = compat.convertTOptions(options);
    }

    return this.resolve(key, options) !== undefined;
  };

  Translator.prototype.extractFromKey = function extractFromKey(key, options) {
    var nsSeparator = options.nsSeparator || this.options.nsSeparator;
    if (nsSeparator === undefined) nsSeparator = ':';
    var keySeparator = options.keySeparator || this.options.keySeparator || '.';

    var namespaces = options.ns || this.options.defaultNS;
    if (nsSeparator && key.indexOf(nsSeparator) > -1) {
      var parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
      key = parts.join(keySeparator);
    }
    if (typeof namespaces === 'string') namespaces = [namespaces];

    return {
      key: key,
      namespaces: namespaces
    };
  };

  Translator.prototype.translate = function translate(keys) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') {
      options = this.options.overloadTranslationOptionHandler(arguments);
    } else if (this.options.compatibilityAPI === 'v1') {
      options = compat.convertTOptions(options);
    }

    // non valid keys handling
    if (keys === undefined || keys === null || keys === '') return '';
    if (typeof keys === 'number') keys = String(keys);
    if (typeof keys === 'string') keys = [keys];

    // separators
    var keySeparator = options.keySeparator || this.options.keySeparator || '.';

    // get namespace(s)

    var _extractFromKey = this.extractFromKey(keys[keys.length - 1], options),
        key = _extractFromKey.key,
        namespaces = _extractFromKey.namespaces;

    var namespace = namespaces[namespaces.length - 1];

    // return key on CIMode
    var lng = options.lng || this.language;
    var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng && lng.toLowerCase() === 'cimode') {
      if (appendNamespaceToCIMode) {
        var nsSeparator = options.nsSeparator || this.options.nsSeparator;
        return namespace + nsSeparator + key;
      }

      return key;
    }

    // resolve from store
    var res = this.resolve(keys, options);

    var resType = Object.prototype.toString.apply(res);
    var noObject = ['[object Number]', '[object Function]', '[object RegExp]'];
    var joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;

    // object
    if (res && typeof res !== 'string' && noObject.indexOf(resType) < 0 && !(joinArrays && resType === '[object Array]')) {
      if (!options.returnObjects && !this.options.returnObjects) {
        this.logger.warn('accessing an object - but returnObjects options is not enabled!');
        return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(key, res, options) : 'key \'' + key + ' (' + this.language + ')\' returned an object instead of string.';
      }

      // if we got a separator we loop over children - else we just return object as is
      // as having it set to false means no hierarchy so no lookup for nested values
      if (options.keySeparator || this.options.keySeparator) {
        var copy = resType === '[object Array]' ? [] : {}; // apply child translation on a copy

        for (var m in res) {
          copy[m] = this.translate('' + key + keySeparator + m, _extends({ joinArrays: false, ns: namespaces }, options));
        }
        res = copy;
      }
    }
    // array special treatment
    else if (joinArrays && resType === '[object Array]') {
        res = res.join(joinArrays);
        if (res) res = this.extendTranslation(res, key, options);
      }
      // string, empty or null
      else {
          var usedDefault = false,
              usedKey = false;

          // fallback value
          if (!this.isValidLookup(res) && options.defaultValue !== undefined) {
            usedDefault = true;
            res = options.defaultValue;
          }
          if (!this.isValidLookup(res)) {
            usedKey = true;
            res = key;
          }

          // save missing
          if (usedKey || usedDefault) {
            this.logger.log('missingKey', lng, namespace, key, res);

            var lngs = [];
            var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
            if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {
              for (var i = 0; i < fallbackLngs.length; i++) {
                lngs.push(fallbackLngs[i]);
              }
            } else if (this.options.saveMissingTo === 'all') {
              lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
            } else {
              //(this.options.saveMissingTo === 'current' || (this.options.saveMissingTo === 'fallback' && this.options.fallbackLng[0] === false) ) {
              lngs.push(options.lng || this.language);
            }

            if (this.options.saveMissing) {
              if (this.options.missingKeyHandler) {
                this.options.missingKeyHandler(lngs, namespace, key, res);
              } else if (this.backendConnector && this.backendConnector.saveMissing) {
                this.backendConnector.saveMissing(lngs, namespace, key, res);
              }
            }

            this.emit('missingKey', lngs, namespace, key, res);
          }

          // extend
          res = this.extendTranslation(res, key, options);

          // append namespace if still key
          if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = namespace + ':' + key;

          // parseMissingKeyHandler
          if (usedKey && this.options.parseMissingKeyHandler) res = this.options.parseMissingKeyHandler(res);
        }

    // return
    return res;
  };

  Translator.prototype.extendTranslation = function extendTranslation(res, key, options) {
    var _this2 = this;

    if (options.interpolation) this.interpolator.init(_extends({}, options, { interpolation: _extends({}, this.options.interpolation, options.interpolation) }));

    // interpolate
    var data = options.replace && typeof options.replace !== 'string' ? options.replace : options;
    if (this.options.interpolation.defaultVariables) data = _extends({}, this.options.interpolation.defaultVariables, data);
    res = this.interpolator.interpolate(res, data, this.language);

    // nesting
    res = this.interpolator.nest(res, function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _this2.translate.apply(_this2, args);
    }, options);

    if (options.interpolation) this.interpolator.reset();

    // post process
    var postProcess = options.postProcess || this.options.postProcess;
    var postProcessorNames = typeof postProcess === 'string' ? [postProcess] : postProcess;

    if (res !== undefined && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
      res = _postProcessor2.default.handle(postProcessorNames, res, key, options, this);
    }

    return res;
  };

  Translator.prototype.resolve = function resolve(keys) {
    var _this3 = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var found = void 0;

    if (typeof keys === 'string') keys = [keys];

    // forEach possible key
    keys.forEach(function (k) {
      if (_this3.isValidLookup(found)) return;

      var _extractFromKey2 = _this3.extractFromKey(k, options),
          key = _extractFromKey2.key,
          namespaces = _extractFromKey2.namespaces;

      if (_this3.options.fallbackNS) namespaces = namespaces.concat(_this3.options.fallbackNS);

      var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';
      var needsContextHandling = options.context !== undefined && typeof options.context === 'string' && options.context !== '';

      var codes = options.lngs ? options.lngs : _this3.languageUtils.toResolveHierarchy(options.lng || _this3.language);

      namespaces.forEach(function (ns) {
        if (_this3.isValidLookup(found)) return;

        codes.forEach(function (code) {
          if (_this3.isValidLookup(found)) return;

          var finalKey = key;
          var finalKeys = [finalKey];

          var pluralSuffix = void 0;
          if (needsPluralHandling) pluralSuffix = _this3.pluralResolver.getSuffix(code, options.count);

          // fallback for plural if context not found
          if (needsPluralHandling && needsContextHandling) finalKeys.push(finalKey + pluralSuffix);

          // get key for context if needed
          if (needsContextHandling) finalKeys.push(finalKey += '' + _this3.options.contextSeparator + options.context);

          // get key for plural if needed
          if (needsPluralHandling) finalKeys.push(finalKey += pluralSuffix);

          // iterate over finalKeys starting with most specific pluralkey (-> contextkey only) -> singularkey only
          var possibleKey = void 0;
          while (possibleKey = finalKeys.pop()) {
            if (_this3.isValidLookup(found)) continue;
            found = _this3.getResource(code, ns, possibleKey, options);
          }
        });
      });
    });

    return found;
  };

  Translator.prototype.isValidLookup = function isValidLookup(res) {
    return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');
  };

  Translator.prototype.getResource = function getResource(code, ns, key) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    return this.resourceStore.getResource(code, ns, key, options);
  };

  return Translator;
}(_EventEmitter3.default);

exports.default = Translator;
},{"./EventEmitter":55,"./compatibility/v1":61,"./logger":65,"./postProcessor":66,"./utils":67}],61:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertAPIOptions = convertAPIOptions;
exports.convertJSONOptions = convertJSONOptions;
exports.convertTOptions = convertTOptions;
exports.appendBackwardsAPI = appendBackwardsAPI;

var _logger = require('../logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function convertInterpolation(options) {

  options.interpolation = {
    unescapeSuffix: 'HTML'
  };

  options.interpolation.prefix = options.interpolationPrefix || '__';
  options.interpolation.suffix = options.interpolationSuffix || '__';
  options.interpolation.escapeValue = options.escapeInterpolation || false;

  options.interpolation.nestingPrefix = options.reusePrefix || '$t(';
  options.interpolation.nestingSuffix = options.reuseSuffix || ')';

  return options;
}

function convertAPIOptions(options) {
  if (options.resStore) options.resources = options.resStore;

  if (options.ns && options.ns.defaultNs) {
    options.defaultNS = options.ns.defaultNs;
    options.ns = options.ns.namespaces;
  } else {
    options.defaultNS = options.ns || 'translation';
  }

  if (options.fallbackToDefaultNS && options.defaultNS) options.fallbackNS = options.defaultNS;

  options.saveMissing = options.sendMissing;
  options.saveMissingTo = options.sendMissingTo || 'current';
  options.returnNull = options.fallbackOnNull ? false : true;
  options.returnEmptyString = options.fallbackOnEmpty ? false : true;
  options.returnObjects = options.returnObjectTrees;
  options.joinArrays = '\n';

  options.returnedObjectHandler = options.objectTreeKeyHandler;
  options.parseMissingKeyHandler = options.parseMissingKey;
  options.appendNamespaceToMissingKey = true;

  options.nsSeparator = options.nsseparator || ':';
  options.keySeparator = options.keyseparator || '.';

  if (options.shortcutFunction === 'sprintf') {
    options.overloadTranslationOptionHandler = function (args) {
      var values = [];

      for (var i = 1; i < args.length; i++) {
        values.push(args[i]);
      }

      return {
        postProcess: 'sprintf',
        sprintf: values
      };
    };
  }

  options.whitelist = options.lngWhitelist;
  options.preload = options.preload;
  if (options.load === 'current') options.load = 'currentOnly';
  if (options.load === 'unspecific') options.load = 'languageOnly';

  // backend
  options.backend = options.backend || {};
  options.backend.loadPath = options.resGetPath || 'locales/__lng__/__ns__.json';
  options.backend.addPath = options.resPostPath || 'locales/add/__lng__/__ns__';
  options.backend.allowMultiLoading = options.dynamicLoad;

  // cache
  options.cache = options.cache || {};
  options.cache.prefix = 'res_';
  options.cache.expirationTime = 7 * 24 * 60 * 60 * 1000;
  options.cache.enabled = options.useLocalStorage ? true : false;

  options = convertInterpolation(options);
  if (options.defaultVariables) options.interpolation.defaultVariables = options.defaultVariables;

  // TODO: deprecation
  // if (options.getAsync === false) throw deprecation error

  return options;
}

function convertJSONOptions(options) {
  options = convertInterpolation(options);
  options.joinArrays = '\n';

  return options;
}

function convertTOptions(options) {
  if (options.interpolationPrefix || options.interpolationSuffix || options.escapeInterpolation) {
    options = convertInterpolation(options);
  }

  options.nsSeparator = options.nsseparator;
  options.keySeparator = options.keyseparator;

  options.returnObjects = options.returnObjectTrees;

  return options;
}

function appendBackwardsAPI(i18n) {
  i18n.lng = function () {
    _logger2.default.deprecate('i18next.lng() can be replaced by i18next.language for detected language or i18next.languages for languages ordered by translation lookup.');
    return i18n.services.languageUtils.toResolveHierarchy(i18n.language)[0];
  };

  i18n.preload = function (lngs, cb) {
    _logger2.default.deprecate('i18next.preload() can be replaced with i18next.loadLanguages()');
    i18n.loadLanguages(lngs, cb);
  };

  i18n.setLng = function (lng, options, callback) {
    _logger2.default.deprecate('i18next.setLng() can be replaced with i18next.changeLanguage() or i18next.getFixedT() to get a translation function with fixed language or namespace.');
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }
    if (!options) options = {};

    if (options.fixLng === true) {
      if (callback) return callback(null, i18n.getFixedT(lng));
    }

    i18n.changeLanguage(lng, callback);
  };

  i18n.addPostProcessor = function (name, fc) {
    _logger2.default.deprecate('i18next.addPostProcessor() can be replaced by i18next.use({ type: \'postProcessor\', name: \'name\', process: fc })');
    i18n.use({
      type: 'postProcessor',
      name: name,
      process: fc
    });
  };
}
},{"../logger":65}],62:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.get = get;
exports.transformOptions = transformOptions;
function get() {
  return {
    debug: false,
    initImmediate: true,

    ns: ['translation'],
    defaultNS: ['translation'],
    fallbackLng: ['dev'],
    fallbackNS: false, // string or array of namespaces

    whitelist: false, // array with whitelisted languages
    nonExplicitWhitelist: false,
    load: 'all', // | currentOnly | languageOnly
    preload: false, // array with preload languages

    keySeparator: '.',
    nsSeparator: ':',
    pluralSeparator: '_',
    contextSeparator: '_',

    saveMissing: false, // enable to send missing values
    saveMissingTo: 'fallback', // 'current' || 'all'
    missingKeyHandler: false, // function(lng, ns, key, fallbackValue) -> override if prefer on handling

    postProcess: false, // string or array of postProcessor names
    returnNull: true, // allows null value as valid translation
    returnEmptyString: true, // allows empty string value as valid translation
    returnObjects: false,
    joinArrays: false, // or string to join array
    returnedObjectHandler: function returnedObjectHandler() {}, // function(key, value, options) triggered if key returns object but returnObjects is set to false
    parseMissingKeyHandler: false, // function(key) parsed a key that was not found in t() before returning
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function overloadTranslationOptionHandler(args) {
      return { defaultValue: args[1] };
    },

    interpolation: {
      escapeValue: true,
      format: function format(value, _format, lng) {
        return value;
      },
      prefix: '{{',
      suffix: '}}',
      formatSeparator: ',',
      // prefixEscaped: '{{',
      // suffixEscaped: '}}',
      // unescapeSuffix: '',
      unescapePrefix: '-',

      nestingPrefix: '$t(',
      nestingSuffix: ')',
      // nestingPrefixEscaped: '$t(',
      // nestingSuffixEscaped: ')',
      defaultVariables: undefined // object that can have values to interpolate on - extends passed in interpolation data
    }
  };
}

function transformOptions(options) {
  // create namespace object if namespace is passed in as string
  if (typeof options.ns === 'string') options.ns = [options.ns];
  if (typeof options.fallbackLng === 'string') options.fallbackLng = [options.fallbackLng];
  if (typeof options.fallbackNS === 'string') options.fallbackNS = [options.fallbackNS];

  // extend whitelist with cimode
  if (options.whitelist && options.whitelist.indexOf('cimode') < 0) options.whitelist.push('cimode');

  return options;
}
},{}],63:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _EventEmitter2 = require('./EventEmitter');

var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);

var _ResourceStore = require('./ResourceStore');

var _ResourceStore2 = _interopRequireDefault(_ResourceStore);

var _Translator = require('./Translator');

var _Translator2 = _interopRequireDefault(_Translator);

var _LanguageUtils = require('./LanguageUtils');

var _LanguageUtils2 = _interopRequireDefault(_LanguageUtils);

var _PluralResolver = require('./PluralResolver');

var _PluralResolver2 = _interopRequireDefault(_PluralResolver);

var _Interpolator = require('./Interpolator');

var _Interpolator2 = _interopRequireDefault(_Interpolator);

var _BackendConnector = require('./BackendConnector');

var _BackendConnector2 = _interopRequireDefault(_BackendConnector);

var _CacheConnector = require('./CacheConnector');

var _CacheConnector2 = _interopRequireDefault(_CacheConnector);

var _defaults2 = require('./defaults');

var _postProcessor = require('./postProcessor');

var _postProcessor2 = _interopRequireDefault(_postProcessor);

var _v = require('./compatibility/v1');

var compat = _interopRequireWildcard(_v);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function noop() {};

var I18n = function (_EventEmitter) {
  _inherits(I18n, _EventEmitter);

  function I18n() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var callback = arguments[1];

    _classCallCheck(this, I18n);

    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));

    _this.options = (0, _defaults2.transformOptions)(options);
    _this.services = {};
    _this.logger = _logger2.default;
    _this.modules = {};

    if (callback && !_this.isInitialized && !options.isClone) _this.init(options, callback);
    return _this;
  }

  I18n.prototype.init = function init(options, callback) {
    var _this2 = this;

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }
    if (!options) options = {};

    if (options.compatibilityAPI === 'v1') {
      this.options = _extends({}, (0, _defaults2.get)(), (0, _defaults2.transformOptions)(compat.convertAPIOptions(options)), {});
    } else if (options.compatibilityJSON === 'v1') {
      this.options = _extends({}, (0, _defaults2.get)(), (0, _defaults2.transformOptions)(compat.convertJSONOptions(options)), {});
    } else {
      this.options = _extends({}, (0, _defaults2.get)(), this.options, (0, _defaults2.transformOptions)(options));
    }
    if (!callback) callback = noop;

    function createClassOnDemand(ClassOrObject) {
      if (!ClassOrObject) return;
      if (typeof ClassOrObject === 'function') return new ClassOrObject();
      return ClassOrObject;
    }

    // init services
    if (!this.options.isClone) {
      if (this.modules.logger) {
        _logger2.default.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        _logger2.default.init(null, this.options);
      }

      var lu = new _LanguageUtils2.default(this.options);
      this.store = new _ResourceStore2.default(this.options.resources, this.options);

      var s = this.services;
      s.logger = _logger2.default;
      s.resourceStore = this.store;
      s.resourceStore.on('added removed', function (lng, ns) {
        s.cacheConnector.save();
      });
      s.languageUtils = lu;
      s.pluralResolver = new _PluralResolver2.default(lu, { prepend: this.options.pluralSeparator, compatibilityJSON: this.options.compatibilityJSON });
      s.interpolator = new _Interpolator2.default(this.options);

      s.backendConnector = new _BackendConnector2.default(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
      // pipe events from backendConnector
      s.backendConnector.on('*', function (event) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        _this2.emit.apply(_this2, [event].concat(args));
      });

      s.backendConnector.on('loaded', function (loaded) {
        s.cacheConnector.save();
      });

      s.cacheConnector = new _CacheConnector2.default(createClassOnDemand(this.modules.cache), s.resourceStore, s, this.options);
      // pipe events from backendConnector
      s.cacheConnector.on('*', function (event) {
        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        _this2.emit.apply(_this2, [event].concat(args));
      });

      if (this.modules.languageDetector) {
        s.languageDetector = createClassOnDemand(this.modules.languageDetector);
        s.languageDetector.init(s, this.options.detection, this.options);
      }

      this.translator = new _Translator2.default(this.services, this.options);
      // pipe events from translator
      this.translator.on('*', function (event) {
        for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }

        _this2.emit.apply(_this2, [event].concat(args));
      });
    }

    // append api
    var storeApi = ['getResource', 'addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle', 'hasResourceBundle', 'getResourceBundle'];
    storeApi.forEach(function (fcName) {
      _this2[fcName] = function () {
        return this.store[fcName].apply(this.store, arguments);
      };
    });

    // TODO: COMPATIBILITY remove this
    if (this.options.compatibilityAPI === 'v1') compat.appendBackwardsAPI(this);

    var load = function load() {
      _this2.changeLanguage(_this2.options.lng, function (err, t) {
        _this2.isInitialized = true;
        _this2.logger.log('initialized', _this2.options);
        _this2.emit('initialized', _this2.options);

        callback(err, t);
      });
    };

    if (this.options.resources || !this.options.initImmediate) {
      load();
    } else {
      setTimeout(load, 0);
    }

    return this;
  };

  I18n.prototype.loadResources = function loadResources() {
    var _this3 = this;

    var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;

    if (!this.options.resources) {
      var _ret = function () {
        if (_this3.language && _this3.language.toLowerCase() === 'cimode') return {
            v: callback()
          }; // avoid loading resources for cimode

        var toLoad = [];

        var append = function append(lng) {
          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
          lngs.forEach(function (l) {
            if (toLoad.indexOf(l) < 0) toLoad.push(l);
          });
        };

        append(_this3.language);

        if (_this3.options.preload) {
          _this3.options.preload.forEach(function (l) {
            append(l);
          });
        }

        _this3.services.cacheConnector.load(toLoad, _this3.options.ns, function () {
          _this3.services.backendConnector.load(toLoad, _this3.options.ns, callback);
        });
      }();

      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
    } else {
      callback(null);
    }
  };

  I18n.prototype.reloadResources = function reloadResources(lngs, ns) {
    if (!lngs) lngs = this.languages;
    if (!ns) ns = this.options.ns;
    this.services.backendConnector.reload(lngs, ns);
  };

  I18n.prototype.use = function use(module) {
    if (module.type === 'backend') {
      this.modules.backend = module;
    }

    if (module.type === 'cache') {
      this.modules.cache = module;
    }

    if (module.type === 'logger' || module.log && module.warn && module.warn) {
      this.modules.logger = module;
    }

    if (module.type === 'languageDetector') {
      this.modules.languageDetector = module;
    }

    if (module.type === 'postProcessor') {
      _postProcessor2.default.addPostProcessor(module);
    }

    return this;
  };

  I18n.prototype.changeLanguage = function changeLanguage(lng, callback) {
    var _this4 = this;

    var done = function done(err) {
      if (lng) {
        _this4.emit('languageChanged', lng);
        _this4.logger.log('languageChanged', lng);
      }

      if (callback) callback(err, function () {
        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        return _this4.t.apply(_this4, args);
      });
    };

    if (!lng && this.services.languageDetector) lng = this.services.languageDetector.detect();

    if (lng) {
      this.language = lng;
      this.languages = this.services.languageUtils.toResolveHierarchy(lng);

      this.translator.changeLanguage(lng);

      if (this.services.languageDetector) this.services.languageDetector.cacheUserLanguage(lng);
    }

    this.loadResources(function (err) {
      done(err);
    });
  };

  I18n.prototype.getFixedT = function getFixedT(lng, ns) {
    var _this5 = this;

    var fixedT = function fixedT(key) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var options = _extends({}, opts);
      options.lng = options.lng || fixedT.lng;
      options.ns = options.ns || fixedT.ns;
      return _this5.t(key, options);
    };
    fixedT.lng = lng;
    fixedT.ns = ns;
    return fixedT;
  };

  I18n.prototype.t = function t() {
    return this.translator && this.translator.translate.apply(this.translator, arguments);
  };

  I18n.prototype.exists = function exists() {
    return this.translator && this.translator.exists.apply(this.translator, arguments);
  };

  I18n.prototype.setDefaultNamespace = function setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  };

  I18n.prototype.loadNamespaces = function loadNamespaces(ns, callback) {
    var _this6 = this;

    if (!this.options.ns) return callback && callback();
    if (typeof ns === 'string') ns = [ns];

    ns.forEach(function (n) {
      if (_this6.options.ns.indexOf(n) < 0) _this6.options.ns.push(n);
    });

    this.loadResources(callback);
  };

  I18n.prototype.loadLanguages = function loadLanguages(lngs, callback) {
    if (typeof lngs === 'string') lngs = [lngs];
    var preloaded = this.options.preload || [];

    var newLngs = lngs.filter(function (lng) {
      return preloaded.indexOf(lng) < 0;
    });
    // Exit early if all given languages are already preloaded
    if (!newLngs.length) return callback();

    this.options.preload = preloaded.concat(newLngs);
    this.loadResources(callback);
  };

  I18n.prototype.dir = function dir(lng) {
    if (!lng) lng = this.language;
    if (!lng) return 'rtl';

    var rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam'];

    return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) >= 0 ? 'rtl' : 'ltr';
  };

  I18n.prototype.createInstance = function createInstance() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var callback = arguments[1];

    return new I18n(options, callback);
  };

  I18n.prototype.cloneInstance = function cloneInstance() {
    var _this7 = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

    var mergedOptions = _extends({}, options, this.options, { isClone: true });
    var clone = new I18n(mergedOptions, callback);
    var membersToCopy = ['store', 'services', 'language'];
    membersToCopy.forEach(function (m) {
      clone[m] = _this7[m];
    });
    clone.translator = new _Translator2.default(clone.services, clone.options);
    clone.translator.on('*', function (event) {
      for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        args[_key5 - 1] = arguments[_key5];
      }

      clone.emit.apply(clone, [event].concat(args));
    });
    clone.init(mergedOptions, callback);

    return clone;
  };

  return I18n;
}(_EventEmitter3.default);

exports.default = new I18n();
},{"./BackendConnector":53,"./CacheConnector":54,"./EventEmitter":55,"./Interpolator":56,"./LanguageUtils":57,"./PluralResolver":58,"./ResourceStore":59,"./Translator":60,"./compatibility/v1":61,"./defaults":62,"./logger":65,"./postProcessor":66}],64:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _i18next = require('./i18next');

var _i18next2 = _interopRequireDefault(_i18next);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _i18next2.default;
},{"./i18next":63}],65:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var consoleLogger = {
  type: 'logger',

  log: function log(args) {
    this._output('log', args);
  },
  warn: function warn(args) {
    this._output('warn', args);
  },
  error: function error(args) {
    this._output('error', args);
  },
  _output: function _output(type, args) {
    if (console && console[type]) console[type].apply(console, Array.prototype.slice.call(args));
  }
};

var Logger = function () {
  function Logger(concreteLogger) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Logger);

    this.init(concreteLogger, options);
  }

  Logger.prototype.init = function init(concreteLogger) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    this.prefix = options.prefix || 'i18next:';
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug === false ? false : true;
  };

  Logger.prototype.setDebug = function setDebug(bool) {
    this.debug = bool;
  };

  Logger.prototype.log = function log() {
    this.forward(arguments, 'log', '', true);
  };

  Logger.prototype.warn = function warn() {
    this.forward(arguments, 'warn', '', true);
  };

  Logger.prototype.error = function error() {
    this.forward(arguments, 'error', '');
  };

  Logger.prototype.deprecate = function deprecate() {
    this.forward(arguments, 'warn', 'WARNING DEPRECATED: ', true);
  };

  Logger.prototype.forward = function forward(args, lvl, prefix, debugOnly) {
    if (debugOnly && !this.debug) return;
    if (typeof args[0] === 'string') args[0] = prefix + this.prefix + ' ' + args[0];
    this.logger[lvl](args);
  };

  Logger.prototype.create = function create(moduleName) {
    var sub = new Logger(this.logger, _extends({ prefix: this.prefix + ':' + moduleName + ':' }, this.options));

    return sub;
  };

  // createInstance(options = {}) {
  //   return new Logger(options, callback);
  // }

  return Logger;
}();

;

exports.default = new Logger();
},{}],66:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {

  processors: {},

  addPostProcessor: function addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle: function handle(processors, value, key, options, translator) {
    var _this = this;

    processors.forEach(function (processor) {
      if (_this.processors[processor]) value = _this.processors[processor].process(value, key, options, translator);
    });

    return value;
  }
};
},{}],67:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeString = makeString;
exports.copy = copy;
exports.setPath = setPath;
exports.pushPath = pushPath;
exports.getPath = getPath;
exports.deepExtend = deepExtend;
exports.regexEscape = regexEscape;
exports.escape = escape;
function makeString(object) {
  if (object == null) return '';
  return '' + object;
}

function copy(a, s, t) {
  a.forEach(function (m) {
    if (s[m]) t[m] = s[m];
  });
}

function getLastOfPath(object, path, Empty) {
  function cleanKey(key) {
    return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;
  }

  var stack = typeof path !== 'string' ? [].concat(path) : path.split('.');
  while (stack.length > 1) {
    if (!object) return {};

    var key = cleanKey(stack.shift());
    if (!object[key] && Empty) object[key] = new Empty();
    object = object[key];
  }

  if (!object) return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}

function setPath(object, path, newValue) {
  var _getLastOfPath = getLastOfPath(object, path, Object),
      obj = _getLastOfPath.obj,
      k = _getLastOfPath.k;

  obj[k] = newValue;
}

function pushPath(object, path, newValue, concat) {
  var _getLastOfPath2 = getLastOfPath(object, path, Object),
      obj = _getLastOfPath2.obj,
      k = _getLastOfPath2.k;

  obj[k] = obj[k] || [];
  if (concat) obj[k] = obj[k].concat(newValue);
  if (!concat) obj[k].push(newValue);
}

function getPath(object, path) {
  var _getLastOfPath3 = getLastOfPath(object, path),
      obj = _getLastOfPath3.obj,
      k = _getLastOfPath3.k;

  if (!obj) return undefined;
  return obj[k];
}

function deepExtend(target, source, overwrite) {
  for (var prop in source) {
    if (prop in target) {
      // If we reached a leaf string in target or source then replace with source or skip depending on the 'overwrite' switch
      if (typeof target[prop] === 'string' || target[prop] instanceof String || typeof source[prop] === 'string' || source[prop] instanceof String) {
        if (overwrite) target[prop] = source[prop];
      } else {
        deepExtend(target[prop], source[prop], overwrite);
      }
    } else {
      target[prop] = source[prop];
    }
  }return target;
}

function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
}

/* eslint-disable */
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': '&quot;',
  "'": '&#39;',
  "/": '&#x2F;'
};
/* eslint-enable */

function escape(data) {
  if (typeof data === 'string') {
    return data.replace(/[&<>"'\/]/g, function (s) {
      return _entityMap[s];
    });
  } else {
    return data;
  }
}
},{}],68:[function(require,module,exports){
module.exports = require('./dist/commonjs/index.js').default;

},{"./dist/commonjs/index.js":64}],69:[function(require,module,exports){
/* globals define,module */
/*
Using a Universal Module Loader that should be browser, require, and AMD friendly
http://ricostacruz.com/cheatsheets/umdjs.html
*/
;(function(root, factory) {
  if (typeof define === "function" && define.amd) {
    define(factory);
  } else if (typeof exports === "object") {
    module.exports = factory();
  } else {
    root.jsonLogic = factory();
  }
}(this, function() {
  "use strict";
  /* globals console:false */

  if ( ! Array.isArray) {
    Array.isArray = function(arg) {
      return Object.prototype.toString.call(arg) === "[object Array]";
    };
  }

  /**
   * Return an array that contains no duplicates (original not modified)
   * @param  {array} array   Original reference array
   * @return {array}         New array with no duplicates
   */
  function arrayUnique(array) {
    var a = [];
    for (var i=0, l=array.length; i<l; i++) {
      if (a.indexOf(array[i]) === -1) {
        a.push(array[i]);
      }
    }
    return a;
  }

  var jsonLogic = {};
  var operations = {
    "==": function(a, b) {
      return a == b;
    },
    "===": function(a, b) {
      return a === b;
    },
    "!=": function(a, b) {
      return a != b;
    },
    "!==": function(a, b) {
      return a !== b;
    },
    ">": function(a, b) {
      return a > b;
    },
    ">=": function(a, b) {
      return a >= b;
    },
    "<": function(a, b, c) {
      return (c === undefined) ? a < b : (a < b) && (b < c);
    },
    "<=": function(a, b, c) {
      return (c === undefined) ? a <= b : (a <= b) && (b <= c);
    },
    "!!": function(a) {
      return jsonLogic.truthy(a);
    },
    "!": function(a) {
      return !jsonLogic.truthy(a);
    },
    "%": function(a, b) {
      return a % b;
    },
    "log": function(a) {
      console.log(a); return a;
    },
    "in": function(a, b) {
      if(typeof b.indexOf === "undefined") return false;
      return (b.indexOf(a) !== -1);
    },
    "cat": function() {
      return Array.prototype.join.call(arguments, "");
    },
    "+": function() {
      return Array.prototype.reduce.call(arguments, function(a, b) {
        return parseFloat(a, 10) + parseFloat(b, 10);
      }, 0);
    },
    "*": function() {
      return Array.prototype.reduce.call(arguments, function(a, b) {
        return parseFloat(a, 10) * parseFloat(b, 10);
      });
    },
    "-": function(a, b) {
      if(b === undefined) {
        return -a;
      }else{
        return a - b;
      }
    },
    "/": function(a, b) {
      return a / b;
    },
    "min": function() {
      return Math.min.apply(this, arguments);
    },
    "max": function() {
      return Math.max.apply(this, arguments);
    },
    "merge": function() {
      return Array.prototype.reduce.call(arguments, function(a, b) {
        return a.concat(b);
      }, []);
    },
    "var": function(a, b) {
      var not_found = (b === undefined) ? null : b;
      var sub_props = String(a).split(".");
      var data = this;
      for(var i = 0; i < sub_props.length; i++) {
        if(data === null) {
          return not_found;
        }
        // Descending into data
        data = data[sub_props[i]];
        if(data === undefined) {
          return not_found;
        }
      }
      return data;
    },
    "missing": function() {
      /*
      Missing can receive many keys as many arguments, like {"missing:[1,2]}
      Missing can also receive *one* argument that is an array of keys,
      which typically happens if it's actually acting on the output of another command
      (like 'if' or 'merge')
      */

      var missing = [];
      var keys = Array.isArray(arguments[0]) ? arguments[0] : arguments;

      for(var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = jsonLogic.apply({"var": key}, this);
        if(value === null || value === "") {
          missing.push(key);
        }
      }

      return missing;
    },
    "missing_some": function(need_count, options) {
      // missing_some takes two arguments, how many (minimum) items must be present, and an array of keys (just like 'missing') to check for presence.
      var are_missing = jsonLogic.apply({"missing": options}, this);

      if(options.length - are_missing.length >= need_count) {
        return [];
      }else{
        return are_missing;
      }
    },
    "method": function(obj, method, args) {
      return obj[method].apply(obj, args);
    },

  };

  jsonLogic.is_logic = function(logic) {
    return (
      logic !== null && typeof logic === "object" && ! Array.isArray(logic)
    );
  };

  /*
  This helper will defer to the JsonLogic spec as a tie-breaker when different language interpreters define different behavior for the truthiness of primitives.  E.g., PHP considers empty arrays to be falsy, but Javascript considers them to be truthy. JsonLogic, as an ecosystem, needs one consistent answer.

  Literal | JS    |  PHP  |  JsonLogic
  --------+-------+-------+---------------
  []      | true  | false | false
  "0"     | true  | false | true
  */
  jsonLogic.truthy = function(value) {
    if(Array.isArray(value) && value.length === 0) {
      return false;
    }
    return !! value;
  };


  jsonLogic.get_operator = function(logic) {
    return Object.keys(logic)[0];
  };

  jsonLogic.get_values = function(logic) {
    return logic[jsonLogic.get_operator(logic)];
  };

  jsonLogic.apply = function(logic, data) {
    // Does this array contain logic? Only one way to find out.
    if(Array.isArray(logic)) {
      return logic.map(function(l) {
        return jsonLogic.apply(l, data);
      });
    }
    // You've recursed to a primitive, stop!
    if( ! jsonLogic.is_logic(logic) ) {
      return logic;
    }

    data = data || {};

    var op = jsonLogic.get_operator(logic);
    var values = logic[op];
    var i;
    var current;

    // easy syntax for unary operators, like {"var" : "x"} instead of strict {"var" : ["x"]}
    if( ! Array.isArray(values)) {
      values = [values];
    }

    // 'if', 'and', and 'or' violate the normal rule of depth-first calculating consequents, let each manage recursion as needed.
    if(op === "if" || op == "?:") {
      /* 'if' should be called with a odd number of parameters, 3 or greater
      This works on the pattern:
      if( 0 ){ 1 }else{ 2 };
      if( 0 ){ 1 }else if( 2 ){ 3 }else{ 4 };
      if( 0 ){ 1 }else if( 2 ){ 3 }else if( 4 ){ 5 }else{ 6 };

      The implementation is:
      For pairs of values (0,1 then 2,3 then 4,5 etc)
      If the first evaluates truthy, evaluate and return the second
      If the first evaluates falsy, jump to the next pair (e.g, 0,1 to 2,3)
      given one parameter, evaluate and return it. (it's an Else and all the If/ElseIf were false)
      given 0 parameters, return NULL (not great practice, but there was no Else)
      */
      for(i = 0; i < values.length - 1; i += 2) {
        if( jsonLogic.truthy( jsonLogic.apply(values[i], data) ) ) {
          return jsonLogic.apply(values[i+1], data);
        }
      }
      if(values.length === i+1) return jsonLogic.apply(values[i], data);
      return null;
    }else if(op === "and") { // Return first falsy, or last
      for(i=0; i < values.length; i+=1) {
        current = jsonLogic.apply(values[i], data);
        if( ! jsonLogic.truthy(current)) {
          return current;
        }
      }
      return current; // Last
    }else if(op === "or") {// Return first truthy, or last
      for(i=0; i < values.length; i+=1) {
        current = jsonLogic.apply(values[i], data);
        if( jsonLogic.truthy(current) ) {
          return current;
        }
      }
      return current; // Last
    }


    // Everyone else gets immediate depth-first recursion
    values = values.map(function(val) {
      return jsonLogic.apply(val, data);
    });


    // The operation is called with "data" bound to its "this" and "values" passed as arguments.
    // Structured commands like % or > can name formal arguments while flexible commands (like missing or merge) can operate on the pseudo-array arguments
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments
    if(typeof operations[op] === "function") {
      return operations[op].apply(data, values);
    }else if(op.indexOf(".") > 0) { // Contains a dot, and not in the 0th position
      var sub_ops = String(op).split(".");
      var operation = operations;
      for(i = 0; i < sub_ops.length; i++) {
        // Descending into operations
        operation = operation[sub_ops[i]];
        if(operation === undefined) {
          throw new Error("Unrecognized operation " + op +
          " (failed at " + sub_ops.slice(0, i+1).join(".") + ")");
        }
      }

      return operation.apply(data, values);
    }

    throw new Error("Unrecognized operation " + op );
  };

  jsonLogic.uses_data = function(logic) {
    var collection = [];

    if( jsonLogic.is_logic(logic) ) {
      var op = jsonLogic.get_operator(logic);
      var values = logic[op];

      if( ! Array.isArray(values)) {
        values = [values];
      }

      if(op === "var") {
        // This doesn't cover the case where the arg to var is itself a rule.
        collection.push(values[0]);
      }else{
        // Recursion!
        values.map(function(val) {
          collection.push.apply(collection, jsonLogic.uses_data(val) );
        });
      }
    }

    return arrayUnique(collection);
  };

  jsonLogic.add_operation = function(name, code) {
    operations[name] = code;
  };

  jsonLogic.rm_operation = function(name) {
    delete operations[name];
  };

  jsonLogic.rule_like = function(rule, pattern) {
    // console.log("Is ". JSON.stringify(rule) . " like " . JSON.stringify(pattern) . "?");
    if(pattern === rule) {
      return true;
    } // TODO : Deep object equivalency?
    if(pattern === "@") {
      return true;
    } // Wildcard!
    if(pattern === "number") {
      return (typeof rule === "number");
    }
    if(pattern === "string") {
      return (typeof rule === "string");
    }
    if(pattern === "array") {
      // !logic test might be superfluous in JavaScript
      return Array.isArray(rule) && ! jsonLogic.is_logic(rule);
    }

    if(jsonLogic.is_logic(pattern)) {
      if(jsonLogic.is_logic(rule)) {
        var pattern_op = jsonLogic.get_operator(pattern);
        var rule_op = jsonLogic.get_operator(rule);

        if(pattern_op === "@" || pattern_op === rule_op) {
        // echo "\nOperators match, go deeper\n";
          return jsonLogic.rule_like(
            jsonLogic.get_values(rule, false),
            jsonLogic.get_values(pattern, false)
          );
        }
      }
      return false; // pattern is logic, rule isn't, can't be eq
    }

    if(Array.isArray(pattern)) {
      if(Array.isArray(rule)) {
        if(pattern.length !== rule.length) {
          return false;
        }
        /*
          Note, array order MATTERS, because we're using this array test logic to consider arguments, where order can matter. (e.g., + is commutative, but '-' or 'if' or 'var' are NOT)
        */
        for(var i = 0; i < pattern.length; i += 1) {
          // If any fail, we fail
          if( ! jsonLogic.rule_like(rule[i], pattern[i])) {
            return false;
          }
        }
        return true; // If they *all* passed, we pass
      }else{
        return false; // Pattern is array, rule isn't
      }
    }

    // Not logic, not array, not a === match for rule.
    return false;
  };

  return jsonLogic;
}));

},{}],70:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

},{"./_getNative":161,"./_root":205}],71:[function(require,module,exports){
var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":169,"./_hashDelete":170,"./_hashGet":171,"./_hashHas":172,"./_hashSet":173}],72:[function(require,module,exports){
var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":184,"./_listCacheDelete":185,"./_listCacheGet":186,"./_listCacheHas":187,"./_listCacheSet":188}],73:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":161,"./_root":205}],74:[function(require,module,exports){
var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":189,"./_mapCacheDelete":190,"./_mapCacheGet":191,"./_mapCacheHas":192,"./_mapCacheSet":193}],75:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

},{"./_getNative":161,"./_root":205}],76:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

},{"./_getNative":161,"./_root":205}],77:[function(require,module,exports){
var MapCache = require('./_MapCache'),
    setCacheAdd = require('./_setCacheAdd'),
    setCacheHas = require('./_setCacheHas');

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;

},{"./_MapCache":74,"./_setCacheAdd":206,"./_setCacheHas":207}],78:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    stackClear = require('./_stackClear'),
    stackDelete = require('./_stackDelete'),
    stackGet = require('./_stackGet'),
    stackHas = require('./_stackHas'),
    stackSet = require('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":72,"./_stackClear":211,"./_stackDelete":212,"./_stackGet":213,"./_stackHas":214,"./_stackSet":215}],79:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":205}],80:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":205}],81:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

},{"./_getNative":161,"./_root":205}],82:[function(require,module,exports){
/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

module.exports = addMapEntry;

},{}],83:[function(require,module,exports){
/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

module.exports = addSetEntry;

},{}],84:[function(require,module,exports){
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],85:[function(require,module,exports){
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],86:[function(require,module,exports){
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;

},{}],87:[function(require,module,exports){
var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isIndex = require('./_isIndex'),
    isTypedArray = require('./isTypedArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":128,"./_isIndex":177,"./isArguments":233,"./isArray":234,"./isBuffer":237,"./isTypedArray":245}],88:[function(require,module,exports){
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

},{}],89:[function(require,module,exports){
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

},{}],90:[function(require,module,exports){
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;

},{}],91:[function(require,module,exports){
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;

},{}],92:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;

},{"./_baseAssignValue":97,"./eq":227}],93:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

},{"./_baseAssignValue":97,"./eq":227}],94:[function(require,module,exports){
var eq = require('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":227}],95:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keys = require('./keys');

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

},{"./_copyObject":144,"./keys":246}],96:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

},{"./_copyObject":144,"./keysIn":247}],97:[function(require,module,exports){
var defineProperty = require('./_defineProperty');

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

},{"./_defineProperty":152}],98:[function(require,module,exports){
var Stack = require('./_Stack'),
    arrayEach = require('./_arrayEach'),
    assignValue = require('./_assignValue'),
    baseAssign = require('./_baseAssign'),
    baseAssignIn = require('./_baseAssignIn'),
    cloneBuffer = require('./_cloneBuffer'),
    copyArray = require('./_copyArray'),
    copySymbols = require('./_copySymbols'),
    copySymbolsIn = require('./_copySymbolsIn'),
    getAllKeys = require('./_getAllKeys'),
    getAllKeysIn = require('./_getAllKeysIn'),
    getTag = require('./_getTag'),
    initCloneArray = require('./_initCloneArray'),
    initCloneByTag = require('./_initCloneByTag'),
    initCloneObject = require('./_initCloneObject'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isObject = require('./isObject'),
    keys = require('./keys');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

},{"./_Stack":78,"./_arrayEach":85,"./_assignValue":93,"./_baseAssign":95,"./_baseAssignIn":96,"./_cloneBuffer":136,"./_copyArray":143,"./_copySymbols":145,"./_copySymbolsIn":146,"./_getAllKeys":157,"./_getAllKeysIn":158,"./_getTag":166,"./_initCloneArray":174,"./_initCloneByTag":175,"./_initCloneObject":176,"./isArray":234,"./isBuffer":237,"./isObject":241,"./keys":246}],99:[function(require,module,exports){
var isObject = require('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;

},{"./isObject":241}],100:[function(require,module,exports){
/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * The base implementation of `_.delay` and `_.defer` which accepts `args`
 * to provide to `func`.
 *
 * @private
 * @param {Function} func The function to delay.
 * @param {number} wait The number of milliseconds to delay invocation.
 * @param {Array} args The arguments to provide to `func`.
 * @returns {number|Object} Returns the timer id or timeout object.
 */
function baseDelay(func, wait, args) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  return setTimeout(function() { func.apply(undefined, args); }, wait);
}

module.exports = baseDelay;

},{}],101:[function(require,module,exports){
var baseForOwn = require('./_baseForOwn'),
    createBaseEach = require('./_createBaseEach');

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;

},{"./_baseForOwn":103,"./_createBaseEach":149}],102:[function(require,module,exports){
var createBaseFor = require('./_createBaseFor');

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;

},{"./_createBaseFor":150}],103:[function(require,module,exports){
var baseFor = require('./_baseFor'),
    keys = require('./keys');

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

},{"./_baseFor":102,"./keys":246}],104:[function(require,module,exports){
var castPath = require('./_castPath'),
    toKey = require('./_toKey');

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;

},{"./_castPath":134,"./_toKey":217}],105:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isArray = require('./isArray');

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

},{"./_arrayPush":89,"./isArray":234}],106:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":79,"./_getRawTag":163,"./_objectToString":201}],107:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

module.exports = baseHas;

},{}],108:[function(require,module,exports){
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

},{}],109:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":106,"./isObjectLike":242}],110:[function(require,module,exports){
var baseIsEqualDeep = require('./_baseIsEqualDeep'),
    isObjectLike = require('./isObjectLike');

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

},{"./_baseIsEqualDeep":111,"./isObjectLike":242}],111:[function(require,module,exports){
var Stack = require('./_Stack'),
    equalArrays = require('./_equalArrays'),
    equalByTag = require('./_equalByTag'),
    equalObjects = require('./_equalObjects'),
    getTag = require('./_getTag'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isTypedArray = require('./isTypedArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

},{"./_Stack":78,"./_equalArrays":153,"./_equalByTag":154,"./_equalObjects":155,"./_getTag":166,"./isArray":234,"./isBuffer":237,"./isTypedArray":245}],112:[function(require,module,exports){
var Stack = require('./_Stack'),
    baseIsEqual = require('./_baseIsEqual');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;

},{"./_Stack":78,"./_baseIsEqual":110}],113:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":181,"./_toSource":218,"./isFunction":239,"./isObject":241}],114:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

},{"./_baseGetTag":106,"./isLength":240,"./isObjectLike":242}],115:[function(require,module,exports){
var baseMatches = require('./_baseMatches'),
    baseMatchesProperty = require('./_baseMatchesProperty'),
    identity = require('./identity'),
    isArray = require('./isArray'),
    property = require('./property');

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;

},{"./_baseMatches":118,"./_baseMatchesProperty":119,"./identity":232,"./isArray":234,"./property":253}],116:[function(require,module,exports){
var isPrototype = require('./_isPrototype'),
    nativeKeys = require('./_nativeKeys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

},{"./_isPrototype":182,"./_nativeKeys":198}],117:[function(require,module,exports){
var isObject = require('./isObject'),
    isPrototype = require('./_isPrototype'),
    nativeKeysIn = require('./_nativeKeysIn');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;

},{"./_isPrototype":182,"./_nativeKeysIn":199,"./isObject":241}],118:[function(require,module,exports){
var baseIsMatch = require('./_baseIsMatch'),
    getMatchData = require('./_getMatchData'),
    matchesStrictComparable = require('./_matchesStrictComparable');

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;

},{"./_baseIsMatch":112,"./_getMatchData":160,"./_matchesStrictComparable":195}],119:[function(require,module,exports){
var baseIsEqual = require('./_baseIsEqual'),
    get = require('./get'),
    hasIn = require('./hasIn'),
    isKey = require('./_isKey'),
    isStrictComparable = require('./_isStrictComparable'),
    matchesStrictComparable = require('./_matchesStrictComparable'),
    toKey = require('./_toKey');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;

},{"./_baseIsEqual":110,"./_isKey":179,"./_isStrictComparable":183,"./_matchesStrictComparable":195,"./_toKey":217,"./get":229,"./hasIn":231}],120:[function(require,module,exports){
var Stack = require('./_Stack'),
    assignMergeValue = require('./_assignMergeValue'),
    baseFor = require('./_baseFor'),
    baseMergeDeep = require('./_baseMergeDeep'),
    isObject = require('./isObject'),
    keysIn = require('./keysIn');

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    if (isObject(srcValue)) {
      stack || (stack = new Stack);
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(object[key], srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;

},{"./_Stack":78,"./_assignMergeValue":92,"./_baseFor":102,"./_baseMergeDeep":121,"./isObject":241,"./keysIn":247}],121:[function(require,module,exports){
var assignMergeValue = require('./_assignMergeValue'),
    cloneBuffer = require('./_cloneBuffer'),
    cloneTypedArray = require('./_cloneTypedArray'),
    copyArray = require('./_copyArray'),
    initCloneObject = require('./_initCloneObject'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isArrayLikeObject = require('./isArrayLikeObject'),
    isBuffer = require('./isBuffer'),
    isFunction = require('./isFunction'),
    isObject = require('./isObject'),
    isPlainObject = require('./isPlainObject'),
    isTypedArray = require('./isTypedArray'),
    toPlainObject = require('./toPlainObject');

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = object[key],
      srcValue = source[key],
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;

},{"./_assignMergeValue":92,"./_cloneBuffer":136,"./_cloneTypedArray":142,"./_copyArray":143,"./_initCloneObject":176,"./isArguments":233,"./isArray":234,"./isArrayLikeObject":236,"./isBuffer":237,"./isFunction":239,"./isObject":241,"./isPlainObject":243,"./isTypedArray":245,"./toPlainObject":258}],122:[function(require,module,exports){
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

},{}],123:[function(require,module,exports){
var baseGet = require('./_baseGet');

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;

},{"./_baseGet":104}],124:[function(require,module,exports){
var baseUnset = require('./_baseUnset'),
    isIndex = require('./_isIndex');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * The base implementation of `_.pullAt` without support for individual
 * indexes or capturing the removed elements.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {number[]} indexes The indexes of elements to remove.
 * @returns {Array} Returns `array`.
 */
function basePullAt(array, indexes) {
  var length = array ? indexes.length : 0,
      lastIndex = length - 1;

  while (length--) {
    var index = indexes[length];
    if (length == lastIndex || index !== previous) {
      var previous = index;
      if (isIndex(index)) {
        splice.call(array, index, 1);
      } else {
        baseUnset(array, index);
      }
    }
  }
  return array;
}

module.exports = basePullAt;

},{"./_baseUnset":131,"./_isIndex":177}],125:[function(require,module,exports){
var identity = require('./identity'),
    overRest = require('./_overRest'),
    setToString = require('./_setToString');

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

},{"./_overRest":203,"./_setToString":209,"./identity":232}],126:[function(require,module,exports){
var constant = require('./constant'),
    defineProperty = require('./_defineProperty'),
    identity = require('./identity');

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;

},{"./_defineProperty":152,"./constant":222,"./identity":232}],127:[function(require,module,exports){
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;

},{}],128:[function(require,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],129:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    arrayMap = require('./_arrayMap'),
    isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;

},{"./_Symbol":79,"./_arrayMap":88,"./isArray":234,"./isSymbol":244}],130:[function(require,module,exports){
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],131:[function(require,module,exports){
var castPath = require('./_castPath'),
    last = require('./last'),
    parent = require('./_parent'),
    toKey = require('./_toKey');

/**
 * The base implementation of `_.unset`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The property path to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 */
function baseUnset(object, path) {
  path = castPath(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last(path))];
}

module.exports = baseUnset;

},{"./_castPath":134,"./_parent":204,"./_toKey":217,"./last":248}],132:[function(require,module,exports){
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

},{}],133:[function(require,module,exports){
var identity = require('./identity');

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;

},{"./identity":232}],134:[function(require,module,exports){
var isArray = require('./isArray'),
    isKey = require('./_isKey'),
    stringToPath = require('./_stringToPath'),
    toString = require('./toString');

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

},{"./_isKey":179,"./_stringToPath":216,"./isArray":234,"./toString":259}],135:[function(require,module,exports){
var Uint8Array = require('./_Uint8Array');

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

},{"./_Uint8Array":80}],136:[function(require,module,exports){
var root = require('./_root');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

},{"./_root":205}],137:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

},{"./_cloneArrayBuffer":135}],138:[function(require,module,exports){
var addMapEntry = require('./_addMapEntry'),
    arrayReduce = require('./_arrayReduce'),
    mapToArray = require('./_mapToArray');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

module.exports = cloneMap;

},{"./_addMapEntry":82,"./_arrayReduce":90,"./_mapToArray":194}],139:[function(require,module,exports){
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

},{}],140:[function(require,module,exports){
var addSetEntry = require('./_addSetEntry'),
    arrayReduce = require('./_arrayReduce'),
    setToArray = require('./_setToArray');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

module.exports = cloneSet;

},{"./_addSetEntry":83,"./_arrayReduce":90,"./_setToArray":208}],141:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

},{"./_Symbol":79}],142:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

},{"./_cloneArrayBuffer":135}],143:[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],144:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    baseAssignValue = require('./_baseAssignValue');

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;

},{"./_assignValue":93,"./_baseAssignValue":97}],145:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbols = require('./_getSymbols');

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

},{"./_copyObject":144,"./_getSymbols":164}],146:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbolsIn = require('./_getSymbolsIn');

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

},{"./_copyObject":144,"./_getSymbolsIn":165}],147:[function(require,module,exports){
var root = require('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":205}],148:[function(require,module,exports){
var baseRest = require('./_baseRest'),
    isIterateeCall = require('./_isIterateeCall');

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"./_baseRest":125,"./_isIterateeCall":178}],149:[function(require,module,exports){
var isArrayLike = require('./isArrayLike');

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;

},{"./isArrayLike":235}],150:[function(require,module,exports){
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;

},{}],151:[function(require,module,exports){
var baseMerge = require('./_baseMerge'),
    isObject = require('./isObject');

/**
 * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
 * objects into destination objects that are passed thru.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to merge.
 * @param {Object} object The parent object of `objValue`.
 * @param {Object} source The parent object of `srcValue`.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 * @returns {*} Returns the value to assign.
 */
function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
  if (isObject(objValue) && isObject(srcValue)) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, objValue);
    baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
    stack['delete'](srcValue);
  }
  return objValue;
}

module.exports = customDefaultsMerge;

},{"./_baseMerge":120,"./isObject":241}],152:[function(require,module,exports){
var getNative = require('./_getNative');

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;

},{"./_getNative":161}],153:[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arraySome = require('./_arraySome'),
    cacheHas = require('./_cacheHas');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

},{"./_SetCache":77,"./_arraySome":91,"./_cacheHas":132}],154:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    Uint8Array = require('./_Uint8Array'),
    eq = require('./eq'),
    equalArrays = require('./_equalArrays'),
    mapToArray = require('./_mapToArray'),
    setToArray = require('./_setToArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;

},{"./_Symbol":79,"./_Uint8Array":80,"./_equalArrays":153,"./_mapToArray":194,"./_setToArray":208,"./eq":227}],155:[function(require,module,exports){
var getAllKeys = require('./_getAllKeys');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

},{"./_getAllKeys":157}],156:[function(require,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],157:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbols = require('./_getSymbols'),
    keys = require('./keys');

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

},{"./_baseGetAllKeys":105,"./_getSymbols":164,"./keys":246}],158:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbolsIn = require('./_getSymbolsIn'),
    keysIn = require('./keysIn');

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

},{"./_baseGetAllKeys":105,"./_getSymbolsIn":165,"./keysIn":247}],159:[function(require,module,exports){
var isKeyable = require('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":180}],160:[function(require,module,exports){
var isStrictComparable = require('./_isStrictComparable'),
    keys = require('./keys');

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;

},{"./_isStrictComparable":183,"./keys":246}],161:[function(require,module,exports){
var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":113,"./_getValue":167}],162:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":202}],163:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":79}],164:[function(require,module,exports){
var arrayFilter = require('./_arrayFilter'),
    stubArray = require('./stubArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;

},{"./_arrayFilter":86,"./stubArray":255}],165:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    getPrototype = require('./_getPrototype'),
    getSymbols = require('./_getSymbols'),
    stubArray = require('./stubArray');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;

},{"./_arrayPush":89,"./_getPrototype":162,"./_getSymbols":164,"./stubArray":255}],166:[function(require,module,exports){
var DataView = require('./_DataView'),
    Map = require('./_Map'),
    Promise = require('./_Promise'),
    Set = require('./_Set'),
    WeakMap = require('./_WeakMap'),
    baseGetTag = require('./_baseGetTag'),
    toSource = require('./_toSource');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;

},{"./_DataView":70,"./_Map":73,"./_Promise":75,"./_Set":76,"./_WeakMap":81,"./_baseGetTag":106,"./_toSource":218}],167:[function(require,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],168:[function(require,module,exports){
var castPath = require('./_castPath'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isIndex = require('./_isIndex'),
    isLength = require('./isLength'),
    toKey = require('./_toKey');

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;

},{"./_castPath":134,"./_isIndex":177,"./_toKey":217,"./isArguments":233,"./isArray":234,"./isLength":240}],169:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":197}],170:[function(require,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],171:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":197}],172:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":197}],173:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":197}],174:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;

},{}],175:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer'),
    cloneDataView = require('./_cloneDataView'),
    cloneMap = require('./_cloneMap'),
    cloneRegExp = require('./_cloneRegExp'),
    cloneSet = require('./_cloneSet'),
    cloneSymbol = require('./_cloneSymbol'),
    cloneTypedArray = require('./_cloneTypedArray');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

},{"./_cloneArrayBuffer":135,"./_cloneDataView":137,"./_cloneMap":138,"./_cloneRegExp":139,"./_cloneSet":140,"./_cloneSymbol":141,"./_cloneTypedArray":142}],176:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    getPrototype = require('./_getPrototype'),
    isPrototype = require('./_isPrototype');

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;

},{"./_baseCreate":99,"./_getPrototype":162,"./_isPrototype":182}],177:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],178:[function(require,module,exports){
var eq = require('./eq'),
    isArrayLike = require('./isArrayLike'),
    isIndex = require('./_isIndex'),
    isObject = require('./isObject');

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;

},{"./_isIndex":177,"./eq":227,"./isArrayLike":235,"./isObject":241}],179:[function(require,module,exports){
var isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;

},{"./isArray":234,"./isSymbol":244}],180:[function(require,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],181:[function(require,module,exports){
var coreJsData = require('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":147}],182:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],183:[function(require,module,exports){
var isObject = require('./isObject');

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

},{"./isObject":241}],184:[function(require,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],185:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":94}],186:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":94}],187:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":94}],188:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":94}],189:[function(require,module,exports){
var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":71,"./_ListCache":72,"./_Map":73}],190:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":159}],191:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":159}],192:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":159}],193:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":159}],194:[function(require,module,exports){
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

},{}],195:[function(require,module,exports){
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;

},{}],196:[function(require,module,exports){
var memoize = require('./memoize');

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

},{"./memoize":249}],197:[function(require,module,exports){
var getNative = require('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":161}],198:[function(require,module,exports){
var overArg = require('./_overArg');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

},{"./_overArg":202}],199:[function(require,module,exports){
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;

},{}],200:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

},{"./_freeGlobal":156}],201:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],202:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],203:[function(require,module,exports){
var apply = require('./_apply');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

},{"./_apply":84}],204:[function(require,module,exports){
var baseGet = require('./_baseGet'),
    baseSlice = require('./_baseSlice');

/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function parent(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}

module.exports = parent;

},{"./_baseGet":104,"./_baseSlice":127}],205:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":156}],206:[function(require,module,exports){
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;

},{}],207:[function(require,module,exports){
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

},{}],208:[function(require,module,exports){
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

},{}],209:[function(require,module,exports){
var baseSetToString = require('./_baseSetToString'),
    shortOut = require('./_shortOut');

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;

},{"./_baseSetToString":126,"./_shortOut":210}],210:[function(require,module,exports){
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

},{}],211:[function(require,module,exports){
var ListCache = require('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;

},{"./_ListCache":72}],212:[function(require,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

},{}],213:[function(require,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],214:[function(require,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],215:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    Map = require('./_Map'),
    MapCache = require('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

},{"./_ListCache":72,"./_Map":73,"./_MapCache":74}],216:[function(require,module,exports){
var memoizeCapped = require('./_memoizeCapped');

/** Used to match property names within property paths. */
var reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;

},{"./_memoizeCapped":196}],217:[function(require,module,exports){
var isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;

},{"./isSymbol":244}],218:[function(require,module,exports){
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],219:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    copyObject = require('./_copyObject'),
    createAssigner = require('./_createAssigner'),
    isArrayLike = require('./isArrayLike'),
    isPrototype = require('./_isPrototype'),
    keys = require('./keys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns own enumerable string keyed properties of source objects to the
 * destination object. Source objects are applied from left to right.
 * Subsequent sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object` and is loosely based on
 * [`Object.assign`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assignIn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assign({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3 }
 */
var assign = createAssigner(function(object, source) {
  if (isPrototype(source) || isArrayLike(source)) {
    copyObject(source, keys(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty.call(source, key)) {
      assignValue(object, key, source[key]);
    }
  }
});

module.exports = assign;

},{"./_assignValue":93,"./_copyObject":144,"./_createAssigner":148,"./_isPrototype":182,"./isArrayLike":235,"./keys":246}],220:[function(require,module,exports){
var baseClone = require('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;

},{"./_baseClone":98}],221:[function(require,module,exports){
var baseClone = require('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;

},{"./_baseClone":98}],222:[function(require,module,exports){
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

},{}],223:[function(require,module,exports){
var isObject = require('./isObject'),
    now = require('./now'),
    toNumber = require('./toNumber');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;

},{"./isObject":241,"./now":252,"./toNumber":257}],224:[function(require,module,exports){
var apply = require('./_apply'),
    baseRest = require('./_baseRest'),
    customDefaultsMerge = require('./_customDefaultsMerge'),
    mergeWith = require('./mergeWith');

/**
 * This method is like `_.defaults` except that it recursively assigns
 * default properties.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaults
 * @example
 *
 * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
 * // => { 'a': { 'b': 2, 'c': 3 } }
 */
var defaultsDeep = baseRest(function(args) {
  args.push(undefined, customDefaultsMerge);
  return apply(mergeWith, undefined, args);
});

module.exports = defaultsDeep;

},{"./_apply":84,"./_baseRest":125,"./_customDefaultsMerge":151,"./mergeWith":251}],225:[function(require,module,exports){
var baseDelay = require('./_baseDelay'),
    baseRest = require('./_baseRest'),
    toNumber = require('./toNumber');

/**
 * Invokes `func` after `wait` milliseconds. Any additional arguments are
 * provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to delay.
 * @param {number} wait The number of milliseconds to delay invocation.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {number} Returns the timer id.
 * @example
 *
 * _.delay(function(text) {
 *   console.log(text);
 * }, 1000, 'later');
 * // => Logs 'later' after one second.
 */
var delay = baseRest(function(func, wait, args) {
  return baseDelay(func, toNumber(wait) || 0, args);
});

module.exports = delay;

},{"./_baseDelay":100,"./_baseRest":125,"./toNumber":257}],226:[function(require,module,exports){
module.exports = require('./forEach');

},{"./forEach":228}],227:[function(require,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],228:[function(require,module,exports){
var arrayEach = require('./_arrayEach'),
    baseEach = require('./_baseEach'),
    castFunction = require('./_castFunction'),
    isArray = require('./isArray');

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;

},{"./_arrayEach":85,"./_baseEach":101,"./_castFunction":133,"./isArray":234}],229:[function(require,module,exports){
var baseGet = require('./_baseGet');

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

},{"./_baseGet":104}],230:[function(require,module,exports){
var baseHas = require('./_baseHas'),
    hasPath = require('./_hasPath');

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

module.exports = has;

},{"./_baseHas":107,"./_hasPath":168}],231:[function(require,module,exports){
var baseHasIn = require('./_baseHasIn'),
    hasPath = require('./_hasPath');

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

},{"./_baseHasIn":108,"./_hasPath":168}],232:[function(require,module,exports){
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],233:[function(require,module,exports){
var baseIsArguments = require('./_baseIsArguments'),
    isObjectLike = require('./isObjectLike');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

},{"./_baseIsArguments":109,"./isObjectLike":242}],234:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],235:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":239,"./isLength":240}],236:[function(require,module,exports){
var isArrayLike = require('./isArrayLike'),
    isObjectLike = require('./isObjectLike');

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

},{"./isArrayLike":235,"./isObjectLike":242}],237:[function(require,module,exports){
var root = require('./_root'),
    stubFalse = require('./stubFalse');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

},{"./_root":205,"./stubFalse":256}],238:[function(require,module,exports){
var baseKeys = require('./_baseKeys'),
    getTag = require('./_getTag'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isArrayLike = require('./isArrayLike'),
    isBuffer = require('./isBuffer'),
    isPrototype = require('./_isPrototype'),
    isTypedArray = require('./isTypedArray');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) &&
      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

module.exports = isEmpty;

},{"./_baseKeys":116,"./_getTag":166,"./_isPrototype":182,"./isArguments":233,"./isArray":234,"./isArrayLike":235,"./isBuffer":237,"./isTypedArray":245}],239:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObject = require('./isObject');

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":106,"./isObject":241}],240:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],241:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],242:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],243:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    getPrototype = require('./_getPrototype'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

},{"./_baseGetTag":106,"./_getPrototype":162,"./isObjectLike":242}],244:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;

},{"./_baseGetTag":106,"./isObjectLike":242}],245:[function(require,module,exports){
var baseIsTypedArray = require('./_baseIsTypedArray'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

},{"./_baseIsTypedArray":114,"./_baseUnary":130,"./_nodeUtil":200}],246:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeys = require('./_baseKeys'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

},{"./_arrayLikeKeys":87,"./_baseKeys":116,"./isArrayLike":235}],247:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeysIn = require('./_baseKeysIn'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

},{"./_arrayLikeKeys":87,"./_baseKeysIn":117,"./isArrayLike":235}],248:[function(require,module,exports){
/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;

},{}],249:[function(require,module,exports){
var MapCache = require('./_MapCache');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;

},{"./_MapCache":74}],250:[function(require,module,exports){
var baseMerge = require('./_baseMerge'),
    createAssigner = require('./_createAssigner');

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;

},{"./_baseMerge":120,"./_createAssigner":148}],251:[function(require,module,exports){
var baseMerge = require('./_baseMerge'),
    createAssigner = require('./_createAssigner');

/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with six arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */
var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
  baseMerge(object, source, srcIndex, customizer);
});

module.exports = mergeWith;

},{"./_baseMerge":120,"./_createAssigner":148}],252:[function(require,module,exports){
var root = require('./_root');

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;

},{"./_root":205}],253:[function(require,module,exports){
var baseProperty = require('./_baseProperty'),
    basePropertyDeep = require('./_basePropertyDeep'),
    isKey = require('./_isKey'),
    toKey = require('./_toKey');

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;

},{"./_baseProperty":122,"./_basePropertyDeep":123,"./_isKey":179,"./_toKey":217}],254:[function(require,module,exports){
var baseIteratee = require('./_baseIteratee'),
    basePullAt = require('./_basePullAt');

/**
 * Removes all elements from `array` that `predicate` returns truthy for
 * and returns an array of the removed elements. The predicate is invoked
 * with three arguments: (value, index, array).
 *
 * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
 * to pull elements from an array by value.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new array of removed elements.
 * @example
 *
 * var array = [1, 2, 3, 4];
 * var evens = _.remove(array, function(n) {
 *   return n % 2 == 0;
 * });
 *
 * console.log(array);
 * // => [1, 3]
 *
 * console.log(evens);
 * // => [2, 4]
 */
function remove(array, predicate) {
  var result = [];
  if (!(array && array.length)) {
    return result;
  }
  var index = -1,
      indexes = [],
      length = array.length;

  predicate = baseIteratee(predicate, 3);
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result.push(value);
      indexes.push(index);
    }
  }
  basePullAt(array, indexes);
  return result;
}

module.exports = remove;

},{"./_baseIteratee":115,"./_basePullAt":124}],255:[function(require,module,exports){
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

},{}],256:[function(require,module,exports){
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}],257:[function(require,module,exports){
var isObject = require('./isObject'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;

},{"./isObject":241,"./isSymbol":244}],258:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;

},{"./_copyObject":144,"./keysIn":247}],259:[function(require,module,exports){
var baseToString = require('./_baseToString');

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

},{"./_baseToString":129}],260:[function(require,module,exports){
//! moment.js
//! version : 2.18.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    var k;
    for (k in obj) {
        // even if its not own property I'd still call it non-empty
        return false;
    }
    return true;
}

function isUndefined(input) {
    return input === void 0;
}

function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null,
        rfc2822         : false,
        weekdayMismatch : false
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

var some$1 = some;

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some$1.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
            '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var keys$1 = keys;

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    ss : '%d seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$1 (mom, unit, value) {
    if (mom.isValid()) {
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

var indexOf$1 = indexOf;

function daysInMonth(year, month) {
    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return isArray(this._months) ? this._months :
            this._months['standalone'];
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort :
            this._monthsShort['standalone'];
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function createDate (y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date = new Date(y, m, d, h, M, s, ms);

    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate (y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    if (!m) {
        return isArray(this._weekdays) ? this._weekdays :
            this._weekdays['standalone'];
    }
    return isArray(this._weekdays) ? this._weekdays[m.day()] :
        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('k',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return null;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            require('./locale/' + name);
            // because defineLocale currently also sets the global locale, we
            // want to undo that for lazy loaded locales
            getSetGlobalLocale(oldLocale);
        } catch (e) { }
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, parentConfig = baseConfig;
        // MERGE
        if (locales[name] != null) {
            parentConfig = locales[name]._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys$1(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
var basicRfcRegex = /^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d?\d\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(?:\d\d)?\d\d\s)(\d\d:\d\d)(\:\d\d)?(\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\d{4}))$/;

// date and time from ref 2822 format
function configFromRFC2822(config) {
    var string, match, dayFormat,
        dateFormat, timeFormat, tzFormat;
    var timezones = {
        ' GMT': ' +0000',
        ' EDT': ' -0400',
        ' EST': ' -0500',
        ' CDT': ' -0500',
        ' CST': ' -0600',
        ' MDT': ' -0600',
        ' MST': ' -0700',
        ' PDT': ' -0700',
        ' PST': ' -0800'
    };
    var military = 'YXWVUTSRQPONZABCDEFGHIKLM';
    var timezone, timezoneIndex;

    string = config._i
        .replace(/\([^\)]*\)|[\n\t]/g, ' ') // Remove comments and folding whitespace
        .replace(/(\s\s+)/g, ' ') // Replace multiple-spaces with a single space
        .replace(/^\s|\s$/g, ''); // Remove leading and trailing spaces
    match = basicRfcRegex.exec(string);

    if (match) {
        dayFormat = match[1] ? 'ddd' + ((match[1].length === 5) ? ', ' : ' ') : '';
        dateFormat = 'D MMM ' + ((match[2].length > 10) ? 'YYYY ' : 'YY ');
        timeFormat = 'HH:mm' + (match[4] ? ':ss' : '');

        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        if (match[1]) { // day of week given
            var momentDate = new Date(match[2]);
            var momentDay = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][momentDate.getDay()];

            if (match[1].substr(0,3) !== momentDay) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return;
            }
        }

        switch (match[5].length) {
            case 2: // military
                if (timezoneIndex === 0) {
                    timezone = ' +0000';
                } else {
                    timezoneIndex = military.indexOf(match[5][1].toUpperCase()) - 12;
                    timezone = ((timezoneIndex < 0) ? ' -' : ' +') +
                        (('' + timezoneIndex).replace(/^-?/, '0')).match(/..$/)[0] + '00';
                }
                break;
            case 4: // Zone
                timezone = timezones[match[5]];
                break;
            default: // UT or +/-9999
                timezone = timezones[' GMT'];
        }
        match[5] = timezone;
        config._i = match.splice(1).join('');
        tzFormat = ' ZZ';
        config._f = dayFormat + dateFormat + timeFormat + tzFormat;
        configFromStringAndFormat(config);
        getParsingFlags(config).rfc2822 = true;
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    configFromRFC2822(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    // Final attempt, use Input Fallback
    hooks.createFromInputFallback(config);
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// constant that refers to the RFC 2822 form
hooks.RFC_2822 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }
    if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (isObject(input)) {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

function isDurationValid(m) {
    for (var key in m) {
        if (!(ordering.indexOf(key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
        }
    }

    var unitHasDecimal = false;
    for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
            if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
            }
        }
    }

    return true;
}

function isValid$1() {
    return this._isValid;
}

function createInvalid$1() {
    return createDuration(NaN);
}

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {milliseconds: 0, months: 0};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input,units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input,units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        delta, output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    if (units === 'year' || units === 'month' || units === 'quarter') {
        output = monthDiff(this, that);
        if (units === 'quarter') {
            output = output / 3;
        } else if (units === 'year') {
            output = output / 12;
        }
    } else {
        delta = this - that;
        output = units === 'second' ? delta / 1e3 : // 1000
            units === 'minute' ? delta / 6e4 : // 1000 * 60
            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
            delta;
    }
    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString() {
    if (!this.isValid()) {
        return null;
    }
    var m = this.clone().utc();
    if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }
    if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        return this.toDate().toISOString();
    }
    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

function startOf (units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf (units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$2 () {
    return isValid(this);
}

function parsingFlags () {
    return extend({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ?
      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
      locale._dayOfMonthOrdinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$2;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;

// Year
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

// Month
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    if (!this.isValid()) {
        return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    if (!this.isValid()) {
        return NaN;
    }
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function get$2 (units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
}

function makeGetter(name) {
    return function () {
        return this.isValid() ? this._data[name] : NaN;
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    ss: 44,         // a few seconds to seconds
    s : 45,         // seconds to minute
    m : 45,         // minutes to hour
    h : 22,         // hours to day
    d : 26,         // days to month
    M : 11          // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds <= thresholds.ss && ['s', seconds]  ||
            seconds < thresholds.s   && ['ss', seconds] ||
            minutes <= 1             && ['m']           ||
            minutes < thresholds.m   && ['mm', minutes] ||
            hours   <= 1             && ['h']           ||
            hours   < thresholds.h   && ['hh', hours]   ||
            days    <= 1             && ['d']           ||
            days    < thresholds.d   && ['dd', days]    ||
            months  <= 1             && ['M']           ||
            months  < thresholds.M   && ['MM', months]  ||
            years   <= 1             && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === 's') {
        thresholds.ss = limit - 1;
    }
    return true;
}

function humanize (withSuffix) {
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds;
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    return (total < 0 ? '-' : '') +
        'P' +
        (Y ? Y + 'Y' : '') +
        (M ? M + 'M' : '') +
        (D ? D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? h + 'H' : '') +
        (m ? m + 'M' : '') +
        (s ? s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.isValid        = isValid$1;
proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports


hooks.version = '2.18.1';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

return hooks;

})));

},{}],261:[function(require,module,exports){
(function (global){
/*! Native Promise Only
    v0.8.1 (c) Kyle Simpson
    MIT License: http://getify.mit-license.org
*/

(function UMD(name,context,definition){
	// special form of UMD for polyfilling across evironments
	context[name] = context[name] || definition();
	if (typeof module != "undefined" && module.exports) { module.exports = context[name]; }
	else if (typeof define == "function" && define.amd) { define(function $AMD$(){ return context[name]; }); }
})("Promise",typeof global != "undefined" ? global : this,function DEF(){
	/*jshint validthis:true */
	"use strict";

	var builtInProp, cycle, scheduling_queue,
		ToString = Object.prototype.toString,
		timer = (typeof setImmediate != "undefined") ?
			function timer(fn) { return setImmediate(fn); } :
			setTimeout
	;

	// dammit, IE8.
	try {
		Object.defineProperty({},"x",{});
		builtInProp = function builtInProp(obj,name,val,config) {
			return Object.defineProperty(obj,name,{
				value: val,
				writable: true,
				configurable: config !== false
			});
		};
	}
	catch (err) {
		builtInProp = function builtInProp(obj,name,val) {
			obj[name] = val;
			return obj;
		};
	}

	// Note: using a queue instead of array for efficiency
	scheduling_queue = (function Queue() {
		var first, last, item;

		function Item(fn,self) {
			this.fn = fn;
			this.self = self;
			this.next = void 0;
		}

		return {
			add: function add(fn,self) {
				item = new Item(fn,self);
				if (last) {
					last.next = item;
				}
				else {
					first = item;
				}
				last = item;
				item = void 0;
			},
			drain: function drain() {
				var f = first;
				first = last = cycle = void 0;

				while (f) {
					f.fn.call(f.self);
					f = f.next;
				}
			}
		};
	})();

	function schedule(fn,self) {
		scheduling_queue.add(fn,self);
		if (!cycle) {
			cycle = timer(scheduling_queue.drain);
		}
	}

	// promise duck typing
	function isThenable(o) {
		var _then, o_type = typeof o;

		if (o != null &&
			(
				o_type == "object" || o_type == "function"
			)
		) {
			_then = o.then;
		}
		return typeof _then == "function" ? _then : false;
	}

	function notify() {
		for (var i=0; i<this.chain.length; i++) {
			notifyIsolated(
				this,
				(this.state === 1) ? this.chain[i].success : this.chain[i].failure,
				this.chain[i]
			);
		}
		this.chain.length = 0;
	}

	// NOTE: This is a separate function to isolate
	// the `try..catch` so that other code can be
	// optimized better
	function notifyIsolated(self,cb,chain) {
		var ret, _then;
		try {
			if (cb === false) {
				chain.reject(self.msg);
			}
			else {
				if (cb === true) {
					ret = self.msg;
				}
				else {
					ret = cb.call(void 0,self.msg);
				}

				if (ret === chain.promise) {
					chain.reject(TypeError("Promise-chain cycle"));
				}
				else if (_then = isThenable(ret)) {
					_then.call(ret,chain.resolve,chain.reject);
				}
				else {
					chain.resolve(ret);
				}
			}
		}
		catch (err) {
			chain.reject(err);
		}
	}

	function resolve(msg) {
		var _then, self = this;

		// already triggered?
		if (self.triggered) { return; }

		self.triggered = true;

		// unwrap
		if (self.def) {
			self = self.def;
		}

		try {
			if (_then = isThenable(msg)) {
				schedule(function(){
					var def_wrapper = new MakeDefWrapper(self);
					try {
						_then.call(msg,
							function $resolve$(){ resolve.apply(def_wrapper,arguments); },
							function $reject$(){ reject.apply(def_wrapper,arguments); }
						);
					}
					catch (err) {
						reject.call(def_wrapper,err);
					}
				})
			}
			else {
				self.msg = msg;
				self.state = 1;
				if (self.chain.length > 0) {
					schedule(notify,self);
				}
			}
		}
		catch (err) {
			reject.call(new MakeDefWrapper(self),err);
		}
	}

	function reject(msg) {
		var self = this;

		// already triggered?
		if (self.triggered) { return; }

		self.triggered = true;

		// unwrap
		if (self.def) {
			self = self.def;
		}

		self.msg = msg;
		self.state = 2;
		if (self.chain.length > 0) {
			schedule(notify,self);
		}
	}

	function iteratePromises(Constructor,arr,resolver,rejecter) {
		for (var idx=0; idx<arr.length; idx++) {
			(function IIFE(idx){
				Constructor.resolve(arr[idx])
				.then(
					function $resolver$(msg){
						resolver(idx,msg);
					},
					rejecter
				);
			})(idx);
		}
	}

	function MakeDefWrapper(self) {
		this.def = self;
		this.triggered = false;
	}

	function MakeDef(self) {
		this.promise = self;
		this.state = 0;
		this.triggered = false;
		this.chain = [];
		this.msg = void 0;
	}

	function Promise(executor) {
		if (typeof executor != "function") {
			throw TypeError("Not a function");
		}

		if (this.__NPO__ !== 0) {
			throw TypeError("Not a promise");
		}

		// instance shadowing the inherited "brand"
		// to signal an already "initialized" promise
		this.__NPO__ = 1;

		var def = new MakeDef(this);

		this["then"] = function then(success,failure) {
			var o = {
				success: typeof success == "function" ? success : true,
				failure: typeof failure == "function" ? failure : false
			};
			// Note: `then(..)` itself can be borrowed to be used against
			// a different promise constructor for making the chained promise,
			// by substituting a different `this` binding.
			o.promise = new this.constructor(function extractChain(resolve,reject) {
				if (typeof resolve != "function" || typeof reject != "function") {
					throw TypeError("Not a function");
				}

				o.resolve = resolve;
				o.reject = reject;
			});
			def.chain.push(o);

			if (def.state !== 0) {
				schedule(notify,def);
			}

			return o.promise;
		};
		this["catch"] = function $catch$(failure) {
			return this.then(void 0,failure);
		};

		try {
			executor.call(
				void 0,
				function publicResolve(msg){
					resolve.call(def,msg);
				},
				function publicReject(msg) {
					reject.call(def,msg);
				}
			);
		}
		catch (err) {
			reject.call(def,err);
		}
	}

	var PromisePrototype = builtInProp({},"constructor",Promise,
		/*configurable=*/false
	);

	// Note: Android 4 cannot use `Object.defineProperty(..)` here
	Promise.prototype = PromisePrototype;

	// built-in "brand" to signal an "uninitialized" promise
	builtInProp(PromisePrototype,"__NPO__",0,
		/*configurable=*/false
	);

	builtInProp(Promise,"resolve",function Promise$resolve(msg) {
		var Constructor = this;

		// spec mandated checks
		// note: best "isPromise" check that's practical for now
		if (msg && typeof msg == "object" && msg.__NPO__ === 1) {
			return msg;
		}

		return new Constructor(function executor(resolve,reject){
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			resolve(msg);
		});
	});

	builtInProp(Promise,"reject",function Promise$reject(msg) {
		return new this(function executor(resolve,reject){
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			reject(msg);
		});
	});

	builtInProp(Promise,"all",function Promise$all(arr) {
		var Constructor = this;

		// spec mandated checks
		if (ToString.call(arr) != "[object Array]") {
			return Constructor.reject(TypeError("Not an array"));
		}
		if (arr.length === 0) {
			return Constructor.resolve([]);
		}

		return new Constructor(function executor(resolve,reject){
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			var len = arr.length, msgs = Array(len), count = 0;

			iteratePromises(Constructor,arr,function resolver(idx,msg) {
				msgs[idx] = msg;
				if (++count === len) {
					resolve(msgs);
				}
			},reject);
		});
	});

	builtInProp(Promise,"race",function Promise$race(arr) {
		var Constructor = this;

		// spec mandated checks
		if (ToString.call(arr) != "[object Array]") {
			return Constructor.reject(TypeError("Not an array"));
		}

		return new Constructor(function executor(resolve,reject){
			if (typeof resolve != "function" || typeof reject != "function") {
				throw TypeError("Not a function");
			}

			iteratePromises(Constructor,arr,function resolver(idx,msg){
				resolve(msg);
			},reject);
		});
	});

	return Promise;
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],262:[function(require,module,exports){
/*! @preserve
 * numeral.js
 * version : 2.0.6
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */

(function (global, factory) {
    if (typeof define === 'function' && define.amd) {
        define(factory);
    } else if (typeof module === 'object' && module.exports) {
        module.exports = factory();
    } else {
        global.numeral = factory();
    }
}(this, function () {
    /************************************
        Variables
    ************************************/

    var numeral,
        _,
        VERSION = '2.0.6',
        formats = {},
        locales = {},
        defaults = {
            currentLocale: 'en',
            zeroFormat: null,
            nullFormat: null,
            defaultFormat: '0,0',
            scalePercentBy100: true
        },
        options = {
            currentLocale: defaults.currentLocale,
            zeroFormat: defaults.zeroFormat,
            nullFormat: defaults.nullFormat,
            defaultFormat: defaults.defaultFormat,
            scalePercentBy100: defaults.scalePercentBy100
        };


    /************************************
        Constructors
    ************************************/

    // Numeral prototype object
    function Numeral(input, number) {
        this._input = input;

        this._value = number;
    }

    numeral = function(input) {
        var value,
            kind,
            unformatFunction,
            regexp;

        if (numeral.isNumeral(input)) {
            value = input.value();
        } else if (input === 0 || typeof input === 'undefined') {
            value = 0;
        } else if (input === null || _.isNaN(input)) {
            value = null;
        } else if (typeof input === 'string') {
            if (options.zeroFormat && input === options.zeroFormat) {
                value = 0;
            } else if (options.nullFormat && input === options.nullFormat || !input.replace(/[^0-9]+/g, '').length) {
                value = null;
            } else {
                for (kind in formats) {
                    regexp = typeof formats[kind].regexps.unformat === 'function' ? formats[kind].regexps.unformat() : formats[kind].regexps.unformat;

                    if (regexp && input.match(regexp)) {
                        unformatFunction = formats[kind].unformat;

                        break;
                    }
                }

                unformatFunction = unformatFunction || numeral._.stringToNumber;

                value = unformatFunction(input);
            }
        } else {
            value = Number(input)|| null;
        }

        return new Numeral(input, value);
    };

    // version number
    numeral.version = VERSION;

    // compare numeral object
    numeral.isNumeral = function(obj) {
        return obj instanceof Numeral;
    };

    // helper functions
    numeral._ = _ = {
        // formats numbers separators, decimals places, signs, abbreviations
        numberToFormat: function(value, format, roundingFunction) {
            var locale = locales[numeral.options.currentLocale],
                negP = false,
                optDec = false,
                leadingCount = 0,
                abbr = '',
                trillion = 1000000000000,
                billion = 1000000000,
                million = 1000000,
                thousand = 1000,
                decimal = '',
                neg = false,
                abbrForce, // force abbreviation
                abs,
                min,
                max,
                power,
                int,
                precision,
                signed,
                thousands,
                output;

            // make sure we never format a null value
            value = value || 0;

            abs = Math.abs(value);

            // see if we should use parentheses for negative number or if we should prefix with a sign
            // if both are present we default to parentheses
            if (numeral._.includes(format, '(')) {
                negP = true;
                format = format.replace(/[\(|\)]/g, '');
            } else if (numeral._.includes(format, '+') || numeral._.includes(format, '-')) {
                signed = numeral._.includes(format, '+') ? format.indexOf('+') : value < 0 ? format.indexOf('-') : -1;
                format = format.replace(/[\+|\-]/g, '');
            }

            // see if abbreviation is wanted
            if (numeral._.includes(format, 'a')) {
                abbrForce = format.match(/a(k|m|b|t)?/);

                abbrForce = abbrForce ? abbrForce[1] : false;

                // check for space before abbreviation
                if (numeral._.includes(format, ' a')) {
                    abbr = ' ';
                }

                format = format.replace(new RegExp(abbr + 'a[kmbt]?'), '');

                if (abs >= trillion && !abbrForce || abbrForce === 't') {
                    // trillion
                    abbr += locale.abbreviations.trillion;
                    value = value / trillion;
                } else if (abs < trillion && abs >= billion && !abbrForce || abbrForce === 'b') {
                    // billion
                    abbr += locale.abbreviations.billion;
                    value = value / billion;
                } else if (abs < billion && abs >= million && !abbrForce || abbrForce === 'm') {
                    // million
                    abbr += locale.abbreviations.million;
                    value = value / million;
                } else if (abs < million && abs >= thousand && !abbrForce || abbrForce === 'k') {
                    // thousand
                    abbr += locale.abbreviations.thousand;
                    value = value / thousand;
                }
            }

            // check for optional decimals
            if (numeral._.includes(format, '[.]')) {
                optDec = true;
                format = format.replace('[.]', '.');
            }

            // break number and format
            int = value.toString().split('.')[0];
            precision = format.split('.')[1];
            thousands = format.indexOf(',');
            leadingCount = (format.split('.')[0].split(',')[0].match(/0/g) || []).length;

            if (precision) {
                if (numeral._.includes(precision, '[')) {
                    precision = precision.replace(']', '');
                    precision = precision.split('[');
                    decimal = numeral._.toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);
                } else {
                    decimal = numeral._.toFixed(value, precision.length, roundingFunction);
                }

                int = decimal.split('.')[0];

                if (numeral._.includes(decimal, '.')) {
                    decimal = locale.delimiters.decimal + decimal.split('.')[1];
                } else {
                    decimal = '';
                }

                if (optDec && Number(decimal.slice(1)) === 0) {
                    decimal = '';
                }
            } else {
                int = numeral._.toFixed(value, 0, roundingFunction);
            }

            // check abbreviation again after rounding
            if (abbr && !abbrForce && Number(int) >= 1000 && abbr !== locale.abbreviations.trillion) {
                int = String(Number(int) / 1000);

                switch (abbr) {
                    case locale.abbreviations.thousand:
                        abbr = locale.abbreviations.million;
                        break;
                    case locale.abbreviations.million:
                        abbr = locale.abbreviations.billion;
                        break;
                    case locale.abbreviations.billion:
                        abbr = locale.abbreviations.trillion;
                        break;
                }
            }


            // format number
            if (numeral._.includes(int, '-')) {
                int = int.slice(1);
                neg = true;
            }

            if (int.length < leadingCount) {
                for (var i = leadingCount - int.length; i > 0; i--) {
                    int = '0' + int;
                }
            }

            if (thousands > -1) {
                int = int.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + locale.delimiters.thousands);
            }

            if (format.indexOf('.') === 0) {
                int = '';
            }

            output = int + decimal + (abbr ? abbr : '');

            if (negP) {
                output = (negP && neg ? '(' : '') + output + (negP && neg ? ')' : '');
            } else {
                if (signed >= 0) {
                    output = signed === 0 ? (neg ? '-' : '+') + output : output + (neg ? '-' : '+');
                } else if (neg) {
                    output = '-' + output;
                }
            }

            return output;
        },
        // unformats numbers separators, decimals places, signs, abbreviations
        stringToNumber: function(string) {
            var locale = locales[options.currentLocale],
                stringOriginal = string,
                abbreviations = {
                    thousand: 3,
                    million: 6,
                    billion: 9,
                    trillion: 12
                },
                abbreviation,
                value,
                i,
                regexp;

            if (options.zeroFormat && string === options.zeroFormat) {
                value = 0;
            } else if (options.nullFormat && string === options.nullFormat || !string.replace(/[^0-9]+/g, '').length) {
                value = null;
            } else {
                value = 1;

                if (locale.delimiters.decimal !== '.') {
                    string = string.replace(/\./g, '').replace(locale.delimiters.decimal, '.');
                }

                for (abbreviation in abbreviations) {
                    regexp = new RegExp('[^a-zA-Z]' + locale.abbreviations[abbreviation] + '(?:\\)|(\\' + locale.currency.symbol + ')?(?:\\))?)?$');

                    if (stringOriginal.match(regexp)) {
                        value *= Math.pow(10, abbreviations[abbreviation]);
                        break;
                    }
                }

                // check for negative number
                value *= (string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2 ? 1 : -1;

                // remove non numbers
                string = string.replace(/[^0-9\.]+/g, '');

                value *= Number(string);
            }

            return value;
        },
        isNaN: function(value) {
            return typeof value === 'number' && isNaN(value);
        },
        includes: function(string, search) {
            return string.indexOf(search) !== -1;
        },
        insert: function(string, subString, start) {
            return string.slice(0, start) + subString + string.slice(start);
        },
        reduce: function(array, callback /*, initialValue*/) {
            if (this === null) {
                throw new TypeError('Array.prototype.reduce called on null or undefined');
            }

            if (typeof callback !== 'function') {
                throw new TypeError(callback + ' is not a function');
            }

            var t = Object(array),
                len = t.length >>> 0,
                k = 0,
                value;

            if (arguments.length === 3) {
                value = arguments[2];
            } else {
                while (k < len && !(k in t)) {
                    k++;
                }

                if (k >= len) {
                    throw new TypeError('Reduce of empty array with no initial value');
                }

                value = t[k++];
            }
            for (; k < len; k++) {
                if (k in t) {
                    value = callback(value, t[k], k, t);
                }
            }
            return value;
        },
        /**
         * Computes the multiplier necessary to make x >= 1,
         * effectively eliminating miscalculations caused by
         * finite precision.
         */
        multiplier: function (x) {
            var parts = x.toString().split('.');

            return parts.length < 2 ? 1 : Math.pow(10, parts[1].length);
        },
        /**
         * Given a variable number of arguments, returns the maximum
         * multiplier that must be used to normalize an operation involving
         * all of them.
         */
        correctionFactor: function () {
            var args = Array.prototype.slice.call(arguments);

            return args.reduce(function(accum, next) {
                var mn = _.multiplier(next);
                return accum > mn ? accum : mn;
            }, 1);
        },
        /**
         * Implementation of toFixed() that treats floats more like decimals
         *
         * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
         * problems for accounting- and finance-related software.
         */
        toFixed: function(value, maxDecimals, roundingFunction, optionals) {
            var splitValue = value.toString().split('.'),
                minDecimals = maxDecimals - (optionals || 0),
                boundedPrecision,
                optionalsRegExp,
                power,
                output;

            // Use the smallest precision value possible to avoid errors from floating point representation
            if (splitValue.length === 2) {
              boundedPrecision = Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals);
            } else {
              boundedPrecision = minDecimals;
            }

            power = Math.pow(10, boundedPrecision);

            // Multiply up by precision, round accurately, then divide and use native toFixed():
            output = (roundingFunction(value + 'e+' + boundedPrecision) / power).toFixed(boundedPrecision);

            if (optionals > maxDecimals - boundedPrecision) {
                optionalsRegExp = new RegExp('\\.?0{1,' + (optionals - (maxDecimals - boundedPrecision)) + '}$');
                output = output.replace(optionalsRegExp, '');
            }

            return output;
        }
    };

    // avaliable options
    numeral.options = options;

    // avaliable formats
    numeral.formats = formats;

    // avaliable formats
    numeral.locales = locales;

    // This function sets the current locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    numeral.locale = function(key) {
        if (key) {
            options.currentLocale = key.toLowerCase();
        }

        return options.currentLocale;
    };

    // This function provides access to the loaded locale data.  If
    // no arguments are passed in, it will simply return the current
    // global locale object.
    numeral.localeData = function(key) {
        if (!key) {
            return locales[options.currentLocale];
        }

        key = key.toLowerCase();

        if (!locales[key]) {
            throw new Error('Unknown locale : ' + key);
        }

        return locales[key];
    };

    numeral.reset = function() {
        for (var property in defaults) {
            options[property] = defaults[property];
        }
    };

    numeral.zeroFormat = function(format) {
        options.zeroFormat = typeof(format) === 'string' ? format : null;
    };

    numeral.nullFormat = function (format) {
        options.nullFormat = typeof(format) === 'string' ? format : null;
    };

    numeral.defaultFormat = function(format) {
        options.defaultFormat = typeof(format) === 'string' ? format : '0.0';
    };

    numeral.register = function(type, name, format) {
        name = name.toLowerCase();

        if (this[type + 's'][name]) {
            throw new TypeError(name + ' ' + type + ' already registered.');
        }

        this[type + 's'][name] = format;

        return format;
    };


    numeral.validate = function(val, culture) {
        var _decimalSep,
            _thousandSep,
            _currSymbol,
            _valArray,
            _abbrObj,
            _thousandRegEx,
            localeData,
            temp;

        //coerce val to string
        if (typeof val !== 'string') {
            val += '';

            if (console.warn) {
                console.warn('Numeral.js: Value is not string. It has been co-erced to: ', val);
            }
        }

        //trim whitespaces from either sides
        val = val.trim();

        //if val is just digits return true
        if (!!val.match(/^\d+$/)) {
            return true;
        }

        //if val is empty return false
        if (val === '') {
            return false;
        }

        //get the decimal and thousands separator from numeral.localeData
        try {
            //check if the culture is understood by numeral. if not, default it to current locale
            localeData = numeral.localeData(culture);
        } catch (e) {
            localeData = numeral.localeData(numeral.locale());
        }

        //setup the delimiters and currency symbol based on culture/locale
        _currSymbol = localeData.currency.symbol;
        _abbrObj = localeData.abbreviations;
        _decimalSep = localeData.delimiters.decimal;
        if (localeData.delimiters.thousands === '.') {
            _thousandSep = '\\.';
        } else {
            _thousandSep = localeData.delimiters.thousands;
        }

        // validating currency symbol
        temp = val.match(/^[^\d]+/);
        if (temp !== null) {
            val = val.substr(1);
            if (temp[0] !== _currSymbol) {
                return false;
            }
        }

        //validating abbreviation symbol
        temp = val.match(/[^\d]+$/);
        if (temp !== null) {
            val = val.slice(0, -1);
            if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {
                return false;
            }
        }

        _thousandRegEx = new RegExp(_thousandSep + '{2}');

        if (!val.match(/[^\d.,]/g)) {
            _valArray = val.split(_decimalSep);
            if (_valArray.length > 2) {
                return false;
            } else {
                if (_valArray.length < 2) {
                    return ( !! _valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx));
                } else {
                    if (_valArray[0].length === 1) {
                        return ( !! _valArray[0].match(/^\d+$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\d+$/));
                    } else {
                        return ( !! _valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\d+$/));
                    }
                }
            }
        }

        return false;
    };


    /************************************
        Numeral Prototype
    ************************************/

    numeral.fn = Numeral.prototype = {
        clone: function() {
            return numeral(this);
        },
        format: function(inputString, roundingFunction) {
            var value = this._value,
                format = inputString || options.defaultFormat,
                kind,
                output,
                formatFunction;

            // make sure we have a roundingFunction
            roundingFunction = roundingFunction || Math.round;

            // format based on value
            if (value === 0 && options.zeroFormat !== null) {
                output = options.zeroFormat;
            } else if (value === null && options.nullFormat !== null) {
                output = options.nullFormat;
            } else {
                for (kind in formats) {
                    if (format.match(formats[kind].regexps.format)) {
                        formatFunction = formats[kind].format;

                        break;
                    }
                }

                formatFunction = formatFunction || numeral._.numberToFormat;

                output = formatFunction(value, format, roundingFunction);
            }

            return output;
        },
        value: function() {
            return this._value;
        },
        input: function() {
            return this._input;
        },
        set: function(value) {
            this._value = Number(value);

            return this;
        },
        add: function(value) {
            var corrFactor = _.correctionFactor.call(null, this._value, value);

            function cback(accum, curr, currI, O) {
                return accum + Math.round(corrFactor * curr);
            }

            this._value = _.reduce([this._value, value], cback, 0) / corrFactor;

            return this;
        },
        subtract: function(value) {
            var corrFactor = _.correctionFactor.call(null, this._value, value);

            function cback(accum, curr, currI, O) {
                return accum - Math.round(corrFactor * curr);
            }

            this._value = _.reduce([value], cback, Math.round(this._value * corrFactor)) / corrFactor;

            return this;
        },
        multiply: function(value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = _.correctionFactor(accum, curr);
                return Math.round(accum * corrFactor) * Math.round(curr * corrFactor) / Math.round(corrFactor * corrFactor);
            }

            this._value = _.reduce([this._value, value], cback, 1);

            return this;
        },
        divide: function(value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = _.correctionFactor(accum, curr);
                return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);
            }

            this._value = _.reduce([this._value, value], cback);

            return this;
        },
        difference: function(value) {
            return Math.abs(numeral(this._value).subtract(value).value());
        }
    };

    /************************************
        Default Locale && Format
    ************************************/

    numeral.register('locale', 'en', {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function(number) {
            var b = number % 10;
            return (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
        },
        currency: {
            symbol: '$'
        }
    });

    

(function() {
        numeral.register('format', 'bps', {
            regexps: {
                format: /(BPS)/,
                unformat: /(BPS)/
            },
            format: function(value, format, roundingFunction) {
                var space = numeral._.includes(format, ' BPS') ? ' ' : '',
                    output;

                value = value * 10000;

                // check for space before BPS
                format = format.replace(/\s?BPS/, '');

                output = numeral._.numberToFormat(value, format, roundingFunction);

                if (numeral._.includes(output, ')')) {
                    output = output.split('');

                    output.splice(-1, 0, space + 'BPS');

                    output = output.join('');
                } else {
                    output = output + space + 'BPS';
                }

                return output;
            },
            unformat: function(string) {
                return +(numeral._.stringToNumber(string) * 0.0001).toFixed(15);
            }
        });
})();


(function() {
        var decimal = {
            base: 1000,
            suffixes: ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
        },
        binary = {
            base: 1024,
            suffixes: ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']
        };

    var allSuffixes =  decimal.suffixes.concat(binary.suffixes.filter(function (item) {
            return decimal.suffixes.indexOf(item) < 0;
        }));
        var unformatRegex = allSuffixes.join('|');
        // Allow support for BPS (http://www.investopedia.com/terms/b/basispoint.asp)
        unformatRegex = '(' + unformatRegex.replace('B', 'B(?!PS)') + ')';

    numeral.register('format', 'bytes', {
        regexps: {
            format: /([0\s]i?b)/,
            unformat: new RegExp(unformatRegex)
        },
        format: function(value, format, roundingFunction) {
            var output,
                bytes = numeral._.includes(format, 'ib') ? binary : decimal,
                suffix = numeral._.includes(format, ' b') || numeral._.includes(format, ' ib') ? ' ' : '',
                power,
                min,
                max;

            // check for space before
            format = format.replace(/\s?i?b/, '');

            for (power = 0; power <= bytes.suffixes.length; power++) {
                min = Math.pow(bytes.base, power);
                max = Math.pow(bytes.base, power + 1);

                if (value === null || value === 0 || value >= min && value < max) {
                    suffix += bytes.suffixes[power];

                    if (min > 0) {
                        value = value / min;
                    }

                    break;
                }
            }

            output = numeral._.numberToFormat(value, format, roundingFunction);

            return output + suffix;
        },
        unformat: function(string) {
            var value = numeral._.stringToNumber(string),
                power,
                bytesMultiplier;

            if (value) {
                for (power = decimal.suffixes.length - 1; power >= 0; power--) {
                    if (numeral._.includes(string, decimal.suffixes[power])) {
                        bytesMultiplier = Math.pow(decimal.base, power);

                        break;
                    }

                    if (numeral._.includes(string, binary.suffixes[power])) {
                        bytesMultiplier = Math.pow(binary.base, power);

                        break;
                    }
                }

                value *= (bytesMultiplier || 1);
            }

            return value;
        }
    });
})();


(function() {
        numeral.register('format', 'currency', {
        regexps: {
            format: /(\$)/
        },
        format: function(value, format, roundingFunction) {
            var locale = numeral.locales[numeral.options.currentLocale],
                symbols = {
                    before: format.match(/^([\+|\-|\(|\s|\$]*)/)[0],
                    after: format.match(/([\+|\-|\)|\s|\$]*)$/)[0]
                },
                output,
                symbol,
                i;

            // strip format of spaces and $
            format = format.replace(/\s?\$\s?/, '');

            // format the number
            output = numeral._.numberToFormat(value, format, roundingFunction);

            // update the before and after based on value
            if (value >= 0) {
                symbols.before = symbols.before.replace(/[\-\(]/, '');
                symbols.after = symbols.after.replace(/[\-\)]/, '');
            } else if (value < 0 && (!numeral._.includes(symbols.before, '-') && !numeral._.includes(symbols.before, '('))) {
                symbols.before = '-' + symbols.before;
            }

            // loop through each before symbol
            for (i = 0; i < symbols.before.length; i++) {
                symbol = symbols.before[i];

                switch (symbol) {
                    case '$':
                        output = numeral._.insert(output, locale.currency.symbol, i);
                        break;
                    case ' ':
                        output = numeral._.insert(output, ' ', i + locale.currency.symbol.length - 1);
                        break;
                }
            }

            // loop through each after symbol
            for (i = symbols.after.length - 1; i >= 0; i--) {
                symbol = symbols.after[i];

                switch (symbol) {
                    case '$':
                        output = i === symbols.after.length - 1 ? output + locale.currency.symbol : numeral._.insert(output, locale.currency.symbol, -(symbols.after.length - (1 + i)));
                        break;
                    case ' ':
                        output = i === symbols.after.length - 1 ? output + ' ' : numeral._.insert(output, ' ', -(symbols.after.length - (1 + i) + locale.currency.symbol.length - 1));
                        break;
                }
            }


            return output;
        }
    });
})();


(function() {
        numeral.register('format', 'exponential', {
        regexps: {
            format: /(e\+|e-)/,
            unformat: /(e\+|e-)/
        },
        format: function(value, format, roundingFunction) {
            var output,
                exponential = typeof value === 'number' && !numeral._.isNaN(value) ? value.toExponential() : '0e+0',
                parts = exponential.split('e');

            format = format.replace(/e[\+|\-]{1}0/, '');

            output = numeral._.numberToFormat(Number(parts[0]), format, roundingFunction);

            return output + 'e' + parts[1];
        },
        unformat: function(string) {
            var parts = numeral._.includes(string, 'e+') ? string.split('e+') : string.split('e-'),
                value = Number(parts[0]),
                power = Number(parts[1]);

            power = numeral._.includes(string, 'e-') ? power *= -1 : power;

            function cback(accum, curr, currI, O) {
                var corrFactor = numeral._.correctionFactor(accum, curr),
                    num = (accum * corrFactor) * (curr * corrFactor) / (corrFactor * corrFactor);
                return num;
            }

            return numeral._.reduce([value, Math.pow(10, power)], cback, 1);
        }
    });
})();


(function() {
        numeral.register('format', 'ordinal', {
        regexps: {
            format: /(o)/
        },
        format: function(value, format, roundingFunction) {
            var locale = numeral.locales[numeral.options.currentLocale],
                output,
                ordinal = numeral._.includes(format, ' o') ? ' ' : '';

            // check for space before
            format = format.replace(/\s?o/, '');

            ordinal += locale.ordinal(value);

            output = numeral._.numberToFormat(value, format, roundingFunction);

            return output + ordinal;
        }
    });
})();


(function() {
        numeral.register('format', 'percentage', {
        regexps: {
            format: /(%)/,
            unformat: /(%)/
        },
        format: function(value, format, roundingFunction) {
            var space = numeral._.includes(format, ' %') ? ' ' : '',
                output;

            if (numeral.options.scalePercentBy100) {
                value = value * 100;
            }

            // check for space before %
            format = format.replace(/\s?\%/, '');

            output = numeral._.numberToFormat(value, format, roundingFunction);

            if (numeral._.includes(output, ')')) {
                output = output.split('');

                output.splice(-1, 0, space + '%');

                output = output.join('');
            } else {
                output = output + space + '%';
            }

            return output;
        },
        unformat: function(string) {
            var number = numeral._.stringToNumber(string);
            if (numeral.options.scalePercentBy100) {
                return number * 0.01;
            }
            return number;
        }
    });
})();


(function() {
        numeral.register('format', 'time', {
        regexps: {
            format: /(:)/,
            unformat: /(:)/
        },
        format: function(value, format, roundingFunction) {
            var hours = Math.floor(value / 60 / 60),
                minutes = Math.floor((value - (hours * 60 * 60)) / 60),
                seconds = Math.round(value - (hours * 60 * 60) - (minutes * 60));

            return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);
        },
        unformat: function(string) {
            var timeArray = string.split(':'),
                seconds = 0;

            // turn hours and minutes into seconds and add them all up
            if (timeArray.length === 3) {
                // hours
                seconds = seconds + (Number(timeArray[0]) * 60 * 60);
                // minutes
                seconds = seconds + (Number(timeArray[1]) * 60);
                // seconds
                seconds = seconds + Number(timeArray[2]);
            } else if (timeArray.length === 2) {
                // minutes
                seconds = seconds + (Number(timeArray[0]) * 60);
                // seconds
                seconds = seconds + Number(timeArray[1]);
            }
            return Number(seconds);
        }
    });
})();

return numeral;
}));

},{}],263:[function(require,module,exports){
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.rangesliderJs=t():e.rangesliderJs=t()}(this,function(){return function(e){function __webpack_require__(i){if(t[i])return t[i].exports;var n=t[i]={i:i,l:!1,exports:{}};return e[i].call(n.exports,n,n.exports,__webpack_require__),n.l=!0,n.exports}var t={};return __webpack_require__.m=e,__webpack_require__.c=t,__webpack_require__.i=function(e){return e},__webpack_require__.d=function(e,t,i){__webpack_require__.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},__webpack_require__.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return __webpack_require__.d(t,"a",t),t},__webpack_require__.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s=6)}([function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default={MIN_DEFAULT:0,MAX_DEFAULT:100,RANGE_CLASS:"rangeslider",FILL_CLASS:"rangeslider__fill",FILL_BG_CLASS:"rangeslider__fill__bg",HANDLE_CLASS:"rangeslider__handle",DISABLED_CLASS:"rangeslider--disabled",STEP_DEFAULT:1,START_EVENTS:["mousedown","touchstart","pointerdown"],MOVE_EVENTS:["mousemove","touchmove","pointermove"],END_EVENTS:["mouseup","touchend","pointerup"],PLUGIN_NAME:"rangeslider-js"}},function(e,t,i){"use strict";function clamp(e,t,i){return t<i?e<t?t:e>i?i:e:e<i?i:e>t?t:e}function isHidden(e){return 0===e.offsetWidth||0===e.offsetHeight||!1===e.open}function isNumberLike(e){return o(parseFloat(e))||o(e)}function getFirstNumberLike(){if(!arguments.length)return null;for(var e=0,t=arguments.length;e<t;e++)if(isNumberLike(arguments[e]))return arguments[e]}function getHiddenParentNodes(e){for(var t=[],i=e.parentNode;i&&isHidden(i);)t.push(i),i=i.parentNode;return t}function getDimension(e,t){function toggleOpenProperty(e){void 0!==e.open&&(e.open=!e.open)}var i=getHiddenParentNodes(e),n=i.length,r=[],s=e[t],o=0,a=void 0;if(n){for(o=0;o<n;o++)a=i[o].style,r[o]=a.display,a.display="block",a.height="0",a.overflow="hidden",a.visibility="hidden",toggleOpenProperty(i[o]);for(s=e[t],o=0;o<n;o++)a=i[o].style,toggleOpenProperty(i[o]),a.display=r[o],a.height="",a.overflow="",a.visibility=""}return s}function forEachAncestorsAndSelf(e,t){for(t(e);e.parentNode&&!t(e);)e=e.parentNode;return e}function insertAfter(e,t){e.parentNode.insertBefore(t,e.nextSibling)}Object.defineProperty(t,"__esModule",{value:!0});var n=i(3),r=function(e){return e&&e.__esModule?e:{default:e}}(n);window.requestAnimationFrame=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame;var s=Number.isNaN||function(e){return e!==e},o=Number.isFinite||function(e){return!("number"!=typeof e||s(e)||e===1/0||e===-1/0)},a=function(){function resize(){t||(t=!0,window.requestAnimationFrame?window.requestAnimationFrame(runCallbacks):setTimeout(runCallbacks,66))}function runCallbacks(){e.forEach(function(e){e()}),t=!1}function addCallback(t){t&&e.push(t)}var e=[],t=!1;return{add:function(t){!e.length&&window.addEventListener("resize",resize),addCallback(t)}}}();t.default={emit:function(e,t,i){e.dispatchEvent(new r.default(t,i))},isFiniteNumber:o,getFirstNumberLike:getFirstNumberLike,getDimension:getDimension,insertAfter:insertAfter,forEachAncestorsAndSelf:forEachAncestorsAndSelf,clamp:clamp,optimizedResize:a}},function(e,t,i){"use strict";function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}var n=function(){function defineProperties(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,i){return t&&defineProperties(e.prototype,t),i&&defineProperties(e,i),e}}(),r=i(4),s=_interopRequireDefault(r),o=i(1),a=_interopRequireDefault(o),u=i(0),l=_interopRequireDefault(u),c=function(e){var t=document&&document.createElement("div");return t.classList.add(e),t},d=function(e){return(""+e).replace(".","").length-1},h=function(){function RangeSlider(e,t){var i=this;_classCallCheck(this,RangeSlider),t=t||{},this.element=e,this.options=t,this.onSlideEventsCount=-1,this.isInteracting=!1,this.needTriggerEvents=!1,this.constructor.count=this.constructor.count||0,this.identifier="js-"+l.default.PLUGIN_NAME+"-"+this.constructor.count++,this.min=a.default.getFirstNumberLike(t.min,parseFloat(e.getAttribute("min")),l.default.MIN_DEFAULT),this.max=a.default.getFirstNumberLike(t.max,parseFloat(e.getAttribute("max")),l.default.MAX_DEFAULT),this.value=a.default.getFirstNumberLike(t.value,parseFloat(e.getAttribute("value")),this.min+(this.max-this.min)/2),this.step=a.default.getFirstNumberLike(t.step,parseFloat(e.getAttribute("step")),l.default.STEP_DEFAULT),this.percent=null,this._updatePercentFromValue(),this.toFixed=d(this.step),this.range=c(l.default.RANGE_CLASS),this.range.id=this.identifier,this.fillBg=c(l.default.FILL_BG_CLASS),this.fill=c(l.default.FILL_CLASS),this.handle=c(l.default.HANDLE_CLASS),["fillBg","fill","handle"].forEach(function(e){return i.range.appendChild(i[e])}),["min","max","step"].forEach(function(t){return e.setAttribute(t,""+i[t])}),this._setValue(this.value),a.default.insertAfter(e,this.range),e.style.position="absolute",e.style.width="1px",e.style.height="1px",e.style.overflow="hidden",e.style.opacity="0",["_update","_handleDown","_handleMove","_handleEnd","_startEventListener","_changeEventListener"].forEach(function(e){i[e]=i[e].bind(i)}),this._init(),a.default.optimizedResize.add(this._update),l.default.START_EVENTS.forEach(function(e){return i.range.addEventListener(e,i._startEventListener)}),e.addEventListener("change",this._changeEventListener)}return n(RangeSlider,[{key:"_init",value:function(){this._update(),this.options.onInit&&this.options.onInit.call(this,this.value,this.percent,this.position)}},{key:"_updatePercentFromValue",value:function(){this.percent=(this.value-this.min)/(this.max-this.min)}},{key:"_startEventListener",value:function(e){var t=e.target,i=this.identifier,n=!1;a.default.forEachAncestorsAndSelf(t,function(e){return n=e.id===i&&!e.classList.contains(l.default.DISABLED_CLASS)}),n&&this._handleDown(e)}},{key:"_changeEventListener",value:function(e,t){(t&&t.origin)!==this.identifier&&this._setPosition(this._getPositionFromValue(e.target.value))}},{key:"_update",value:function(){this.handleWidth=a.default.getDimension(this.handle,"offsetWidth"),this.rangeWidth=a.default.getDimension(this.range,"offsetWidth"),this.maxHandleX=this.rangeWidth-this.handleWidth,this.grabX=this.handleWidth/2,this.position=this._getPositionFromValue(this.value),this.range.classList[this.element.disabled?"add":"remove"](l.default.DISABLED_CLASS),this._setPosition(this.position),this._updatePercentFromValue(),this._emit("change")}},{key:"_listen",value:function(e){var t=this,i=(e?"add":"remove")+"EventListener";l.default.MOVE_EVENTS.forEach(function(e){return document&&document[i](e,t._handleMove)}),l.default.END_EVENTS.forEach(function(e){document&&document[i](e,t._handleEnd),t.range[i](e,t._handleEnd)})}},{key:"_handleDown",value:function(e){if(e.preventDefault(),this.isInteracting=!0,this._listen(!0),!e.target.classList.contains(l.default.HANDLE_CLASS)){var t=(0,s.default)(e,this.range).x,i=this.range.getBoundingClientRect().left,n=this.handle.getBoundingClientRect().left-i;this._setPosition(t-this.grabX),t>=n&&t<n+this.handleWidth&&(this.grabX=t-n),this._updatePercentFromValue()}}},{key:"_handleMove",value:function(e){this.isInteracting=!0,e.preventDefault();var t=(0,s.default)(e,this.range).x;this._setPosition(t-this.grabX)}},{key:"_handleEnd",value:function(e){e.preventDefault(),this._listen(!1),this._emit("change"),(this.isInteracting||this.needTriggerEvents)&&this.options.onSlideEnd&&this.options.onSlideEnd.call(this,this.value,this.percent,this.position),this.onSlideEventsCount=0,this.isInteracting=!1}},{key:"_setPosition",value:function(e){var t=this.isInteracting?this._getValueFromPosition(a.default.clamp(e,0,this.maxHandleX)):this.value,i=this._getPositionFromValue(t);this.fill.style.width=i+this.grabX+"px",this.handle.style.webkitTransform=this.handle.style.transform="translate("+i+"px, -50%)",this._setValue(t),this.position=i,this.value=t,this._updatePercentFromValue(),(this.isInteracting||this.needTriggerEvents)&&(this.options.onSlideStart&&0===this.onSlideEventsCount&&this.options.onSlideStart.call(this,this.value,this.percent,this.position),this.options.onSlide&&this.options.onSlide.call(this,this.value,this.percent,this.position)),this.onSlideEventsCount++}},{key:"_getPositionFromValue",value:function(e){return(e-this.min)/(this.max-this.min)*this.maxHandleX}},{key:"_getValueFromPosition",value:function(e){var t=e/(this.maxHandleX||1),i=this.step*Math.round(t*(this.max-this.min)/this.step)+this.min;return Number(i.toFixed(this.toFixed))}},{key:"_setValue",value:function(e){(e=a.default.clamp(e,this.min,this.max))===this.value&&e===this.element.value||(this.value=this.element.value=e,this._emit("input"))}},{key:"_emit",value:function(e){a.default.emit(this.element,e,{origin:this.identifier})}},{key:"update",value:function(e,t){return e=e||{},this.needTriggerEvents=!!t,a.default.isFiniteNumber(e.min)&&(this.element.setAttribute("min",""+e.min),this.min=e.min),a.default.isFiniteNumber(e.max)&&(this.element.setAttribute("max",""+e.max),this.max=e.max),a.default.isFiniteNumber(e.step)&&(this.element.setAttribute("step",""+e.step),this.step=e.step,this.toFixed=d(e.step)),a.default.isFiniteNumber(e.value)&&this._setValue(e.value),this._update(),this.onSlideEventsCount=0,this.needTriggerEvents=!1,this}},{key:"destroy",value:function(){var e=this;"undefined"!=typeof window&&window.removeEventListener("resize",this._update,!1),l.default.START_EVENTS.forEach(function(t){return e.range.removeEventListener(t,e._startEventListener)}),this.element.removeEventListener("change",this._changeEventListener),this.element.style.cssText="",delete this.element[l.default.PLUGIN_NAME],this.range.parentNode.removeChild(this.range)}}]),RangeSlider}();e.exports=h},function(e,t,i){"use strict";(function(t){var i=t.CustomEvent;e.exports=function(){try{var e=new i("cat",{detail:{foo:"bar"}});return"cat"===e.type&&"bar"===e.detail.foo}catch(e){}return!1}()?i:"undefined"!=typeof document&&"function"==typeof document.createEvent?function(e,t){var i=document.createEvent("CustomEvent");return t?i.initCustomEvent(e,t.bubbles,t.cancelable,t.detail):i.initCustomEvent(e,!1,!1,void 0),i}:function(e,t){var i=document.createEventObject();return i.type=e,t?(i.bubbles=Boolean(t.bubbles),i.cancelable=Boolean(t.cancelable),i.detail=t.detail):(i.bubbles=!1,i.cancelable=!1,i.detail=void 0),i}}).call(t,i(5))},function(e,t,i){"use strict";var n=function(e){return"number"==typeof e&&!isNaN(e)},r=function(e,t){t=t||t.currentTarget;var i=t.getBoundingClientRect(),r=e.originalEvent||e,s=e.touches&&e.touches.length,o=0,a=0;return s?n(e.touches[0].pageX)&&n(e.touches[0].pageY)?(o=e.touches[0].pageX,a=e.touches[0].pageY):n(e.touches[0].clientX)&&n(e.touches[0].clientY)&&(o=r.touches[0].clientX,a=r.touches[0].clientY):n(e.pageX)&&n(e.pageY)?(o=e.pageX,a=e.pageY):e.currentPoint&&n(e.currentPoint.x)&&n(e.currentPoint.y)&&(o=e.currentPoint.x,a=e.currentPoint.y),{x:o-i.left,y:a-i.top}};e.exports=r},function(e,t,i){"use strict";var n,r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};n=function(){return this}();try{n=n||Function("return this")()||(0,eval)("this")}catch(e){"object"===("undefined"==typeof window?"undefined":r(window))&&(n=window)}e.exports=n},function(e,t,i){"use strict";function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}var n=i(1),r=_interopRequireDefault(n),s=i(2),o=_interopRequireDefault(s),a=i(0),u=_interopRequireDefault(a),l={RangeSlider:o.default,utils:r.default,create:function(e,t){function createInstance(e){e[u.default.PLUGIN_NAME]=e[u.default.PLUGIN_NAME]||new o.default(e,t)}e&&(e.length?Array.prototype.slice.call(e).forEach(function(e){return createInstance(e)}):createInstance(e))}};e.exports=l}])});
},{}],264:[function(require,module,exports){
module.exports = function (obj) {
    if (!obj || typeof obj !== 'object') return obj;
    
    var copy;
    
    if (isArray(obj)) {
        var len = obj.length;
        copy = Array(len);
        for (var i = 0; i < len; i++) {
            copy[i] = obj[i];
        }
    }
    else {
        var keys = objectKeys(obj);
        copy = {};
        
        for (var i = 0, l = keys.length; i < l; i++) {
            var key = keys[i];
            copy[key] = obj[key];
        }
    }
    return copy;
};

var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) {
        if ({}.hasOwnProperty.call(obj, key)) keys.push(key);
    }
    return keys;
};

var isArray = Array.isArray || function (xs) {
    return {}.toString.call(xs) === '[object Array]';
};

},{}],265:[function(require,module,exports){
/*!
 * Signature Pad v2.3.0
 * https://github.com/szimek/signature_pad
 *
 * Copyright 2017 Szymon Nowak
 * Released under the MIT license
 *
 * The main idea and some parts of the code (e.g. drawing variable width Bzier curve) are taken from:
 * http://corner.squareup.com/2012/07/smoother-signatures.html
 *
 * Implementation of interpolation using cubic Bzier curves is taken from:
 * http://benknowscode.wordpress.com/2012/09/14/path-interpolation-using-cubic-bezier-and-control-point-estimation-in-javascript
 *
 * Algorithm for approximated length of a Bzier curve is taken from:
 * http://www.lemoda.net/maths/bezier-length/index.html
 *
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.SignaturePad = factory());
}(this, (function () { 'use strict';

function Point(x, y, time) {
  this.x = x;
  this.y = y;
  this.time = time || new Date().getTime();
}

Point.prototype.velocityFrom = function (start) {
  return this.time !== start.time ? this.distanceTo(start) / (this.time - start.time) : 1;
};

Point.prototype.distanceTo = function (start) {
  return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));
};

Point.prototype.equals = function (other) {
  return this.x === other.x && this.y === other.y && this.time === other.time;
};

function Bezier(startPoint, control1, control2, endPoint) {
  this.startPoint = startPoint;
  this.control1 = control1;
  this.control2 = control2;
  this.endPoint = endPoint;
}

// Returns approximated length.
Bezier.prototype.length = function () {
  var steps = 10;
  var length = 0;
  var px = void 0;
  var py = void 0;

  for (var i = 0; i <= steps; i += 1) {
    var t = i / steps;
    var cx = this._point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);
    var cy = this._point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);
    if (i > 0) {
      var xdiff = cx - px;
      var ydiff = cy - py;
      length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);
    }
    px = cx;
    py = cy;
  }

  return length;
};

/* eslint-disable no-multi-spaces, space-in-parens */
Bezier.prototype._point = function (t, start, c1, c2, end) {
  return start * (1.0 - t) * (1.0 - t) * (1.0 - t) + 3.0 * c1 * (1.0 - t) * (1.0 - t) * t + 3.0 * c2 * (1.0 - t) * t * t + end * t * t * t;
};

/* eslint-disable */

// http://stackoverflow.com/a/27078401/815507
function throttle(func, wait, options) {
  var context, args, result;
  var timeout = null;
  var previous = 0;
  if (!options) options = {};
  var later = function later() {
    previous = options.leading === false ? 0 : Date.now();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  };
  return function () {
    var now = Date.now();
    if (!previous && options.leading === false) previous = now;
    var remaining = wait - (now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };
}

function SignaturePad(canvas, options) {
  var self = this;
  var opts = options || {};

  this.velocityFilterWeight = opts.velocityFilterWeight || 0.7;
  this.minWidth = opts.minWidth || 0.5;
  this.maxWidth = opts.maxWidth || 2.5;
  this.throttle = 'throttle' in opts ? opts.throttle : 16; // in miliseconds
  this.minDistance = opts.minDistance || 5;

  if (this.throttle) {
    this._strokeMoveUpdate = throttle(SignaturePad.prototype._strokeUpdate, this.throttle);
  } else {
    this._strokeMoveUpdate = SignaturePad.prototype._strokeUpdate;
  }

  this.dotSize = opts.dotSize || function () {
    return (this.minWidth + this.maxWidth) / 2;
  };
  this.penColor = opts.penColor || 'black';
  this.backgroundColor = opts.backgroundColor || 'rgba(0,0,0,0)';
  this.onBegin = opts.onBegin;
  this.onEnd = opts.onEnd;

  this._canvas = canvas;
  this._ctx = canvas.getContext('2d');
  this.clear();

  // We need add these inline so they are available to unbind while still having
  // access to 'self' we could use _.bind but it's not worth adding a dependency.
  this._handleMouseDown = function (event) {
    if (event.which === 1) {
      self._mouseButtonDown = true;
      self._strokeBegin(event);
    }
  };

  this._handleMouseMove = function (event) {
    if (self._mouseButtonDown) {
      self._strokeMoveUpdate(event);
    }
  };

  this._handleMouseUp = function (event) {
    if (event.which === 1 && self._mouseButtonDown) {
      self._mouseButtonDown = false;
      self._strokeEnd(event);
    }
  };

  this._handleTouchStart = function (event) {
    if (event.targetTouches.length === 1) {
      var touch = event.changedTouches[0];
      self._strokeBegin(touch);
    }
  };

  this._handleTouchMove = function (event) {
    // Prevent scrolling.
    event.preventDefault();

    var touch = event.targetTouches[0];
    self._strokeMoveUpdate(touch);
  };

  this._handleTouchEnd = function (event) {
    var wasCanvasTouched = event.target === self._canvas;
    if (wasCanvasTouched) {
      event.preventDefault();
      self._strokeEnd(event);
    }
  };

  // Enable mouse and touch event handlers
  this.on();
}

// Public methods
SignaturePad.prototype.clear = function () {
  var ctx = this._ctx;
  var canvas = this._canvas;

  ctx.fillStyle = this.backgroundColor;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  this._data = [];
  this._reset();
  this._isEmpty = true;
};

SignaturePad.prototype.fromDataURL = function (dataUrl) {
  var _this = this;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var image = new Image();
  var ratio = options.ratio || window.devicePixelRatio || 1;
  var width = options.width || this._canvas.width / ratio;
  var height = options.height || this._canvas.height / ratio;

  this._reset();
  image.src = dataUrl;
  image.onload = function () {
    _this._ctx.drawImage(image, 0, 0, width, height);
  };
  this._isEmpty = false;
};

SignaturePad.prototype.toDataURL = function (type) {
  var _canvas;

  switch (type) {
    case 'image/svg+xml':
      return this._toSVG();
    default:
      for (var _len = arguments.length, options = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        options[_key - 1] = arguments[_key];
      }

      return (_canvas = this._canvas).toDataURL.apply(_canvas, [type].concat(options));
  }
};

SignaturePad.prototype.on = function () {
  this._handleMouseEvents();
  this._handleTouchEvents();
};

SignaturePad.prototype.off = function () {
  this._canvas.removeEventListener('mousedown', this._handleMouseDown);
  this._canvas.removeEventListener('mousemove', this._handleMouseMove);
  document.removeEventListener('mouseup', this._handleMouseUp);

  this._canvas.removeEventListener('touchstart', this._handleTouchStart);
  this._canvas.removeEventListener('touchmove', this._handleTouchMove);
  this._canvas.removeEventListener('touchend', this._handleTouchEnd);
};

SignaturePad.prototype.isEmpty = function () {
  return this._isEmpty;
};

// Private methods
SignaturePad.prototype._strokeBegin = function (event) {
  this._data.push([]);
  this._reset();
  this._strokeUpdate(event);

  if (typeof this.onBegin === 'function') {
    this.onBegin(event);
  }
};

SignaturePad.prototype._strokeUpdate = function (event) {
  var x = event.clientX;
  var y = event.clientY;

  var point = this._createPoint(x, y);
  var lastPointGroup = this._data[this._data.length - 1];
  var lastPoint = lastPointGroup && lastPointGroup[lastPointGroup.length - 1];
  var isLastPointTooClose = lastPoint && point.distanceTo(lastPoint) < this.minDistance;

  // Skip this point if it's too close to the previous one
  if (!(lastPoint && isLastPointTooClose)) {
    var _addPoint = this._addPoint(point),
        curve = _addPoint.curve,
        widths = _addPoint.widths;

    if (curve && widths) {
      this._drawCurve(curve, widths.start, widths.end);
    }

    this._data[this._data.length - 1].push({
      x: point.x,
      y: point.y,
      time: point.time,
      color: this.penColor
    });
  }
};

SignaturePad.prototype._strokeEnd = function (event) {
  var canDrawCurve = this.points.length > 2;
  var point = this.points[0]; // Point instance

  if (!canDrawCurve && point) {
    this._drawDot(point);
  }

  if (point) {
    var lastPointGroup = this._data[this._data.length - 1];
    var lastPoint = lastPointGroup[lastPointGroup.length - 1]; // plain object

    // When drawing a dot, there's only one point in a group, so without this check
    // such group would end up with exactly the same 2 points.
    if (!point.equals(lastPoint)) {
      lastPointGroup.push({
        x: point.x,
        y: point.y,
        time: point.time,
        color: this.penColor
      });
    }
  }

  if (typeof this.onEnd === 'function') {
    this.onEnd(event);
  }
};

SignaturePad.prototype._handleMouseEvents = function () {
  this._mouseButtonDown = false;

  this._canvas.addEventListener('mousedown', this._handleMouseDown);
  this._canvas.addEventListener('mousemove', this._handleMouseMove);
  document.addEventListener('mouseup', this._handleMouseUp);
};

SignaturePad.prototype._handleTouchEvents = function () {
  // Pass touch events to canvas element on mobile IE11 and Edge.
  this._canvas.style.msTouchAction = 'none';
  this._canvas.style.touchAction = 'none';

  this._canvas.addEventListener('touchstart', this._handleTouchStart);
  this._canvas.addEventListener('touchmove', this._handleTouchMove);
  this._canvas.addEventListener('touchend', this._handleTouchEnd);
};

SignaturePad.prototype._reset = function () {
  this.points = [];
  this._lastVelocity = 0;
  this._lastWidth = (this.minWidth + this.maxWidth) / 2;
  this._ctx.fillStyle = this.penColor;
};

SignaturePad.prototype._createPoint = function (x, y, time) {
  var rect = this._canvas.getBoundingClientRect();

  return new Point(x - rect.left, y - rect.top, time || new Date().getTime());
};

SignaturePad.prototype._addPoint = function (point) {
  var points = this.points;
  var tmp = void 0;

  points.push(point);

  if (points.length > 2) {
    // To reduce the initial lag make it work with 3 points
    // by copying the first point to the beginning.
    if (points.length === 3) points.unshift(points[0]);

    tmp = this._calculateCurveControlPoints(points[0], points[1], points[2]);
    var c2 = tmp.c2;
    tmp = this._calculateCurveControlPoints(points[1], points[2], points[3]);
    var c3 = tmp.c1;
    var curve = new Bezier(points[1], c2, c3, points[2]);
    var widths = this._calculateCurveWidths(curve);

    // Remove the first element from the list,
    // so that we always have no more than 4 points in points array.
    points.shift();

    return { curve: curve, widths: widths };
  }

  return {};
};

SignaturePad.prototype._calculateCurveControlPoints = function (s1, s2, s3) {
  var dx1 = s1.x - s2.x;
  var dy1 = s1.y - s2.y;
  var dx2 = s2.x - s3.x;
  var dy2 = s2.y - s3.y;

  var m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };
  var m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };

  var l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
  var l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

  var dxm = m1.x - m2.x;
  var dym = m1.y - m2.y;

  var k = l2 / (l1 + l2);
  var cm = { x: m2.x + dxm * k, y: m2.y + dym * k };

  var tx = s2.x - cm.x;
  var ty = s2.y - cm.y;

  return {
    c1: new Point(m1.x + tx, m1.y + ty),
    c2: new Point(m2.x + tx, m2.y + ty)
  };
};

SignaturePad.prototype._calculateCurveWidths = function (curve) {
  var startPoint = curve.startPoint;
  var endPoint = curve.endPoint;
  var widths = { start: null, end: null };

  var velocity = this.velocityFilterWeight * endPoint.velocityFrom(startPoint) + (1 - this.velocityFilterWeight) * this._lastVelocity;

  var newWidth = this._strokeWidth(velocity);

  widths.start = this._lastWidth;
  widths.end = newWidth;

  this._lastVelocity = velocity;
  this._lastWidth = newWidth;

  return widths;
};

SignaturePad.prototype._strokeWidth = function (velocity) {
  return Math.max(this.maxWidth / (velocity + 1), this.minWidth);
};

SignaturePad.prototype._drawPoint = function (x, y, size) {
  var ctx = this._ctx;

  ctx.moveTo(x, y);
  ctx.arc(x, y, size, 0, 2 * Math.PI, false);
  this._isEmpty = false;
};

SignaturePad.prototype._drawCurve = function (curve, startWidth, endWidth) {
  var ctx = this._ctx;
  var widthDelta = endWidth - startWidth;
  var drawSteps = Math.floor(curve.length());

  ctx.beginPath();

  for (var i = 0; i < drawSteps; i += 1) {
    // Calculate the Bezier (x, y) coordinate for this step.
    var t = i / drawSteps;
    var tt = t * t;
    var ttt = tt * t;
    var u = 1 - t;
    var uu = u * u;
    var uuu = uu * u;

    var x = uuu * curve.startPoint.x;
    x += 3 * uu * t * curve.control1.x;
    x += 3 * u * tt * curve.control2.x;
    x += ttt * curve.endPoint.x;

    var y = uuu * curve.startPoint.y;
    y += 3 * uu * t * curve.control1.y;
    y += 3 * u * tt * curve.control2.y;
    y += ttt * curve.endPoint.y;

    var width = startWidth + ttt * widthDelta;
    this._drawPoint(x, y, width);
  }

  ctx.closePath();
  ctx.fill();
};

SignaturePad.prototype._drawDot = function (point) {
  var ctx = this._ctx;
  var width = typeof this.dotSize === 'function' ? this.dotSize() : this.dotSize;

  ctx.beginPath();
  this._drawPoint(point.x, point.y, width);
  ctx.closePath();
  ctx.fill();
};

SignaturePad.prototype._fromData = function (pointGroups, drawCurve, drawDot) {
  for (var i = 0; i < pointGroups.length; i += 1) {
    var group = pointGroups[i];

    if (group.length > 1) {
      for (var j = 0; j < group.length; j += 1) {
        var rawPoint = group[j];
        var point = new Point(rawPoint.x, rawPoint.y, rawPoint.time);
        var color = rawPoint.color;

        if (j === 0) {
          // First point in a group. Nothing to draw yet.
          this._reset();
          this._addPoint(point);
        } else if (j !== group.length - 1) {
          // Middle point in a group.
          var _addPoint2 = this._addPoint(point),
              curve = _addPoint2.curve,
              widths = _addPoint2.widths;

          if (curve && widths) {
            drawCurve(curve, widths, color);
          }
        } else {
          // Last point in a group. Do nothing.
        }
      }
    } else {
      this._reset();
      var _rawPoint = group[0];
      drawDot(_rawPoint);
    }
  }
};

SignaturePad.prototype._toSVG = function () {
  var _this2 = this;

  var pointGroups = this._data;
  var canvas = this._canvas;
  var ratio = Math.max(window.devicePixelRatio || 1, 1);
  var minX = 0;
  var minY = 0;
  var maxX = canvas.width / ratio;
  var maxY = canvas.height / ratio;
  var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');

  svg.setAttributeNS(null, 'width', canvas.width);
  svg.setAttributeNS(null, 'height', canvas.height);

  this._fromData(pointGroups, function (curve, widths, color) {
    var path = document.createElement('path');

    // Need to check curve for NaN values, these pop up when drawing
    // lines on the canvas that are not continuous. E.g. Sharp corners
    // or stopping mid-stroke and than continuing without lifting mouse.
    if (!isNaN(curve.control1.x) && !isNaN(curve.control1.y) && !isNaN(curve.control2.x) && !isNaN(curve.control2.y)) {
      var attr = 'M ' + curve.startPoint.x.toFixed(3) + ',' + curve.startPoint.y.toFixed(3) + ' ' + ('C ' + curve.control1.x.toFixed(3) + ',' + curve.control1.y.toFixed(3) + ' ') + (curve.control2.x.toFixed(3) + ',' + curve.control2.y.toFixed(3) + ' ') + (curve.endPoint.x.toFixed(3) + ',' + curve.endPoint.y.toFixed(3));

      path.setAttribute('d', attr);
      path.setAttribute('stroke-width', (widths.end * 2.25).toFixed(3));
      path.setAttribute('stroke', color);
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke-linecap', 'round');

      svg.appendChild(path);
    }
  }, function (rawPoint) {
    var circle = document.createElement('circle');
    var dotSize = typeof _this2.dotSize === 'function' ? _this2.dotSize() : _this2.dotSize;
    circle.setAttribute('r', dotSize);
    circle.setAttribute('cx', rawPoint.x);
    circle.setAttribute('cy', rawPoint.y);
    circle.setAttribute('fill', rawPoint.color);

    svg.appendChild(circle);
  });

  var prefix = 'data:image/svg+xml;base64,';
  var header = '<svg' + ' xmlns="http://www.w3.org/2000/svg"' + ' xmlns:xlink="http://www.w3.org/1999/xlink"' + (' viewBox="' + minX + ' ' + minY + ' ' + maxX + ' ' + maxY + '"') + (' width="' + maxX + '"') + (' height="' + maxY + '"') + '>';
  var body = svg.innerHTML;

  // IE hack for missing innerHTML property on SVGElement
  if (body === undefined) {
    var dummy = document.createElement('dummy');
    var nodes = svg.childNodes;
    dummy.innerHTML = '';

    for (var i = 0; i < nodes.length; i += 1) {
      dummy.appendChild(nodes[i].cloneNode(true));
    }

    body = dummy.innerHTML;
  }

  var footer = '</svg>';
  var data = header + body + footer;

  return prefix + btoa(data);
};

SignaturePad.prototype.fromData = function (pointGroups) {
  var _this3 = this;

  this.clear();

  this._fromData(pointGroups, function (curve, widths) {
    return _this3._drawCurve(curve, widths.start, widths.end);
  }, function (rawPoint) {
    return _this3._drawDot(rawPoint);
  });

  this._data = pointGroups;
};

SignaturePad.prototype.toData = function () {
  return this._data;
};

return SignaturePad;

})));

},{}],266:[function(require,module,exports){
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.createNumberMask=t():e.createNumberMask=t()}(this,function(){return function(e){function t(n){if(o[n])return o[n].exports;var i=o[n]={exports:{},id:n,loaded:!1};return e[n].call(i.exports,i,i.exports,t),i.loaded=!0,i.exports}var o={};return t.m=e,t.c=o,t.p="",t(0)}([function(e,t,o){e.exports=o(2)},,function(e,t){"use strict";function o(){function e(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:l,t=e.length;if(e===l||e[0]===y[0]&&1===t)return y.split(l).concat([v]).concat(h.split(l));if(e===k&&M)return y.split(l).concat(["0",k,v]).concat(h.split(l));var o=e.lastIndexOf(k),c=o!==-1,u=e[0]===s&&q,a=void 0,b=void 0,g=void 0;if(e.slice(T*-1)===h&&(e=e.slice(0,T*-1)),c&&(M||$)?(a=e.slice(e.slice(0,R)===y?R:0,o),b=e.slice(o+1,t),b=n(b.replace(f,l))):a=e.slice(0,R)===y?e.slice(R):e,P&&("undefined"==typeof P?"undefined":r(P))===p){var S="."===j?"[.]":""+j,w=(a.match(new RegExp(S,"g"))||[]).length;a=a.slice(0,P+w*Z)}return a=a.replace(f,l),E||(a=a.replace(/^0+(0$|[^0])/,"$1")),a=x?i(a,j):a,g=n(a),(c&&M||$===!0)&&(e[o-1]!==k&&g.push(m),g.push(k,m),b&&(("undefined"==typeof L?"undefined":r(L))===p&&(b=b.slice(0,L)),g=g.concat(b)),$===!0&&e[o-1]===k&&g.push(v)),R>0&&(g=y.split(l).concat(g)),u&&(g.length===R&&g.push(v),g=[d].concat(g)),h.length>0&&(g=g.concat(h.split(l))),g}var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},o=t.prefix,y=void 0===o?c:o,b=t.suffix,h=void 0===b?l:b,g=t.includeThousandsSeparator,x=void 0===g||g,S=t.thousandsSeparatorSymbol,j=void 0===S?u:S,w=t.allowDecimal,M=void 0!==w&&w,N=t.decimalSymbol,k=void 0===N?a:N,D=t.decimalLimit,L=void 0===D?2:D,O=t.requireDecimal,$=void 0!==O&&O,_=t.allowNegative,q=void 0!==_&&_,B=t.allowLeadingZeroes,E=void 0!==B&&B,I=t.integerLimit,P=void 0===I?null:I,R=y&&y.length||0,T=h&&h.length||0,Z=j&&j.length||0;return e.instanceOf="createNumberMask",e}function n(e){return e.split(l).map(function(e){return v.test(e)?v:e})}function i(e,t){return e.replace(/\B(?=(\d{3})+(?!\d))/g,t)}Object.defineProperty(t,"__esModule",{value:!0});var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};t.default=o;var c="$",l="",u=",",a=".",s="-",d=/-/,f=/\D+/g,p="number",v=/\d/,m="[]"}])});
},{}],267:[function(require,module,exports){
!function(e,r){"object"==typeof exports&&"object"==typeof module?module.exports=r():"function"==typeof define&&define.amd?define([],r):"object"==typeof exports?exports.vanillaTextMask=r():e.vanillaTextMask=r()}(this,function(){return function(e){function r(n){if(t[n])return t[n].exports;var o=t[n]={exports:{},id:n,loaded:!1};return e[n].call(o.exports,o,o.exports,r),o.loaded=!0,o.exports}var t={};return r.m=e,r.c=t,r.p="",r(0)}([function(e,r,t){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function o(e){var r=e.inputElement,t=(0,u.default)(e),n=function(e){var r=e.target.value;return t.update(r)};return r.addEventListener("input",n),t.update(r.value),{textMaskInputElement:t,destroy:function(){r.removeEventListener("input",n)}}}Object.defineProperty(r,"__esModule",{value:!0}),r.conformToMask=void 0,r.maskInput=o;var i=t(2);Object.defineProperty(r,"conformToMask",{enumerable:!0,get:function(){return n(i).default}});var a=t(5),u=n(a);r.default=o},function(e,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.placeholderChar="_"},function(e,r,t){"use strict";function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:a,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:a,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},n=t.guide,u=void 0===n||n,l=t.previousConformedValue,s=void 0===l?a:l,f=t.placeholderChar,d=void 0===f?i.placeholderChar:f,c=t.placeholder,v=void 0===c?(0,o.convertMaskToPlaceholder)(r,d):c,p=t.currentCaretPosition,h=t.keepCharPositions,g=u===!1&&void 0!==s,m=e.length,y=s.length,b=v.length,C=r.length,P=m-y,x=P>0,k=p+(x?-P:0),O=k+Math.abs(P);if(h===!0&&!x){for(var M=a,T=k;T<O;T++)v[T]===d&&(M+=d);e=e.slice(0,k)+M+e.slice(k,m)}for(var w=e.split(a).map(function(e,r){return{char:e,isNew:r>=k&&r<O}}),_=m-1;_>=0;_--){var j=w[_].char;if(j!==d){var V=_>=k&&y===C;j===v[V?_-P:_]&&w.splice(_,1)}}var S=a,E=!1;e:for(var N=0;N<b;N++){var A=v[N];if(A===d){if(w.length>0)for(;w.length>0;){var I=w.shift(),L=I.char,R=I.isNew;if(L===d&&g!==!0){S+=d;continue e}if(r[N].test(L)){if(h===!0&&R!==!1&&s!==a&&u!==!1&&x){for(var J=w.length,q=null,F=0;F<J;F++){var W=w[F];if(W.char!==d&&W.isNew===!1)break;if(W.char===d){q=F;break}}null!==q?(S+=L,w.splice(q,1)):N--}else S+=L;continue e}E=!0}g===!1&&(S+=v.substr(N,b));break}S+=A}if(g&&x===!1){for(var z=null,B=0;B<S.length;B++)v[B]===d&&(z=B);S=null!==z?S.substr(0,z+1):a}return{conformedValue:S,meta:{someCharsRejected:E}}}Object.defineProperty(r,"__esModule",{value:!0}),r.default=n;var o=t(3),i=t(1),a=""},function(e,r,t){"use strict";function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:l,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:u.placeholderChar;if(e.indexOf(r)!==-1)throw new Error("Placeholder character must not be used as part of the mask. Please specify a character that is not present in your mask as your placeholder character.\n\n"+("The placeholder character that was received is: "+JSON.stringify(r)+"\n\n")+("The mask that was received is: "+JSON.stringify(e)));return e.map(function(e){return e instanceof RegExp?r:e}).join("")}function o(e){return"string"==typeof e||e instanceof String}function i(e){return"number"==typeof e&&void 0===e.length&&!isNaN(e)}function a(e){for(var r=[],t=void 0;t=e.indexOf(s),t!==-1;)r.push(t),e.splice(t,1);return{maskWithoutCaretTraps:e,indexes:r}}Object.defineProperty(r,"__esModule",{value:!0}),r.convertMaskToPlaceholder=n,r.isString=o,r.isNumber=i,r.processCaretTraps=a;var u=t(1),l=[],s="[]"},function(e,r){"use strict";function t(e){var r=e.previousConformedValue,t=void 0===r?o:r,i=e.previousPlaceholder,a=void 0===i?o:i,u=e.currentCaretPosition,l=void 0===u?0:u,s=e.conformedValue,f=e.rawValue,d=e.placeholderChar,c=e.placeholder,v=e.indexesOfPipedChars,p=void 0===v?n:v,h=e.caretTrapIndexes,g=void 0===h?n:h;if(0===l)return 0;var m=f.length,y=t.length,b=c.length,C=s.length,P=m-y,x=P>0,k=0===y,O=P>1&&!x&&!k;if(O)return l;var M=x&&(t===s||s===c),T=0,w=void 0,_=void 0;if(M)T=l-P;else{var j=s.toLowerCase(),V=f.toLowerCase(),S=V.substr(0,l).split(o),E=S.filter(function(e){return j.indexOf(e)!==-1});_=E[E.length-1];var N=a.substr(0,E.length).split(o).filter(function(e){return e!==d}).length,A=c.substr(0,E.length).split(o).filter(function(e){return e!==d}).length,I=A!==N,L=void 0!==a[E.length-1]&&void 0!==c[E.length-2]&&a[E.length-1]!==d&&a[E.length-1]!==c[E.length-1]&&a[E.length-1]===c[E.length-2];!x&&(I||L)&&N>0&&c.indexOf(_)>-1&&void 0!==f[l]&&(w=!0,_=f[l]);for(var R=p.map(function(e){return j[e]}),J=R.filter(function(e){return e===_}).length,q=E.filter(function(e){return e===_}).length,F=c.substr(0,c.indexOf(d)).split(o).filter(function(e,r){return e===_&&f[r]!==e}).length,W=F+q+J+(w?1:0),z=0,B=0;B<C;B++){var D=j[B];if(T=B+1,D===_&&z++,z>=W)break}}if(x){for(var G=T,H=T;H<=b;H++)if(c[H]===d&&(G=H),c[H]===d||g.indexOf(H)!==-1||H===b)return G}else if(w){for(var K=T-1;K>=0;K--)if(s[K]===_||g.indexOf(K)!==-1||0===K)return K}else for(var Q=T;Q>=0;Q--)if(c[Q-1]===d||g.indexOf(Q)!==-1||0===Q)return Q}Object.defineProperty(r,"__esModule",{value:!0}),r.default=t;var n=[],o=""},function(e,r,t){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function o(e){var r={previousConformedValue:void 0,previousPlaceholder:void 0};return{state:r,update:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e,o=n.inputElement,s=n.mask,d=n.guide,m=n.pipe,b=n.placeholderChar,C=void 0===b?p.placeholderChar:b,P=n.keepCharPositions,x=void 0!==P&&P,k=n.showMask,O=void 0!==k&&k;if("undefined"==typeof t&&(t=o.value),t!==r.previousConformedValue){("undefined"==typeof s?"undefined":l(s))===y&&void 0!==s.pipe&&void 0!==s.mask&&(m=s.pipe,s=s.mask);var M=void 0,T=void 0;if(s instanceof Array&&(M=(0,v.convertMaskToPlaceholder)(s,C)),s!==!1){var w=a(t),_=o.selectionEnd,j=r.previousConformedValue,V=r.previousPlaceholder,S=void 0;if(("undefined"==typeof s?"undefined":l(s))===h){if(T=s(w,{currentCaretPosition:_,previousConformedValue:j,placeholderChar:C}),T===!1)return;var E=(0,v.processCaretTraps)(T),N=E.maskWithoutCaretTraps,A=E.indexes;T=N,S=A,M=(0,v.convertMaskToPlaceholder)(T,C)}else T=s;var I={previousConformedValue:j,guide:d,placeholderChar:C,pipe:m,placeholder:M,currentCaretPosition:_,keepCharPositions:x},L=(0,c.default)(w,T,I),R=L.conformedValue,J=("undefined"==typeof m?"undefined":l(m))===h,q={};J&&(q=m(R,u({rawValue:w},I)),q===!1?q={value:j,rejected:!0}:(0,v.isString)(q)&&(q={value:q}));var F=J?q.value:R,W=(0,f.default)({previousConformedValue:j,previousPlaceholder:V,conformedValue:F,placeholder:M,rawValue:w,currentCaretPosition:_,placeholderChar:C,indexesOfPipedChars:q.indexesOfPipedChars,caretTrapIndexes:S}),z=F===M&&0===W,B=O?M:g,D=z?B:F;r.previousConformedValue=D,r.previousPlaceholder=M,o.value!==D&&(o.value=D,i(o,W))}}}}}function i(e,r){document.activeElement===e&&(b?C(function(){return e.setSelectionRange(r,r,m)},0):e.setSelectionRange(r,r,m))}function a(e){if((0,v.isString)(e))return e;if((0,v.isNumber)(e))return String(e);if(void 0===e||null===e)return g;throw new Error("The 'value' provided to Text Mask needs to be a string or a number. The value received was:\n\n "+JSON.stringify(e))}Object.defineProperty(r,"__esModule",{value:!0});var u=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var t=arguments[r];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e},l="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};r.default=o;var s=t(4),f=n(s),d=t(2),c=n(d),v=t(3),p=t(1),h="function",g="",m="none",y="object",b="undefined"!=typeof navigator&&/Android/i.test(navigator.userAgent),C="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:setTimeout}])});
},{}],268:[function(require,module,exports){
(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob()
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ]

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    }

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift()
        return {done: value === undefined, value: value}
      }
    }

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      }
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1])
      }, this)
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var oldValue = this.map[name]
    this.map[name] = oldValue ? oldValue+','+value : value
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    name = normalizeName(name)
    return this.has(name) ? this.map[name] : null
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value)
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this)
      }
    }
  }

  Headers.prototype.keys = function() {
    var items = []
    this.forEach(function(value, name) { items.push(name) })
    return iteratorFor(items)
  }

  Headers.prototype.values = function() {
    var items = []
    this.forEach(function(value) { items.push(value) })
    return iteratorFor(items)
  }

  Headers.prototype.entries = function() {
    var items = []
    this.forEach(function(value, name) { items.push([name, value]) })
    return iteratorFor(items)
  }

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsArrayBuffer(blob)
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsText(blob)
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf)
    var chars = new Array(view.length)

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i])
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength)
      view.set(new Uint8Array(buf))
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false

    this._initBody = function(body) {
      this._bodyInit = body
      if (!body) {
        this._bodyText = ''
      } else if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString()
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer)
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer])
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body)
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      }
    }

    this.text = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body && input._bodyInit != null) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    } else {
      this.url = String(input)
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers()
    rawHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':')
      var key = parts.shift().trim()
      if (key) {
        var value = parts.join(':').trim()
        headers.append(key, value)
      }
    })
    return headers
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = 'status' in options ? options.status : 200
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = 'statusText' in options ? options.statusText : 'OK'
    this.headers = new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers
  self.Request = Request
  self.Response = Response

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init)
      var xhr = new XMLHttpRequest()

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        }
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
        var body = 'response' in xhr ? xhr.response : xhr.responseText
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);

},{}]},{},[42])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJidWlsZC9jb21wb25lbnRzL0NvbXBvbmVudHMuanMiLCJidWlsZC9jb21wb25lbnRzL1ZhbGlkYXRvci5qcyIsImJ1aWxkL2NvbXBvbmVudHMvYWRkcmVzcy9BZGRyZXNzLmpzIiwiYnVpbGQvY29tcG9uZW50cy9iYXNlL0Jhc2UuanMiLCJidWlsZC9jb21wb25lbnRzL2J1dHRvbi9CdXR0b24uanMiLCJidWlsZC9jb21wb25lbnRzL2J1dHRvbnZhbHVlL0J1dHRvblZhbHVlLmpzIiwiYnVpbGQvY29tcG9uZW50cy9jaGVja2JveC9DaGVja2JveC5qcyIsImJ1aWxkL2NvbXBvbmVudHMvY29sdW1ucy9Db2x1bW4uanMiLCJidWlsZC9jb21wb25lbnRzL2NvbHVtbnMvQ29sdW1ucy5qcyIsImJ1aWxkL2NvbXBvbmVudHMvY29udGFpbmVyL0NvbnRhaW5lci5qcyIsImJ1aWxkL2NvbXBvbmVudHMvY29udGVudC9Db250ZW50LmpzIiwiYnVpbGQvY29tcG9uZW50cy9jdXJyZW5jeS9DdXJyZW5jeS5qcyIsImJ1aWxkL2NvbXBvbmVudHMvZGF0YWdyaWQvRGF0YUdyaWQuanMiLCJidWlsZC9jb21wb25lbnRzL2RhdGV0aW1lL0RhdGVUaW1lLmpzIiwiYnVpbGQvY29tcG9uZW50cy9kYXkvRGF5LmpzIiwiYnVpbGQvY29tcG9uZW50cy9lbWFpbC9FbWFpbC5qcyIsImJ1aWxkL2NvbXBvbmVudHMvZmllbGRzZXQvRmllbGRzZXQuanMiLCJidWlsZC9jb21wb25lbnRzL2Zvcm0vRm9ybS5qcyIsImJ1aWxkL2NvbXBvbmVudHMvZ21hcC9HbWFwLmpzIiwiYnVpbGQvY29tcG9uZW50cy9oaWRkZW4vSGlkZGVuLmpzIiwiYnVpbGQvY29tcG9uZW50cy9odG1sL0hUTUwuanMiLCJidWlsZC9jb21wb25lbnRzL2luZGV4LmpzIiwiYnVpbGQvY29tcG9uZW50cy9qb3JuYXlhL0pvcm5heWEuanMiLCJidWlsZC9jb21wb25lbnRzL251bWJlci9OdW1iZXIuanMiLCJidWlsZC9jb21wb25lbnRzL3BhbmVsL1BhbmVsLmpzIiwiYnVpbGQvY29tcG9uZW50cy9wYXNzd29yZC9QYXNzd29yZC5qcyIsImJ1aWxkL2NvbXBvbmVudHMvcGhvbmVudW1iZXIvUGhvbmVOdW1iZXIuanMiLCJidWlsZC9jb21wb25lbnRzL3JhZGlvL1JhZGlvLmpzIiwiYnVpbGQvY29tcG9uZW50cy9yZXNvdXJjZS9SZXNvdXJjZS5qcyIsImJ1aWxkL2NvbXBvbmVudHMvc2VsZWN0L1NlbGVjdC5qcyIsImJ1aWxkL2NvbXBvbmVudHMvc2VsZWN0Ym94ZXMvU2VsZWN0Qm94ZXMuanMiLCJidWlsZC9jb21wb25lbnRzL3NpZ25hdHVyZS9TaWduYXR1cmUuanMiLCJidWlsZC9jb21wb25lbnRzL3NsaWRlci9TbGlkZXIuanMiLCJidWlsZC9jb21wb25lbnRzL3N1cnZleS9TdXJ2ZXkuanMiLCJidWlsZC9jb21wb25lbnRzL3RhYmxlL1RhYmxlLmpzIiwiYnVpbGQvY29tcG9uZW50cy90ZXh0YXJlYS9UZXh0QXJlYS5qcyIsImJ1aWxkL2NvbXBvbmVudHMvdGV4dGZpZWxkL1RleHRGaWVsZC5qcyIsImJ1aWxkL2NvbXBvbmVudHMvdW5rbm93bi9Vbmtub3duLmpzIiwiYnVpbGQvY29tcG9uZW50cy93ZWxsL1dlbGwuanMiLCJidWlsZC9mb3JtaW8uZm9ybS5qcyIsImJ1aWxkL2Zvcm1pby5qcyIsImJ1aWxkL2Zvcm1pby53aXphcmQuanMiLCJidWlsZC9sb2NhbHMvZW4uanMiLCJidWlsZC9wcm92aWRlcnMvaW5kZXguanMiLCJidWlsZC9wcm92aWRlcnMvc3RvcmFnZS9kcm9wYm94LmpzIiwiYnVpbGQvcHJvdmlkZXJzL3N0b3JhZ2UvaW5kZXguanMiLCJidWlsZC9wcm92aWRlcnMvc3RvcmFnZS9zMy5qcyIsImJ1aWxkL3Byb3ZpZGVycy9zdG9yYWdlL3VybC5qcyIsImJ1aWxkL3V0aWxzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Nob2ljZXMuanMvYXNzZXRzL3NjcmlwdHMvZGlzdC9jaG9pY2VzLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIyL2xpYi9ldmVudGVtaXR0ZXIyLmpzIiwibm9kZV9tb2R1bGVzL2ZsYXRwaWNrci9kaXN0L2ZsYXRwaWNrci5qcyIsIm5vZGVfbW9kdWxlcy9pMThuZXh0L2Rpc3QvY29tbW9uanMvQmFja2VuZENvbm5lY3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9pMThuZXh0L2Rpc3QvY29tbW9uanMvQ2FjaGVDb25uZWN0b3IuanMiLCJub2RlX21vZHVsZXMvaTE4bmV4dC9kaXN0L2NvbW1vbmpzL0V2ZW50RW1pdHRlci5qcyIsIm5vZGVfbW9kdWxlcy9pMThuZXh0L2Rpc3QvY29tbW9uanMvSW50ZXJwb2xhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2kxOG5leHQvZGlzdC9jb21tb25qcy9MYW5ndWFnZVV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2kxOG5leHQvZGlzdC9jb21tb25qcy9QbHVyYWxSZXNvbHZlci5qcyIsIm5vZGVfbW9kdWxlcy9pMThuZXh0L2Rpc3QvY29tbW9uanMvUmVzb3VyY2VTdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9pMThuZXh0L2Rpc3QvY29tbW9uanMvVHJhbnNsYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9pMThuZXh0L2Rpc3QvY29tbW9uanMvY29tcGF0aWJpbGl0eS92MS5qcyIsIm5vZGVfbW9kdWxlcy9pMThuZXh0L2Rpc3QvY29tbW9uanMvZGVmYXVsdHMuanMiLCJub2RlX21vZHVsZXMvaTE4bmV4dC9kaXN0L2NvbW1vbmpzL2kxOG5leHQuanMiLCJub2RlX21vZHVsZXMvaTE4bmV4dC9kaXN0L2NvbW1vbmpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2kxOG5leHQvZGlzdC9jb21tb25qcy9sb2dnZXIuanMiLCJub2RlX21vZHVsZXMvaTE4bmV4dC9kaXN0L2NvbW1vbmpzL3Bvc3RQcm9jZXNzb3IuanMiLCJub2RlX21vZHVsZXMvaTE4bmV4dC9kaXN0L2NvbW1vbmpzL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2kxOG5leHQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbi1sb2dpYy1qcy9sb2dpYy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX0RhdGFWaWV3LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fUHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldENhY2hlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19VaW50OEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fV2Vha01hcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FkZE1hcEVudHJ5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYWRkU2V0RW50cnkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcHBseS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TWFwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlQdXNoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlSZWR1Y2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVNvbWUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25NZXJnZVZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzaWduVmFsdWUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnbkluLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnblZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNsb25lLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VEZWxheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VFYWNoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3JPd24uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldEFsbEtleXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VIYXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0VxdWFsLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTWF0Y2guanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNOYXRpdmUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUl0ZXJhdGVlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5c0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hdGNoZXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1lcmdlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1lcmdlRGVlcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eURlZXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHVsbEF0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlc3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0VG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2xpY2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVGltZXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5hcnkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5zZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RGdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RQYXRoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVEYXRhVmlldy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lTWFwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVSZWdFeHAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVNldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lU3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weUFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlTeW1ib2xzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weVN5bWJvbHNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVBc3NpZ25lci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VFYWNoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2N1c3RvbURlZmF1bHRzTWVyZ2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsQXJyYXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxCeVRhZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZyZWVHbG9iYWwuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5c0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWFwRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hdGNoRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE5hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRTeW1ib2xzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRUYWcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRWYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc1BhdGguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEdldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVCeVRhZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXlhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNNYXNrZWQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlR2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVDbGVhci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVHZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19ub2RlVXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJSZXN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fcGFyZW50LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlQWRkLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0VG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zaG9ydE91dC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrR2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja1NldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmluZ1RvUGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvS2V5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2Fzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvY2xvbmUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2Nsb25lRGVlcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvY29uc3RhbnQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2RlYm91bmNlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9kZWZhdWx0c0RlZXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2RlbGF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9lYWNoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvZm9yRWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvZ2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9oYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2hhc0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNCdWZmZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzRW1wdHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzTGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2xhc3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL21lbW9pemUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL21lcmdlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9tZXJnZVdpdGguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL25vdy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3JlbW92ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3RvTnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC90b1BsYWluT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC90b1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwibm9kZV9tb2R1bGVzL25hdGl2ZS1wcm9taXNlLW9ubHkvbGliL25wby5zcmMuanMiLCJub2RlX21vZHVsZXMvbnVtZXJhbC9udW1lcmFsLmpzIiwibm9kZV9tb2R1bGVzL3Jhbmdlc2xpZGVyLWpzL2Rpc3QvcmFuZ2VzbGlkZXItanMubWluLmpzIiwibm9kZV9tb2R1bGVzL3NoYWxsb3ctY29weS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaWduYXR1cmVfcGFkL2Rpc3Qvc2lnbmF0dXJlX3BhZC5qcyIsIm5vZGVfbW9kdWxlcy90ZXh0LW1hc2stYWxsL2FkZG9ucy9kaXN0L2NyZWF0ZU51bWJlck1hc2suanMiLCJub2RlX21vZHVsZXMvdGV4dC1tYXNrLWFsbC92YW5pbGxhL2Rpc3QvdmFuaWxsYVRleHRNYXNrLmpzIiwibm9kZV9tb2R1bGVzL3doYXR3Zy1mZXRjaC9mZXRjaC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOzs7O0FBRUEsT0FBTyxjQUFQLENBQXNCLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQzNDLFNBQU87QUFEb0MsQ0FBN0M7QUFHQSxRQUFRLGdCQUFSLEdBQTJCLFNBQTNCOztBQUVBLElBQUksZUFBZSxZQUFZO0FBQUUsV0FBUyxnQkFBVCxDQUEwQixNQUExQixFQUFrQyxLQUFsQyxFQUF5QztBQUFFLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxNQUFNLE1BQTFCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQUUsVUFBSSxhQUFhLE1BQU0sQ0FBTixDQUFqQixDQUEyQixXQUFXLFVBQVgsR0FBd0IsV0FBVyxVQUFYLElBQXlCLEtBQWpELENBQXdELFdBQVcsWUFBWCxHQUEwQixJQUExQixDQUFnQyxJQUFJLFdBQVcsVUFBZixFQUEyQixXQUFXLFFBQVgsR0FBc0IsSUFBdEIsQ0FBNEIsT0FBTyxjQUFQLENBQXNCLE1BQXRCLEVBQThCLFdBQVcsR0FBekMsRUFBOEMsVUFBOUM7QUFBNEQ7QUFBRSxHQUFDLE9BQU8sVUFBVSxXQUFWLEVBQXVCLFVBQXZCLEVBQW1DLFdBQW5DLEVBQWdEO0FBQUUsUUFBSSxVQUFKLEVBQWdCLGlCQUFpQixZQUFZLFNBQTdCLEVBQXdDLFVBQXhDLEVBQXFELElBQUksV0FBSixFQUFpQixpQkFBaUIsV0FBakIsRUFBOEIsV0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2x0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzV2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDallBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDLzJJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDclhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyL0JBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdsQkE7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRm9ybWlvQ29tcG9uZW50cyA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX2VhY2gyID0gcmVxdWlyZSgnbG9kYXNoL2VhY2gnKTtcblxudmFyIF9lYWNoMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2gyKTtcblxudmFyIF9jbG9uZTIgPSByZXF1aXJlKCdsb2Rhc2gvY2xvbmUnKTtcblxudmFyIF9jbG9uZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbG9uZTIpO1xuXG52YXIgX3JlbW92ZTIgPSByZXF1aXJlKCdsb2Rhc2gvcmVtb3ZlJyk7XG5cbnZhciBfcmVtb3ZlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlbW92ZTIpO1xuXG52YXIgX2Fzc2lnbjIgPSByZXF1aXJlKCdsb2Rhc2gvYXNzaWduJyk7XG5cbnZhciBfYXNzaWduMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2lnbjIpO1xuXG52YXIgX25hdGl2ZVByb21pc2VPbmx5ID0gcmVxdWlyZSgnbmF0aXZlLXByb21pc2Utb25seScpO1xuXG52YXIgX25hdGl2ZVByb21pc2VPbmx5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX25hdGl2ZVByb21pc2VPbmx5KTtcblxudmFyIF9CYXNlID0gcmVxdWlyZSgnLi9iYXNlL0Jhc2UnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgRm9ybWlvQ29tcG9uZW50cyA9IGV4cG9ydHMuRm9ybWlvQ29tcG9uZW50cyA9IGZ1bmN0aW9uIChfQmFzZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoRm9ybWlvQ29tcG9uZW50cywgX0Jhc2VDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEZvcm1pb0NvbXBvbmVudHMoY29tcG9uZW50LCBvcHRpb25zLCBkYXRhKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcm1pb0NvbXBvbmVudHMpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEZvcm1pb0NvbXBvbmVudHMuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGb3JtaW9Db21wb25lbnRzKSkuY2FsbCh0aGlzLCBjb21wb25lbnQsIG9wdGlvbnMsIGRhdGEpKTtcblxuICAgIF90aGlzLnR5cGUgPSAnY29tcG9uZW50cyc7XG4gICAgX3RoaXMuY29tcG9uZW50cyA9IFtdO1xuICAgIF90aGlzLmhpZGRlbiA9IFtdO1xuICAgIF90aGlzLmJlZm9yZU5leHRQYWdlQ2FsbGJhY2sgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGb3JtaW9Db21wb25lbnRzLCBbe1xuICAgIGtleTogJ2J1aWxkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGQoKSB7XG4gICAgICB0aGlzLmNyZWF0ZUVsZW1lbnQoKTtcbiAgICAgIHRoaXMuYWRkQ29tcG9uZW50cygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldENvbXBvbmVudHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb21wb25lbnRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgZGVlcCBpdGVyYXRpb24gb3ZlciBldmVyeSBjb21wb25lbnQsIGluY2x1ZGluZyB0aG9zZVxuICAgICAqIHdpdGhpbiBvdGhlciBjb250YWluZXIgYmFzZWQgY29tcG9uZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIC0gQ2FsbGVkIGZvciBldmVyeSBjb21wb25lbnQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2V2ZXJ5Q29tcG9uZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZlcnlDb21wb25lbnQoY2IpIHtcbiAgICAgIHZhciBjb21wb25lbnRzID0gdGhpcy5nZXRDb21wb25lbnRzKCk7XG4gICAgICAoMCwgX2VhY2gzLmRlZmF1bHQpKGNvbXBvbmVudHMsIGZ1bmN0aW9uIChjb21wb25lbnQsIGluZGV4KSB7XG4gICAgICAgIGlmIChjb21wb25lbnQudHlwZSA9PT0gJ2NvbXBvbmVudHMnKSB7XG4gICAgICAgICAgaWYgKGNvbXBvbmVudC5ldmVyeUNvbXBvbmVudChjYikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNiKGNvbXBvbmVudCwgY29tcG9uZW50cywgaW5kZXgpID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhbiBpdGVyYXRpb24gb3ZlciBlYWNoIGNvbXBvbmVudCB3aXRoaW4gdGhpcyBjb250YWluZXIgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgLSBDYWxsZWQgZm9yIGVhY2ggY29tcG9uZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2VhY2hDb21wb25lbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlYWNoQ29tcG9uZW50KGNiKSB7XG4gICAgICAoMCwgX2VhY2gzLmRlZmF1bHQpKHRoaXMuZ2V0Q29tcG9uZW50cygpLCBmdW5jdGlvbiAoY29tcG9uZW50LCBpbmRleCkge1xuICAgICAgICBpZiAoY2IoY29tcG9uZW50LCBpbmRleCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29tcG9uZW50IHByb3ZpZGVkIGEga2V5LiBUaGlzIHBlcmZvcm1zIGEgZGVlcCBzZWFyY2ggd2l0aGluIHRoZVxuICAgICAqIGNvbXBvbmVudCB0cmVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIGNvbXBvbmVudCB0byByZXRyaWV2ZS5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiAtIENhbGxlZCB3aXRoIHRoZSBjb21wb25lbnQgb25jZSBmb3VuZC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC0gVGhlIGNvbXBvbmVudCB0aGF0IGlzIGxvY2F0ZWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldENvbXBvbmVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbXBvbmVudChrZXksIGNiKSB7XG4gICAgICB2YXIgY29tcCA9IG51bGw7XG4gICAgICB0aGlzLmV2ZXJ5Q29tcG9uZW50KGZ1bmN0aW9uIChjb21wb25lbnQsIGNvbXBvbmVudHMpIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudC5jb21wb25lbnQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICBjb21wID0gY29tcG9uZW50O1xuICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgY2IoY29tcG9uZW50LCBjb21wb25lbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb21wO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGNvbXBvbmVudCBwcm92aWRlZCB0aGUgSWQgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIFRoZSBJZCBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIC0gQ2FsbGVkIHdpdGggdGhlIGNvbXBvbmVudCBvbmNlIGl0IGlzIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC0gVGhlIGNvbXBvbmVudCByZXRyaWV2ZWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldENvbXBvbmVudEJ5SWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb21wb25lbnRCeUlkKGlkLCBjYikge1xuICAgICAgdmFyIGNvbXAgPSBudWxsO1xuICAgICAgdGhpcy5ldmVyeUNvbXBvbmVudChmdW5jdGlvbiAoY29tcG9uZW50LCBjb21wb25lbnRzKSB7XG4gICAgICAgIGlmIChjb21wb25lbnQuaWQgPT09IGlkKSB7XG4gICAgICAgICAgY29tcCA9IGNvbXBvbmVudDtcbiAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgIGNiKGNvbXBvbmVudCwgY29tcG9uZW50cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29tcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBuZXcgY29tcG9uZW50IHRvIHRoZSBjb21wb25lbnRzIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbXBvbmVudCAtIFRoZSBjb21wb25lbnQgSlNPTiBzY2hlbWEgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgRE9NIGVsZW1lbnQgdG8gYXBwZW5kIHRoaXMgY2hpbGQgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgc3VibWlzc2lvbiBkYXRhIG9iamVjdCB0byBob3VzZSB0aGUgZGF0YSBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAgICogQHJldHVybiB7QmFzZUNvbXBvbmVudH0gLSBUaGUgY3JlYXRlZCBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZENvbXBvbmVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZENvbXBvbmVudChjb21wb25lbnQsIGVsZW1lbnQsIGRhdGEpIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50IHx8IHRoaXMuZWxlbWVudDtcbiAgICAgIGRhdGEgPSBkYXRhIHx8IHRoaXMuZGF0YTtcbiAgICAgIHZhciBjb21wb25lbnRzID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuICAgICAgY29tcG9uZW50LnJvdyA9IHRoaXMucm93O1xuICAgICAgdmFyIGNvbXAgPSBjb21wb25lbnRzLmNyZWF0ZShjb21wb25lbnQsIHRoaXMub3B0aW9ucywgZGF0YSk7XG4gICAgICB0aGlzLmNvbXBvbmVudHMucHVzaChjb21wKTtcbiAgICAgIHRoaXMuc2V0SGlkZGVuKGNvbXApO1xuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChjb21wLmdldEVsZW1lbnQoKSk7XG4gICAgICByZXR1cm4gY29tcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBjb21wb25lbnQgZnJvbSB0aGUgY29tcG9uZW50cyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QmFzZUNvbXBvbmVudH0gY29tcG9uZW50IC0gVGhlIGNvbXBvbmVudCB0byByZW1vdmUgZnJvbSB0aGUgY29tcG9uZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5PEJhc2VDb21wb25lbnQ+fSBjb21wb25lbnRzIC0gQW4gYXJyYXkgb2YgY29tcG9uZW50cyB0byByZW1vdmUgdGhpcyBjb21wb25lbnQgZnJvbS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlQ29tcG9uZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQ29tcG9uZW50KGNvbXBvbmVudCwgY29tcG9uZW50cykge1xuICAgICAgY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICAgIHZhciBlbGVtZW50ID0gY29tcG9uZW50LmdldEVsZW1lbnQoKTtcbiAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgICAoMCwgX3JlbW92ZTMuZGVmYXVsdCkoY29tcG9uZW50cywgeyBpZDogY29tcG9uZW50LmlkIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjb21wb25lbnQgcHJvdmlkZWQgdGhlIEFQSSBrZXkgb2YgdGhhdCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIEFQSSBrZXkgb2YgdGhlIGNvbXBvbmVudCB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgLSBDYWxsZWQgb25jZSB0aGUgY29tcG9uZW50IGlzIHJlbW92ZWQuXG4gICAgICogQHJldHVybiB7bnVsbH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlQ29tcG9uZW50QnlLZXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVDb21wb25lbnRCeUtleShrZXksIGNiKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGNvbXAgPSB0aGlzLmdldENvbXBvbmVudChrZXksIGZ1bmN0aW9uIChjb21wb25lbnQsIGNvbXBvbmVudHMpIHtcbiAgICAgICAgX3RoaXMyLnJlbW92ZUNvbXBvbmVudChjb21wb25lbnQsIGNvbXBvbmVudHMpO1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICBjYihjb21wb25lbnQsIGNvbXBvbmVudHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghY29tcCkge1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICBjYihudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY29tcG9uZW50IHByb3ZpZGVkIHRoZSBJZCBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gVGhlIElkIG9mIHRoZSBjb21wb25lbnQgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIC0gQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyByZW1vdmVkLlxuICAgICAqIEByZXR1cm4ge251bGx9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZUNvbXBvbmVudEJ5SWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVDb21wb25lbnRCeUlkKGlkLCBjYikge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBjb21wID0gdGhpcy5nZXRDb21wb25lbnRCeUlkKGlkLCBmdW5jdGlvbiAoY29tcG9uZW50LCBjb21wb25lbnRzKSB7XG4gICAgICAgIF90aGlzMy5yZW1vdmVDb21wb25lbnQoY29tcG9uZW50LCBjb21wb25lbnRzKTtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgY2IoY29tcG9uZW50LCBjb21wb25lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIWNvbXApIHtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgY2IobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZENvbXBvbmVudHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRDb21wb25lbnRzKGVsZW1lbnQsIGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBlbGVtZW50ID0gZWxlbWVudCB8fCB0aGlzLmVsZW1lbnQ7XG4gICAgICBkYXRhID0gZGF0YSB8fCB0aGlzLmRhdGE7XG4gICAgICAoMCwgX2VhY2gzLmRlZmF1bHQpKHRoaXMuY29tcG9uZW50LmNvbXBvbmVudHMsIGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNC5hZGRDb21wb25lbnQoY29tcG9uZW50LCBlbGVtZW50LCBkYXRhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZVZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlVmFsdWUobm9WYWxpZGF0ZSkge1xuICAgICAgKDAsIF9lYWNoMy5kZWZhdWx0KSh0aGlzLmNvbXBvbmVudHMsIGZ1bmN0aW9uIChjb21wKSB7XG4gICAgICAgIHJldHVybiBjb21wLnVwZGF0ZVZhbHVlKG5vVmFsaWRhdGUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBtb3JlIHBlcmZvcm1hbnQgd2F5IHRvIGNoZWNrIHRoZSBjb25kaXRpb25zLCBjYWxjdWxhdGlvbnMsIGFuZCB2YWxpZGl0eSBvZlxuICAgICAqIGEgc3VibWlzc2lvbiBvbmNlIGl0IGhhcyBiZWVuIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqIEBwYXJhbSBub1ZhbGlkYXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NoZWNrRGF0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRGF0YShkYXRhLCBub1ZhbGlkYXRlKSB7XG4gICAgICAoMCwgX2VhY2gzLmRlZmF1bHQpKHRoaXMuZ2V0Q29tcG9uZW50cygpLCBmdW5jdGlvbiAoY29tcCkge1xuICAgICAgICBpZiAoY29tcC50eXBlICE9PSAnZm9ybWNvbXBvbmVudCcpIHtcbiAgICAgICAgICBjb21wLmNoZWNrQ29uZGl0aW9ucyhkYXRhKTtcbiAgICAgICAgICBjb21wLmNhbGN1bGF0ZVZhbHVlKGRhdGEpO1xuICAgICAgICAgIGlmICghbm9WYWxpZGF0ZSkge1xuICAgICAgICAgICAgY29tcC5jaGVja1ZhbGlkaXR5KGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2hlY2tDb25kaXRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tDb25kaXRpb25zKGRhdGEpIHtcbiAgICAgIHZhciBzaG93ID0gX2dldChGb3JtaW9Db21wb25lbnRzLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZvcm1pb0NvbXBvbmVudHMucHJvdG90eXBlKSwgJ2NoZWNrQ29uZGl0aW9ucycsIHRoaXMpLmNhbGwodGhpcywgZGF0YSk7XG4gICAgICAoMCwgX2VhY2gzLmRlZmF1bHQpKHRoaXMuZ2V0Q29tcG9uZW50cygpLCBmdW5jdGlvbiAoY29tcCkge1xuICAgICAgICBzaG93IHw9IGNvbXAuY2hlY2tDb25kaXRpb25zKGRhdGEpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc2hvdztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGxvdyBjb21wb25lbnRzIHRvIGhvb2sgaW50byB0aGUgbmV4dCBwYWdlIHRyaWdnZXIgdG8gcGVyZm9ybSB0aGVpciBvd24gbG9naWMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdiZWZvcmVOZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmVmb3JlTmV4dCgpIHtcbiAgICAgIHZhciBvcHMgPSBbXTtcbiAgICAgICgwLCBfZWFjaDMuZGVmYXVsdCkodGhpcy5nZXRDb21wb25lbnRzKCksIGZ1bmN0aW9uIChjb21wKSB7XG4gICAgICAgIHJldHVybiBvcHMucHVzaChjb21wLmJlZm9yZU5leHQoKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfbmF0aXZlUHJvbWlzZU9ubHkyLmRlZmF1bHQuYWxsKG9wcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxsb3cgY29tcG9uZW50cyB0byBob29rIGludG8gdGhlIHN1Ym1pc3Npb24gdG8gcHJvdmlkZSB0aGVpciBvd24gYXN5bmMgZGF0YS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2JlZm9yZVN1Ym1pdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJlZm9yZVN1Ym1pdCgpIHtcbiAgICAgIHZhciBvcHMgPSBbXTtcbiAgICAgICgwLCBfZWFjaDMuZGVmYXVsdCkodGhpcy5nZXRDb21wb25lbnRzKCksIGZ1bmN0aW9uIChjb21wKSB7XG4gICAgICAgIHJldHVybiBvcHMucHVzaChjb21wLmJlZm9yZVN1Ym1pdCgpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF9uYXRpdmVQcm9taXNlT25seTIuZGVmYXVsdC5hbGwob3BzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYWxjdWxhdGVWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZVZhbHVlKGRhdGEpIHtcbiAgICAgIF9nZXQoRm9ybWlvQ29tcG9uZW50cy5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGb3JtaW9Db21wb25lbnRzLnByb3RvdHlwZSksICdjYWxjdWxhdGVWYWx1ZScsIHRoaXMpLmNhbGwodGhpcywgZGF0YSk7XG4gICAgICAoMCwgX2VhY2gzLmRlZmF1bHQpKHRoaXMuZ2V0Q29tcG9uZW50cygpLCBmdW5jdGlvbiAoY29tcCkge1xuICAgICAgICByZXR1cm4gY29tcC5jYWxjdWxhdGVWYWx1ZShkYXRhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NoZWNrVmFsaWRpdHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1ZhbGlkaXR5KGRhdGEsIGRpcnR5KSB7XG4gICAgICB2YXIgY2hlY2sgPSBfZ2V0KEZvcm1pb0NvbXBvbmVudHMucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRm9ybWlvQ29tcG9uZW50cy5wcm90b3R5cGUpLCAnY2hlY2tWYWxpZGl0eScsIHRoaXMpLmNhbGwodGhpcywgZGF0YSwgZGlydHkpO1xuICAgICAgKDAsIF9lYWNoMy5kZWZhdWx0KSh0aGlzLmdldENvbXBvbmVudHMoKSwgZnVuY3Rpb24gKGNvbXApIHtcbiAgICAgICAgY2hlY2sgJj0gY29tcC5jaGVja1ZhbGlkaXR5KGRhdGEsIGRpcnR5KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNoZWNrO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KGFsbCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIF9nZXQoRm9ybWlvQ29tcG9uZW50cy5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGb3JtaW9Db21wb25lbnRzLnByb3RvdHlwZSksICdkZXN0cm95JywgdGhpcykuY2FsbCh0aGlzLCBhbGwpO1xuICAgICAgdmFyIGNvbXBvbmVudHMgPSAoMCwgX2Nsb25lMy5kZWZhdWx0KSh0aGlzLmNvbXBvbmVudHMpO1xuICAgICAgKDAsIF9lYWNoMy5kZWZhdWx0KShjb21wb25lbnRzLCBmdW5jdGlvbiAoY29tcCkge1xuICAgICAgICByZXR1cm4gX3RoaXM1LnJlbW92ZUNvbXBvbmVudChjb21wLCBfdGhpczUuY29tcG9uZW50cyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRIaWRkZW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRIaWRkZW4oY29tcG9uZW50KSB7XG4gICAgICBpZiAoY29tcG9uZW50LmNvbXBvbmVudHMgJiYgY29tcG9uZW50LmNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbXBvbmVudC5oaWRlQ29tcG9uZW50cyh0aGlzLmhpZGRlbik7XG4gICAgICB9IGVsc2UgaWYgKGNvbXBvbmVudC5jb21wb25lbnQuaGlkZGVuKSB7XG4gICAgICAgIGNvbXBvbmVudC52aXNpYmxlID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb25lbnQudmlzaWJsZSA9ICF0aGlzLmhpZGRlbiB8fCB0aGlzLmhpZGRlbi5pbmRleE9mKGNvbXBvbmVudC5jb21wb25lbnQua2V5KSA9PT0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGlkZUNvbXBvbmVudHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlQ29tcG9uZW50cyhoaWRkZW4pIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICB0aGlzLmhpZGRlbiA9IGhpZGRlbjtcbiAgICAgIHRoaXMuZWFjaENvbXBvbmVudChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiBfdGhpczYuc2V0SGlkZGVuKGNvbXBvbmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRCZWZvcmVOZXh0UGFnZUNhbGxiYWNrJyxcblxuXG4gICAgLy8gRE1TXG5cbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmVmb3JlTmV4dFBhZ2VDYWxsYmFjaygpIHtcbiAgICAgIHJldHVybiB0aGlzLmJlZm9yZU5leHRQYWdlQ2FsbGJhY2s7XG4gICAgfVxuXG4gICAgLy8gRE1TXG5cbiAgfSwge1xuICAgIGtleTogJ3NldEJlZm9yZU5leHRQYWdlQ2FsbGJhY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRCZWZvcmVOZXh0UGFnZUNhbGxiYWNrKGJlZm9yZU5leHRQYWdlQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMuYmVmb3JlTmV4dFBhZ2VDYWxsYmFjayA9IGJlZm9yZU5leHRQYWdlQ2FsbGJhY2s7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSwgbm9VcGRhdGUsIG5vVmFsaWRhdGUpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgKDAsIF9lYWNoMy5kZWZhdWx0KSh0aGlzLmdldENvbXBvbmVudHMoKSwgZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoY29tcG9uZW50LnR5cGUgPT09ICdidXR0b24nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jb25zb2xlLmRpcihjb21wb25lbnQpO1xuXG4gICAgICAgIC8vY29uc29sZS5sb2coJ3NldFZhbHVlJyArICcuJyArICdjb21wb25lbnQudHlwZScpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKGNvbXBvbmVudC50eXBlKTtcblxuICAgICAgICBpZiAoY29tcG9uZW50LnR5cGUgPT09ICdjb21wb25lbnRzJykge1xuICAgICAgICAgIGNvbXBvbmVudC5zZXRWYWx1ZSh2YWx1ZSwgbm9VcGRhdGUsIG5vVmFsaWRhdGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHZhbHVlLmhhc093blByb3BlcnR5KGNvbXBvbmVudC5jb21wb25lbnQua2V5KSkge1xuICAgICAgICAgIGlmIChjb21wb25lbnQudHlwZSA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NvbXBvbmVudCBpcyBhIHNlbGVjdCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wb25lbnQuc2V0VmFsdWUodmFsdWVbY29tcG9uZW50LmNvbXBvbmVudC5rZXldLCBub1VwZGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvbmVudC5jb21wb25lbnQuaW5wdXQpIHtcbiAgICAgICAgICBjb21wb25lbnQuc2V0VmFsdWUobnVsbCwgbm9VcGRhdGUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkaXNhYmxlZCcsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoZGlzYWJsZWQpIHtcbiAgICAgICgwLCBfZWFjaDMuZGVmYXVsdCkodGhpcy5jb21wb25lbnRzLCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiBjb21wb25lbnQuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAoMCwgX2VhY2gzLmRlZmF1bHQpKHRoaXMuZ2V0Q29tcG9uZW50cygpLCBmdW5jdGlvbiAoY29tcCkge1xuICAgICAgICB2YXIgY29tcEVycm9ycyA9IGNvbXAuZXJyb3JzO1xuICAgICAgICBpZiAoY29tcEVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGNvbXBFcnJvcnMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZvcm1pb0NvbXBvbmVudHM7XG59KF9CYXNlLkJhc2VDb21wb25lbnQpOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuVmFsaWRhdG9yID0gdW5kZWZpbmVkO1xuXG52YXIgX2dldDIgPSByZXF1aXJlKCdsb2Rhc2gvZ2V0Jyk7XG5cbnZhciBfZ2V0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldDIpO1xuXG52YXIgX2VhY2gyID0gcmVxdWlyZSgnbG9kYXNoL2VhY2gnKTtcblxudmFyIF9lYWNoMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2gyKTtcblxudmFyIF9oYXMyID0gcmVxdWlyZSgnbG9kYXNoL2hhcycpO1xuXG52YXIgX2hhczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYXMyKTtcblxudmFyIF9pc0FycmF5MiA9IHJlcXVpcmUoJ2xvZGFzaC9pc0FycmF5Jyk7XG5cbnZhciBfaXNBcnJheTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0FycmF5Mik7XG5cbnZhciBfanNvbkxvZ2ljSnMgPSByZXF1aXJlKCdqc29uLWxvZ2ljLWpzJyk7XG5cbnZhciBfanNvbkxvZ2ljSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanNvbkxvZ2ljSnMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgVmFsaWRhdG9yID0gZXhwb3J0cy5WYWxpZGF0b3IgPSB7XG4gIGdldDogX2dldDMuZGVmYXVsdCxcbiAgZWFjaDogX2VhY2gzLmRlZmF1bHQsXG4gIGhhczogX2hhczMuZGVmYXVsdCxcbiAgYm9vbFZhbHVlOiBmdW5jdGlvbiBib29sVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAhIXZhbHVlO1xuICAgIH1cbiAgfSxcbiAgZW1wdHk6IGZ1bmN0aW9uIGVtcHR5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgdmFsdWUubGVuZ3RoID09PSAwO1xuICB9LFxuICBuYW1lOiBmdW5jdGlvbiBuYW1lKGNvbXBvbmVudCkge1xuICAgIHJldHVybiBjb21wb25lbnQubGFiZWwgfHwgY29tcG9uZW50LnBsYWNlaG9sZGVyIHx8IGNvbXBvbmVudC5rZXk7XG4gIH0sXG4gIGNoZWNrVmFsaWRhdG9yOiBmdW5jdGlvbiBjaGVja1ZhbGlkYXRvcih2YWxpZGF0b3IsIGNvbXBvbmVudCwgc2V0dGluZywgdmFsdWUsIGRhdGEsIHJvdywgdCkge1xuICAgIHZhciByZXN1bHQgPSB2YWxpZGF0b3IuY2hlY2suY2FsbCh0aGlzLCBjb21wb25lbnQsIHNldHRpbmcsIHZhbHVlLCBkYXRhLCByb3cpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiB2YWxpZGF0b3IubWVzc2FnZS5jYWxsKHRoaXMsIGNvbXBvbmVudCwgc2V0dGluZywgdCk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfSxcbiAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKHZhbGlkYXRvciwgY29tcG9uZW50LCB2YWx1ZSwgZGF0YSwgcm93LCB0KSB7XG4gICAgaWYgKHZhbGlkYXRvci5rZXkgJiYgKDAsIF9oYXMzLmRlZmF1bHQpKGNvbXBvbmVudCwgdmFsaWRhdG9yLmtleSkpIHtcbiAgICAgIHZhciBzZXR0aW5nID0gdGhpcy5nZXQoY29tcG9uZW50LCB2YWxpZGF0b3Iua2V5KTtcbiAgICAgIHJldHVybiB0aGlzLmNoZWNrVmFsaWRhdG9yKHZhbGlkYXRvciwgY29tcG9uZW50LCBzZXR0aW5nLCB2YWx1ZSwgZGF0YSwgcm93LCB0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2hlY2tWYWxpZGF0b3IodmFsaWRhdG9yLCBjb21wb25lbnQsIG51bGwsIHZhbHVlLCBkYXRhLCByb3csIHQpO1xuICB9LFxuICBjaGVjazogZnVuY3Rpb24gY2hlY2sodmFsaWRhdG9ycywgY29tcG9uZW50LCB2YWx1ZSwgZGF0YSwgcm93LCB0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAoMCwgX2VhY2gzLmRlZmF1bHQpKHZhbGlkYXRvcnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAoX3RoaXMudmFsaWRhdG9ycy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICB2YXIgdmFsaWRhdG9yID0gX3RoaXMudmFsaWRhdG9yc1tuYW1lXTtcbiAgICAgICAgaWYgKGNvbXBvbmVudC5tdWx0aXBsZSAmJiAoMCwgX2lzQXJyYXkzLmRlZmF1bHQpKHZhbHVlKSkge1xuICAgICAgICAgICgwLCBfZWFjaDMuZGVmYXVsdCkodmFsdWUsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IF90aGlzLnZhbGlkYXRlKHZhbGlkYXRvciwgY29tcG9uZW50LCB2YWwsIGRhdGEsIHJvdywgdCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBfdGhpcy52YWxpZGF0ZSh2YWxpZGF0b3IsIGNvbXBvbmVudCwgdmFsdWUsIGRhdGEsIHJvdywgdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIHZhbGlkYXRvcnM6IHtcbiAgICByZXF1aXJlZDoge1xuICAgICAga2V5OiAndmFsaWRhdGUucmVxdWlyZWQnLFxuICAgICAgbWVzc2FnZTogZnVuY3Rpb24gbWVzc2FnZShjb21wb25lbnQsIHNldHRpbmcsIHQpIHtcbiAgICAgICAgcmV0dXJuIHQoJ3JlcXVpcmVkJywgeyBmaWVsZDogdGhpcy5uYW1lKGNvbXBvbmVudCkgfSk7XG4gICAgICB9LFxuICAgICAgY2hlY2s6IGZ1bmN0aW9uIGNoZWNrKGNvbXBvbmVudCwgc2V0dGluZywgdmFsdWUpIHtcbiAgICAgICAgdmFyIHJlcXVpcmVkID0gVmFsaWRhdG9yLmJvb2xWYWx1ZShzZXR0aW5nKTtcbiAgICAgICAgaWYgKCFyZXF1aXJlZCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhVmFsaWRhdG9yLmVtcHR5KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1pbkxlbmd0aDoge1xuICAgICAga2V5OiAndmFsaWRhdGUubWluTGVuZ3RoJyxcbiAgICAgIG1lc3NhZ2U6IGZ1bmN0aW9uIG1lc3NhZ2UoY29tcG9uZW50LCBzZXR0aW5nLCB0KSB7XG4gICAgICAgIHJldHVybiB0KCdtaW5MZW5ndGgnLCB7XG4gICAgICAgICAgZmllbGQ6IHRoaXMubmFtZShjb21wb25lbnQpLFxuICAgICAgICAgIGxlbmd0aDogc2V0dGluZyAtIDFcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgY2hlY2s6IGZ1bmN0aW9uIGNoZWNrKGNvbXBvbmVudCwgc2V0dGluZywgdmFsdWUpIHtcbiAgICAgICAgdmFyIG1pbkxlbmd0aCA9IHBhcnNlSW50KHNldHRpbmcsIDEwKTtcbiAgICAgICAgaWYgKCFtaW5MZW5ndGggfHwgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPj0gbWluTGVuZ3RoO1xuICAgICAgfVxuICAgIH0sXG4gICAgbWF4TGVuZ3RoOiB7XG4gICAgICBrZXk6ICd2YWxpZGF0ZS5tYXhMZW5ndGgnLFxuICAgICAgbWVzc2FnZTogZnVuY3Rpb24gbWVzc2FnZShjb21wb25lbnQsIHNldHRpbmcsIHQpIHtcbiAgICAgICAgcmV0dXJuIHQoJ21heExlbmd0aCcsIHtcbiAgICAgICAgICBmaWVsZDogdGhpcy5uYW1lKGNvbXBvbmVudCksXG4gICAgICAgICAgbGVuZ3RoOiBzZXR0aW5nICsgMVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBjaGVjazogZnVuY3Rpb24gY2hlY2soY29tcG9uZW50LCBzZXR0aW5nLCB2YWx1ZSkge1xuICAgICAgICB2YXIgbWF4TGVuZ3RoID0gcGFyc2VJbnQoc2V0dGluZywgMTApO1xuICAgICAgICBpZiAoIW1heExlbmd0aCB8fCB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA8PSBtYXhMZW5ndGg7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbWFpbDoge1xuICAgICAgbWVzc2FnZTogZnVuY3Rpb24gbWVzc2FnZShjb21wb25lbnQsIHNldHRpbmcsIHQpIHtcbiAgICAgICAgcmV0dXJuIHQoJ2ludmFsaWRfZW1haWwnLCB7XG4gICAgICAgICAgZmllbGQ6IHRoaXMubmFtZShjb21wb25lbnQpXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGNoZWNrOiBmdW5jdGlvbiBjaGVjayhjb21wb25lbnQsIHNldHRpbmcsIHZhbHVlKSB7XG4gICAgICAgIC8vIEZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80NjE1NS92YWxpZGF0ZS1lbWFpbC1hZGRyZXNzLWluLWphdmFzY3JpcHRcbiAgICAgICAgdmFyIHJlID0gL14oKFtePD4oKVxcW1xcXVxcXFwuLDs6XFxzQFwiXSsoXFwuW148PigpXFxbXFxdXFxcXC4sOzpcXHNAXCJdKykqKXwoXCIuK1wiKSlAKChcXFtbMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XSl8KChbYS16QS1aXFwtMC05XStcXC4pK1thLXpBLVpdezIsfSkpJC87XG4gICAgICAgIHJldHVybiByZS50ZXN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGU6IHtcbiAgICAgIG1lc3NhZ2U6IGZ1bmN0aW9uIG1lc3NhZ2UoY29tcG9uZW50LCBzZXR0aW5nLCB0KSB7XG4gICAgICAgIHJldHVybiB0KCdpbnZhbGlkX2RhdGUnLCB7XG4gICAgICAgICAgZmllbGQ6IHRoaXMubmFtZShjb21wb25lbnQpXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGNoZWNrOiBmdW5jdGlvbiBjaGVjayhjb21wb25lbnQsIHNldHRpbmcsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gJ0ludmFsaWQgZGF0ZSc7XG4gICAgICB9XG4gICAgfSxcbiAgICBwYXR0ZXJuOiB7XG4gICAgICBrZXk6ICd2YWxpZGF0ZS5wYXR0ZXJuJyxcbiAgICAgIG1lc3NhZ2U6IGZ1bmN0aW9uIG1lc3NhZ2UoY29tcG9uZW50LCBzZXR0aW5nLCB0KSB7XG4gICAgICAgIHJldHVybiB0KCdwYXR0ZXJuJywge1xuICAgICAgICAgIGZpZWxkOiB0aGlzLm5hbWUoY29tcG9uZW50KVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBjaGVjazogZnVuY3Rpb24gY2hlY2soY29tcG9uZW50LCBzZXR0aW5nLCB2YWx1ZSkge1xuICAgICAgICB2YXIgcGF0dGVybiA9IHNldHRpbmc7XG4gICAgICAgIGlmICghcGF0dGVybikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWdleFN0ciA9ICdeJyArIHBhdHRlcm4gKyAnJCc7XG4gICAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAocmVnZXhTdHIpO1xuICAgICAgICByZXR1cm4gcmVnZXgudGVzdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBqc29uOiB7XG4gICAgICBrZXk6ICd2YWxpZGF0ZS5qc29uJyxcbiAgICAgIGNoZWNrOiBmdW5jdGlvbiBjaGVjayhjb21wb25lbnQsIHNldHRpbmcsIHZhbHVlLCBkYXRhLCByb3cpIHtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YWxpZCA9IF9qc29uTG9naWNKczIuZGVmYXVsdC5hcHBseShzZXR0aW5nLCB7XG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgcm93OiByb3dcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdmFsaWQgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICBjdXN0b206IHtcbiAgICAgIGtleTogJ3ZhbGlkYXRlLmN1c3RvbScsXG4gICAgICBtZXNzYWdlOiBmdW5jdGlvbiBtZXNzYWdlKGNvbXBvbmVudCwgc2V0dGluZywgdCkge1xuICAgICAgICByZXR1cm4gdCgnY3VzdG9tJywge1xuICAgICAgICAgIGZpZWxkOiB0aGlzLm5hbWUoY29tcG9uZW50KVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBjaGVjazogZnVuY3Rpb24gY2hlY2soY29tcG9uZW50LCBzZXR0aW5nLCB2YWx1ZSwgZGF0YSwgcm93KSB7XG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWxpZCA9IHRydWU7XG4gICAgICAgIHZhciBjdXN0b20gPSBzZXR0aW5nO1xuICAgICAgICAvKmVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgICAgIHZhciBpbnB1dCA9IHZhbHVlO1xuICAgICAgICAvKmVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICAgICAgY3VzdG9tID0gY3VzdG9tLnJlcGxhY2UoLyh7e1xccysoLiopXFxzK319KS8sIGZ1bmN0aW9uIChtYXRjaCwgJDEsICQyKSB7XG4gICAgICAgICAgaWYgKCQyLmluZGV4T2YoJ2RhdGEuJykgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2dldDMuZGVmYXVsdCkoZGF0YSwgJDIucmVwbGFjZSgnZGF0YS4nLCAnJykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJDIuaW5kZXhPZigncm93LicpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9nZXQzLmRlZmF1bHQpKHJvdywgJDIucmVwbGFjZSgncm93LicsICcnKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU3VwcG9ydCBsZWdhY3kuLi5cbiAgICAgICAgICByZXR1cm4gKDAsIF9nZXQzLmRlZmF1bHQpKGRhdGEsICQyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoganNoaW50IGV2aWw6IHRydWUgKi9cbiAgICAgICAgZXZhbChjdXN0b20pO1xuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG59OyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQWRkcmVzc0NvbXBvbmVudCA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX1RleHRGaWVsZCA9IHJlcXVpcmUoJy4uL3RleHRmaWVsZC9UZXh0RmllbGQnKTtcblxudmFyIF9CYXNlID0gcmVxdWlyZSgnLi4vYmFzZS9CYXNlJyk7XG5cbnZhciBfZGVmYXVsdHNEZWVwMiA9IHJlcXVpcmUoJ2xvZGFzaC9kZWZhdWx0c0RlZXAnKTtcblxudmFyIF9kZWZhdWx0c0RlZXAzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmYXVsdHNEZWVwMik7XG5cbnZhciBfZGVsYXkyID0gcmVxdWlyZSgnbG9kYXNoL2RlbGF5Jyk7XG5cbnZhciBfZGVsYXkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVsYXkyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQWRkcmVzc0NvbXBvbmVudCA9IGV4cG9ydHMuQWRkcmVzc0NvbXBvbmVudCA9IGZ1bmN0aW9uIChfVGV4dEZpZWxkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhBZGRyZXNzQ29tcG9uZW50LCBfVGV4dEZpZWxkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBBZGRyZXNzQ29tcG9uZW50KGNvbXBvbmVudCwgb3B0aW9ucywgZGF0YSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBZGRyZXNzQ29tcG9uZW50KTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChBZGRyZXNzQ29tcG9uZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQWRkcmVzc0NvbXBvbmVudCkpLmNhbGwodGhpcywgY29tcG9uZW50LCBvcHRpb25zLCBkYXRhKSk7XG5cbiAgICB2YXIgc3JjID0gJ2h0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9qcz92PTMmbGlicmFyaWVzPXBsYWNlcyZjYWxsYmFjaz1nb29nbGVNYXBzQ2FsbGJhY2snO1xuICAgIGlmIChjb21wb25lbnQubWFwICYmIGNvbXBvbmVudC5tYXAua2V5KSB7XG4gICAgICBzcmMgKz0gJyZrZXk9JyArIGNvbXBvbmVudC5tYXAua2V5O1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50Lm1hcCAmJiBjb21wb25lbnQubWFwLnJlZ2lvbikge1xuICAgICAgc3JjICs9ICcmcmVnaW9uPScgKyBjb21wb25lbnQubWFwLnJlZ2lvbjtcbiAgICB9XG4gICAgX0Jhc2UuQmFzZUNvbXBvbmVudC5yZXF1aXJlTGlicmFyeSgnZ29vZ2xlTWFwcycsICdnb29nbGUubWFwcy5wbGFjZXMnLCBzcmMpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBZGRyZXNzQ29tcG9uZW50LCBbe1xuICAgIGtleTogJ3NldFZhbHVlQXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZUF0KGluZGV4LCB2YWx1ZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFZhbHVlQXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZUF0KGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydCB0aGUgYXV0b2NvbXBsZXRlIGFuZCB0aGUgaW5wdXQgbGlzdGVuZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgKiAgIFRoZSBpbnB1dCBmaWVsZFxuICAgICAqIEBwYXJhbSBhdXRvQ29tcGxldGVPcHRpb25zXG4gICAgICogICBUaGUgZGVmYXVsdCBvcHRpb24gZm9yIHRoZSBhdXRvY29tcGxldGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhdXRvQ29tcGxldGVJbml0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXV0b0NvbXBsZXRlSW5pdChpbnB1dCwgYXV0b0NvbXBsZXRlT3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIC8vIFNldCBhdHRyaWJ1dGUgYXV0b0NvbXBsZXRlIHRvIG9mZlxuICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwiYXV0b2NvbXBsZXRlXCIsIFwib2ZmXCIpO1xuXG4gICAgICAvLyBJbml0IHN1Z2dlc3Rpb25zIGxpc3RcbiAgICAgIHRoaXMuYXV0b0NvbXBsZXRlU3VnZ2VzdGlvbnMgPSBbXTtcblxuICAgICAgLy8gU3RhcnQgR29vZ2xlIEF1dG9jb21wbGV0ZVNlcnZpY2VcbiAgICAgIHZhciBhdXRvQ29tcGxldGUgPSBuZXcgZ29vZ2xlLm1hcHMucGxhY2VzLkF1dG9jb21wbGV0ZVNlcnZpY2UoKTtcblxuICAgICAgLy8gQ3JlYXRlIHN1Z2dlc3Rpb25zIGNvbnRhaW5lclxuICAgICAgdmFyIHN1Z2dlc3Rpb25Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHN1Z2dlc3Rpb25Db250YWluZXIuY2xhc3NMaXN0LmFkZCgncGFjLWNvbnRhaW5lcicsICdwYWMtbG9nbycpO1xuICAgICAgaW5wdXQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChzdWdnZXN0aW9uQ29udGFpbmVyKTtcblxuICAgICAgLy8gQWRkIGxpc3RlbmVyIG9uIGlucHV0IGZpZWxkIGZvciBpbnB1dCBldmVudFxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGlucHV0LCAnaW5wdXQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGlucHV0LnZhbHVlKSB7XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBpbnB1dDogaW5wdXQudmFsdWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIGF1dG9Db21wbGV0ZS5nZXRQbGFjZVByZWRpY3Rpb25zKCgwLCBfZGVmYXVsdHNEZWVwMy5kZWZhdWx0KShvcHRpb25zLCBhdXRvQ29tcGxldGVPcHRpb25zKSwgZnVuY3Rpb24gKHN1Z2dlc3Rpb25zLCBzdGF0dXMpIHtcbiAgICAgICAgICAgIF90aGlzMi5hdXRvQ29tcGxldGVEaXNwbGF5U3VnZ2VzdGlvbnMoc3VnZ2VzdGlvbnMsIHN0YXR1cywgc3VnZ2VzdGlvbkNvbnRhaW5lciwgaW5wdXQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzMi5hdXRvQ29tcGxldGVDbGVhblN1Z2dlc3Rpb25zKHN1Z2dlc3Rpb25Db250YWluZXIpO1xuICAgICAgICAgIHN1Z2dlc3Rpb25Db250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBBZGQgbGlzdGVuZXIgb24gaW5wdXQgZmllbGQgZm9yIGJsdXIgZXZlbnRcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihpbnB1dCwgJ2JsdXInLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gRGVsYXkgdG8gYWxsb3cgY2xpY2sgb24gc3VnZ2VzdGlvbiBsaXN0XG4gICAgICAgICgwLCBfZGVsYXkzLmRlZmF1bHQpKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdWdnZXN0aW9uQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgICB9KTtcbiAgICAgIC8vIEFkZCBsaXN0ZW5lciBvbiBpbnB1dCBmaWVsZCBmb3IgZm9jdXMgZXZlbnRcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihpbnB1dCwgJ2ZvY3VzJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChzdWdnZXN0aW9uQ29udGFpbmVyLmNoaWxkRWxlbWVudENvdW50KSB7XG4gICAgICAgICAgc3VnZ2VzdGlvbkNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBBZGQgbGlzdGVuZXIgb24gaW5wdXQgZmllbGQgZm9yIGZvY3VzIGV2ZW50XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCAncmVzaXplJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIFNldCB0aGUgc2FtZSB3aWR0aCBhcyBpbnB1dCBmaWVsZFxuICAgICAgICBzdWdnZXN0aW9uQ29udGFpbmVyLnN0eWxlLndpZHRoID0gaW5wdXQub2Zmc2V0V2lkdGggKyAncHgnO1xuICAgICAgfSk7XG4gICAgICAvLyBBZGQgbGlzdGluZXIgb24gaW5wdXQgZmllbGQgZm9yIGtleSBldmVudFxuICAgICAgdGhpcy5hdXRvQ29tcGxldGVLZXlib2FyZExpc3RlbmVyKHN1Z2dlc3Rpb25Db250YWluZXIsIGlucHV0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgbGlzdGluZXIgb24gaW5wdXQgZmllbGQgZm9yIGtleSBldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHN1Z2dlc3Rpb25Db250YWluZXJcbiAgICAgKiAgIFN1Z2dlc3Rpb25zIGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqICAgSW5wdXQgZmllbGQgdG8gbGlzdGVuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2F1dG9Db21wbGV0ZUtleWJvYXJkTGlzdGVuZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdXRvQ29tcGxldGVLZXlib2FyZExpc3RlbmVyKHN1Z2dlc3Rpb25Db250YWluZXIsIGlucHV0KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdGhpcy5hdXRvQ29tcGxldGVLZXlDb2RlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGlucHV0LnZhbHVlKSB7XG4gICAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgICAvLyBVUFxuICAgICAgICAgICAgICBfdGhpczMuYXV0b0NvbXBsZXRlS2V5VXBJbnRlcmFjdGlvbihzdWdnZXN0aW9uQ29udGFpbmVyLCBpbnB1dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgICAgICAvLyBET1dOXG4gICAgICAgICAgICAgIF90aGlzMy5hdXRvQ29tcGxldGVLZXlEb3duSW50ZXJhY3Rpb24oc3VnZ2VzdGlvbkNvbnRhaW5lciwgaW5wdXQpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAvLyBUQUJcbiAgICAgICAgICAgICAgX3RoaXMzLmF1dG9Db21wbGV0ZUtleVZhbGlkYXRpb25JbnRlcmFjdGlvbihzdWdnZXN0aW9uQ29udGFpbmVyLCBpbnB1dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAvLyBFTlRFUlxuICAgICAgICAgICAgICBfdGhpczMuYXV0b0NvbXBsZXRlS2V5VmFsaWRhdGlvbkludGVyYWN0aW9uKHN1Z2dlc3Rpb25Db250YWluZXIsIGlucHV0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoaW5wdXQsICdrZXlkb3duJywgdGhpcy5hdXRvQ29tcGxldGVLZXlDb2RlTGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFjdGlvbiB3aGVuIGtleSB1cCBpcyB0cmlnZ2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3VnZ2VzdGlvbkNvbnRhaW5lclxuICAgICAqICAgU3VnZ2VzdGlvbnMgY29udGFpbmVyXG4gICAgICogQHBhcmFtIGlucHV0XG4gICAgICogICBJbnB1dCBmaWVsZCB0byBsaXN0ZW5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYXV0b0NvbXBsZXRlS2V5VXBJbnRlcmFjdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF1dG9Db21wbGV0ZUtleVVwSW50ZXJhY3Rpb24oc3VnZ2VzdGlvbkNvbnRhaW5lciwgaW5wdXQpIHtcbiAgICAgIHZhciBlbGVtZW50U2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGFjLWl0ZW0tc2VsZWN0ZWQnKTtcbiAgICAgIGlmICghZWxlbWVudFNlbGVjdGVkKSB7XG4gICAgICAgIC8vIFJldHVybnMgdGhlIGJvdHRvbSBvZiB0aGUgbGlzdC5cbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0b0NvbXBsZXRlTGlzdERlY29yYXRvcihzdWdnZXN0aW9uQ29udGFpbmVyLmxhc3RDaGlsZCwgaW5wdXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVHJhbnN2ZXJzZSB0aGUgbGlzdCBpbiByZXZlcnNlIG9yZGVyLlxuICAgICAgICB2YXIgcHJldmlvdXNTaWJsaW5nID0gZWxlbWVudFNlbGVjdGVkLnByZXZpb3VzU2libGluZztcbiAgICAgICAgaWYgKHByZXZpb3VzU2libGluZykge1xuICAgICAgICAgIHRoaXMuYXV0b0NvbXBsZXRlTGlzdERlY29yYXRvcihwcmV2aW91c1NpYmxpbmcsIGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZXR1cm4gdG8gaW5wdXQgdmFsdWVcbiAgICAgICAgICBlbGVtZW50U2VsZWN0ZWQuY2xhc3NMaXN0LnJlbW92ZSgncGFjLWl0ZW0tc2VsZWN0ZWQnKTtcbiAgICAgICAgICBpbnB1dC52YWx1ZSA9IHRoaXMuYXV0b0NvbXBsZXRlSW5wdXRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFjdGlvbiB3aGVuIGtleSBkb3duIGlzIHRyaWdnZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWdnZXN0aW9uQ29udGFpbmVyXG4gICAgICogICBTdWdnZXN0aW9ucyBjb250YWluZXJcbiAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgKiAgIElucHV0IGZpZWxkIHRvIGxpc3RlblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhdXRvQ29tcGxldGVLZXlEb3duSW50ZXJhY3Rpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdXRvQ29tcGxldGVLZXlEb3duSW50ZXJhY3Rpb24oc3VnZ2VzdGlvbkNvbnRhaW5lciwgaW5wdXQpIHtcbiAgICAgIHZhciBlbGVtZW50U2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGFjLWl0ZW0tc2VsZWN0ZWQnKTtcbiAgICAgIGlmICghZWxlbWVudFNlbGVjdGVkKSB7XG4gICAgICAgIC8vIFN0YXJ0IGF0IHRoZSB0b3Agb2YgdGhlIGxpc3QuXG4gICAgICAgIGlmIChzdWdnZXN0aW9uQ29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hdXRvQ29tcGxldGVMaXN0RGVjb3JhdG9yKHN1Z2dlc3Rpb25Db250YWluZXIuZmlyc3RDaGlsZCwgaW5wdXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUcmFuc3ZlcnNlIHRoZSBsaXN0IGZyb20gdG9wIGRvd24uXG4gICAgICAgIHZhciBuZXh0U2libGluZyA9IGVsZW1lbnRTZWxlY3RlZC5uZXh0U2libGluZztcbiAgICAgICAgaWYgKG5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgdGhpcy5hdXRvQ29tcGxldGVMaXN0RGVjb3JhdG9yKG5leHRTaWJsaW5nLCBpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmV0dXJuIHRvIGlucHV0IHZhbHVlXG4gICAgICAgICAgZWxlbWVudFNlbGVjdGVkLmNsYXNzTGlzdC5yZW1vdmUoJ3BhYy1pdGVtLXNlbGVjdGVkJyk7XG4gICAgICAgICAgaW5wdXQudmFsdWUgPSB0aGlzLmF1dG9Db21wbGV0ZUlucHV0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBY3Rpb24gd2hlbiB2YWxpZGF0aW9uIGlzIHRyaWdnZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWdnZXN0aW9uQ29udGFpbmVyXG4gICAgICogICBTdWdnZXN0aW9ucyBjb250YWluZXJcbiAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgKiAgIElucHV0IGZpZWxkIHRvIGxpc3RlblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhdXRvQ29tcGxldGVLZXlWYWxpZGF0aW9uSW50ZXJhY3Rpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdXRvQ29tcGxldGVLZXlWYWxpZGF0aW9uSW50ZXJhY3Rpb24oc3VnZ2VzdGlvbkNvbnRhaW5lciwgaW5wdXQpIHtcbiAgICAgIHZhciBlbGVtZW50U2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGFjLWl0ZW0tc2VsZWN0ZWQnKTtcbiAgICAgIGlmIChlbGVtZW50U2VsZWN0ZWQpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdGhpcy5hdXRvQ29tcGxldGVTdWdnZXN0aW9uc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBzdWdnZXN0aW9uID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gZWxlbWVudFNlbGVjdGVkLnRleHRDb250ZW50IHx8IGVsZW1lbnRTZWxlY3RlZC5pbm5lclRleHQ7XG4gICAgICAgICAgICBpZiAoY29udGVudCA9PT0gc3VnZ2VzdGlvbi5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICB0aGlzLmF1dG9Db21wbGV0ZVNlcnZpY2VMaXN0ZW5lcihzdWdnZXN0aW9uLCBzdWdnZXN0aW9uQ29udGFpbmVyLCBpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnRTZWxlY3RlZC5jbGFzc0xpc3QucmVtb3ZlKCdwYWMtaXRlbS1zZWxlY3RlZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhpZ2hsaWdodCBzdWdnZXN0aW9uIHNlbGVjdGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaXRlbVxuICAgICAqICAgSXRlbSBzZWxlY3RlZCBpbiBzdWdnZXN0aW9ucyBjb250YWluZXJcbiAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgKiAgIElucHV0IGZpZWxkIHRvIGxpc3RlblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhdXRvQ29tcGxldGVMaXN0RGVjb3JhdG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXV0b0NvbXBsZXRlTGlzdERlY29yYXRvcihpdGVtLCBpbnB1dCkge1xuICAgICAgdmFyIGVsZW1lbnRTZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wYWMtaXRlbS1zZWxlY3RlZCcpO1xuICAgICAgaWYgKGVsZW1lbnRTZWxlY3RlZCkge1xuICAgICAgICBlbGVtZW50U2VsZWN0ZWQuY2xhc3NMaXN0LnJlbW92ZSgncGFjLWl0ZW0tc2VsZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGlucHV0LnZhbHVlID0gaXRlbS50ZXh0Q29udGVudCB8fCBzdWdnZXN0aW9uQ29udGFpbmVyLmlubmVyVGV4dDtcbiAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZCgncGFjLWl0ZW0tc2VsZWN0ZWQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgbWV0aG9kIHRvIHJldHVybiBpZiB0aGUgc3VnZ2VzdGlvbiBzaG91bGQgYmUgZGlzcGxheWVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqICAgRGF0YSB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhdXRvQ29tcGxldGVGaWx0ZXJTdWdnZXN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXV0b0NvbXBsZXRlRmlsdGVyU3VnZ2VzdGlvbihkYXRhKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc2NyaXB0ID0gJyhmdW5jdGlvbigpIHsgdmFyIHNob3cgPSB0cnVlOyc7XG4gICAgICAgIHNjcmlwdCArPSB0aGlzLmNvbXBvbmVudC5tYXAuYXV0b0NvbXBsZXRlRmlsdGVyLnRvU3RyaW5nKCk7XG4gICAgICAgIHNjcmlwdCArPSAnOyByZXR1cm4gc2hvdzsgfSkoKSc7XG4gICAgICAgIHZhciByZXN1bHQgPSBldmFsKHNjcmlwdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKSA9PT0gJ3RydWUnO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0FuIGVycm9yIG9jY3VycmVkIGluIGEgY3VzdG9tIGF1dG9Db21wbGV0ZSBmaWx0ZXIgc3RhdGVtZW50IGZvciBjb21wb25lbnQgJyArIHRoaXMuY29tcG9uZW50LmtleSwgZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFuIHN1Z2dlc3Rpb25zIGxpc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWdnZXN0aW9uQ29udGFpbmVyXG4gICAgICogICBDb250YWluZXIgdGFnXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2F1dG9Db21wbGV0ZUNsZWFuU3VnZ2VzdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdXRvQ29tcGxldGVDbGVhblN1Z2dlc3Rpb25zKHN1Z2dlc3Rpb25Db250YWluZXIpIHtcbiAgICAgIC8vIENsZWFuIGNsaWNrIGxpc3RlbmVyXG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IHRoaXMuYXV0b0NvbXBsZXRlU3VnZ2VzdGlvbnNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgc3VnZ2VzdGlvbiA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgIHN1Z2dlc3Rpb24uaXRlbS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHN1Z2dlc3Rpb24uY2xpY2tMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5hdXRvQ29tcGxldGVTdWdnZXN0aW9ucyA9IFtdO1xuXG4gICAgICAvLyBEZWxldGUgY3VycmVudCBzdWdnZXN0aW9uIGxpc3RcbiAgICAgIHdoaWxlIChzdWdnZXN0aW9uQ29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgc3VnZ2VzdGlvbkNvbnRhaW5lci5yZW1vdmVDaGlsZChzdWdnZXN0aW9uQ29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXkgc3VnZ2VzdGlvbnMgd2hlbiBBUEkgcmV0dXJucyB2YWx1ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHN1Z2dlc3Rpb25zXG4gICAgICogICBTdWdnZXN0aW9ucyByZXR1cm5lZFxuICAgICAqIEBwYXJhbSBzdGF0dXNcbiAgICAgKiAgIFN0YXRlIHJldHVybmVkXG4gICAgICogQHBhcmFtIHN1Z2dlc3Rpb25Db250YWluZXJcbiAgICAgKiAgIFN1Z2dlc3Rpb25zIGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqICAgSW5wdXQgZmllbGQgdG8gbGlzdGVuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2F1dG9Db21wbGV0ZURpc3BsYXlTdWdnZXN0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF1dG9Db21wbGV0ZURpc3BsYXlTdWdnZXN0aW9ucyhzdWdnZXN0aW9ucywgc3RhdHVzLCBzdWdnZXN0aW9uQ29udGFpbmVyLCBpbnB1dCkge1xuXG4gICAgICAvLyBTZXQgdGhlIHNhbWUgd2lkdGggYXMgaW5wdXQgZmllbGRcbiAgICAgIHN1Z2dlc3Rpb25Db250YWluZXIuc3R5bGUud2lkdGggPSBpbnB1dC5vZmZzZXRXaWR0aCArICdweCc7XG5cbiAgICAgIC8vIFNldCB0aGUgZGVmYXVsdCBpbnB1dCB2YWx1ZVxuICAgICAgdGhpcy5hdXRvQ29tcGxldGVJbnB1dFZhbHVlID0gaW5wdXQudmFsdWU7XG5cbiAgICAgIHRoaXMuYXV0b0NvbXBsZXRlQ2xlYW5TdWdnZXN0aW9ucyhzdWdnZXN0aW9uQ29udGFpbmVyKTtcbiAgICAgIGlmIChzdGF0dXMgIT0gZ29vZ2xlLm1hcHMucGxhY2VzLlBsYWNlc1NlcnZpY2VTdGF0dXMuT0spIHtcbiAgICAgICAgc3VnZ2VzdGlvbkNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gc3VnZ2VzdGlvbnNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgc3VnZ2VzdGlvbiA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICAgIGlmICh0aGlzLmF1dG9Db21wbGV0ZUZpbHRlclN1Z2dlc3Rpb24oc3VnZ2VzdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b0NvbXBsZXRlU3VnZ2VzdGlvbnMucHVzaChzdWdnZXN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuYXV0b0NvbXBsZXRlU3VnZ2VzdGlvbkJ1aWxkZXIoc3VnZ2VzdGlvbiwgc3VnZ2VzdGlvbkNvbnRhaW5lciwgaW5wdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yMyA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyAmJiBfaXRlcmF0b3IzLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMy5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXN1Z2dlc3Rpb25Db250YWluZXIuY2hpbGRFbGVtZW50Q291bnQpIHtcbiAgICAgICAgdGhpcy5hdXRvQ29tcGxldGVDbGVhblN1Z2dlc3Rpb25zKHN1Z2dlc3Rpb25Db250YWluZXIpO1xuICAgICAgICBzdWdnZXN0aW9uQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWdnZXN0aW9uQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXcgYSBzdWdnZXN0aW9uIGluIHRoZSBsaXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3VnZ2VzdGlvblxuICAgICAqICAgU3VnZ2VzdGlvbiB0byBkcmF3XG4gICAgICogQHBhcmFtIHN1Z2dlc3Rpb25Db250YWluZXJcbiAgICAgKiAgIFN1Z2dlc3Rpb25zIGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqICAgSW5wdXQgZmllbGQgdG8gbGlzdGVuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2F1dG9Db21wbGV0ZVN1Z2dlc3Rpb25CdWlsZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXV0b0NvbXBsZXRlU3VnZ2VzdGlvbkJ1aWxkZXIoc3VnZ2VzdGlvbiwgc3VnZ2VzdGlvbkNvbnRhaW5lciwgaW5wdXQpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKCdwYWMtaXRlbScpO1xuXG4gICAgICB2YXIgaXRlbUxvZ28gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICBpdGVtTG9nby5jbGFzc0xpc3QuYWRkKCdwYWMtaWNvbicsICdwYWMtaWNvbi1tYXJrZXInKTtcbiAgICAgIGl0ZW0uYXBwZW5kQ2hpbGQoaXRlbUxvZ28pO1xuXG4gICAgICAvLyBEcmF3IE1haW4gcGFydFxuICAgICAgdmFyIGl0ZW1NYWluID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgaXRlbU1haW4uY2xhc3NMaXN0LmFkZCgncGFjLWl0ZW0tcXVlcnknKTtcbiAgICAgIGlmIChzdWdnZXN0aW9uLnN0cnVjdHVyZWRfZm9ybWF0dGluZy5tYWluX3RleHRfbWF0Y2hlZF9zdWJzdHJpbmdzKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gc3VnZ2VzdGlvbi5zdHJ1Y3R1cmVkX2Zvcm1hdHRpbmcubWFpbl90ZXh0X21hdGNoZWRfc3Vic3RyaW5ncztcbiAgICAgICAgZm9yICh2YXIgayBpbiBtYXRjaGVzKSB7XG4gICAgICAgICAgdmFyIHBhcnQgPSBtYXRjaGVzW2tdO1xuICAgICAgICAgIGlmIChrID09IDAgJiYgcGFydC5vZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBpdGVtTWFpbi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdWdnZXN0aW9uLnN0cnVjdHVyZWRfZm9ybWF0dGluZy5tYWluX3RleHQuc3Vic3RyaW5nKDAsIHBhcnQub2Zmc2V0KSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpdGVtQm9sZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICBpdGVtQm9sZC5jbGFzc0xpc3QuYWRkKCdwYWMtbWF0Y2hlZCcpO1xuICAgICAgICAgIGl0ZW1Cb2xkLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHN1Z2dlc3Rpb24uc3RydWN0dXJlZF9mb3JtYXR0aW5nLm1haW5fdGV4dC5zdWJzdHJpbmcocGFydC5vZmZzZXQsIHBhcnQub2Zmc2V0ICsgcGFydC5sZW5ndGgpKSk7XG4gICAgICAgICAgaXRlbU1haW4uYXBwZW5kQ2hpbGQoaXRlbUJvbGQpO1xuXG4gICAgICAgICAgaWYgKGsgPT0gbWF0Y2hlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHN1Z2dlc3Rpb24uc3RydWN0dXJlZF9mb3JtYXR0aW5nLm1haW5fdGV4dC5zdWJzdHJpbmcocGFydC5vZmZzZXQgKyBwYXJ0Lmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGl0ZW1NYWluLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvbnRlbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1NYWluLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHN1Z2dlc3Rpb24uc3RydWN0dXJlZF9mb3JtYXR0aW5nLm1haW5fdGV4dCkpO1xuICAgICAgfVxuICAgICAgaXRlbS5hcHBlbmRDaGlsZChpdGVtTWFpbik7XG5cbiAgICAgIC8vIERyYXcgc2Vjb25kYXJ5IHBhcnRcbiAgICAgIGlmIChzdWdnZXN0aW9uLnN0cnVjdHVyZWRfZm9ybWF0dGluZy5zZWNvbmRhcnlfdGV4dCkge1xuICAgICAgICB2YXIgaXRlbVNlY29uZGFyeSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgaWYgKHN1Z2dlc3Rpb24uc3RydWN0dXJlZF9mb3JtYXR0aW5nLnNlY29uZGFyeV90ZXh0X21hdGNoZWRfc3Vic3RyaW5ncykge1xuICAgICAgICAgIHZhciBfbWF0Y2hlcyA9IHN1Z2dlc3Rpb24uc3RydWN0dXJlZF9mb3JtYXR0aW5nLnNlY29uZGFyeV90ZXh0X21hdGNoZWRfc3Vic3RyaW5ncztcbiAgICAgICAgICBmb3IgKHZhciBfayBpbiBfbWF0Y2hlcykge1xuICAgICAgICAgICAgdmFyIF9wYXJ0ID0gX21hdGNoZXNbX2tdO1xuICAgICAgICAgICAgaWYgKF9rID09IDAgJiYgX3BhcnQub2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgICBpdGVtU2Vjb25kYXJ5LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHN1Z2dlc3Rpb24uc3RydWN0dXJlZF9mb3JtYXR0aW5nLnNlY29uZGFyeV90ZXh0LnN1YnN0cmluZygwLCBfcGFydC5vZmZzZXQpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfaXRlbUJvbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICBfaXRlbUJvbGQuY2xhc3NMaXN0LmFkZCgncGFjLW1hdGNoZWQnKTtcbiAgICAgICAgICAgIF9pdGVtQm9sZC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdWdnZXN0aW9uLnN0cnVjdHVyZWRfZm9ybWF0dGluZy5zZWNvbmRhcnlfdGV4dC5zdWJzdHJpbmcoX3BhcnQub2Zmc2V0LCBfcGFydC5vZmZzZXQgKyBfcGFydC5sZW5ndGgpKSk7XG4gICAgICAgICAgICBpdGVtU2Vjb25kYXJ5LmFwcGVuZENoaWxkKF9pdGVtQm9sZCk7XG5cbiAgICAgICAgICAgIGlmIChfayA9PSBfbWF0Y2hlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIHZhciBfY29udGVudCA9IHN1Z2dlc3Rpb24uc3RydWN0dXJlZF9mb3JtYXR0aW5nLnNlY29uZGFyeV90ZXh0LnN1YnN0cmluZyhfcGFydC5vZmZzZXQgKyBfcGFydC5sZW5ndGgpO1xuICAgICAgICAgICAgICBpZiAoX2NvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGl0ZW1TZWNvbmRhcnkuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoX2NvbnRlbnQpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtU2Vjb25kYXJ5LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHN1Z2dlc3Rpb24uc3RydWN0dXJlZF9mb3JtYXR0aW5nLnNlY29uZGFyeV90ZXh0KSk7XG4gICAgICAgIH1cbiAgICAgICAgaXRlbS5hcHBlbmRDaGlsZChpdGVtU2Vjb25kYXJ5KTtcbiAgICAgIH1cblxuICAgICAgc3VnZ2VzdGlvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChpdGVtKTtcblxuICAgICAgdmFyIGNsaWNrTGlzdGVuZXIgPSBmdW5jdGlvbiBjbGlja0xpc3RlbmVyKGV2ZW50KSB7XG4gICAgICAgIGlucHV0LnZhbHVlID0gc3VnZ2VzdGlvbi5kZXNjcmlwdGlvbjtcbiAgICAgICAgX3RoaXM0LmF1dG9Db21wbGV0ZUlucHV0VmFsdWUgPSBzdWdnZXN0aW9uLmRlc2NyaXB0aW9uO1xuICAgICAgICBfdGhpczQuYXV0b0NvbXBsZXRlU2VydmljZUxpc3RlbmVyKHN1Z2dlc3Rpb24sIHN1Z2dlc3Rpb25Db250YWluZXIsIGlucHV0KTtcbiAgICAgIH07XG4gICAgICBzdWdnZXN0aW9uLmNsaWNrTGlzdGVuZXIgPSBjbGlja0xpc3RlbmVyO1xuICAgICAgc3VnZ2VzdGlvbi5pdGVtID0gaXRlbTtcbiAgICAgIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gaXRlbSkge1xuICAgICAgICBpdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xpY2tMaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICgnYXR0YWNoRXZlbnQnIGluIGl0ZW0pIHtcbiAgICAgICAgaXRlbS5hdHRhY2hFdmVudCgnb25jbGljaycsIGNsaWNrTGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBkZXRhaWxlZCBpbmZvcm1hdGlvbiBhbmQgc2V0IGl0IGFzIHZhbHVlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3VnZ2VzdGlvblxuICAgICAqICAgU3VnZ2VzdGlvbiB0byBkcmF3XG4gICAgICogQHBhcmFtIHN1Z2dlc3Rpb25Db250YWluZXJcbiAgICAgKiAgIFN1Z2dlc3Rpb25zIGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqICAgSW5wdXQgZmllbGQgdG8gbGlzdGVuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2F1dG9Db21wbGV0ZVNlcnZpY2VMaXN0ZW5lcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF1dG9Db21wbGV0ZVNlcnZpY2VMaXN0ZW5lcihzdWdnZXN0aW9uLCBzdWdnZXN0aW9uQ29udGFpbmVyLCBpbnB1dCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHZhciBzZXJ2aWNlID0gbmV3IGdvb2dsZS5tYXBzLnBsYWNlcy5QbGFjZXNTZXJ2aWNlKGlucHV0KTtcbiAgICAgIHNlcnZpY2UuZ2V0RGV0YWlscyh7XG4gICAgICAgIHBsYWNlSWQ6IHN1Z2dlc3Rpb24ucGxhY2VfaWRcbiAgICAgIH0sIGZ1bmN0aW9uIChwbGFjZSwgc3RhdHVzKSB7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IGdvb2dsZS5tYXBzLnBsYWNlcy5QbGFjZXNTZXJ2aWNlU3RhdHVzLk9LKSB7XG4gICAgICAgICAgX3RoaXM1LnNldFZhbHVlKHBsYWNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWRkSW5wdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJbnB1dChpbnB1dCwgY29udGFpbmVyKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgX2dldChBZGRyZXNzQ29tcG9uZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEFkZHJlc3NDb21wb25lbnQucHJvdG90eXBlKSwgJ2FkZElucHV0JywgdGhpcykuY2FsbCh0aGlzLCBpbnB1dCwgY29udGFpbmVyKTtcbiAgICAgIF9CYXNlLkJhc2VDb21wb25lbnQubGlicmFyeVJlYWR5KCdnb29nbGVNYXBzJykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhdXRvQ29tcGxldGVPcHRpb25zID0ge307XG4gICAgICAgIGlmIChfdGhpczYuY29tcG9uZW50Lm1hcCkge1xuICAgICAgICAgIGF1dG9Db21wbGV0ZU9wdGlvbnMgPSBfdGhpczYuY29tcG9uZW50Lm1hcC5hdXRvQ29tcGxldGVPcHRpb25zIHx8IHt9O1xuICAgICAgICAgIGlmIChhdXRvQ29tcGxldGVPcHRpb25zLmxvY2F0aW9uKSB7XG4gICAgICAgICAgICBhdXRvQ29tcGxldGVPcHRpb25zLmxvY2F0aW9uID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhhdXRvQ29tcGxldGVPcHRpb25zLmxvY2F0aW9uLmxhdCwgYXV0b0NvbXBsZXRlT3B0aW9ucy5sb2NhdGlvbi5sbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpczYuY29tcG9uZW50Lm1hcCAmJiBfdGhpczYuY29tcG9uZW50Lm1hcC5hdXRvQ29tcGxldGVGaWx0ZXIpIHtcbiAgICAgICAgICAvLyBDYWxsIGN1c3RvbSBhdXRvQ29tcGxldGUgdG8gZmlsdGVyIHN1Z2dlc3Rpb25zXG4gICAgICAgICAgX3RoaXM2LmF1dG9Db21wbGV0ZUluaXQoaW5wdXQsIGF1dG9Db21wbGV0ZU9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhdXRvY29tcGxldGUgPSBuZXcgZ29vZ2xlLm1hcHMucGxhY2VzLkF1dG9jb21wbGV0ZShpbnB1dCk7XG4gICAgICAgICAgYXV0b2NvbXBsZXRlLmFkZExpc3RlbmVyKFwicGxhY2VfY2hhbmdlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM2LnNldFZhbHVlKGF1dG9jb21wbGV0ZS5nZXRQbGFjZSgpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZWxlbWVudEluZm8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbGVtZW50SW5mbygpIHtcbiAgICAgIHZhciBpbmZvID0gX2dldChBZGRyZXNzQ29tcG9uZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEFkZHJlc3NDb21wb25lbnQucHJvdG90eXBlKSwgJ2VsZW1lbnRJbmZvJywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIGluZm8uYXR0ci5jbGFzcyArPSAnIGFkZHJlc3Mtc2VhcmNoJztcbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBZGRyZXNzQ29tcG9uZW50O1xufShfVGV4dEZpZWxkLlRleHRGaWVsZENvbXBvbmVudCk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5CYXNlQ29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3ZhbmlsbGEgPSByZXF1aXJlKCd0ZXh0LW1hc2stYWxsL3ZhbmlsbGEnKTtcblxudmFyIF92YW5pbGxhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZhbmlsbGEpO1xuXG52YXIgX25hdGl2ZVByb21pc2VPbmx5ID0gcmVxdWlyZSgnbmF0aXZlLXByb21pc2Utb25seScpO1xuXG52YXIgX25hdGl2ZVByb21pc2VPbmx5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX25hdGl2ZVByb21pc2VPbmx5KTtcblxudmFyIF9nZXQyID0gcmVxdWlyZSgnbG9kYXNoL2dldCcpO1xuXG52YXIgX2dldDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXQyKTtcblxudmFyIF9lYWNoMiA9IHJlcXVpcmUoJ2xvZGFzaC9lYWNoJyk7XG5cbnZhciBfZWFjaDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYWNoMik7XG5cbnZhciBfZGVib3VuY2UyID0gcmVxdWlyZSgnbG9kYXNoL2RlYm91bmNlJyk7XG5cbnZhciBfZGVib3VuY2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVib3VuY2UyKTtcblxudmFyIF9pc0FycmF5MiA9IHJlcXVpcmUoJ2xvZGFzaC9pc0FycmF5Jyk7XG5cbnZhciBfaXNBcnJheTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0FycmF5Mik7XG5cbnZhciBfYXNzaWduMiA9IHJlcXVpcmUoJ2xvZGFzaC9hc3NpZ24nKTtcblxudmFyIF9hc3NpZ24zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXNzaWduMik7XG5cbnZhciBfY2xvbmUyID0gcmVxdWlyZSgnbG9kYXNoL2Nsb25lJyk7XG5cbnZhciBfY2xvbmUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xvbmUyKTtcblxudmFyIF9pMThuZXh0ID0gcmVxdWlyZSgnaTE4bmV4dCcpO1xuXG52YXIgX2kxOG5leHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaTE4bmV4dCk7XG5cbnZhciBfanNvbkxvZ2ljSnMgPSByZXF1aXJlKCdqc29uLWxvZ2ljLWpzJyk7XG5cbnZhciBfanNvbkxvZ2ljSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanNvbkxvZ2ljSnMpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcblxudmFyIF91dGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlscyk7XG5cbnZhciBfVmFsaWRhdG9yID0gcmVxdWlyZSgnLi4vVmFsaWRhdG9yJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbl9pMThuZXh0Mi5kZWZhdWx0LmluaXRpYWxpemVkID0gZmFsc2U7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgQmFzZUNvbXBvbmVudCBjbGFzcyB3aGljaCBhbGwgZWxlbWVudHMgd2l0aGluIHRoZSBGb3JtaW9Gb3JtIGRlcml2ZSBmcm9tLlxuICovXG5cbnZhciBCYXNlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSBhIG5ldyBCYXNlQ29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50IC0gVGhlIGNvbXBvbmVudCBKU09OIHlvdSB3aXNoIHRvIGluaXRpYWxpemUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIFRoZSBnbG9iYWwgZGF0YSBzdWJtaXNzaW9uIG9iamVjdCB0aGlzIGNvbXBvbmVudCB3aWxsIGJlbG9uZy5cbiAgICovXG4gIGZ1bmN0aW9uIEJhc2VDb21wb25lbnQoY29tcG9uZW50LCBvcHRpb25zLCBkYXRhKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VDb21wb25lbnQpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIElEIG9mIHRoaXMgY29tcG9uZW50LiBUaGlzIHZhbHVlIGlzIGF1dG8tZ2VuZXJhdGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBjcmVhdGVkLCBidXRcbiAgICAgKiBjYW4gYWxzbyBiZSBwcm92aWRlZCBmcm9tIHRoZSBjb21wb25lbnQuaWQgdmFsdWUgcGFzc2VkIGludG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5pZCA9IGNvbXBvbmVudCAmJiBjb21wb25lbnQuaWQgPyBjb21wb25lbnQuaWQgOiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9ucyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAgICogQHR5cGUge3t9fVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9ICgwLCBfY2xvbmUzLmRlZmF1bHQpKG9wdGlvbnMpIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGkxOG4gY29uZmlndXJhdGlvbiBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zLmkxOG4gPSB0aGlzLm9wdGlvbnMuaTE4biB8fCByZXF1aXJlKCcuLi8uLi9sb2NhbHMvZW4nKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudHMgdGhhdCBhcmUgdHJpZ2dlcmVkIGZvciB0aGUgd2hvbGUgRm9ybWlvRm9ybSBvYmplY3QuXG4gICAgICovXG4gICAgdGhpcy5ldmVudHMgPSB0aGlzLm9wdGlvbnMuZXZlbnRzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGEgb2JqZWN0IGluIHdoaWNoIHRoaXMgY29tcG9uZW50IHJlc2lkZXMuXG4gICAgICogQHR5cGUgeyp9XG4gICAgICovXG4gICAgdGhpcy5kYXRhID0gZGF0YSB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBGb3JtLmlvIGNvbXBvbmVudCBKU09OIHNjaGVtYS5cbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudCB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBib3VuZGluZyBIVE1MIEVsZW1lbnQgd2hpY2ggdGhpcyBjb21wb25lbnQgaXMgcmVuZGVyZWQuXG4gICAgICogQHR5cGUge251bGx9XG4gICAgICovXG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBIVE1MIEVsZW1lbnQgZm9yIHRoZSB0YWJsZSBib2R5LiBUaGlzIGlzIHJlbGV2YW50IGZvciB0aGUgXCJtdWx0aXBsZVwiIGZsYWcgb24gaW5wdXRzLlxuICAgICAqIEB0eXBlIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMudGJvZHkgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIEhUTUxFbGVtZW50IHRoYXQgaXMgYXNzaWduZWQgdG8gdGhlIGxhYmVsIG9mIHRoaXMgY29tcG9uZW50LlxuICAgICAqIEB0eXBlIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMubGFiZWwgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIEhUTUxFbGVtZW50IGZvciB3aGljaCB0aGUgZXJyb3JzIGFyZSByZW5kZXJlZCBmb3IgdGhpcyBjb21wb25lbnQgKHVzdWFsbHkgdW5kZXJuZWF0aCB0aGUgY29tcG9uZW50KS5cbiAgICAgKiBAdHlwZSB7bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmVycm9yRWxlbWVudCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXhpc3RpbmcgZXJyb3IgdGhhdCB0aGlzIGNvbXBvbmVudCBoYXMuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmVycm9yID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBhbGwgb2YgdGhlIGlucHV0IEhUTUwgRWxlbWVudHMgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhpcyBjb21wb25lbnQuXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuaW5wdXRzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzaWMgY29tcG9uZW50IGluZm9ybWF0aW9uIHdoaWNoIHRlbGxzIHRoZSBCYXNlQ29tcG9uZW50IGhvdyB0byByZW5kZXIgdGhlIGlucHV0IGVsZW1lbnQgb2YgdGhlIGNvbXBvbmVudHMgdGhhdCBkZXJpdmUgZnJvbSB0aGlzIGNsYXNzLlxuICAgICAqIEB0eXBlIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMuaW5mbyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgb2YgdGhpcyBjb21wb25lbnRcbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICB0aGlzLnZhbHVlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSByb3cgcGF0aCBvZiB0aGlzIGNvbXBvbmVudC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucm93ID0gY29tcG9uZW50ID8gY29tcG9uZW50LnJvdyA6ICcnO1xuICAgIHRoaXMucm93ID0gdGhpcy5yb3cgfHwgJyc7XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoaXMgY29tcG9uZW50IGlzIGRpc2FibGVkLCBvciBub3QuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhpcyBpbnB1dCBoYXMgYmVlbiBpbnB1dCBhbmQgcHJvdmlkZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnByaXN0aW5lID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBJbnB1dCBtYXNrIGluc3RhbmNlIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICAgKiBAdHlwZSB7SW5wdXRNYXNrfVxuICAgICAqL1xuICAgIHRoaXMuaW5wdXRNYXNrID0gbnVsbDtcblxuICAgIHRoaXMub3B0aW9ucy5uYW1lID0gdGhpcy5vcHRpb25zLm5hbWUgfHwgJ2RhdGEnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbGlkYXRvcnMgdGhhdCBhcmUgYXNzaWduZWQgdG8gdGhpcyBjb21wb25lbnQuXG4gICAgICogQHR5cGUge1tzdHJpbmddfVxuICAgICAqL1xuICAgIHRoaXMudmFsaWRhdG9ycyA9IFsncmVxdWlyZWQnLCAnbWluTGVuZ3RoJywgJ21heExlbmd0aCcsICdjdXN0b20nLCAncGF0dGVybicsICdqc29uJ107XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHRyaWdnZXIgYSBuZXcgY2hhbmdlIGluIHRoaXMgY29tcG9uZW50LlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn0gLSBDYWxsIHRvIHRyaWdnZXIgYSBjaGFuZ2UgaW4gdGhpcyBjb21wb25lbnQuXG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyQ2hhbmdlID0gKDAsIF9kZWJvdW5jZTMuZGVmYXVsdCkodGhpcy5vbkNoYW5nZS5iaW5kKHRoaXMpLCAyMDApO1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgZXZlbnQgaGFuZGxlcnMgc28gdGhhdCB0aGUgZGVzdHJ5IGNvbW1hbmQgY2FuIGRlcmVnaXN0ZXIgdGhlbS5cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5ldmVudEhhbmRsZXJzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiB0aGUgZXZlbnQgbGlzdGVuZXJzIHNvIHRoYXQgdGhlIGRlc3Ryb3kgY29tbWFuZCBjYW4gZGVyZWdpc3RlciB0aGVtLlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gW107XG5cbiAgICBpZiAodGhpcy5jb21wb25lbnQpIHtcbiAgICAgIHRoaXMudHlwZSA9IHRoaXMuY29tcG9uZW50LnR5cGU7XG4gICAgICBpZiAodGhpcy5jb21wb25lbnQuaW5wdXQgJiYgdGhpcy5jb21wb25lbnQua2V5KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5uYW1lICs9ICdbJyArIHRoaXMuY29tcG9uZW50LmtleSArICddJztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgZWxlbWVudCBpbmZvcm1hdGlvbiBmb3IgY3JlYXRpbmcgdGhlIGlucHV0IGVsZW1lbnQuXG4gICAgICAgKiBAdHlwZSB7Kn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5pbmZvID0gdGhpcy5lbGVtZW50SW5mbygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2xhdGUgYSB0ZXh0IHVzaW5nIHRoZSBpMThuIHN5c3RlbS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgaTE4biBpZGVudGlmaWVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIGkxOG4gcGFyYW1ldGVycyB0byB1c2UgZm9yIHRyYW5zbGF0aW9uLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhCYXNlQ29tcG9uZW50LCBbe1xuICAgIGtleTogJ3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0KHRleHQsIHBhcmFtcykge1xuICAgICAgdmFyIG1lc3NhZ2UgPSBfaTE4bmV4dDIuZGVmYXVsdC50KHRleHQsIHBhcmFtcyk7XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBmb3IgYSBuZXcgZXZlbnQgd2l0aGluIHRoaXMgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBsZXQgY29tcG9uZW50ID0gbmV3IEJhc2VDb21wb25lbnQoe1xuICAgICAqICAgdHlwZTogJ3RleHRmaWVsZCcsXG4gICAgICogICBsYWJlbDogJ0ZpcnN0IE5hbWUnLFxuICAgICAqICAga2V5OiAnZmlyc3ROYW1lJ1xuICAgICAqIH0pO1xuICAgICAqIGNvbXBvbmVudC5vbignY29tcG9uZW50Q2hhbmdlJywgKGNoYW5nZWQpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCd0aGlzIGVsZW1lbnQgaXMgY2hhbmdlZC4nKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gVGhlIGV2ZW50IHlvdSB3aXNoIHRvIHJlZ2lzdGVyIHRoZSBoYW5kbGVyIGZvci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiAtIFRoZSBjYWxsYmFjayBoYW5kbGVyIHRvIGhhbmRsZSB0aGlzIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW50ZXJuYWwgLSBUaGlzIGlzIGFuIGludGVybmFsIGV2ZW50IGhhbmRsZXIuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb24oZXZlbnQsIGNiLCBpbnRlcm5hbCkge1xuICAgICAgaWYgKCF0aGlzLmV2ZW50cykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9ICdmb3JtaW8uJyArIGV2ZW50O1xuICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgbGlzdGVuZXI6IGNiLFxuICAgICAgICBpbnRlcm5hbDogaW50ZXJuYWxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzLm9uKHR5cGUsIGNiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbWl0IGEgbmV3IGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gVGhlIGV2ZW50IHRvIGVtaXQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSB0byBlbWl0IHdpdGggdGhlIGhhbmRsZXIuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2VtaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0KGV2ZW50LCBkYXRhKSB7XG4gICAgICB0aGlzLmV2ZW50cy5lbWl0KCdmb3JtaW8uJyArIGV2ZW50LCBkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIEhUTUxFbGVtZW50IGljb24gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGljb24gdG8gcmV0cmlldmUuXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSAtIFRoZSBpY29uIGVsZW1lbnQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldEljb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJY29uKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNlKG5hbWUgKyAnSWNvbicsICdpJywge1xuICAgICAgICBjbGFzczogJ2dseXBoaWNvbiBnbHlwaGljb24tJyArIG5hbWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gdGhlIGxvY2FsaXphdGlvbiBpbml0aWFsaXphdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbG9jYWxpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2NhbGl6ZSgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmIChfaTE4bmV4dDIuZGVmYXVsdC5pbml0aWFsaXplZCkge1xuICAgICAgICByZXR1cm4gX25hdGl2ZVByb21pc2VPbmx5Mi5kZWZhdWx0LnJlc29sdmUoX2kxOG5leHQyLmRlZmF1bHQpO1xuICAgICAgfVxuICAgICAgX2kxOG5leHQyLmRlZmF1bHQuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5ldyBfbmF0aXZlUHJvbWlzZU9ubHkyLmRlZmF1bHQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBfaTE4bmV4dDIuZGVmYXVsdC5pbml0KF90aGlzLm9wdGlvbnMuaTE4biwgZnVuY3Rpb24gKGVyciwgdCkge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShfaTE4bmV4dDIuZGVmYXVsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGJlZm9yZSBhIG5leHQgcGFnZSBpcyB0cmlnZ2VyZWQgYWxsb3dpbmcgdGhlIGNvbXBvbmVudHNcbiAgICAgKiB0byBwZXJmb3JtIHNwZWNpYWwgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYmVmb3JlTmV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJlZm9yZU5leHQoKSB7XG4gICAgICByZXR1cm4gX25hdGl2ZVByb21pc2VPbmx5Mi5kZWZhdWx0LnJlc29sdmUodHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGJlZm9yZSBhIHN1Ym1pc3Npb24gaXMgdHJpZ2dlcmVkIGFsbG93aW5nIHRoZSBjb21wb25lbnRzXG4gICAgICogdG8gcGVyZm9ybSBzcGVjaWFsIGFzeW5jIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2JlZm9yZVN1Ym1pdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJlZm9yZVN1Ym1pdCgpIHtcbiAgICAgIHJldHVybiBfbmF0aXZlUHJvbWlzZU9ubHkyLmRlZmF1bHQucmVzb2x2ZSh0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYnVpbGQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZCgpIHtcbiAgICAgIHRoaXMuY3JlYXRlRWxlbWVudCgpO1xuICAgICAgdGhpcy5jcmVhdGVMYWJlbCh0aGlzLmVsZW1lbnQpO1xuICAgICAgaWYgKCF0aGlzLmNyZWF0ZVdyYXBwZXIoKSkge1xuICAgICAgICB0aGlzLmNyZWF0ZUlucHV0KHRoaXMuZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIERpc2FibGUgaWYgbmVlZGVkLlxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWFkT25seSB8fCB0aGlzLmNvbXBvbmVudC5kaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IGRlZmF1bHQgdmFsdWVzLlxuICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHRoaXMuZGVmYXVsdFZhbHVlO1xuICAgICAgaWYgKGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICB0aGlzLnNldFZhbHVlKGRlZmF1bHRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBDU1MgY2xhc3MgbmFtZSBvZiB0aGlzIGNvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBjbGFzcyBuYW1lIG9mIHRoaXMgY29tcG9uZW50LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRFbGVtZW50JyxcblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgb3V0c2lkZSB3cmFwcGluZyBlbGVtZW50IG9mIHRoaXMgY29tcG9uZW50LlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBvdXRzaWRlIHdyYXBwaW5nIGVsZW1lbnQgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlRWxlbWVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQoKSB7XG4gICAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLmNlKCdlbGVtZW50JywgJ2RpdicsIHtcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIGNsYXNzOiB0aGlzLmNsYXNzTmFtZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgLy8gRW5zdXJlIHlvdSBjYW4gZ2V0IHRoZSBjb21wb25lbnQgaW5mbyBmcm9tIHRoZSBlbGVtZW50LlxuICAgICAgICB0aGlzLmVsZW1lbnQuY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBpbnB1dCB3cmFwcGluZyBlbGVtZW50LiBGb3IgbXVsdGlwbGUsIHRoaXMgbWF5IGJlIHRoZSB0YWJsZSB3cmFwcGVyIGZvciB0aGUgZWxlbWVudHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZVdyYXBwZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVXcmFwcGVyKCkge1xuICAgICAgaWYgKCF0aGlzLmNvbXBvbmVudC5tdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGFibGUgPSB0aGlzLmNlKCd3cmFwcGVyJywgJ3RhYmxlJywge1xuICAgICAgICAgIGNsYXNzOiAndGFibGUgdGFibGUtYm9yZGVyZWQnXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRib2R5ID0gdGhpcy5jZSgnd3JhcHBlckJvZHknLCAndGJvZHknKTtcbiAgICAgICAgdGFibGUuYXBwZW5kQ2hpbGQodGhpcy50Ym9keSk7XG5cbiAgICAgICAgLy8gQWRkIGEgZGVmYXVsdCB2YWx1ZS5cbiAgICAgICAgaWYgKCF0aGlzLmRhdGFbdGhpcy5jb21wb25lbnQua2V5XSB8fCAhdGhpcy5kYXRhW3RoaXMuY29tcG9uZW50LmtleV0ubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5hZGROZXdWYWx1ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnVpbGQgdGhlIHJvd3MuXG4gICAgICAgIHRoaXMuYnVpbGRSb3dzKCk7XG5cbiAgICAgICAgLy8gQWRkIHRoZSB0YWJsZSB0byB0aGUgZWxlbWVudC5cbiAgICAgICAgdGhpcy5hcHBlbmQodGFibGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhZGROZXdWYWx1ZScsXG5cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgZW1wdHkgdmFsdWUgdG8gdGhlIGRhdGEgYXJyYXkuXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE5ld1ZhbHVlKCkge1xuICAgICAgaWYgKCF0aGlzLmRhdGFbdGhpcy5jb21wb25lbnQua2V5XSkge1xuICAgICAgICB0aGlzLmRhdGFbdGhpcy5jb21wb25lbnQua2V5XSA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKCEoMCwgX2lzQXJyYXkzLmRlZmF1bHQpKHRoaXMuZGF0YVt0aGlzLmNvbXBvbmVudC5rZXldKSkge1xuICAgICAgICB0aGlzLmRhdGFbdGhpcy5jb21wb25lbnQua2V5XSA9IFt0aGlzLmRhdGFbdGhpcy5jb21wb25lbnQua2V5XV07XG4gICAgICB9XG4gICAgICB0aGlzLmRhdGFbdGhpcy5jb21wb25lbnQua2V5XS5wdXNoKHRoaXMuZGVmYXVsdFZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGVtcHR5IHZhbHVlIHRvIHRoZSBkYXRhIGFycmF5LCBhbmQgYWRkIGEgbmV3IHJvdyB0byBjb250YWluIGl0LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFZhbHVlKCkge1xuICAgICAgdGhpcy5hZGROZXdWYWx1ZSgpO1xuICAgICAgdGhpcy5idWlsZFJvd3MoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgdmFsdWUgb3V0IG9mIHRoZSBkYXRhIGFycmF5IGFuZCByZWJ1aWxkIHRoZSByb3dzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgZGF0YSBlbGVtZW50IHRvIHJlbW92ZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlVmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVWYWx1ZShpbmRleCkge1xuICAgICAgaWYgKHRoaXMuZGF0YS5oYXNPd25Qcm9wZXJ0eSh0aGlzLmNvbXBvbmVudC5rZXkpKSB7XG4gICAgICAgIHRoaXMuZGF0YVt0aGlzLmNvbXBvbmVudC5rZXldLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICB0aGlzLmJ1aWxkUm93cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYnVpbGQgdGhlIHJvd3MgdG8gY29udGFpbiB0aGUgdmFsdWVzIG9mIHRoaXMgY29tcG9uZW50LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdidWlsZFJvd3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZFJvd3MoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLnRib2R5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5wdXRzID0gW107XG4gICAgICB0aGlzLnRib2R5LmlubmVySFRNTCA9ICcnO1xuICAgICAgKDAsIF9lYWNoMy5kZWZhdWx0KSh0aGlzLmRhdGFbdGhpcy5jb21wb25lbnQua2V5XSwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIgdHIgPSBfdGhpczIuY2UoJ3JvdycsICd0cicpO1xuICAgICAgICB2YXIgdGQgPSBfdGhpczIuY2UoJ2NvbHVtbicsICd0ZCcpO1xuICAgICAgICBfdGhpczIuY3JlYXRlSW5wdXQodGQpO1xuICAgICAgICB0ci5hcHBlbmRDaGlsZCh0ZCk7XG4gICAgICAgIHZhciB0ZEFkZCA9IF90aGlzMi5jZSgnY29sdW1uQWRkJywgJ3RkJyk7XG4gICAgICAgIHRkQWRkLmFwcGVuZENoaWxkKF90aGlzMi5yZW1vdmVCdXR0b24oaW5kZXgpKTtcbiAgICAgICAgdHIuYXBwZW5kQ2hpbGQodGRBZGQpO1xuICAgICAgICBfdGhpczIudGJvZHkuYXBwZW5kQ2hpbGQodHIpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciB0ciA9IHRoaXMuY2UoJ3Jvd0FkZCcsICd0cicpO1xuICAgICAgdmFyIHRkID0gdGhpcy5jZSgnYWRkUm93Q29sdW1uJywgJ3RkJywge1xuICAgICAgICBjb2xzcGFuOiAnMidcbiAgICAgIH0pO1xuICAgICAgdGQuYXBwZW5kQ2hpbGQodGhpcy5hZGRCdXR0b24oKSk7XG4gICAgICB0ci5hcHBlbmRDaGlsZCh0ZCk7XG4gICAgICB0aGlzLnRib2R5LmFwcGVuZENoaWxkKHRyKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVhZE9ubHkpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBidXR0b24gdG8gYWRkIG5ldyByb3dzIHRvIHRoZSBtdWx0aXBsZSBpbnB1dCBlbGVtZW50cy5cbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IC0gVGhlIFwiQWRkIE5ld1wiIGJ1dHRvbiBodG1sIGVsZW1lbnQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZEJ1dHRvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEJ1dHRvbigpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgYWRkQnV0dG9uID0gdGhpcy5jZSgnYWRkQnV0dG9uJywgJ2EnLCB7XG4gICAgICAgIGNsYXNzOiAnYnRuIGJ0bi1wcmltYXJ5J1xuICAgICAgfSk7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoYWRkQnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgX3RoaXMzLmFkZFZhbHVlKCk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGFkZEljb24gPSB0aGlzLmNlKCdhZGRJY29uJywgJ3NwYW4nLCB7XG4gICAgICAgIGNsYXNzOiAnZ2x5cGhpY29uIGdseXBoaWNvbi1wbHVzJ1xuICAgICAgfSk7XG4gICAgICBhZGRCdXR0b24uYXBwZW5kQ2hpbGQoYWRkSWNvbik7XG4gICAgICBhZGRCdXR0b24uYXBwZW5kQ2hpbGQodGhpcy50ZXh0KHRoaXMuY29tcG9uZW50LmFkZEFub3RoZXIgfHwgJyBBZGQgQW5vdGhlcicpKTtcbiAgICAgIHJldHVybiBhZGRCdXR0b247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHJlYWRpYmxlIG5hbWUgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIG5hbWUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlQnV0dG9uJyxcblxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBcInJlbW92ZVwiIHJvdyBidXR0b24gYW5kIHJldHVybnMgdGhlIGh0bWwgZWxlbWVudCBvZiB0aGF0IGJ1dHRvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHJvdyB0aGF0IHNob3VsZCBiZSByZW1vdmVkLlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gLSBUaGUgaHRtbCBlbGVtZW50IG9mIHRoZSByZW1vdmUgYnV0dG9uLlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVCdXR0b24oaW5kZXgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgcmVtb3ZlQnV0dG9uID0gdGhpcy5jZSgncmVtb3ZlQnV0dG9uJywgJ2J1dHRvbicsIHtcbiAgICAgICAgdHlwZTogJ2J1dHRvbicsXG4gICAgICAgIGNsYXNzOiAnYnRuIGJ0bi1kZWZhdWx0JyxcbiAgICAgICAgdGFiaW5kZXg6ICctMSdcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIocmVtb3ZlQnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgX3RoaXM0LnJlbW92ZVZhbHVlKGluZGV4KTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgcmVtb3ZlSWNvbiA9IHRoaXMuY2UoJ3JlbW92ZUljb24nLCAnc3BhbicsIHtcbiAgICAgICAgY2xhc3M6ICdnbHlwaGljb24gZ2x5cGhpY29uLXJlbW92ZS1jaXJjbGUnXG4gICAgICB9KTtcbiAgICAgIHJlbW92ZUJ1dHRvbi5hcHBlbmRDaGlsZChyZW1vdmVJY29uKTtcbiAgICAgIHJldHVybiByZW1vdmVCdXR0b247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBIVE1MIGVsZW1lbnQgZm9yIHRoZSBsYWJlbCBvZiB0aGlzIGNvbW9uZW50LlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciAtIFRoZSBjb250YWluaW5nIGVsZW1lbnQgdGhhdCB3aWxsIGNvbXRhaW4gdGhpcyBsYWJlbC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlTGFiZWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVMYWJlbChjb250YWluZXIpIHtcbiAgICAgIGlmICghdGhpcy5jb21wb25lbnQubGFiZWwgfHwgdGhpcy5vcHRpb25zLmlucHV0c09ubHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sYWJlbCA9IHRoaXMuY2UoJ2xhYmVsJywgJ2xhYmVsJywge1xuICAgICAgICBjbGFzczogJ2NvbnRyb2wtbGFiZWwnXG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLmluZm8uYXR0ci5pZCkge1xuICAgICAgICB0aGlzLmxhYmVsLnNldEF0dHJpYnV0ZSgnZm9yJywgdGhpcy5pbmZvLmF0dHIuaWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5sYWJlbC5hcHBlbmRDaGlsZCh0aGlzLnRleHQodGhpcy5jb21wb25lbnQubGFiZWwpKTtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmxhYmVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGVycm9yIGVsZW1lbnQgdG8gaG9sZCB0aGUgZXJyb3JzIG9mIHRoaXMgZWxlbWVudC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlRXJyb3JFbGVtZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlRXJyb3JFbGVtZW50KCkge1xuICAgICAgaWYgKCF0aGlzLmVycm9yQ29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXJyb3JFbGVtZW50ID0gdGhpcy5jZSgnZXJyb3JzJywgJ2RpdicsIHtcbiAgICAgICAgY2xhc3M6ICdmb3JtaW8tZXJyb3JzJ1xuICAgICAgfSk7XG4gICAgICB0aGlzLmVycm9yQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZXJyb3JFbGVtZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcHJlZml4IGh0bWwgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGlucHV0IC0gVGhlIGlucHV0IGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaW5wdXRHcm91cCAtIFRoZSBncm91cCB0aGF0IHdpbGwgaG9sZCB0aGlzIHByZWZpeC5cbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IC0gVGhlIGh0bWwgZWxlbWVudCBmb3IgdGhpcyBwcmVmaXguXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZFByZWZpeCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFByZWZpeChpbnB1dCwgaW5wdXRHcm91cCkge1xuICAgICAgdmFyIHByZWZpeCA9IG51bGw7XG4gICAgICBpZiAodGhpcy5jb21wb25lbnQucHJlZml4KSB7XG4gICAgICAgIHByZWZpeCA9IHRoaXMuY2UoJ3ByZWZpeCcsICdkaXYnLCB7XG4gICAgICAgICAgY2xhc3M6ICdpbnB1dC1ncm91cC1hZGRvbidcbiAgICAgICAgfSk7XG4gICAgICAgIHByZWZpeC5hcHBlbmRDaGlsZCh0aGlzLnRleHQodGhpcy5jb21wb25lbnQucHJlZml4KSk7XG4gICAgICAgIGlucHV0R3JvdXAuYXBwZW5kQ2hpbGQocHJlZml4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHN1ZmZpeCBodG1sIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpbnB1dCAtIFRoZSBpbnB1dCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGlucHV0R3JvdXAgLSBUaGUgZ3JvdXAgdGhhdCB3aWxsIGhvbGQgdGhpcyBzdWZmaXguXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSAtIFRoZSBodG1sIGVsZW1lbnQgZm9yIHRoaXMgc3VmZml4LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRTdWZmaXgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRTdWZmaXgoaW5wdXQsIGlucHV0R3JvdXApIHtcbiAgICAgIHZhciBzdWZmaXggPSBudWxsO1xuICAgICAgaWYgKHRoaXMuY29tcG9uZW50LnN1ZmZpeCkge1xuICAgICAgICBzdWZmaXggPSB0aGlzLmNlKCdzdWZmaXgnLCAnZGl2Jywge1xuICAgICAgICAgIGNsYXNzOiAnaW5wdXQtZ3JvdXAtYWRkb24nXG4gICAgICAgIH0pO1xuICAgICAgICBzdWZmaXguYXBwZW5kQ2hpbGQodGhpcy50ZXh0KHRoaXMuY29tcG9uZW50LnN1ZmZpeCkpO1xuICAgICAgICBpbnB1dEdyb3VwLmFwcGVuZENoaWxkKHN1ZmZpeCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VmZml4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgaW5wdXQgZ3JvdXAgdG8gaG9sZCB0aGUgaW5wdXQgaHRtbCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGlucHV0IC0gVGhlIGlucHV0IGh0bWwgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgLSBUaGUgY29udGFpbmluZyBodG1sIGVsZW1lbnQgZm9yIHRoaXMgZ3JvdXAuXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSAtIFRoZSBpbnB1dCBncm91cCBlbGVtZW50LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRJbnB1dEdyb3VwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5wdXRHcm91cChpbnB1dCwgY29udGFpbmVyKSB7XG4gICAgICB2YXIgaW5wdXRHcm91cCA9IG51bGw7XG4gICAgICBpZiAodGhpcy5jb21wb25lbnQucHJlZml4IHx8IHRoaXMuY29tcG9uZW50LnN1ZmZpeCkge1xuICAgICAgICBpbnB1dEdyb3VwID0gdGhpcy5jZSgnaW5wdXRHcm91cCcsICdkaXYnLCB7XG4gICAgICAgICAgY2xhc3M6ICdpbnB1dC1ncm91cCdcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChpbnB1dEdyb3VwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnB1dEdyb3VwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gaW5wdXQgbWFzayB0aGF0IGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgaW5wdXQgbWFzayBsaWJyYXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXNrIC0gVGhlIEZvcm0uaW8gaW5wdXQgbWFzay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IC0gVGhlIGlucHV0IG1hc2sgZm9yIHRoZSBtYXNrIGxpYnJhcnkuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldElucHV0TWFzaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldElucHV0TWFzayhtYXNrKSB7XG4gICAgICBpZiAobWFzayBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHJldHVybiBtYXNrO1xuICAgICAgfVxuICAgICAgdmFyIG1hc2tBcnJheSA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN3aXRjaCAobWFza1tpXSkge1xuICAgICAgICAgIGNhc2UgJzknOlxuICAgICAgICAgICAgbWFza0FycmF5LnB1c2goL1xcZC8pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICBtYXNrQXJyYXkucHVzaCgvW2EtekEtWl0vKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgbWFza0FycmF5LnB1c2goL1thLXpBLVowLTldLyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbWFza0FycmF5LnB1c2gobWFza1tpXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1hc2tBcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGlucHV0IG1hc2sgcGxhY2Vob2xkZXIuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbWFzayAtIFRoZSBpbnB1dCBtYXNrLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIHBsYWNlaG9sZGVyIHRoYXQgd2lsbCBleGlzdCB3aXRoaW4gdGhlIGlucHV0IGFzIHRoZXkgdHlwZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbWFza1BsYWNlaG9sZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFza1BsYWNlaG9sZGVyKG1hc2spIHtcbiAgICAgIHJldHVybiBtYXNrLm1hcChmdW5jdGlvbiAoY2hhcikge1xuICAgICAgICByZXR1cm4gY2hhciBpbnN0YW5jZW9mIFJlZ0V4cCA/ICdfJyA6IGNoYXI7XG4gICAgICB9KS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBpbnB1dCBtYXNrIGZvciBhbiBpbnB1dC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpbnB1dCAtIFRoZSBodG1sIGlucHV0IHRvIGFwcGx5IHRoZSBtYXNrIHRvLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRJbnB1dE1hc2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRJbnB1dE1hc2soaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dCAmJiB0aGlzLmNvbXBvbmVudC5pbnB1dE1hc2spIHtcbiAgICAgICAgdmFyIG1hc2sgPSB0aGlzLmdldElucHV0TWFzayh0aGlzLmNvbXBvbmVudC5pbnB1dE1hc2spO1xuICAgICAgICB0aGlzLmlucHV0TWFzayA9ICgwLCBfdmFuaWxsYTIuZGVmYXVsdCkoe1xuICAgICAgICAgIGlucHV0RWxlbWVudDogaW5wdXQsXG4gICAgICAgICAgbWFzazogbWFzayxcbiAgICAgICAgICBwbGFjZWhvbGRlckNoYXI6ICdcXHUyMDAwJ1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBvbmVudC5wbGFjZWhvbGRlcikge1xuICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInLCB0aGlzLm1hc2tQbGFjZWhvbGRlcihtYXNrKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGlucHV0IGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIC0gVGhlIGNvbnRhaW5lciB3aGljaCBzaG91bGQgaG9sZCB0aGlzIG5ldyBpbnB1dCBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gLSBFaXRoZXIgdGhlIGlucHV0IG9yIHRoZSBncm91cCB0aGF0IGNvbnRhaW5zIHRoZSBpbnB1dC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlSW5wdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVJbnB1dChjb250YWluZXIpIHtcbiAgICAgIHZhciBpbnB1dCA9IHRoaXMuY2UoJ2lucHV0JywgdGhpcy5pbmZvLnR5cGUsIHRoaXMuaW5mby5hdHRyKTtcbiAgICAgIHRoaXMuc2V0SW5wdXRNYXNrKGlucHV0KTtcbiAgICAgIHZhciBpbnB1dEdyb3VwID0gdGhpcy5hZGRJbnB1dEdyb3VwKGlucHV0LCBjb250YWluZXIpO1xuICAgICAgdGhpcy5hZGRQcmVmaXgoaW5wdXQsIGlucHV0R3JvdXApO1xuICAgICAgdGhpcy5hZGRJbnB1dChpbnB1dCwgaW5wdXRHcm91cCB8fCBjb250YWluZXIpO1xuICAgICAgdGhpcy5hZGRTdWZmaXgoaW5wdXQsIGlucHV0R3JvdXApO1xuICAgICAgdGhpcy5lcnJvckNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgIHJldHVybiBpbnB1dEdyb3VwIHx8IGlucHV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdyYXBwZXIgbWV0aG9kIHRvIGFkZCBhbiBldmVudCBsaXN0ZW5lciB0byBhbiBIVE1MIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2JqXG4gICAgICogICBUaGUgRE9NIGVsZW1lbnQgdG8gYWRkIHRoZSBldmVudCB0by5cbiAgICAgKiBAcGFyYW0gZXZ0XG4gICAgICogICBUaGUgZXZlbnQgbmFtZSB0byBhZGQuXG4gICAgICogQHBhcmFtIGZ1bmNcbiAgICAgKiAgIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBsaXN0ZW5lciBpcyB0cmlnZ2VyZWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZEV2ZW50TGlzdGVuZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG9iaiwgZXZ0LCBmdW5jKSB7XG4gICAgICB0aGlzLmV2ZW50SGFuZGxlcnMucHVzaCh7IHR5cGU6IGV2dCwgZnVuYzogZnVuYyB9KTtcbiAgICAgIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XG4gICAgICAgIG9iai5hZGRFdmVudExpc3RlbmVyKGV2dCwgZnVuYywgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICgnYXR0YWNoRXZlbnQnIGluIG9iaikge1xuICAgICAgICBvYmouYXR0YWNoRXZlbnQoJ29uJyArIGV2dCwgZnVuYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBldmVudCBoYW5kbGVycy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koYWxsKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuaW5wdXRNYXNrKSB7XG4gICAgICAgIHRoaXMuaW5wdXRNYXNrLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgICgwLCBfZWFjaDMuZGVmYXVsdCkodGhpcy5ldmVudExpc3RlbmVycywgZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIGlmIChhbGwgfHwgbGlzdGVuZXIuaW50ZXJuYWwpIHtcbiAgICAgICAgICBfdGhpczUuZXZlbnRzLm9mZihsaXN0ZW5lci50eXBlLCBsaXN0ZW5lci5saXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgKDAsIF9lYWNoMy5kZWZhdWx0KSh0aGlzLmV2ZW50SGFuZGxlcnMsIGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKGhhbmRsZXIuZXZlbnQsIGhhbmRsZXIuZnVuYyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3IgZG9jdW1lbnQuY3JlYXRlRWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGVsZW1lbnQgdG8gY3JlYXRlLCBmb3IgdGVtcGxhdGluZyBwdXJwb3Nlcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIGVsZW1lbnQgdG8gY3JlYXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHIgLSBUaGUgZWxlbWVudCBhdHRyaWJ1dGVzIHRvIGFkZCB0byB0aGUgY3JlYXRlZCBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IC0gVGhlIGNyZWF0ZWQgZWxlbWVudC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjZShuYW1lLCB0eXBlLCBhdHRyKSB7XG4gICAgICAvLyBBbGxvdyBmb3IgdGVtcGxhdGUgb3ZlcnJpZGVzLlxuICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICAgICAgdmFyIGNvbXBUeXBlID0gdGhpcy5jb21wb25lbnQudHlwZSB8fCB0aGlzLnR5cGU7XG4gICAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy50ZW1wbGF0ZSAmJiAodGhpcy5vcHRpb25zLnRlbXBsYXRlW2NvbXBUeXBlXSAmJiB0aGlzLm9wdGlvbnMudGVtcGxhdGVbY29tcFR5cGVdW25hbWVdIHx8IHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5nbG9iYWwgJiYgdGhpcy5vcHRpb25zLnRlbXBsYXRlLmdsb2JhbFtuYW1lXSkpIHtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gKDAsIF9nZXQzLmRlZmF1bHQpKHRoaXMub3B0aW9ucywgJ3RlbXBsYXRlLicgKyBjb21wVHlwZSArICcuJyArIG5hbWUpIHx8ICgwLCBfZ2V0My5kZWZhdWx0KSh0aGlzLm9wdGlvbnMsICd0ZW1wbGF0ZS5nbG9iYWwuJyArIG5hbWUpO1xuICAgICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIHJldHVybkVsZW1lbnQgPSB0ZW1wbGF0ZSh0aGlzLCB0eXBlLCBhdHRyLCBlbGVtZW50KTtcbiAgICAgICAgICBpZiAocmV0dXJuRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybkVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFzc2lnbiB0aGUgYXR0cmlidXRlcy5cbiAgICAgICAgICAoMCwgX2Fzc2lnbjMuZGVmYXVsdCkoYXR0ciwgdGVtcGxhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYXR0cikge1xuICAgICAgICB0aGlzLmF0dHIoZWxlbWVudCwgYXR0cik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyB0byBjcmVhdGUgYSB0ZXh0IG5vZGUuXG4gICAgICogQHBhcmFtIHRleHRcbiAgICAgKiBAcmV0dXJucyB7VGV4dH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRleHQoX3RleHQpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShfdGV4dCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBvYmplY3Qgb2YgYXR0cmlidXRlcyBvbnRvIGFuIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtIdG1sRWxlbWVudH0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIGFkZCB0aGUgYXR0cmlidXRlcyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXR0ciAtIFRoZSBhdHRyaWJ1dGVzIHRvIGFkZCB0byB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYXR0cicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHIoZWxlbWVudCwgX2F0dHIpIHtcbiAgICAgICgwLCBfZWFjaDMuZGVmYXVsdCkoX2F0dHIsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBjbGFzcyB0byBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKiAgIFRoZSBlbGVtZW50IHRvIGFkZCBhIGNsYXNzIHRvLlxuICAgICAqIEBwYXJhbSBjbGFzc05hbWVcbiAgICAgKiAgIFRoZSBuYW1lIG9mIHRoZSBjbGFzcyB0byBhZGQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZENsYXNzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgICB2YXIgY2xzID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgICBjbHMgKz0gJyAnICsgY2xhc3NOYW1lO1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBjbGFzcyBmcm9tIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqICAgVGhlIERPTSBlbGVtZW50IHRvIHJlbW92ZSB0aGUgY2xhc3MgZnJvbS5cbiAgICAgKiBAcGFyYW0gY2xhc3NOYW1lXG4gICAgICogICBUaGUgbmFtZSBvZiB0aGUgY2xhc3MgdGhhdCBpcyB0byBiZSByZW1vdmVkLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmVDbGFzcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgICAgdmFyIGNscyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgY2xzID0gY2xzLnJlcGxhY2UoY2xhc3NOYW1lLCAnJyk7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGZvciBjb25kaXRpb25hbHMgYW5kIGhpZGUvc2hvdyB0aGUgZWxlbWVudCBiYXNlZCBvbiB0aG9zZSBjb25kaXRpb25zLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdjaGVja0NvbmRpdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0NvbmRpdGlvbnMoZGF0YSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2hvdyhfdXRpbHMyLmRlZmF1bHQuY2hlY2tDb25kaXRpb24odGhpcy5jb21wb25lbnQsIHRoaXMuZGF0YSwgZGF0YSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyBpbnB1dCBlcnJvciB0byB0aGlzIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYWRkSW5wdXRFcnJvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZElucHV0RXJyb3IobWVzc2FnZSkge1xuICAgICAgaWYgKHRoaXMuZXJyb3JFbGVtZW50KSB7XG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSB0aGlzLmNlKCdlcnJvck1lc3NhZ2UnLCAncCcsIHtcbiAgICAgICAgICBjbGFzczogJ2hlbHAtYmxvY2snXG4gICAgICAgIH0pO1xuICAgICAgICBlcnJvck1lc3NhZ2UuYXBwZW5kQ2hpbGQodGhpcy50ZXh0KG1lc3NhZ2UpKTtcbiAgICAgICAgdGhpcy5lcnJvckVsZW1lbnQuYXBwZW5kQ2hpbGQoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgdGhpcy5hZGRDbGFzcyh0aGlzLmVsZW1lbnQsICdoYXMtZXJyb3InKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIaWRlIG9yIFNob3cgYW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaG93XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Nob3cnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KF9zaG93KSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKF9zaG93ICYmICF0aGlzLmNvbXBvbmVudC5oaWRkZW4pIHtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnaGlkZGVuJyk7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICB9IGVsc2UgaWYgKCFfc2hvdyB8fCB0aGlzLmNvbXBvbmVudC5oaWRkZW4pIHtcbiAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaGlkZGVuJywgdHJ1ZSk7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfc2hvdztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkNoYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2hhbmdlKG5vVmFsaWRhdGUpIHtcbiAgICAgIGlmICghbm9WYWxpZGF0ZSkge1xuICAgICAgICB0aGlzLnByaXN0aW5lID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5ldmVudHMpIHtcbiAgICAgICAgLy8gRE1TXG5cbiAgICAgICAgLyp0aGlzLmVtaXQoJ2NvbXBvbmVudENoYW5nZScsIHtcbiAgICAgICAgICBjb21wb25lbnQ6IHRoaXMuY29tcG9uZW50LFxuICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgICAgIHZhbGlkYXRlOiAhbm9WYWxpZGF0ZVxuICAgICAgICB9KTsqL1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICd0ZXh0ZmllbGQnICYmIHRoaXMudHlwZSAhPT0gJ2VtYWlsJyAmJiB0aGlzLnR5cGUgIT09ICdzZWxlY3QnIHx8ICh0aGlzLnR5cGUgPT09ICd0ZXh0ZmllbGQnIHx8IHRoaXMudHlwZSA9PT0gJ2VtYWlsJyB8fCB0aGlzLnR5cGUgPT09ICdzZWxlY3QnKSAmJiB0aGlzLmVycm9yKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdjb21wb25lbnRDaGFuZ2UnLCB7XG4gICAgICAgICAgICBjb21wb25lbnQ6IHRoaXMuY29tcG9uZW50LFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICAgICAgICB2YWxpZGF0ZTogIW5vVmFsaWRhdGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FkZElucHV0U3VibWl0TGlzdGVuZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJbnB1dFN1Ym1pdExpc3RlbmVyKGlucHV0KSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGlucHV0LCAna2V5cHJlc3MnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGtleSA9IGV2ZW50LmtleUNvZGUgfHwgZXZlbnQud2hpY2g7XG4gICAgICAgIGlmIChrZXkgPT0gMTMpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIF90aGlzNi5lbWl0KCdzdWJtaXRCdXR0b24nKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIG5ldyBpbnB1dCBlbGVtZW50IGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRJbnB1dEV2ZW50TGlzdGVuZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJbnB1dEV2ZW50TGlzdGVuZXIoaW5wdXQpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoaW5wdXQsIHRoaXMuaW5mby5jaGFuZ2VFdmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM3LnVwZGF0ZVZhbHVlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBuZXcgaW5wdXQgdG8gdGhpcyBjb21vbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqIEBwYXJhbSBjb250YWluZXJcbiAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRJbnB1dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZElucHV0KGlucHV0LCBjb250YWluZXIsIG5vU2V0KSB7XG4gICAgICBpZiAoaW5wdXQgJiYgY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuaW5wdXRzLnB1c2goaW5wdXQpO1xuICAgICAgICBpbnB1dCA9IGNvbnRhaW5lci5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICB9XG4gICAgICB0aGlzLmFkZElucHV0RXZlbnRMaXN0ZW5lcihpbnB1dCk7XG4gICAgICB0aGlzLmFkZElucHV0U3VibWl0TGlzdGVuZXIoaW5wdXQpO1xuXG4gICAgICAvLyBSZXNldCB0aGUgdmFsdWVzIG9mIHRoZSBpbnB1dHMuXG4gICAgICBpZiAoIW5vU2V0ICYmIHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEuaGFzT3duUHJvcGVydHkodGhpcy5jb21wb25lbnQua2V5KSkge1xuICAgICAgICB0aGlzLnNldFZhbHVlKHRoaXMuZGF0YVt0aGlzLmNvbXBvbmVudC5rZXldLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIGF0IGEgc3BlY2lmaWMgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0VmFsdWVBdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlQXQoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlucHV0c1tpbmRleF0udmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIGlmICghdGhpcy5jb21wb25lbnQuaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmlucHV0cykge1xuICAgICAgICBpZiAoIXRoaXMuY29tcG9uZW50Lm11bHRpcGxlKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0VmFsdWVBdChpKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLmdldFZhbHVlQXQoaSkpO1xuICAgICAgfVxuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlcztcbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlVmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVWYWx1ZShub1ZhbGlkYXRlKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLmRhdGFbdGhpcy5jb21wb25lbnQua2V5XTtcbiAgICAgIHZhciBmYWxzZXkgPSAhdmFsdWUgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZGF0YVt0aGlzLmNvbXBvbmVudC5rZXldID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgdmFyIGNoYW5nZWQgPSB2YWx1ZSAhPT0gdGhpcy5kYXRhW3RoaXMuY29tcG9uZW50LmtleV07XG4gICAgICBpZiAoIWNoYW5nZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGZhbHNleSkge1xuICAgICAgICBpZiAoISF0aGlzLmRhdGFbdGhpcy5jb21wb25lbnQua2V5XSkge1xuICAgICAgICAgIHRoaXMudHJpZ2dlckNoYW5nZShub1ZhbGlkYXRlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyQ2hhbmdlKG5vVmFsaWRhdGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSBjYWxjdWxhdGVkIHZhbHVlIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGdsb2JhbCBkYXRhIG9iamVjdC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlVmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVWYWx1ZShkYXRhKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKCdjYWxjdWxhdGVWYWx1ZScpO1xuXG4gICAgICBpZiAoIXRoaXMuY29tcG9uZW50LmNhbGN1bGF0ZVZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHN0cmluZywgdGhlbiB1c2UgZXZhbCB0byBldmFsdWxhdGUgaXQuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuY29tcG9uZW50LmNhbGN1bGF0ZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciByb3cgPSB0aGlzLmRhdGE7XG5cbiAgICAgICAgICAvLyBETVNcblxuICAgICAgICAgIC8vbGV0IHZhbCA9IGV2YWwoJ3ZhciB2YWx1ZSA9IFtdOycgKyB0aGlzLmNvbXBvbmVudC5jYWxjdWxhdGVWYWx1ZS50b1N0cmluZygpICsgJzsgcmV0dXJuIHZhbHVlOycpO1xuICAgICAgICAgIHZhciB2YWwgPSBldmFsKCd2YXIgdmFsdWUgPSBbXTsnICsgdGhpcy5jb21wb25lbnQuY2FsY3VsYXRlVmFsdWUudG9TdHJpbmcoKSArICc7Jyk7XG5cbiAgICAgICAgICAvL2NvbnNvbGUubG9nKCd2YWwnICsgJyA9ICcgKyB2YWwpO1xuXG4gICAgICAgICAgdGhpcy5zZXRWYWx1ZSh2YWwpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgICAgICAgIGNvbnNvbGUud2FybignQW4gZXJyb3Igb2NjdXJyZWQgY2FsY3VsYXRpbmcgYSB2YWx1ZSBmb3IgJyArIHRoaXMuY29tcG9uZW50LmtleSwgZSk7XG4gICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIF92YWwgPSBfanNvbkxvZ2ljSnMyLmRlZmF1bHQuYXBwbHkodGhpcy5jb21wb25lbnQuY2FsY3VsYXRlVmFsdWUsIHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICByb3c6IHRoaXMuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuc2V0VmFsdWUoX3ZhbCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0FuIGVycm9yIG9jY3VycmVkIGNhbGN1bGF0aW5nIGEgdmFsdWUgZm9yICcgKyB0aGlzLmNvbXBvbmVudC5rZXksIGUpO1xuICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2hlY2tWYWxpZGl0eScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrVmFsaWRpdHkoZGF0YSwgZGlydHkpIHtcbiAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIGVycm9ycyBpZiB0aGVyZSBpcyBubyBpbnB1dCBvciBpZiBpdCBpcyBwcmlzdGluZS5cbiAgICAgIGlmICghdGhpcy5jb21wb25lbnQuaW5wdXQgfHwgIWRpcnR5ICYmIHRoaXMucHJpc3RpbmUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBtZXNzYWdlID0gX1ZhbGlkYXRvci5WYWxpZGF0b3IuY2hlY2sodGhpcy52YWxpZGF0b3JzLCB0aGlzLmNvbXBvbmVudCwgdGhpcy5nZXRSYXdWYWx1ZSgpLCBkYXRhIHx8IHRoaXMuZGF0YSwgdGhpcy5kYXRhLCB0aGlzLnQuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLnNldEN1c3RvbVZhbGlkaXR5KG1lc3NhZ2UpO1xuXG4gICAgICAvLyBObyBtZXNzYWdlLCByZXR1cm5zIHRydWVcbiAgICAgIHJldHVybiBtZXNzYWdlID8gZmFsc2UgOiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFJhd1ZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmF3VmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhW3RoaXMuY29tcG9uZW50LmtleV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW50ZXJwb2xhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnBvbGF0ZShzdHJpbmcsIGRhdGEpIHtcbiAgICAgIHJldHVybiBfdXRpbHMyLmRlZmF1bHQuaW50ZXJwb2xhdGUoc3RyaW5nLCBkYXRhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRDdXN0b21WYWxpZGl0eScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEN1c3RvbVZhbGlkaXR5KG1lc3NhZ2UpIHtcbiAgICAgIGlmICh0aGlzLmVycm9yRWxlbWVudCAmJiB0aGlzLmVycm9yQ29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuZXJyb3JFbGVtZW50LmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuZXJyb3JDb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5lcnJvckVsZW1lbnQpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICB9XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKHRoaXMuZWxlbWVudCwgJ2hhcy1lcnJvcicpO1xuICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5lcnJvciA9IHtcbiAgICAgICAgICBjb21wb25lbnQ6IHRoaXMuY29tcG9uZW50LFxuICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbWl0KCdjb21wb25lbnRFcnJvcicsIHRoaXMuZXJyb3IpO1xuICAgICAgICB0aGlzLmNyZWF0ZUVycm9yRWxlbWVudCgpO1xuICAgICAgICB0aGlzLmFkZElucHV0RXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICAgIH1cbiAgICAgICgwLCBfZWFjaDMuZGVmYXVsdCkodGhpcy5pbnB1dHMsIGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0LnNldEN1c3RvbVZhbGlkaXR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaW5wdXQuc2V0Q3VzdG9tVmFsaWRpdHkobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgYXQgYSBzcGVjaWZpYyBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleFxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRWYWx1ZUF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWVBdChpbmRleCwgdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5kZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgICB0aGlzLmlucHV0c1tpbmRleF0udmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIG9mIHRoaXMgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKHZhbHVlLCBub1VwZGF0ZSwgbm9WYWxpZGF0ZSkge1xuICAgICAgaWYgKCF0aGlzLmNvbXBvbmVudC5pbnB1dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB2YXIgaXNBcnJheSA9ICgwLCBfaXNBcnJheTMuZGVmYXVsdCkodmFsdWUpO1xuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmlucHV0cykge1xuICAgICAgICB0aGlzLnNldFZhbHVlQXQoaSwgaXNBcnJheSA/IHZhbHVlW2ldIDogdmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKCFub1VwZGF0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKG5vVmFsaWRhdGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBpZiB0aGUgY29tcG9uZW50IGlzIGRpc2FibGVkLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NlbGVjdE9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RPcHRpb25zKHNlbGVjdCwgdGFnLCBvcHRpb25zLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICAoMCwgX2VhY2gzLmRlZmF1bHQpKG9wdGlvbnMsIGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgdmFyIGF0dHJzID0ge1xuICAgICAgICAgIHZhbHVlOiBvcHRpb24udmFsdWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbi52YWx1ZSA9PT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgYXR0cnMuc2VsZWN0ZWQgPSAnc2VsZWN0ZWQnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcHRpb25FbGVtZW50ID0gX3RoaXM4LmNlKHRhZywgJ29wdGlvbicsIGF0dHJzKTtcbiAgICAgICAgb3B0aW9uRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczgudGV4dChvcHRpb24ubGFiZWwpKTtcbiAgICAgICAgc2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbkVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0U2VsZWN0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTZWxlY3RWYWx1ZShzZWxlY3QsIHZhbHVlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHNlbGVjdC5xdWVyeVNlbGVjdG9yQWxsKCdvcHRpb24nKTtcbiAgICAgICgwLCBfZWFjaDMuZGVmYXVsdCkob3B0aW9ucywgZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICBpZiAob3B0aW9uLnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgIG9wdGlvbi5zZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJywgJ3NlbGVjdGVkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9uLnJlbW92ZUF0dHJpYnV0ZSgnc2VsZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoc2VsZWN0Lm9uY2hhbmdlKSB7XG4gICAgICAgIHNlbGVjdC5vbmNoYW5nZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdC5vbnNlbGVjdCkge1xuICAgICAgICBzZWxlY3Qub25jaGFuZ2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjbGVhcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSAnJztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhcHBlbmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmQoZWxlbWVudCkge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncHJlcGVuZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZXBlbmQoZWxlbWVudCkge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudCAmJiB0aGlzLmVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIHRoaXMuZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmVDaGlsZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGVsZW1lbnQpIHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZWxlbWVudCBpbmZvcm1hdGlvbi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZWxlbWVudEluZm8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbGVtZW50SW5mbygpIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAgICAgbmFtZTogdGhpcy5vcHRpb25zLm5hbWUsXG4gICAgICAgIHR5cGU6IHRoaXMuY29tcG9uZW50LmlucHV0VHlwZSB8fCAndGV4dCcsXG4gICAgICAgIGNsYXNzOiAnZm9ybS1jb250cm9sJ1xuICAgICAgfTtcbiAgICAgICgwLCBfZWFjaDMuZGVmYXVsdCkoe1xuICAgICAgICB0YWJpbmRleDogJ3RhYmluZGV4JyxcbiAgICAgICAgcGxhY2Vob2xkZXI6ICdwbGFjZWhvbGRlcidcbiAgICAgIH0sIGZ1bmN0aW9uIChwYXRoLCBwcm9wKSB7XG4gICAgICAgIHZhciBhdHRyVmFsdWUgPSAoMCwgX2dldDMuZGVmYXVsdCkoX3RoaXM5LmNvbXBvbmVudCwgcGF0aCk7XG4gICAgICAgIGlmIChhdHRyVmFsdWUpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzW3Byb3BdID0gYXR0clZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICAgIGNvbXBvbmVudDogdGhpcy5jb21wb25lbnQsXG4gICAgICAgIGNoYW5nZUV2ZW50OiAnY2hhbmdlJyxcbiAgICAgICAgYXR0cjogYXR0cmlidXRlc1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjbGFzc05hbWUnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuY29tcG9uZW50LmlucHV0ID8gJ2Zvcm0tZ3JvdXAgaGFzLWZlZWRiYWNrICcgOiAnJztcbiAgICAgIGNsYXNzTmFtZSArPSAnZm9ybWlvLWNvbXBvbmVudCBmb3JtaW8tY29tcG9uZW50LScgKyB0aGlzLmNvbXBvbmVudC50eXBlICsgJyAnO1xuICAgICAgaWYgKHRoaXMuY29tcG9uZW50LmtleSkge1xuICAgICAgICBjbGFzc05hbWUgKz0gJ2Zvcm1pby1jb21wb25lbnQtJyArIHRoaXMuY29tcG9uZW50LmtleSArICcgJztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5jdXN0b21DbGFzcykge1xuICAgICAgICBjbGFzc05hbWUgKz0gdGhpcy5jb21wb25lbnQuY3VzdG9tQ2xhc3M7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb21wb25lbnQuaW5wdXQgJiYgdGhpcy5jb21wb25lbnQudmFsaWRhdGUgJiYgdGhpcy5jb21wb25lbnQudmFsaWRhdGUucmVxdWlyZWQpIHtcbiAgICAgICAgY2xhc3NOYW1lICs9ICcgcmVxdWlyZWQnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWZhdWx0VmFsdWUnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgICAgaWYgKHRoaXMuY29tcG9uZW50LmRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBkZWZhdWx0VmFsdWUgPSB0aGlzLmNvbXBvbmVudC5kZWZhdWx0VmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY29tcG9uZW50LmN1c3RvbURlZmF1bHRWYWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29tcG9uZW50LmN1c3RvbURlZmF1bHRWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJvdyA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gZXZhbCgnKGZ1bmN0aW9uKGRhdGEsIHJvdykgeyB2YXIgdmFsdWUgPSBcIlwiOycgKyB0aGlzLmNvbXBvbmVudC5jdXN0b21EZWZhdWx0VmFsdWUudG9TdHJpbmcoKSArICc7IHJldHVybiB2YWx1ZTsgfSkoZGF0YSwgcm93KScpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0FuIGVycm9yIG9jY3VycmVkIGdldHRpbmcgZGVmYXVsdCB2YWx1ZSBmb3IgJyArIHRoaXMuY29tcG9uZW50LmtleSwgZSk7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IF9qc29uTG9naWNKczIuZGVmYXVsdC5hcHBseSh0aGlzLmNvbXBvbmVudC5jdXN0b21EZWZhdWx0VmFsdWUsIHtcbiAgICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgICByb3c6IHRoaXMuZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdBbiBlcnJvciBvY2N1cnJlZCBjYWxjdWxhdGluZyBhIHZhbHVlIGZvciAnICsgdGhpcy5jb21wb25lbnQua2V5LCBlKTtcbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICduYW1lJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5sYWJlbCB8fCB0aGlzLmNvbXBvbmVudC5wbGFjZWhvbGRlciB8fCB0aGlzLmNvbXBvbmVudC5rZXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndmlzaWJsZScsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmlzaWJsZSkge1xuICAgICAgdGhpcy5zaG93KHZpc2libGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Vycm9ycycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lcnJvciA/IFt0aGlzLmVycm9yXSA6IFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGVkJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlIHRoaXMgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZFxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChkaXNhYmxlZCkge1xuICAgICAgdGhpcy5fZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICAgIC8vIERpc2FibGUgYWxsIGlucHV0LlxuICAgICAgKDAsIF9lYWNoMy5kZWZhdWx0KSh0aGlzLmlucHV0cywgZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIGlucHV0LmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXNlQ29tcG9uZW50O1xufSgpO1xuXG5leHBvcnRzLkJhc2VDb21wb25lbnQgPSBCYXNlQ29tcG9uZW50O1xuXG5cbkJhc2VDb21wb25lbnQuZXh0ZXJuYWxMaWJyYXJpZXMgPSB7fTtcbkJhc2VDb21wb25lbnQucmVxdWlyZUxpYnJhcnkgPSBmdW5jdGlvbiAobmFtZSwgcHJvcGVydHksIHNyYywgcG9sbGluZykge1xuICBpZiAoIUJhc2VDb21wb25lbnQuZXh0ZXJuYWxMaWJyYXJpZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICBCYXNlQ29tcG9uZW50LmV4dGVybmFsTGlicmFyaWVzW25hbWVdID0ge307XG4gICAgQmFzZUNvbXBvbmVudC5leHRlcm5hbExpYnJhcmllc1tuYW1lXS5yZWFkeSA9IG5ldyBfbmF0aXZlUHJvbWlzZU9ubHkyLmRlZmF1bHQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgQmFzZUNvbXBvbmVudC5leHRlcm5hbExpYnJhcmllc1tuYW1lXS5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIEJhc2VDb21wb25lbnQuZXh0ZXJuYWxMaWJyYXJpZXNbbmFtZV0ucmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuXG4gICAgaWYgKCFwb2xsaW5nICYmICF3aW5kb3dbbmFtZSArICdDYWxsYmFjayddKSB7XG4gICAgICB3aW5kb3dbbmFtZSArICdDYWxsYmFjayddID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlc29sdmUoKTtcbiAgICAgIH0uYmluZChCYXNlQ29tcG9uZW50LmV4dGVybmFsTGlicmFyaWVzW25hbWVdKTtcbiAgICB9XG5cbiAgICAvLyBTZWUgaWYgdGhlIHBsdWdpbiBhbHJlYWR5IGV4aXN0cy5cbiAgICB2YXIgcGx1Z2luID0gKDAsIF9nZXQzLmRlZmF1bHQpKHdpbmRvdywgcHJvcGVydHkpO1xuICAgIGlmIChwbHVnaW4pIHtcbiAgICAgIEJhc2VDb21wb25lbnQuZXh0ZXJuYWxMaWJyYXJpZXNbbmFtZV0ucmVzb2x2ZShwbHVnaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBZGQgdGhlIHNjcmlwdCB0byB0aGUgdG9wIHBhZ2UuXG4gICAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBzY3JpcHQuc2V0QXR0cmlidXRlKCdzcmMnLCBzcmMpO1xuICAgICAgc2NyaXB0LnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2phdmFzY3JpcHQnKTtcbiAgICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUoJ2RlZmVyJywgdHJ1ZSk7XG4gICAgICBzY3JpcHQuc2V0QXR0cmlidXRlKCdhc3luYycsIHRydWUpO1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuXG4gICAgICAvLyBpZiBubyBjYWxsYmFjayBpcyBwcm92aWRlZCwgdGhlbiBjaGVjayBwZXJpb2RpY2FsbHkgZm9yIHRoZSBzY3JpcHQuXG4gICAgICBpZiAocG9sbGluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uIGNoZWNrTGlicmFyeSgpIHtcbiAgICAgICAgICB2YXIgcGx1Z2luID0gKDAsIF9nZXQzLmRlZmF1bHQpKHdpbmRvdywgcHJvcGVydHkpO1xuICAgICAgICAgIGlmIChwbHVnaW4pIHtcbiAgICAgICAgICAgIEJhc2VDb21wb25lbnQuZXh0ZXJuYWxMaWJyYXJpZXNbbmFtZV0ucmVzb2x2ZShwbHVnaW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjaGVjayBhZ2FpbiBhZnRlciAyMDAgbXMuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNoZWNrTGlicmFyeSwgMjAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDIwMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBCYXNlQ29tcG9uZW50LmV4dGVybmFsTGlicmFyaWVzW25hbWVdLnJlYWR5O1xufTtcblxuQmFzZUNvbXBvbmVudC5saWJyYXJ5UmVhZHkgPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoQmFzZUNvbXBvbmVudC5leHRlcm5hbExpYnJhcmllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBCYXNlQ29tcG9uZW50LmV4dGVybmFsTGlicmFyaWVzW25hbWVdLnJlYWR5KSB7XG4gICAgcmV0dXJuIEJhc2VDb21wb25lbnQuZXh0ZXJuYWxMaWJyYXJpZXNbbmFtZV0ucmVhZHk7XG4gIH1cblxuICByZXR1cm4gX25hdGl2ZVByb21pc2VPbmx5Mi5kZWZhdWx0LnJlamVjdChuYW1lICsgJyBsaWJyYXJ5IHdhcyBub3QgcmVxdWlyZWQuJyk7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQnV0dG9uQ29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3NldCA9IGZ1bmN0aW9uIHNldChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpIHsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCAhPT0gbnVsbCkgeyBzZXQocGFyZW50LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjICYmIGRlc2Mud3JpdGFibGUpIHsgZGVzYy52YWx1ZSA9IHZhbHVlOyB9IGVsc2UgeyB2YXIgc2V0dGVyID0gZGVzYy5zZXQ7IGlmIChzZXR0ZXIgIT09IHVuZGVmaW5lZCkgeyBzZXR0ZXIuY2FsbChyZWNlaXZlciwgdmFsdWUpOyB9IH0gcmV0dXJuIHZhbHVlOyB9O1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfQmFzZSA9IHJlcXVpcmUoJy4uL2Jhc2UvQmFzZScpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBCdXR0b25Db21wb25lbnQgPSBleHBvcnRzLkJ1dHRvbkNvbXBvbmVudCA9IGZ1bmN0aW9uIChfQmFzZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoQnV0dG9uQ29tcG9uZW50LCBfQmFzZUNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gQnV0dG9uQ29tcG9uZW50KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdXR0b25Db21wb25lbnQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChCdXR0b25Db21wb25lbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCdXR0b25Db21wb25lbnQpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCdXR0b25Db21wb25lbnQsIFt7XG4gICAga2V5OiAnZWxlbWVudEluZm8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbGVtZW50SW5mbygpIHtcbiAgICAgIHZhciBpbmZvID0gX2dldChCdXR0b25Db21wb25lbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQnV0dG9uQ29tcG9uZW50LnByb3RvdHlwZSksICdlbGVtZW50SW5mbycsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICBpbmZvLnR5cGUgPSAnYnV0dG9uJztcbiAgICAgIGluZm8uYXR0ci50eXBlID0gdGhpcy5jb21wb25lbnQuYWN0aW9uID09PSAnc3VibWl0JyA/ICdzdWJtaXQnIDogJ2J1dHRvbic7XG4gICAgICBpbmZvLmF0dHIuY2xhc3MgPSAnYnRuIGJ0bi0nICsgdGhpcy5jb21wb25lbnQudGhlbWU7XG4gICAgICBpZiAodGhpcy5jb21wb25lbnQuYmxvY2spIHtcbiAgICAgICAgaW5mby5hdHRyLmNsYXNzICs9ICcgYnRuLWJsb2NrJztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5jdXN0b21DbGFzcykge1xuICAgICAgICBpbmZvLmF0dHIuY2xhc3MgKz0gJyAnICsgdGhpcy5jb21wb25lbnQuY3VzdG9tQ2xhc3M7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdidWlsZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZWxlbWVudCA9IHRoaXMuY2UoJ2VsZW1lbnQnLCB0aGlzLmluZm8udHlwZSwgdGhpcy5pbmZvLmF0dHIpO1xuICAgICAgaWYgKHRoaXMuY29tcG9uZW50LmxhYmVsKSB7XG4gICAgICAgIHRoaXMubGFiZWwgPSB0aGlzLnRleHQodGhpcy5jb21wb25lbnQubGFiZWwpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5sYWJlbCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb21wb25lbnQuYWN0aW9uID09PSAnc3VibWl0Jykge1xuICAgICAgICB0aGlzLm9uKCdzdWJtaXRCdXR0b24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIF90aGlzMi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICB0aGlzLm9uKCdzdWJtaXREb25lJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgX3RoaXMyLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICB0aGlzLm9uKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB9LCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmVsZW1lbnQsICdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKF90aGlzMi5jb21wb25lbnQuYWN0aW9uKSB7XG4gICAgICAgICAgY2FzZSAnc3VibWl0JzpcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIF90aGlzMi5lbWl0KCdzdWJtaXRCdXR0b24nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2V2ZW50JzpcbiAgICAgICAgICAgIF90aGlzMi5ldmVudHMuZW1pdChfdGhpczIuY29tcG9uZW50LmV2ZW50LCBfdGhpczIuZGF0YSk7XG4gICAgICAgICAgICBfdGhpczIuZW1pdCgnY3VzdG9tRXZlbnQnLCB7XG4gICAgICAgICAgICAgIHR5cGU6IF90aGlzMi5jb21wb25lbnQuZXZlbnQsXG4gICAgICAgICAgICAgIGNvbXBvbmVudDogX3RoaXMyLmNvbXBvbmVudCxcbiAgICAgICAgICAgICAgZGF0YTogX3RoaXMyLmRhdGEsXG4gICAgICAgICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyZXNldCc6XG4gICAgICAgICAgICBfdGhpczIuZW1pdCgncmVzZXRGb3JtJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdvYXV0aCc6XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnT0F1dGggY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJlYWRPbmx5KSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xvYWRpbmcnLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGxvYWRpbmcpIHtcbiAgICAgIHRoaXMuX2xvYWRpbmcgPSBsb2FkaW5nO1xuICAgICAgaWYgKCF0aGlzLmxvYWRlciAmJiBsb2FkaW5nKSB7XG4gICAgICAgIHRoaXMubG9hZGVyID0gdGhpcy5jZSgnYnV0dG9uTG9hZGVyJywgJ2knLCB7XG4gICAgICAgICAgY2xhc3M6ICdnbHlwaGljb24gZ2x5cGhpY29uLXJlZnJlc2ggZ2x5cGhpY29uLXNwaW4gYnV0dG9uLWljb24tcmlnaHQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICAgIGlmIChsb2FkaW5nKSB7XG4gICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMubG9hZGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5sb2FkZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGlzYWJsZWQnLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGRpc2FibGVkKSB7XG4gICAgICBfc2V0KEJ1dHRvbkNvbXBvbmVudC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCdXR0b25Db21wb25lbnQucHJvdG90eXBlKSwgJ2Rpc2FibGVkJywgZGlzYWJsZWQsIHRoaXMpO1xuICAgICAgdGhpcy5lbGVtZW50LmRpc2FibGUgPSBkaXNhYmxlZDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQnV0dG9uQ29tcG9uZW50O1xufShfQmFzZS5CYXNlQ29tcG9uZW50KTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkJ1dHRvblZhbHVlQ29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3NldCA9IGZ1bmN0aW9uIHNldChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpIHsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCAhPT0gbnVsbCkgeyBzZXQocGFyZW50LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjICYmIGRlc2Mud3JpdGFibGUpIHsgZGVzYy52YWx1ZSA9IHZhbHVlOyB9IGVsc2UgeyB2YXIgc2V0dGVyID0gZGVzYy5zZXQ7IGlmIChzZXR0ZXIgIT09IHVuZGVmaW5lZCkgeyBzZXR0ZXIuY2FsbChyZWNlaXZlciwgdmFsdWUpOyB9IH0gcmV0dXJuIHZhbHVlOyB9O1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfQmFzZSA9IHJlcXVpcmUoJy4uL2Jhc2UvQmFzZScpO1xuXG52YXIgX2VhY2gyID0gcmVxdWlyZSgnbG9kYXNoL2VhY2gnKTtcblxudmFyIF9lYWNoMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2gyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQnV0dG9uVmFsdWVDb21wb25lbnQgPSBleHBvcnRzLkJ1dHRvblZhbHVlQ29tcG9uZW50ID0gZnVuY3Rpb24gKF9CYXNlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhCdXR0b25WYWx1ZUNvbXBvbmVudCwgX0Jhc2VDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEJ1dHRvblZhbHVlQ29tcG9uZW50KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdXR0b25WYWx1ZUNvbXBvbmVudCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJ1dHRvblZhbHVlQ29tcG9uZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQnV0dG9uVmFsdWVDb21wb25lbnQpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCdXR0b25WYWx1ZUNvbXBvbmVudCwgW3tcbiAgICBrZXk6ICdlbGVtZW50SW5mbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVsZW1lbnRJbmZvKCkge1xuICAgICAgdmFyIGluZm8gPSBfZ2V0KEJ1dHRvblZhbHVlQ29tcG9uZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJ1dHRvblZhbHVlQ29tcG9uZW50LnByb3RvdHlwZSksICdlbGVtZW50SW5mbycsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICBpbmZvLnR5cGUgPSAnYnV0dG9uJztcbiAgICAgIGluZm8uYXR0ci50eXBlID0gdGhpcy5jb21wb25lbnQuYWN0aW9uID09PSAnc3VibWl0JyA/ICdzdWJtaXQnIDogJ2J1dHRvbic7XG4gICAgICBpbmZvLmF0dHIuY2xhc3MgPSAnYnRuIGJ0bi0nICsgdGhpcy5jb21wb25lbnQudGhlbWU7XG4gICAgICBpbmZvLmF0dHIudmFsdWUgPSB0aGlzLmNvbXBvbmVudC52YWx1ZSA/IHRoaXMuY29tcG9uZW50LnZhbHVlIDogJyc7XG5cbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5ibG9jaykge1xuICAgICAgICBpbmZvLmF0dHIuY2xhc3MgKz0gJyBidG4tYmxvY2snO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29tcG9uZW50LmN1c3RvbUNsYXNzKSB7XG4gICAgICAgIGluZm8uYXR0ci5jbGFzcyArPSAnICcgKyB0aGlzLmNvbXBvbmVudC5jdXN0b21DbGFzcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2J1aWxkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5lbGVtZW50ID0gdGhpcy5jZSgnZWxlbWVudCcsIHRoaXMuaW5mby50eXBlLCB0aGlzLmluZm8uYXR0cik7XG4gICAgICBpZiAodGhpcy5jb21wb25lbnQubGFiZWwpIHtcbiAgICAgICAgdGhpcy5sYWJlbCA9IHRoaXMudGV4dCh0aGlzLmNvbXBvbmVudC5sYWJlbCk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmxhYmVsKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5hY3Rpb24gPT09ICdzdWJtaXQnKSB7XG4gICAgICAgIHRoaXMub24oJ3N1Ym1pdEJ1dHRvbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgX3RoaXMyLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMub24oJ3N1Ym1pdERvbmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBfdGhpczIuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMub24oJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuZWxlbWVudCwgJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoX3RoaXMyLmNvbXBvbmVudC5hY3Rpb24pIHtcbiAgICAgICAgICBjYXNlICdzdWJtaXQnOlxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgX3RoaXMyLmVtaXQoJ3N1Ym1pdEJ1dHRvbicpO1xuICAgICAgICAgICAgX3RoaXMyLnNldFZhbHVlKF90aGlzMi5jb21wb25lbnQudmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZXZlbnQnOlxuICAgICAgICAgICAgX3RoaXMyLmV2ZW50cy5lbWl0KF90aGlzMi5jb21wb25lbnQuZXZlbnQsIF90aGlzMi5kYXRhKTtcbiAgICAgICAgICAgIF90aGlzMi5lbWl0KCdjdXN0b21FdmVudCcsIHtcbiAgICAgICAgICAgICAgdHlwZTogX3RoaXMyLmNvbXBvbmVudC5ldmVudCxcbiAgICAgICAgICAgICAgY29tcG9uZW50OiBfdGhpczIuY29tcG9uZW50LFxuICAgICAgICAgICAgICBkYXRhOiBfdGhpczIuZGF0YSxcbiAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzMi5zZXRWYWx1ZShfdGhpczIuY29tcG9uZW50LnZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3Jlc2V0JzpcbiAgICAgICAgICAgIF90aGlzMi5lbWl0KCdyZXNldEZvcm0nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ29hdXRoJzpcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdPQXV0aCBjdXJyZW50bHkgbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVhZE9ubHkpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9hZGluZycsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobG9hZGluZykge1xuICAgICAgdGhpcy5fbG9hZGluZyA9IGxvYWRpbmc7XG4gICAgICBpZiAoIXRoaXMubG9hZGVyICYmIGxvYWRpbmcpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSB0aGlzLmNlKCdidXR0b25Mb2FkZXInLCAnaScsIHtcbiAgICAgICAgICBjbGFzczogJ2dseXBoaWNvbiBnbHlwaGljb24tcmVmcmVzaCBnbHlwaGljb24tc3BpbiBidXR0b24taWNvbi1yaWdodCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5sb2FkZXIpIHtcbiAgICAgICAgaWYgKGxvYWRpbmcpIHtcbiAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5sb2FkZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLmxvYWRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkaXNhYmxlZCcsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoZGlzYWJsZWQpIHtcbiAgICAgIF9zZXQoQnV0dG9uVmFsdWVDb21wb25lbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQnV0dG9uVmFsdWVDb21wb25lbnQucHJvdG90eXBlKSwgJ2Rpc2FibGVkJywgZGlzYWJsZWQsIHRoaXMpO1xuICAgICAgdGhpcy5lbGVtZW50LmRpc2FibGUgPSBkaXNhYmxlZDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQnV0dG9uVmFsdWVDb21wb25lbnQ7XG59KF9CYXNlLkJhc2VDb21wb25lbnQpOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQ2hlY2tCb3hDb21wb25lbnQgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9CYXNlID0gcmVxdWlyZSgnLi4vYmFzZS9CYXNlJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIENoZWNrQm94Q29tcG9uZW50ID0gZXhwb3J0cy5DaGVja0JveENvbXBvbmVudCA9IGZ1bmN0aW9uIChfQmFzZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoQ2hlY2tCb3hDb21wb25lbnQsIF9CYXNlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBDaGVja0JveENvbXBvbmVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hlY2tCb3hDb21wb25lbnQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDaGVja0JveENvbXBvbmVudC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENoZWNrQm94Q29tcG9uZW50KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2hlY2tCb3hDb21wb25lbnQsIFt7XG4gICAga2V5OiAnZWxlbWVudEluZm8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbGVtZW50SW5mbygpIHtcbiAgICAgIHZhciBpbmZvID0gX2dldChDaGVja0JveENvbXBvbmVudC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDaGVja0JveENvbXBvbmVudC5wcm90b3R5cGUpLCAnZWxlbWVudEluZm8nLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgaW5mby50eXBlID0gJ2lucHV0JztcbiAgICAgIGluZm8uY2hhbmdlRXZlbnQgPSAnY2xpY2snO1xuICAgICAgaW5mby5hdHRyLnR5cGUgPSB0aGlzLmNvbXBvbmVudC5pbnB1dFR5cGU7XG4gICAgICBpbmZvLmF0dHIuY2xhc3MgPSAnJztcbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5uYW1lKSB7XG4gICAgICAgIGluZm8uYXR0ci5uYW1lID0gJ2RhdGFbJyArIHRoaXMuY29tcG9uZW50Lm5hbWUgKyAnXSc7XG4gICAgICB9XG4gICAgICBpbmZvLmF0dHIudmFsdWUgPSB0aGlzLmNvbXBvbmVudC52YWx1ZSA/IHRoaXMuY29tcG9uZW50LnZhbHVlIDogMDtcbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2J1aWxkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGQoKSB7XG4gICAgICBpZiAoIXRoaXMuY29tcG9uZW50LmlucHV0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3JlYXRlRWxlbWVudCgpO1xuICAgICAgdGhpcy5pbnB1dCA9IHRoaXMuY3JlYXRlSW5wdXQodGhpcy5lbGVtZW50KTtcbiAgICAgIHRoaXMuY3JlYXRlTGFiZWwodGhpcy5lbGVtZW50LCB0aGlzLmlucHV0KTtcbiAgICAgIGlmICghdGhpcy5sYWJlbCkge1xuICAgICAgICB0aGlzLmFkZElucHV0KHRoaXMuaW5wdXQsIHRoaXMuZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJlYWRPbmx5KSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZUVsZW1lbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KCkge1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lO1xuICAgICAgaWYgKHRoaXMuY29tcG9uZW50LmxhYmVsKSB7XG4gICAgICAgIGNsYXNzTmFtZSArPSAnIGNoZWNrYm94JztcbiAgICAgIH1cbiAgICAgIHRoaXMuZWxlbWVudCA9IHRoaXMuY2UoJ2VsZW1lbnQnLCAnZGl2Jywge1xuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgY2xhc3M6IGNsYXNzTmFtZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlTGFiZWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVMYWJlbChjb250YWluZXIsIGlucHV0KSB7XG4gICAgICBpZiAoIXRoaXMuY29tcG9uZW50LmxhYmVsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5sYWJlbCA9IHRoaXMuY2UoJ2xhYmVsJywgJ2xhYmVsJywge1xuICAgICAgICBjbGFzczogJ2NvbnRyb2wtbGFiZWwnXG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIHRoZSBTUEFOIGFyb3VuZCB0aGUgdGV4dE5vZGUgZm9yIGJldHRlciBzdHlsZSBob29rc1xuICAgICAgdGhpcy5sYWJlbFNwYW4gPSB0aGlzLmNlKCdsYWJlbFNwYW4nLCAnc3BhbicpO1xuXG4gICAgICBpZiAodGhpcy5pbmZvLmF0dHIuaWQpIHtcbiAgICAgICAgdGhpcy5sYWJlbC5zZXRBdHRyaWJ1dGUoJ2ZvcicsIHRoaXMuaW5mby5hdHRyLmlkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkSW5wdXQoaW5wdXQsIHRoaXMubGFiZWwpO1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaW5wdXRzT25seSkge1xuICAgICAgICAvLyBETVNcblxuICAgICAgICAvL3RoaXMubGFiZWxTcGFuLmFwcGVuZENoaWxkKHRoaXMudGV4dCh0aGlzLmNvbXBvbmVudC5sYWJlbCkpO1xuICAgICAgICAvL3RoaXMubGFiZWwuYXBwZW5kQ2hpbGQodGhpcy5sYWJlbFNwYW4pO1xuXG4gICAgICAgIHZhciBsYWJlbEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbGFiZWxFbGVtZW50LmlubmVySFRNTCA9IHRoaXMuY29tcG9uZW50LmxhYmVsO1xuICAgICAgICB0aGlzLmxhYmVsLmFwcGVuZENoaWxkKGxhYmVsRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5sYWJlbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlSW5wdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVJbnB1dChjb250YWluZXIpIHtcbiAgICAgIGlmICghdGhpcy5jb21wb25lbnQuaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGlucHV0ID0gdGhpcy5jZSgnaW5wdXQnLCB0aGlzLmluZm8udHlwZSwgdGhpcy5pbmZvLmF0dHIpO1xuICAgICAgdGhpcy5lcnJvckNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhZGRJbnB1dEV2ZW50TGlzdGVuZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJbnB1dEV2ZW50TGlzdGVuZXIoaW5wdXQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoaW5wdXQsIHRoaXMuaW5mby5jaGFuZ2VFdmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBJZiB0aGlzIGlucHV0IGhhcyBhIFwibmFtZVwiLCB0aGVuIGl0cyBvdGhlciBpbnB1dCBlbGVtZW50cyBhcmUgZWxzZXdoZXJlIG9uXG4gICAgICAgIC8vIHRoZSBmb3JtLiBUbyBnZXQgdGhlIGNvcnJlY3Qgc3VibWlzc2lvbiBvYmplY3QsIHdlIG5lZWQgdG8gcmVmcmVzaCB0aGUgd2hvbGVcbiAgICAgICAgLy8gZGF0YSBvYmplY3QuXG4gICAgICAgIGlmIChfdGhpczIuY29tcG9uZW50Lm5hbWUpIHtcbiAgICAgICAgICBfdGhpczIuZW1pdCgncmVmcmVzaERhdGEnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczIudXBkYXRlVmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VmFsdWVBdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlQXQoaW5kZXgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuaW5wdXRzW2luZGV4XS5jaGVja2VkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUodmFsdWUsIG5vVXBkYXRlLCBub1ZhbGlkYXRlKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAoIXRoaXMuaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSAnb24nKSB7XG4gICAgICAgIHRoaXMuaW5wdXQudmFsdWUgPSAxO1xuICAgICAgICB0aGlzLmlucHV0LmNoZWNrZWQgPSAxO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ29mZicpIHtcbiAgICAgICAgdGhpcy5pbnB1dC52YWx1ZSA9IDA7XG4gICAgICAgIHRoaXMuaW5wdXQuY2hlY2tlZCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaW5wdXQudmFsdWUgPSAxO1xuICAgICAgICB0aGlzLmlucHV0LmNoZWNrZWQgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbnB1dC52YWx1ZSA9IDA7XG4gICAgICAgIHRoaXMuaW5wdXQuY2hlY2tlZCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoIW5vVXBkYXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWUobm9WYWxpZGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENoZWNrQm94Q29tcG9uZW50O1xufShfQmFzZS5CYXNlQ29tcG9uZW50KTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkNvbHVtbkNvbXBvbmVudCA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9Db21wb25lbnRzID0gcmVxdWlyZSgnLi4vQ29tcG9uZW50cycpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBDb2x1bW5Db21wb25lbnQgPSBleHBvcnRzLkNvbHVtbkNvbXBvbmVudCA9IGZ1bmN0aW9uIChfRm9ybWlvQ29tcG9uZW50cykge1xuICBfaW5oZXJpdHMoQ29sdW1uQ29tcG9uZW50LCBfRm9ybWlvQ29tcG9uZW50cyk7XG5cbiAgZnVuY3Rpb24gQ29sdW1uQ29tcG9uZW50KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb2x1bW5Db21wb25lbnQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDb2x1bW5Db21wb25lbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2x1bW5Db21wb25lbnQpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDb2x1bW5Db21wb25lbnQsIFt7XG4gICAga2V5OiAnY2xhc3NOYW1lJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnY29sIGNvbC1zbS0nICsgdGhpcy5jb21wb25lbnQuY29sV2lkdGg7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbHVtbkNvbXBvbmVudDtcbn0oX0NvbXBvbmVudHMuRm9ybWlvQ29tcG9uZW50cyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Db2x1bW5zQ29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2VhY2gyID0gcmVxdWlyZSgnbG9kYXNoL2VhY2gnKTtcblxudmFyIF9lYWNoMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2gyKTtcblxudmFyIF9Db21wb25lbnRzID0gcmVxdWlyZSgnLi4vQ29tcG9uZW50cycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBDb2x1bW5zQ29tcG9uZW50ID0gZXhwb3J0cy5Db2x1bW5zQ29tcG9uZW50ID0gZnVuY3Rpb24gKF9Gb3JtaW9Db21wb25lbnRzKSB7XG4gIF9pbmhlcml0cyhDb2x1bW5zQ29tcG9uZW50LCBfRm9ybWlvQ29tcG9uZW50cyk7XG5cbiAgZnVuY3Rpb24gQ29sdW1uc0NvbXBvbmVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sdW1uc0NvbXBvbmVudCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENvbHVtbnNDb21wb25lbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2x1bW5zQ29tcG9uZW50KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29sdW1uc0NvbXBvbmVudCwgW3tcbiAgICBrZXk6ICdhZGRDb21wb25lbnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQ29tcG9uZW50cygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgY29sV2lkdGggPSBNYXRoLmZsb29yKDEyIC8gdGhpcy5jb21wb25lbnQuY29sdW1ucy5sZW5ndGgpO1xuICAgICAgKDAsIF9lYWNoMy5kZWZhdWx0KSh0aGlzLmNvbXBvbmVudC5jb2x1bW5zLCBmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgIGNvbHVtbi50eXBlID0gJ2NvbHVtbic7XG4gICAgICAgIGNvbHVtbi5jb2xXaWR0aCA9IGNvbFdpZHRoO1xuICAgICAgICBfdGhpczIuYWRkQ29tcG9uZW50KGNvbHVtbiwgX3RoaXMyLmVsZW1lbnQsIF90aGlzMi5kYXRhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NsYXNzTmFtZScsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ3Jvdyc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbHVtbnNDb21wb25lbnQ7XG59KF9Db21wb25lbnRzLkZvcm1pb0NvbXBvbmVudHMpOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQ29udGFpbmVyQ29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX0NvbXBvbmVudHMgPSByZXF1aXJlKCcuLi9Db21wb25lbnRzJyk7XG5cbnZhciBfaXNPYmplY3QyID0gcmVxdWlyZSgnbG9kYXNoL2lzT2JqZWN0Jyk7XG5cbnZhciBfaXNPYmplY3QzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNPYmplY3QyKTtcblxudmFyIF9lYWNoMiA9IHJlcXVpcmUoJ2xvZGFzaC9lYWNoJyk7XG5cbnZhciBfZWFjaDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYWNoMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIENvbnRhaW5lckNvbXBvbmVudCA9IGV4cG9ydHMuQ29udGFpbmVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKF9Gb3JtaW9Db21wb25lbnRzKSB7XG4gIF9pbmhlcml0cyhDb250YWluZXJDb21wb25lbnQsIF9Gb3JtaW9Db21wb25lbnRzKTtcblxuICBmdW5jdGlvbiBDb250YWluZXJDb21wb25lbnQoY29tcG9uZW50LCBvcHRpb25zLCBkYXRhKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRhaW5lckNvbXBvbmVudCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ29udGFpbmVyQ29tcG9uZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29udGFpbmVyQ29tcG9uZW50KSkuY2FsbCh0aGlzLCBjb21wb25lbnQsIG9wdGlvbnMsIGRhdGEpKTtcblxuICAgIF90aGlzLnR5cGUgPSAnY29udGFpbmVyJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29udGFpbmVyQ29tcG9uZW50LCBbe1xuICAgIGtleTogJ2J1aWxkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGQoKSB7XG4gICAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLmNlKCdlbGVtZW50JywgJ2RpdicsIHtcbiAgICAgICAgY2xhc3M6ICdmb3JtaW8tY29udGFpbmVyLWNvbXBvbmVudCdcbiAgICAgIH0pO1xuICAgICAgaWYgKCF0aGlzLmRhdGFbdGhpcy5jb21wb25lbnQua2V5XSkge1xuICAgICAgICB0aGlzLmRhdGFbdGhpcy5jb21wb25lbnQua2V5XSA9IHt9O1xuICAgICAgfVxuICAgICAgdGhpcy5hZGRDb21wb25lbnRzKHRoaXMuZWxlbWVudCwgdGhpcy5kYXRhW3RoaXMuY29tcG9uZW50LmtleV0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICB2YXIgdmFsdWUgPSB7fTtcbiAgICAgICgwLCBfZWFjaDMuZGVmYXVsdCkodGhpcy5jb21wb25lbnRzLCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHZhbHVlW2NvbXBvbmVudC5jb21wb25lbnQua2V5XSA9IGNvbXBvbmVudC5nZXRWYWx1ZSgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSwgbm9VcGRhdGUsIG5vVmFsaWRhdGUpIHtcbiAgICAgIGlmICghdmFsdWUgfHwgISgwLCBfaXNPYmplY3QzLmRlZmF1bHQpKHZhbHVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAoMCwgX2VhY2gzLmRlZmF1bHQpKHRoaXMuY29tcG9uZW50cywgZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoY29tcG9uZW50LnR5cGUgPT09ICdjb21wb25lbnRzJykge1xuICAgICAgICAgIGNvbXBvbmVudC5zZXRWYWx1ZSh2YWx1ZSwgbm9VcGRhdGUsIG5vVmFsaWRhdGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KGNvbXBvbmVudC5jb21wb25lbnQua2V5KSkge1xuICAgICAgICAgIGNvbXBvbmVudC5zZXRWYWx1ZSh2YWx1ZVtjb21wb25lbnQuY29tcG9uZW50LmtleV0sIG5vVXBkYXRlLCBub1ZhbGlkYXRlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIW5vVXBkYXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWUobm9WYWxpZGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbnRhaW5lckNvbXBvbmVudDtcbn0oX0NvbXBvbmVudHMuRm9ybWlvQ29tcG9uZW50cyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Db250ZW50Q29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX0Jhc2UgPSByZXF1aXJlKCcuLi9iYXNlL0Jhc2UnKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQ29udGVudENvbXBvbmVudCA9IGV4cG9ydHMuQ29udGVudENvbXBvbmVudCA9IGZ1bmN0aW9uIChfQmFzZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoQ29udGVudENvbXBvbmVudCwgX0Jhc2VDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIENvbnRlbnRDb21wb25lbnQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRlbnRDb21wb25lbnQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDb250ZW50Q29tcG9uZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29udGVudENvbXBvbmVudCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENvbnRlbnRDb21wb25lbnQsIFt7XG4gICAga2V5OiAnYnVpbGQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZCgpIHtcbiAgICAgIHRoaXMuZWxlbWVudCA9IHRoaXMuY2UoJ2VsZW1lbnQnLCAnZGl2Jywge1xuICAgICAgICBjbGFzczogJ2Zvcm0tZ3JvdXAnXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLmludGVycG9sYXRlKHRoaXMuY29tcG9uZW50Lmh0bWwsIHsgZGF0YTogdGhpcy5kYXRhIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb250ZW50Q29tcG9uZW50O1xufShfQmFzZS5CYXNlQ29tcG9uZW50KTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkN1cnJlbmN5Q29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3ZhbmlsbGEgPSByZXF1aXJlKCd0ZXh0LW1hc2stYWxsL3ZhbmlsbGEnKTtcblxudmFyIF92YW5pbGxhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZhbmlsbGEpO1xuXG52YXIgX2NyZWF0ZU51bWJlck1hc2sgPSByZXF1aXJlKCd0ZXh0LW1hc2stYWxsL2FkZG9ucy9kaXN0L2NyZWF0ZU51bWJlck1hc2snKTtcblxudmFyIF9jcmVhdGVOdW1iZXJNYXNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZU51bWJlck1hc2spO1xuXG52YXIgX2dldDIgPSByZXF1aXJlKCdsb2Rhc2gvZ2V0Jyk7XG5cbnZhciBfZ2V0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldDIpO1xuXG52YXIgX1RleHRGaWVsZCA9IHJlcXVpcmUoJy4uL3RleHRmaWVsZC9UZXh0RmllbGQnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQ3VycmVuY3lDb21wb25lbnQgPSBleHBvcnRzLkN1cnJlbmN5Q29tcG9uZW50ID0gZnVuY3Rpb24gKF9UZXh0RmllbGRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEN1cnJlbmN5Q29tcG9uZW50LCBfVGV4dEZpZWxkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBDdXJyZW5jeUNvbXBvbmVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3VycmVuY3lDb21wb25lbnQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDdXJyZW5jeUNvbXBvbmVudC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEN1cnJlbmN5Q29tcG9uZW50KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ3VycmVuY3lDb21wb25lbnQsIFt7XG4gICAga2V5OiAnc2V0SW5wdXRNYXNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW5wdXRNYXNrKGlucHV0KSB7XG4gICAgICB0aGlzLmlucHV0TWFzayA9ICgwLCBfdmFuaWxsYTIuZGVmYXVsdCkoe1xuICAgICAgICBpbnB1dEVsZW1lbnQ6IGlucHV0LFxuICAgICAgICBtYXNrOiAoMCwgX2NyZWF0ZU51bWJlck1hc2syLmRlZmF1bHQpKHtcbiAgICAgICAgICBwcmVmaXg6ICcnLFxuICAgICAgICAgIHN1ZmZpeDogJycsXG4gICAgICAgICAgdGhvdXNhbmRzU2VwYXJhdG9yU3ltYm9sOiAoMCwgX2dldDMuZGVmYXVsdCkodGhpcy5jb21wb25lbnQsICd0aG91c2FuZHNTZXBhcmF0b3InLCAnLCcpLFxuICAgICAgICAgIGRlY2ltYWxTeW1ib2w6ICgwLCBfZ2V0My5kZWZhdWx0KSh0aGlzLmNvbXBvbmVudCwgJ2RlY2ltYWxTeW1ib2wnLCAnLicpLFxuICAgICAgICAgIGFsbG93TmVnYXRpdmU6ICgwLCBfZ2V0My5kZWZhdWx0KSh0aGlzLmNvbXBvbmVudCwgJ2FsbG93TmVnYXRpdmUnLCBmYWxzZSksXG4gICAgICAgICAgYWxsb3dEZWNpbWFsOiAoMCwgX2dldDMuZGVmYXVsdCkodGhpcy5jb21wb25lbnQsICdhbGxvd0RlY2ltYWwnLCB0cnVlKVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEN1cnJlbmN5Q29tcG9uZW50O1xufShfVGV4dEZpZWxkLlRleHRGaWVsZENvbXBvbmVudCk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5EYXRhR3JpZENvbXBvbmVudCA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX2VhY2gyID0gcmVxdWlyZSgnbG9kYXNoL2VhY2gnKTtcblxudmFyIF9lYWNoMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2gyKTtcblxudmFyIF9jbG9uZURlZXAyID0gcmVxdWlyZSgnbG9kYXNoL2Nsb25lRGVlcCcpO1xuXG52YXIgX2Nsb25lRGVlcDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbG9uZURlZXAyKTtcblxudmFyIF9jbG9uZTIgPSByZXF1aXJlKCdsb2Rhc2gvY2xvbmUnKTtcblxudmFyIF9jbG9uZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbG9uZTIpO1xuXG52YXIgX2lzQXJyYXkyID0gcmVxdWlyZSgnbG9kYXNoL2lzQXJyYXknKTtcblxudmFyIF9pc0FycmF5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzQXJyYXkyKTtcblxudmFyIF9Db21wb25lbnRzID0gcmVxdWlyZSgnLi4vQ29tcG9uZW50cycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBEYXRhR3JpZENvbXBvbmVudCA9IGV4cG9ydHMuRGF0YUdyaWRDb21wb25lbnQgPSBmdW5jdGlvbiAoX0Zvcm1pb0NvbXBvbmVudHMpIHtcbiAgX2luaGVyaXRzKERhdGFHcmlkQ29tcG9uZW50LCBfRm9ybWlvQ29tcG9uZW50cyk7XG5cbiAgZnVuY3Rpb24gRGF0YUdyaWRDb21wb25lbnQoY29tcG9uZW50LCBvcHRpb25zLCBkYXRhKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGFHcmlkQ29tcG9uZW50KTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChEYXRhR3JpZENvbXBvbmVudC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERhdGFHcmlkQ29tcG9uZW50KSkuY2FsbCh0aGlzLCBjb21wb25lbnQsIG9wdGlvbnMsIGRhdGEpKTtcblxuICAgIF90aGlzLnR5cGUgPSAnZGF0YWdyaWQnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEYXRhR3JpZENvbXBvbmVudCwgW3tcbiAgICBrZXk6ICdidWlsZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkKCkge1xuICAgICAgdGhpcy5jcmVhdGVFbGVtZW50KCk7XG4gICAgICB0aGlzLmNyZWF0ZUxhYmVsKHRoaXMuZWxlbWVudCk7XG4gICAgICBpZiAoIXRoaXMuZGF0YS5oYXNPd25Qcm9wZXJ0eSh0aGlzLmNvbXBvbmVudC5rZXkpKSB7XG4gICAgICAgIHRoaXMuYWRkTmV3VmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudmlzaWJsZUNvbHVtbnMgPSB0cnVlO1xuICAgICAgdGhpcy5idWlsZFRhYmxlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYnVpbGRUYWJsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkVGFibGUoZGF0YSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgaWYgKHRoaXMudGFibGVFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLnRhYmxlRWxlbWVudCk7XG4gICAgICAgIHRoaXMudGFibGVFbGVtZW50LmlubmVySFRNTCA9ICcnO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFibGVDbGFzcyA9ICd0YWJsZSBkYXRhZ3JpZC10YWJsZSB0YWJsZS1ib3JkZXJlZCBmb3JtLWdyb3VwIGZvcm1pby1kYXRhLWdyaWQgJztcbiAgICAgICgwLCBfZWFjaDMuZGVmYXVsdCkoWydzdHJpcGVkJywgJ2JvcmRlcmVkJywgJ2hvdmVyJywgJ2NvbmRlbnNlZCddLCBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICBpZiAoX3RoaXMyLmNvbXBvbmVudFtwcm9wXSkge1xuICAgICAgICAgIHRhYmxlQ2xhc3MgKz0gJ3RhYmxlLScgKyBwcm9wICsgJyAnO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMudGFibGVFbGVtZW50ID0gdGhpcy5jZSgnZWxlbWVudCcsICd0YWJsZScsIHtcbiAgICAgICAgY2xhc3M6IHRhYmxlQ2xhc3NcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgdGhlYWQgPSB0aGlzLmNlKCdoZWFkZXInLCAndGhlYWQnKTtcblxuICAgICAgLy8gQnVpbGQgdGhlIGhlYWRlci5cbiAgICAgIHZhciB0ciA9IHRoaXMuY2UoJ2hlYWRlclJvdycsICd0cicpO1xuICAgICAgKDAsIF9lYWNoMy5kZWZhdWx0KSh0aGlzLmNvbXBvbmVudC5jb21wb25lbnRzLCBmdW5jdGlvbiAoY29tcCkge1xuICAgICAgICBpZiAoX3RoaXMyLnZpc2libGVDb2x1bW5zID09PSB0cnVlIHx8IF90aGlzMi52aXNpYmxlQ29sdW1uc1tjb21wLmtleV0pIHtcbiAgICAgICAgICB2YXIgX3RoID0gX3RoaXMyLmNlKCdoZWFkZXJDb2x1bW4nLCAndGgnKTtcbiAgICAgICAgICBpZiAoY29tcC52YWxpZGF0ZSAmJiBjb21wLnZhbGlkYXRlLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICBfdGguc2V0QXR0cmlidXRlKCdjbGFzcycsICdmaWVsZC1yZXF1aXJlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdGl0bGUgPSBjb21wLmxhYmVsIHx8IGNvbXAudGl0bGU7XG4gICAgICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgICBfdGguYXBwZW5kQ2hpbGQoX3RoaXMyLnRleHQodGl0bGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHIuYXBwZW5kQ2hpbGQoX3RoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgdGggPSB0aGlzLmNlKCdoZWFkZXJFeHRyYScsICd0aCcpO1xuICAgICAgdHIuYXBwZW5kQ2hpbGQodGgpO1xuICAgICAgdGhlYWQuYXBwZW5kQ2hpbGQodHIpO1xuICAgICAgdGhpcy50YWJsZUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhlYWQpO1xuXG4gICAgICAvLyBDcmVhdGUgdGhlIHRhYmxlIGJvZHkuXG4gICAgICB0aGlzLnRib2R5ID0gdGhpcy5jZSgndGFibGUnLCAndGJvZHknKTtcblxuICAgICAgLy8gQnVpbGQgdGhlIHJvd3MuXG4gICAgICB0aGlzLmJ1aWxkUm93cyhkYXRhKTtcblxuICAgICAgLy8gQWRkIHRoZSBib2R5IHRvIHRoZSB0YWJsZSBhbmQgdG8gdGhlIGVsZW1lbnQuXG4gICAgICB0aGlzLnRhYmxlRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnRib2R5KTtcbiAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnRhYmxlRWxlbWVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYnVpbGRSb3dzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRSb3dzKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgY29tcG9uZW50cyA9IHJlcXVpcmUoJy4uL2luZGV4Jyk7XG4gICAgICB0aGlzLnRib2R5LmlubmVySFRNTCA9ICcnO1xuICAgICAgdGhpcy5yb3dzID0gW107XG4gICAgICAoMCwgX2VhY2gzLmRlZmF1bHQpKHRoaXMuZGF0YVt0aGlzLmNvbXBvbmVudC5rZXldLCBmdW5jdGlvbiAocm93LCBpbmRleCkge1xuICAgICAgICB2YXIgdHIgPSBfdGhpczMuY2UoJ3RhYmxlUm93JywgJ3RyJyk7XG4gICAgICAgIHZhciBjb2xzID0ge307XG4gICAgICAgICgwLCBfZWFjaDMuZGVmYXVsdCkoX3RoaXMzLmNvbXBvbmVudC5jb21wb25lbnRzLCBmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgICAgdmFyIGNvbHVtbiA9ICgwLCBfY2xvbmVEZWVwMy5kZWZhdWx0KShjb2wpO1xuICAgICAgICAgIGNvbHVtbi5sYWJlbCA9IGZhbHNlO1xuICAgICAgICAgIGNvbHVtbi5yb3cgPSBfdGhpczMucm93ICsgJy0nICsgaW5kZXg7XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSAoMCwgX2Nsb25lMy5kZWZhdWx0KShfdGhpczMub3B0aW9ucyk7XG4gICAgICAgICAgb3B0aW9ucy5uYW1lICs9ICdbJyArIGluZGV4ICsgJ10nO1xuICAgICAgICAgIHZhciBjb21wID0gY29tcG9uZW50cy5jcmVhdGUoY29sdW1uLCBvcHRpb25zLCByb3cpO1xuICAgICAgICAgIGlmIChyb3cuaGFzT3duUHJvcGVydHkoY29sdW1uLmtleSkpIHtcbiAgICAgICAgICAgIGNvbXAuc2V0VmFsdWUocm93W2NvbHVtbi5rZXldKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbXAudHlwZSA9PT0gJ2NvbXBvbmVudHMnKSB7XG4gICAgICAgICAgICBjb21wLnNldFZhbHVlKHJvdyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbHNbY29sdW1uLmtleV0gPSBjb21wO1xuICAgICAgICAgIGlmIChfdGhpczMudmlzaWJsZUNvbHVtbnMgPT09IHRydWUgfHwgX3RoaXMzLnZpc2libGVDb2x1bW5zW2NvbC5rZXldKSB7XG4gICAgICAgICAgICB2YXIgX3RkID0gX3RoaXMzLmNlKCd0YWJsZUNvbHVtbicsICd0ZCcpO1xuICAgICAgICAgICAgX3RkLmFwcGVuZENoaWxkKGNvbXAuZWxlbWVudCk7XG4gICAgICAgICAgICB0ci5hcHBlbmRDaGlsZChfdGQpO1xuICAgICAgICAgICAgY29tcC5jaGVja0NvbmRpdGlvbnMoZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMzLnJvd3MucHVzaChjb2xzKTtcbiAgICAgICAgdmFyIHRkID0gX3RoaXMzLmNlKCd0YWJsZVJlbW92ZVJvdycsICd0ZCcpO1xuICAgICAgICB0ZC5hcHBlbmRDaGlsZChfdGhpczMucmVtb3ZlQnV0dG9uKGluZGV4KSk7XG4gICAgICAgIHRyLmFwcGVuZENoaWxkKHRkKTtcbiAgICAgICAgX3RoaXMzLnRib2R5LmFwcGVuZENoaWxkKHRyKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBZGQgdGhlIGFkZCBidXR0b24uXG4gICAgICB2YXIgdHIgPSB0aGlzLmNlKCd0YWJsZUFkZFJvdycsICd0cicpO1xuICAgICAgdmFyIHRkID0gdGhpcy5jZSgndGFibGVBZGRDb2x1bW4nLCAndGQnLCB7XG4gICAgICAgIGNvbHNwYW46IHRoaXMuY29tcG9uZW50LmNvbXBvbmVudHMubGVuZ3RoICsgMVxuICAgICAgfSk7XG4gICAgICB0ZC5hcHBlbmRDaGlsZCh0aGlzLmFkZEJ1dHRvbigpKTtcbiAgICAgIHRyLmFwcGVuZENoaWxkKHRkKTtcbiAgICAgIHRoaXMudGJvZHkuYXBwZW5kQ2hpbGQodHIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NoZWNrQ29uZGl0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrQ29uZGl0aW9ucyhkYXRhKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIHNob3cgPSBfZ2V0KERhdGFHcmlkQ29tcG9uZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERhdGFHcmlkQ29tcG9uZW50LnByb3RvdHlwZSksICdjaGVja0NvbmRpdGlvbnMnLCB0aGlzKS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgICAgdmFyIHJlYnVpbGQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLnZpc2libGVDb2x1bW5zID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMudmlzaWJsZUNvbHVtbnMgPSB7fTtcbiAgICAgIH1cbiAgICAgICgwLCBfZWFjaDMuZGVmYXVsdCkodGhpcy5jb21wb25lbnQuY29tcG9uZW50cywgZnVuY3Rpb24gKGNvbCkge1xuICAgICAgICB2YXIgc2hvd0NvbHVtbiA9IGZhbHNlO1xuICAgICAgICAoMCwgX2VhY2gzLmRlZmF1bHQpKF90aGlzNC5yb3dzLCBmdW5jdGlvbiAoY29tcHMpIHtcbiAgICAgICAgICBzaG93Q29sdW1uIHw9IGNvbXBzW2NvbC5rZXldLmNoZWNrQ29uZGl0aW9ucyhkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChfdGhpczQudmlzaWJsZUNvbHVtbnNbY29sLmtleV0gJiYgIXNob3dDb2x1bW4gfHwgIV90aGlzNC52aXNpYmxlQ29sdW1uc1tjb2wua2V5XSAmJiBzaG93Q29sdW1uKSB7XG4gICAgICAgICAgcmVidWlsZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczQudmlzaWJsZUNvbHVtbnNbY29sLmtleV0gPSBzaG93Q29sdW1uO1xuICAgICAgICBzaG93IHw9IHNob3dDb2x1bW47XG4gICAgICB9KTtcblxuICAgICAgLy8gSWYgYSByZWJ1aWxkIGlzIG5lZWRlZCwgdGhlbiByZWJ1aWxkIHRoZSB0YWJsZS5cbiAgICAgIGlmIChyZWJ1aWxkICYmIHNob3cpIHtcbiAgICAgICAgdGhpcy5idWlsZFRhYmxlKGRhdGEpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gaWYgdGhpcyB0YWJsZSBzaG91bGQgc2hvdy5cbiAgICAgIHJldHVybiBzaG93O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUodmFsdWUsIG5vVXBkYXRlLCBub1ZhbGlkYXRlKSB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghKDAsIF9pc0FycmF5My5kZWZhdWx0KSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG5cbiAgICAgIC8vIEFkZCBuZWVkZWQgcm93cy5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnJvd3MubGVuZ3RoOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGRWYWx1ZSgpO1xuICAgICAgfVxuXG4gICAgICAoMCwgX2VhY2gzLmRlZmF1bHQpKHRoaXMucm93cywgZnVuY3Rpb24gKHJvdywgaW5kZXgpIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAoMCwgX2VhY2gzLmRlZmF1bHQpKHJvdywgZnVuY3Rpb24gKGNvbCwga2V5KSB7XG4gICAgICAgICAgaWYgKGNvbC50eXBlID09PSAnY29tcG9uZW50cycpIHtcbiAgICAgICAgICAgIGNvbC5zZXRWYWx1ZSh2YWx1ZVtpbmRleF0sIG5vVXBkYXRlLCBub1ZhbGlkYXRlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlW2luZGV4XS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBjb2wuc2V0VmFsdWUodmFsdWVbaW5kZXhdW2tleV0sIG5vVXBkYXRlLCBub1ZhbGlkYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB2YWx1ZSBvZiB0aGlzIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgKDAsIF9lYWNoMy5kZWZhdWx0KSh0aGlzLnJvd3MsIGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgdmFyIHZhbHVlID0ge307XG4gICAgICAgICgwLCBfZWFjaDMuZGVmYXVsdCkocm93LCBmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgICAgaWYgKGNvbCAmJiBjb2wuY29tcG9uZW50ICYmIGNvbC5jb21wb25lbnQua2V5KSB7XG4gICAgICAgICAgICB2YWx1ZVtjb2wuY29tcG9uZW50LmtleV0gPSBjb2wuZ2V0VmFsdWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVmYXVsdFZhbHVlJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGF0YUdyaWRDb21wb25lbnQ7XG59KF9Db21wb25lbnRzLkZvcm1pb0NvbXBvbmVudHMpOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRGF0ZVRpbWVDb21wb25lbnQgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfc2V0ID0gZnVuY3Rpb24gc2V0KG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcikgeyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ICE9PSBudWxsKSB7IHNldChwYXJlbnQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MgJiYgZGVzYy53cml0YWJsZSkgeyBkZXNjLnZhbHVlID0gdmFsdWU7IH0gZWxzZSB7IHZhciBzZXR0ZXIgPSBkZXNjLnNldDsgaWYgKHNldHRlciAhPT0gdW5kZWZpbmVkKSB7IHNldHRlci5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7IH0gfSByZXR1cm4gdmFsdWU7IH07XG5cbnZhciBfZ2V0MiA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfQmFzZSA9IHJlcXVpcmUoJy4uL2Jhc2UvQmFzZScpO1xuXG52YXIgX2ZsYXRwaWNrciA9IHJlcXVpcmUoJ2ZsYXRwaWNrcicpO1xuXG52YXIgX2ZsYXRwaWNrcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mbGF0cGlja3IpO1xuXG52YXIgX2dldDMgPSByZXF1aXJlKCdsb2Rhc2gvZ2V0Jyk7XG5cbnZhciBfZ2V0NCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldDMpO1xuXG52YXIgX2VhY2gyID0gcmVxdWlyZSgnbG9kYXNoL2VhY2gnKTtcblxudmFyIF9lYWNoMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2gyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgRGF0ZVRpbWVDb21wb25lbnQgPSBleHBvcnRzLkRhdGVUaW1lQ29tcG9uZW50ID0gZnVuY3Rpb24gKF9CYXNlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhEYXRlVGltZUNvbXBvbmVudCwgX0Jhc2VDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIERhdGVUaW1lQ29tcG9uZW50KGNvbXBvbmVudCwgb3B0aW9ucywgZGF0YSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRlVGltZUNvbXBvbmVudCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRGF0ZVRpbWVDb21wb25lbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihEYXRlVGltZUNvbXBvbmVudCkpLmNhbGwodGhpcywgY29tcG9uZW50LCBvcHRpb25zLCBkYXRhKSk7XG5cbiAgICBfdGhpcy52YWxpZGF0b3JzLnB1c2goJ2RhdGUnKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRGF0ZVRpbWVDb21wb25lbnQsIFt7XG4gICAga2V5OiAnZWxlbWVudEluZm8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbGVtZW50SW5mbygpIHtcbiAgICAgIHZhciBpbmZvID0gX2dldDIoRGF0ZVRpbWVDb21wb25lbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRGF0ZVRpbWVDb21wb25lbnQucHJvdG90eXBlKSwgJ2VsZW1lbnRJbmZvJywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIGluZm8udHlwZSA9ICdpbnB1dCc7XG4gICAgICBpbmZvLmF0dHIudHlwZSA9ICd0ZXh0JztcbiAgICAgIGluZm8uY2hhbmdlRXZlbnQgPSAnaW5wdXQnO1xuICAgICAgdGhpcy5jb21wb25lbnQuc3VmZml4ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoaXMgc2VsZWN0IGNvbXBvbmVudCBjYW4gaGFuZGxlIG11bHRpcGxlIGl0ZW1zIG9uIGl0cyBvd24uXG5cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZVdyYXBwZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVXcmFwcGVyKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbnZlcnRGb3JtYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb252ZXJ0Rm9ybWF0KGZvcm1hdCkge1xuICAgICAgLy8gWWVhciBjb252ZXJzaW9uLlxuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoL3kvZywgJ1knKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdZWVlZJywgJ1knKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdZWScsICd5Jyk7XG5cbiAgICAgIC8vIE1vbnRoIGNvbnZlcnNpb24uXG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnTU1NTScsICdGJyk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvTS9nLCAnbicpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ25ubicsICdNJyk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnbm4nLCAnbScpO1xuXG4gICAgICAvLyBEYXkgaW4gbW9udGguXG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvZC9nLCAnaicpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ2pqJywgJ2QnKTtcblxuICAgICAgLy8gRGF5IGluIHdlZWsuXG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnRUVFRScsICdsJyk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnRUVFJywgJ0QnKTtcblxuICAgICAgLy8gSG91cnMsIG1pbnV0ZXMsIHNlY29uZHNcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdISCcsICdIJyk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnaGgnLCAnaCcpO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ21tJywgJ2knKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdzcycsICdTJyk7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvYS9nLCAnSycpO1xuICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhZGRTdWZmaXgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRTdWZmaXgoaW5wdXQsIGlucHV0R3JvdXApIHtcbiAgICAgIHZhciBzdWZmaXggPSB0aGlzLmNlKCdzdWZmaXgnLCAnc3BhbicsIHtcbiAgICAgICAgY2xhc3M6ICdpbnB1dC1ncm91cC1hZGRvbidcbiAgICAgIH0pO1xuICAgICAgc3VmZml4LmFwcGVuZENoaWxkKHRoaXMuZ2V0SWNvbih0aGlzLmNvbXBvbmVudC5lbmFibGVEYXRlID8gJ2NhbGVuZGFyJyA6ICd0aW1lJykpO1xuICAgICAgaW5wdXRHcm91cC5hcHBlbmRDaGlsZChzdWZmaXgpO1xuICAgICAgcmV0dXJuIHN1ZmZpeDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhZGRJbnB1dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZElucHV0KGlucHV0LCBjb250YWluZXIsIG5hbWUpIHtcbiAgICAgIF9nZXQyKERhdGVUaW1lQ29tcG9uZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERhdGVUaW1lQ29tcG9uZW50LnByb3RvdHlwZSksICdhZGRJbnB1dCcsIHRoaXMpLmNhbGwodGhpcywgaW5wdXQsIGNvbnRhaW5lciwgbmFtZSk7XG4gICAgICBpbnB1dC5jYWxlbmRhciA9IG5ldyBfZmxhdHBpY2tyMi5kZWZhdWx0KGlucHV0LCB0aGlzLmNvbmZpZyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0RGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERhdGUodmFsdWUpIHtcbiAgICAgIHZhciB0aW1lc3RhbXAgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgaWYgKCF0aW1lc3RhbXApIHtcbiAgICAgICAgLy8gSnVzdCBkZWZhdWx0IHRvIHRvZGF5LlxuICAgICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRGF0ZSh0aW1lc3RhbXAgKiAxMDAwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRSYXdWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJhd1ZhbHVlKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmlucHV0cykge1xuICAgICAgICBpZiAoIXRoaXMuY29tcG9uZW50Lm11bHRpcGxlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0ZSh0aGlzLmlucHV0c1tpXS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzLnB1c2godGhpcy5nZXREYXRlKHRoaXMuaW5wdXRzW2ldLnZhbHVlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFZhbHVlQXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZUF0KGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXREYXRlKHRoaXMuaW5wdXRzW2luZGV4XS52YWx1ZSkudG9JU09TdHJpbmcoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRWYWx1ZUF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWVBdChpbmRleCwgdmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLmlucHV0c1tpbmRleF0uY2FsZW5kYXIpIHtcbiAgICAgICAgdmFyIGRhdGUgPSB2YWx1ZSA/IG5ldyBEYXRlKHZhbHVlKSA6IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMuaW5wdXRzW2luZGV4XS5jYWxlbmRhci5zZXREYXRlKGRhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbmZpZycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWx0SW5wdXQ6IHRydWUsXG4gICAgICAgIGNsaWNrT3BlbnM6IHRydWUsXG4gICAgICAgIGVuYWJsZURhdGU6IHRydWUsXG4gICAgICAgIG1vZGU6IHRoaXMuY29tcG9uZW50Lm11bHRpcGxlID8gJ211bHRpcGxlJyA6ICdzaW5nbGUnLFxuICAgICAgICBlbmFibGVUaW1lOiAoMCwgX2dldDQuZGVmYXVsdCkodGhpcy5jb21wb25lbnQsICdlbmFibGVUaW1lJywgdHJ1ZSksXG4gICAgICAgIG5vQ2FsZW5kYXI6ICEoMCwgX2dldDQuZGVmYXVsdCkodGhpcy5jb21wb25lbnQsICdlbmFibGVEYXRlJywgdHJ1ZSksXG4gICAgICAgIGFsdEZvcm1hdDogdGhpcy5jb252ZXJ0Rm9ybWF0KCgwLCBfZ2V0NC5kZWZhdWx0KSh0aGlzLmNvbXBvbmVudCwgJ2Zvcm1hdCcsICcnKSksXG4gICAgICAgIGRhdGVGb3JtYXQ6ICdVJyxcbiAgICAgICAgZGVmYXVsdERhdGU6ICgwLCBfZ2V0NC5kZWZhdWx0KSh0aGlzLmNvbXBvbmVudCwgJ2RlZmF1bHREYXRlJywgJycpLFxuICAgICAgICBob3VySW5jcmVtZW50OiAoMCwgX2dldDQuZGVmYXVsdCkodGhpcy5jb21wb25lbnQsICd0aW1lUGlja2VyLmhvdXJTdGVwJywgMSksXG4gICAgICAgIG1pbnV0ZUluY3JlbWVudDogKDAsIF9nZXQ0LmRlZmF1bHQpKHRoaXMuY29tcG9uZW50LCAndGltZVBpY2tlci5taW51dGVTdGVwJywgNSksXG4gICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLm9uQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGlzYWJsZWQnLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGRpc2FibGVkKSB7XG4gICAgICBfc2V0KERhdGVUaW1lQ29tcG9uZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERhdGVUaW1lQ29tcG9uZW50LnByb3RvdHlwZSksICdkaXNhYmxlZCcsIGRpc2FibGVkLCB0aGlzKTtcbiAgICAgICgwLCBfZWFjaDMuZGVmYXVsdCkodGhpcy5pbnB1dHMsIGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQuY2FsZW5kYXIpIHtcbiAgICAgICAgICBpbnB1dC5jYWxlbmRhci5yZWRyYXcoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERhdGVUaW1lQ29tcG9uZW50O1xufShfQmFzZS5CYXNlQ29tcG9uZW50KTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkRheUNvbXBvbmVudCA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQyID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9CYXNlID0gcmVxdWlyZSgnLi4vYmFzZS9CYXNlJyk7XG5cbnZhciBfZ2V0MyA9IHJlcXVpcmUoJ2xvZGFzaC9nZXQnKTtcblxudmFyIF9nZXQ0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0Myk7XG5cbnZhciBfZWFjaDIgPSByZXF1aXJlKCdsb2Rhc2gvZWFjaCcpO1xuXG52YXIgX2VhY2gzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWFjaDIpO1xuXG52YXIgX21vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xuXG52YXIgX21vbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tb21lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBEYXlDb21wb25lbnQgPSBleHBvcnRzLkRheUNvbXBvbmVudCA9IGZ1bmN0aW9uIChfQmFzZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoRGF5Q29tcG9uZW50LCBfQmFzZUNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRGF5Q29tcG9uZW50KGNvbXBvbmVudCwgb3B0aW9ucywgZGF0YSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXlDb21wb25lbnQpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKERheUNvbXBvbmVudC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERheUNvbXBvbmVudCkpLmNhbGwodGhpcywgY29tcG9uZW50LCBvcHRpb25zLCBkYXRhKSk7XG5cbiAgICBfdGhpcy52YWxpZGF0b3JzLnB1c2goJ2RhdGUnKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRGF5Q29tcG9uZW50LCBbe1xuICAgIGtleTogJ2VsZW1lbnRJbmZvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWxlbWVudEluZm8oKSB7XG4gICAgICB2YXIgaW5mbyA9IF9nZXQyKERheUNvbXBvbmVudC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihEYXlDb21wb25lbnQucHJvdG90eXBlKSwgJ2VsZW1lbnRJbmZvJywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIGluZm8udHlwZSA9ICdpbnB1dCc7XG4gICAgICBpbmZvLmF0dHIudHlwZSA9ICdoaWRkZW4nO1xuICAgICAgaW5mby5jaGFuZ2VFdmVudCA9ICdjaGFuZ2UnO1xuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlRGF5SW5wdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVEYXlJbnB1dCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgZGF5Q29sdW1uID0gdGhpcy5jZSgnZGF5Q29sdW1uJywgJ2RpdicsIHtcbiAgICAgICAgY2xhc3M6ICdmb3JtLWdyb3VwIGNvbCBjb2wteHMtMydcbiAgICAgIH0pO1xuICAgICAgdmFyIGRheUxhYmVsID0gdGhpcy5jZSgnZGF5TGFiZWwnLCAnbGFiZWwnLCB7XG4gICAgICAgIGZvcjogdGhpcy5jb21wb25lbnQua2V5ICsgJy1kYXknLFxuICAgICAgICBjbGFzczogKDAsIF9nZXQ0LmRlZmF1bHQpKHRoaXMuY29tcG9uZW50LCAnZmllbGRzLmRheS5yZXF1aXJlZCcsIGZhbHNlKSA/ICdmaWVsZC1yZXF1aXJlZCcgOiAnJ1xuICAgICAgfSk7XG4gICAgICBkYXlMYWJlbC5hcHBlbmRDaGlsZCh0aGlzLnRleHQodGhpcy50KCdkYXknKSkpO1xuICAgICAgZGF5Q29sdW1uLmFwcGVuZENoaWxkKGRheUxhYmVsKTtcbiAgICAgIHRoaXMuZGF5SW5wdXQgPSB0aGlzLmNlKCdkYXlJbnB1dCcsICdpbnB1dCcsIHtcbiAgICAgICAgY2xhc3M6ICdmb3JtLWNvbnRyb2wnLFxuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgc3RlcDogJzEnLFxuICAgICAgICBtaW46ICcxJyxcbiAgICAgICAgbWF4OiAnMzEnLFxuICAgICAgICBwbGFjZWhvbGRlcjogKDAsIF9nZXQ0LmRlZmF1bHQpKHRoaXMuY29tcG9uZW50LCAnZmllbGRzLmRheS5wbGFjZWhvbGRlcicsICcnKSxcbiAgICAgICAgaWQ6IHRoaXMuY29tcG9uZW50LmtleSArICctZGF5J1xuICAgICAgfSk7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5kYXlJbnB1dCwgJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi51cGRhdGVWYWx1ZSgpO1xuICAgICAgfSk7XG4gICAgICBkYXlDb2x1bW4uYXBwZW5kQ2hpbGQodGhpcy5kYXlJbnB1dCk7XG4gICAgICByZXR1cm4gZGF5Q29sdW1uO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZU1vbnRoSW5wdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVNb250aElucHV0KCkge1xuICAgICAgdmFyIG1vbnRoQ29sdW1uID0gdGhpcy5jZSgnbW9udGhDb2x1bW4nLCAnZGl2Jywge1xuICAgICAgICBjbGFzczogJ2Zvcm0tZ3JvdXAgY29sIGNvbC14cy00J1xuICAgICAgfSk7XG4gICAgICB2YXIgbW9udGhMYWJlbCA9IHRoaXMuY2UoJ21vbnRoTGFiZWwnLCAnbGFiZWwnLCB7XG4gICAgICAgIGZvcjogdGhpcy5jb21wb25lbnQua2V5ICsgJy1tb250aCcsXG4gICAgICAgIGNsYXNzOiAoMCwgX2dldDQuZGVmYXVsdCkodGhpcy5jb21wb25lbnQsICdmaWVsZHMubW9udGgucmVxdWlyZWQnLCBmYWxzZSkgPyAnZmllbGQtcmVxdWlyZWQnIDogJydcbiAgICAgIH0pO1xuICAgICAgbW9udGhMYWJlbC5hcHBlbmRDaGlsZCh0aGlzLnRleHQodGhpcy50KCdtb250aCcpKSk7XG4gICAgICBtb250aENvbHVtbi5hcHBlbmRDaGlsZChtb250aExhYmVsKTtcbiAgICAgIHRoaXMubW9udGhJbnB1dCA9IHRoaXMuY2UoJ21vbnRoSW5wdXQnLCAnc2VsZWN0Jywge1xuICAgICAgICBjbGFzczogJ2Zvcm0tY29udHJvbCcsXG4gICAgICAgIGlkOiB0aGlzLmNvbXBvbmVudC5rZXkgKyAnLW1vbnRoJ1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNlbGVjdE9wdGlvbnModGhpcy5tb250aElucHV0LCAnbW9udGhPcHRpb24nLCB0aGlzLm1vbnRocyk7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIEVuc3VyZSB0aGUgZGF5IGxpbWl0cyBtYXRjaCB1cCB3aXRoIHRoZSBtb250aHMgc2VsZWN0ZWQuXG4gICAgICB0aGlzLm1vbnRoSW5wdXQub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZGF5SW5wdXQubWF4ID0gbmV3IERhdGUoc2VsZi55ZWFySW5wdXQudmFsdWUsIHRoaXMudmFsdWUsIDApLmdldERhdGUoKTtcbiAgICAgICAgaWYgKHNlbGYuZGF5SW5wdXQudmFsdWUgPiBzZWxmLmRheUlucHV0Lm1heCkge1xuICAgICAgICAgIHNlbGYuZGF5SW5wdXQudmFsdWUgPSBzZWxmLmRheUlucHV0Lm1heDtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLnVwZGF0ZVZhbHVlKCk7XG4gICAgICB9O1xuICAgICAgbW9udGhDb2x1bW4uYXBwZW5kQ2hpbGQodGhpcy5tb250aElucHV0KTtcbiAgICAgIHJldHVybiBtb250aENvbHVtbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjcmVhdGVZZWFySW5wdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVZZWFySW5wdXQoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHllYXJDb2x1bW4gPSB0aGlzLmNlKCd5ZWFyQ29sdW1uJywgJ2RpdicsIHtcbiAgICAgICAgY2xhc3M6ICdmb3JtLWdyb3VwIGNvbCBjb2wteHMtNSdcbiAgICAgIH0pO1xuICAgICAgdmFyIHllYXJMYWJlbCA9IHRoaXMuY2UoJ3llYXJMYWJlbCcsICdsYWJlbCcsIHtcbiAgICAgICAgZm9yOiB0aGlzLmNvbXBvbmVudC5rZXkgKyAnLXllYXInLFxuICAgICAgICBjbGFzczogKDAsIF9nZXQ0LmRlZmF1bHQpKHRoaXMuY29tcG9uZW50LCAnZmllbGRzLnllYXIucmVxdWlyZWQnLCBmYWxzZSkgPyAnZmllbGQtcmVxdWlyZWQnIDogJydcbiAgICAgIH0pO1xuICAgICAgeWVhckxhYmVsLmFwcGVuZENoaWxkKHRoaXMudGV4dCh0aGlzLnQoJ3llYXInKSkpO1xuICAgICAgeWVhckNvbHVtbi5hcHBlbmRDaGlsZCh5ZWFyTGFiZWwpO1xuICAgICAgdGhpcy55ZWFySW5wdXQgPSB0aGlzLmNlKCd5ZWFySW5wdXQnLCAnaW5wdXQnLCB7XG4gICAgICAgIGNsYXNzOiAnZm9ybS1jb250cm9sJyxcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHN0ZXA6ICcxJyxcbiAgICAgICAgbWluOiAnMScsXG4gICAgICAgIHBsYWNlaG9sZGVyOiAoMCwgX2dldDQuZGVmYXVsdCkodGhpcy5jb21wb25lbnQsICdmaWVsZHMueWVhci5wbGFjZWhvbGRlcicsICcnKSxcbiAgICAgICAgdmFsdWU6IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgaWQ6IHRoaXMuY29tcG9uZW50LmtleSArICcteWVhcidcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHRoaXMueWVhcklucHV0LCAnY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMzLnVwZGF0ZVZhbHVlKCk7XG4gICAgICB9KTtcbiAgICAgIHllYXJDb2x1bW4uYXBwZW5kQ2hpbGQodGhpcy55ZWFySW5wdXQpO1xuICAgICAgcmV0dXJuIHllYXJDb2x1bW47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlSW5wdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVJbnB1dChjb250YWluZXIpIHtcbiAgICAgIHZhciBpbnB1dEdyb3VwID0gdGhpcy5jZSgnaW5wdXRHcm91cCcsICdkaXYnLCB7XG4gICAgICAgIGNsYXNzOiAnaW5wdXQtZ3JvdXAgcm93J1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBkYXlDb2x1bW4gPSB0aGlzLmNyZWF0ZURheUlucHV0KCk7XG4gICAgICB2YXIgbW9udGhDb2x1bW4gPSB0aGlzLmNyZWF0ZU1vbnRoSW5wdXQoKTtcbiAgICAgIHZhciB5ZWFyQ29sdW1uID0gdGhpcy5jcmVhdGVZZWFySW5wdXQoKTtcblxuICAgICAgLy8gQWRkIHRoZSBjb2x1bW5zIHRvIHRoZSBkYXkgc2VsZWN0IGluIHRoZSByaWdodCBvcmRlci5cbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5kYXlGaXJzdCAmJiAhKDAsIF9nZXQ0LmRlZmF1bHQpKHRoaXMuY29tcG9uZW50LCAnZmllbGRzLmRheS5oaWRlJywgZmFsc2UpKSB7XG4gICAgICAgIGlucHV0R3JvdXAuYXBwZW5kQ2hpbGQoZGF5Q29sdW1uKTtcbiAgICAgIH1cbiAgICAgIGlmICghKDAsIF9nZXQ0LmRlZmF1bHQpKHRoaXMuY29tcG9uZW50LCAnZmllbGRzLm1vbnRoLmhpZGUnLCBmYWxzZSkpIHtcbiAgICAgICAgaW5wdXRHcm91cC5hcHBlbmRDaGlsZChtb250aENvbHVtbik7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY29tcG9uZW50LmRheUZpcnN0ICYmICEoMCwgX2dldDQuZGVmYXVsdCkodGhpcy5jb21wb25lbnQsICdmaWVsZHMuZGF5LmhpZGUnLCBmYWxzZSkpIHtcbiAgICAgICAgaW5wdXRHcm91cC5hcHBlbmRDaGlsZChkYXlDb2x1bW4pO1xuICAgICAgfVxuICAgICAgaWYgKCEoMCwgX2dldDQuZGVmYXVsdCkodGhpcy5jb21wb25lbnQsICdmaWVsZHMueWVhci5oaWRlJywgZmFsc2UpKSB7XG4gICAgICAgIGlucHV0R3JvdXAuYXBwZW5kQ2hpbGQoeWVhckNvbHVtbik7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbnB1dCA9IHRoaXMuY2UoJ2lucHV0JywgdGhpcy5pbmZvLnR5cGUsIHRoaXMuaW5mby5hdHRyKTtcbiAgICAgIHRoaXMuYWRkSW5wdXQoaW5wdXQsIGlucHV0R3JvdXApO1xuICAgICAgdGhpcy5lcnJvckNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChpbnB1dEdyb3VwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIGF0IGEgc3BlY2lmaWMgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0VmFsdWVBdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlQXQoaW5kZXgsIHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJ0cyA9IHZhbHVlLnNwbGl0KCcvJyk7XG4gICAgICBpZiAodGhpcy5jb21wb25lbnQuZGF5Rmlyc3QgJiYgISgwLCBfZ2V0NC5kZWZhdWx0KSh0aGlzLmNvbXBvbmVudCwgJ2ZpZWxkcy5kYXkuaGlkZScsIGZhbHNlKSkge1xuICAgICAgICB0aGlzLmRheUlucHV0LnZhbHVlID0gcGFyc2VJbnQocGFydHMuc2hpZnQoKSwgMTApO1xuICAgICAgfVxuICAgICAgaWYgKCEoMCwgX2dldDQuZGVmYXVsdCkodGhpcy5jb21wb25lbnQsICdmaWVsZHMubW9udGguaGlkZScsIGZhbHNlKSkge1xuICAgICAgICB0aGlzLm1vbnRoSW5wdXQudmFsdWUgPSBwYXJzZUludChwYXJ0cy5zaGlmdCgpLCAxMCk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY29tcG9uZW50LmRheUZpcnN0ICYmICEoMCwgX2dldDQuZGVmYXVsdCkodGhpcy5jb21wb25lbnQsICdmaWVsZHMuZGF5LmhpZGUnLCBmYWxzZSkpIHtcbiAgICAgICAgdGhpcy5kYXlJbnB1dC52YWx1ZSA9IHBhcnNlSW50KHBhcnRzLnNoaWZ0KCksIDEwKTtcbiAgICAgIH1cbiAgICAgIGlmICghKDAsIF9nZXQ0LmRlZmF1bHQpKHRoaXMuY29tcG9uZW50LCAnZmllbGRzLnllYXIuaGlkZScsIGZhbHNlKSkge1xuICAgICAgICB0aGlzLnllYXJJbnB1dC52YWx1ZSA9IHBhcnNlSW50KHBhcnRzLnNoaWZ0KCksIDEwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGZvcm1hdCBmb3IgdGhlIHZhbHVlIHN0cmluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRSYXdWYWx1ZScsXG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcmF3IHZhbHVlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0RhdGV9XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJhd1ZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0ZS5mb3JtYXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIGF0IGEgc3BlY2lmaWMgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0VmFsdWVBdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlQXQoaW5kZXgpIHtcbiAgICAgIHRoaXMuaW5wdXRzW2luZGV4XS52YWx1ZSA9IHRoaXMuZGF0ZS5mb3JtYXQodGhpcy5mb3JtYXQpO1xuICAgICAgcmV0dXJuIHRoaXMuaW5wdXRzW2luZGV4XS52YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtb250aHMnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKHRoaXMuX21vbnRocykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzO1xuICAgICAgfVxuICAgICAgdGhpcy5fbW9udGhzID0gW3sgdmFsdWU6IDAsIGxhYmVsOiAoMCwgX2dldDQuZGVmYXVsdCkodGhpcy5jb21wb25lbnQsICdmaWVsZHMubW9udGgucGxhY2Vob2xkZXInLCAnJykgfSwgeyB2YWx1ZTogMSwgbGFiZWw6IHRoaXMudCgnamFudWFyeScpIH0sIHsgdmFsdWU6IDIsIGxhYmVsOiB0aGlzLnQoJ2ZlYnJ1YXJ5JykgfSwgeyB2YWx1ZTogMywgbGFiZWw6IHRoaXMudCgnbWFyY2gnKSB9LCB7IHZhbHVlOiA0LCBsYWJlbDogdGhpcy50KCdhcHJpbCcpIH0sIHsgdmFsdWU6IDUsIGxhYmVsOiB0aGlzLnQoJ21heScpIH0sIHsgdmFsdWU6IDYsIGxhYmVsOiB0aGlzLnQoJ2p1bmUnKSB9LCB7IHZhbHVlOiA3LCBsYWJlbDogdGhpcy50KCdqdWx5JykgfSwgeyB2YWx1ZTogOCwgbGFiZWw6IHRoaXMudCgnYXVndXN0JykgfSwgeyB2YWx1ZTogOSwgbGFiZWw6IHRoaXMudCgnc2VwdGVtYmVyJykgfSwgeyB2YWx1ZTogMTAsIGxhYmVsOiB0aGlzLnQoJ29jdG9iZXInKSB9LCB7IHZhbHVlOiAxMSwgbGFiZWw6IHRoaXMudCgnbm92ZW1iZXInKSB9LCB7IHZhbHVlOiAxMiwgbGFiZWw6IHRoaXMudCgnZGVjZW1iZXInKSB9XTtcbiAgICAgIHJldHVybiB0aGlzLl9tb250aHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0JyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBmb3JtYXQgPSAnJztcbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5kYXlGaXJzdCAmJiAhKDAsIF9nZXQ0LmRlZmF1bHQpKHRoaXMuY29tcG9uZW50LCAnZmllbGRzLmRheS5oaWRlJywgZmFsc2UpKSB7XG4gICAgICAgIGZvcm1hdCArPSAnRC8nO1xuICAgICAgfVxuICAgICAgaWYgKCEoMCwgX2dldDQuZGVmYXVsdCkodGhpcy5jb21wb25lbnQsICdmaWVsZHMubW9udGguaGlkZScsIGZhbHNlKSkge1xuICAgICAgICBmb3JtYXQgKz0gJ00vJztcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5jb21wb25lbnQuZGF5Rmlyc3QgJiYgISgwLCBfZ2V0NC5kZWZhdWx0KSh0aGlzLmNvbXBvbmVudCwgJ2ZpZWxkcy5kYXkuaGlkZScsIGZhbHNlKSkge1xuICAgICAgICBmb3JtYXQgKz0gJ0QvJztcbiAgICAgIH1cbiAgICAgIGlmICghKDAsIF9nZXQ0LmRlZmF1bHQpKHRoaXMuY29tcG9uZW50LCAnZmllbGRzLnllYXIuaGlkZScsIGZhbHNlKSkge1xuICAgICAgICBmb3JtYXQgKz0gJ1lZWVknO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRhdGUgb2JqZWN0IGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJucyB7RGF0ZX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGF0ZScsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgZGF5ID0gdGhpcy5kYXlJbnB1dC52YWx1ZTtcbiAgICAgIHZhciBtb250aCA9IHRoaXMubW9udGhJbnB1dC52YWx1ZTtcbiAgICAgIHZhciB5ZWFyID0gdGhpcy55ZWFySW5wdXQudmFsdWU7XG4gICAgICByZXR1cm4gKDAsIF9tb21lbnQyLmRlZmF1bHQpKFtwYXJzZUludCh5ZWFyLCAxMCksIHBhcnNlSW50KG1vbnRoLCAxMCkgLSAxLCBwYXJzZUludChkYXksIDEwKV0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEYXlDb21wb25lbnQ7XG59KF9CYXNlLkJhc2VDb21wb25lbnQpOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRW1haWxDb21wb25lbnQgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9UZXh0RmllbGQgPSByZXF1aXJlKCcuLi90ZXh0ZmllbGQvVGV4dEZpZWxkJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEVtYWlsQ29tcG9uZW50ID0gZXhwb3J0cy5FbWFpbENvbXBvbmVudCA9IGZ1bmN0aW9uIChfVGV4dEZpZWxkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhFbWFpbENvbXBvbmVudCwgX1RleHRGaWVsZENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRW1haWxDb21wb25lbnQoY29tcG9uZW50LCBvcHRpb25zLCBkYXRhKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVtYWlsQ29tcG9uZW50KTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChFbWFpbENvbXBvbmVudC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEVtYWlsQ29tcG9uZW50KSkuY2FsbCh0aGlzLCBjb21wb25lbnQsIG9wdGlvbnMsIGRhdGEpKTtcblxuICAgIF90aGlzLnZhbGlkYXRvcnMucHVzaCgnZW1haWwnKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRW1haWxDb21wb25lbnQsIFt7XG4gICAga2V5OiAnZWxlbWVudEluZm8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbGVtZW50SW5mbygpIHtcbiAgICAgIHZhciBpbmZvID0gX2dldChFbWFpbENvbXBvbmVudC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihFbWFpbENvbXBvbmVudC5wcm90b3R5cGUpLCAnZWxlbWVudEluZm8nLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgaW5mby5hdHRyLnR5cGUgPSAnZW1haWwnO1xuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVtYWlsQ29tcG9uZW50O1xufShfVGV4dEZpZWxkLlRleHRGaWVsZENvbXBvbmVudCk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5GaWVsZHNldENvbXBvbmVudCA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9Db21wb25lbnRzID0gcmVxdWlyZSgnLi4vQ29tcG9uZW50cycpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBGaWVsZHNldENvbXBvbmVudCA9IGV4cG9ydHMuRmllbGRzZXRDb21wb25lbnQgPSBmdW5jdGlvbiAoX0Zvcm1pb0NvbXBvbmVudHMpIHtcbiAgX2luaGVyaXRzKEZpZWxkc2V0Q29tcG9uZW50LCBfRm9ybWlvQ29tcG9uZW50cyk7XG5cbiAgZnVuY3Rpb24gRmllbGRzZXRDb21wb25lbnQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZpZWxkc2V0Q29tcG9uZW50KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRmllbGRzZXRDb21wb25lbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGaWVsZHNldENvbXBvbmVudCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZpZWxkc2V0Q29tcG9uZW50LCBbe1xuICAgIGtleTogJ2J1aWxkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGQoKSB7XG4gICAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLmNlKCdlbGVtZW50JywgJ2ZpZWxkc2V0Jywge1xuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgY2xhc3M6IHRoaXMuY2xhc3NOYW1lICsgJyBmb3JtLWdyb3VwJ1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5jb21wb25lbnQubGVnZW5kKSB7XG4gICAgICAgIHZhciBsZWdlbmQgPSB0aGlzLmNlKCdsZWdlbmQnLCAnbGVnZW5kJyk7XG4gICAgICAgIGxlZ2VuZC5hcHBlbmRDaGlsZCh0aGlzLnRleHQodGhpcy5jb21wb25lbnQubGVnZW5kKSk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChsZWdlbmQpO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGRDb21wb25lbnRzKHRoaXMuZWxlbWVudCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZpZWxkc2V0Q29tcG9uZW50O1xufShfQ29tcG9uZW50cy5Gb3JtaW9Db21wb25lbnRzKTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkZvcm1Db21wb25lbnQgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9mb3JtaW8gPSByZXF1aXJlKCcuLi8uLi9mb3JtaW8uZm9ybScpO1xuXG52YXIgX2Zvcm1pbzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb3JtaW8pO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcblxudmFyIF91dGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlscyk7XG5cbnZhciBfbWVyZ2UyID0gcmVxdWlyZSgnbG9kYXNoL21lcmdlJyk7XG5cbnZhciBfbWVyZ2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWVyZ2UyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgRm9ybUNvbXBvbmVudCA9IGV4cG9ydHMuRm9ybUNvbXBvbmVudCA9IGZ1bmN0aW9uIChfRm9ybWlvRm9ybSkge1xuICBfaW5oZXJpdHMoRm9ybUNvbXBvbmVudCwgX0Zvcm1pb0Zvcm0pO1xuXG4gIGZ1bmN0aW9uIEZvcm1Db21wb25lbnQoY29tcG9uZW50LCBvcHRpb25zLCBkYXRhKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcm1Db21wb25lbnQpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEZvcm1Db21wb25lbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGb3JtQ29tcG9uZW50KSkuY2FsbCh0aGlzLCBudWxsLCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy50eXBlID0gJ2Zvcm1jb21wb25lbnQnO1xuICAgIF90aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICBfdGhpcy5zdWJtaXR0ZWQgPSBmYWxzZTtcbiAgICBfdGhpcy5kYXRhID0gZGF0YTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGlmIHJlZmVyZW5jZSBpcyBwcm92aWRlZCwgdGhlIGZvcm0gbXVzdCBzdWJtaXQuXG4gICAgaWYgKF90aGlzLmNvbXBvbmVudC5yZWZlcmVuY2UpIHtcbiAgICAgIF90aGlzLmNvbXBvbmVudC5zdWJtaXQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRoZSBzb3VyY2UgYmFzZWQgb24gdGhlIHJvb3Qgc3JjIHBhdGguXG4gICAgaWYgKCFjb21wb25lbnQuc3JjICYmIGNvbXBvbmVudC5wYXRoICYmIF90aGlzLm9wdGlvbnMuZm9ybWlvKSB7XG4gICAgICB2YXIgcm9vdFNyYyA9IF90aGlzLm9wdGlvbnMuZm9ybWlvLmZvcm1Vcmw7XG4gICAgICB2YXIgcGFydHMgPSByb290U3JjLnNwbGl0KCcvJyk7XG4gICAgICBwYXJ0cy5wb3AoKTtcbiAgICAgIGNvbXBvbmVudC5zcmMgPSBwYXJ0cy5qb2luKCcvJykgKyAnLycgKyBjb21wb25lbnQucGF0aDtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIHNvdXJjZSB0byB0aGlzIGFjdHVhbCBzdWJtaXNzaW9uIGlmIHRoZSBjb21wb25lbnQgaXMgYSByZWZlcmVuY2UuXG4gICAgaWYgKGRhdGFbY29tcG9uZW50LmtleV0gJiYgX3RoaXMuY29tcG9uZW50LnJlZmVyZW5jZSAmJiBjb21wb25lbnQuc3JjLmluZGV4T2YoJy9zdWJtaXNzaW9uLycpID09PSAtMSkge1xuICAgICAgY29tcG9uZW50LnNyYyArPSAnL3N1Ym1pc3Npb24vJyArIGRhdGFbY29tcG9uZW50LmtleV0uX2lkO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgc3JjIGlmIHRoZSBwcm9wZXJ0eSBpcyBwcm92aWRlZCBpbiB0aGUgSlNPTi5cbiAgICBpZiAoY29tcG9uZW50LnNyYykge1xuICAgICAgX3RoaXMuc3JjID0gY29tcG9uZW50LnNyYztcbiAgICB9XG5cbiAgICAvLyBEaXJlY3RseSBzZXQgdGhlIHN1Ym1pc3Npb24gaWYgaXQgaXNuJ3QgYSByZWZlcmVuY2UuXG4gICAgaWYgKGRhdGFbY29tcG9uZW50LmtleV0gJiYgIV90aGlzLmNvbXBvbmVudC5yZWZlcmVuY2UpIHtcbiAgICAgIF90aGlzLnNldFN1Ym1pc3Npb24oZGF0YVtjb21wb25lbnQua2V5XSk7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJtaXQgdGhlIGZvcm0gYmVmb3JlIHRoZSBuZXh0IHBhZ2UgaXMgdHJpZ2dlcmVkLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhGb3JtQ29tcG9uZW50LCBbe1xuICAgIGtleTogJ2JlZm9yZU5leHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiZWZvcmVOZXh0KCkge1xuICAgICAgLy8gSWYgd2Ugd2lzaCB0byBzdWJtaXQgdGhlIGZvcm0gb24gbmV4dCBwYWdlLCB0aGVuIGRvIHRoYXQgaGVyZS5cbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5zdWJtaXQpIHtcbiAgICAgICAgdGhpcy5zdWJtaXR0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJtaXQodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX2dldChGb3JtQ29tcG9uZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZvcm1Db21wb25lbnQucHJvdG90eXBlKSwgJ2JlZm9yZU5leHQnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN1Ym1pdCB0aGUgZm9ybSBiZWZvcmUgdGhlIHdob2xlIGZvcm0gaXMgdHJpZ2dlcmVkLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdiZWZvcmVTdWJtaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiZWZvcmVTdWJtaXQoKSB7XG4gICAgICAvLyBCZWZvcmUgd2Ugc3VibWl0LCB3ZSBuZWVkIHRvIGZpbHRlciBvdXQgdGhlIHJlZmVyZW5jZXMuXG4gICAgICB0aGlzLmRhdGFbdGhpcy5jb21wb25lbnQua2V5XSA9IHRoaXMuY29tcG9uZW50LnJlZmVyZW5jZSA/IHsgX2lkOiB0aGlzLl9zdWJtaXNzaW9uLl9pZCB9IDogdGhpcy5fc3VibWlzc2lvbjtcblxuICAgICAgLy8gRW5zdXJlIHdlIHN1Ym1pdCB0aGUgZm9ybS5cbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5zdWJtaXQgJiYgIXRoaXMuc3VibWl0dGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Ym1pdCh0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBfZ2V0KEZvcm1Db21wb25lbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRm9ybUNvbXBvbmVudC5wcm90b3R5cGUpLCAnYmVmb3JlU3VibWl0JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdidWlsZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkKCkge1xuICAgICAgaWYgKCF0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVFbGVtZW50KCk7XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudCh0aGlzLmVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBJdGVyYXRlIHRocm91Z2ggZXZlcnkgY29tcG9uZW50IGFuZCBoaWRlIHRoZSBzdWJtaXQgYnV0dG9uLlxuICAgICAgX3V0aWxzMi5kZWZhdWx0LmVhY2hDb21wb25lbnQodGhpcy5jb21wb25lbnQuY29tcG9uZW50cywgZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoY29tcG9uZW50LnR5cGUgPT09ICdidXR0b24nICYmIGNvbXBvbmVudC5hY3Rpb24gPT09ICdzdWJtaXQnKSB7XG4gICAgICAgICAgY29tcG9uZW50LmhpZGRlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXRoaXMuZGF0YVt0aGlzLmNvbXBvbmVudC5rZXldKSB7XG4gICAgICAgIHRoaXMuZGF0YVt0aGlzLmNvbXBvbmVudC5rZXldID0geyBkYXRhOiB7fSB9O1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgY29tcG9uZW50cyB1c2luZyB0aGUgZGF0YSBvZiB0aGUgc3VibWlzc2lvbi5cbiAgICAgIHRoaXMuYWRkQ29tcG9uZW50cyh0aGlzLmVsZW1lbnQsIHRoaXMuZGF0YVt0aGlzLmNvbXBvbmVudC5rZXldLmRhdGEpO1xuXG4gICAgICAvLyBTZXQgZGVmYXVsdCB2YWx1ZXMuXG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gdGhpcy5kZWZhdWx0VmFsdWU7XG4gICAgICBpZiAoZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0VmFsdWUoZGVmYXVsdFZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgY29uZGl0aW9ucyBmb3IgdGhpcyBmb3JtLlxuICAgICAgdGhpcy5jaGVja0NvbmRpdGlvbnModGhpcy5nZXRWYWx1ZSgpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKHN1Ym1pc3Npb24sIG5vVXBkYXRlLCBub1ZhbGlkYXRlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKCFzdWJtaXNzaW9uKSB7XG4gICAgICAgIHRoaXMuZGF0YVt0aGlzLmNvbXBvbmVudC5rZXldID0gdGhpcy5fc3VibWlzc2lvbiA9IHsgZGF0YToge30gfTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3VibWlzc2lvbi5kYXRhKSB7XG4gICAgICAgIHRoaXMuX3N1Ym1pc3Npb24gPSAoMCwgX21lcmdlMy5kZWZhdWx0KSh0aGlzLmRhdGFbdGhpcy5jb21wb25lbnQua2V5XSwgc3VibWlzc2lvbik7XG4gICAgICAgIHJldHVybiBfZ2V0KEZvcm1Db21wb25lbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRm9ybUNvbXBvbmVudC5wcm90b3R5cGUpLCAnc2V0VmFsdWUnLCB0aGlzKS5jYWxsKHRoaXMsIHN1Ym1pc3Npb24sIG5vVXBkYXRlLCBub1ZhbGlkYXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VibWlzc2lvbi5faWQpIHtcbiAgICAgICAgdGhpcy5mb3JtaW8uc3VibWlzc2lvbklkID0gc3VibWlzc2lvbi5faWQ7XG4gICAgICAgIHRoaXMuZm9ybWlvLnN1Ym1pc3Npb25VcmwgPSB0aGlzLmZvcm1pby5zdWJtaXNzaW9uc1VybCArICcvJyArIHN1Ym1pc3Npb24uX2lkO1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtUmVhZHkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLl9sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgX3RoaXMyLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBfdGhpczIuZm9ybWlvLmxvYWRTdWJtaXNzaW9uKCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBfdGhpczIubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5zZXRWYWx1ZShyZXN1bHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLmNvbXBvbmVudC5rZXldO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGb3JtQ29tcG9uZW50O1xufShfZm9ybWlvMi5kZWZhdWx0KTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkdtYXBDb21wb25lbnQgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9CYXNlID0gcmVxdWlyZSgnLi4vYmFzZS9CYXNlJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEdtYXBDb21wb25lbnQgPSBleHBvcnRzLkdtYXBDb21wb25lbnQgPSBmdW5jdGlvbiAoX0Jhc2VDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEdtYXBDb21wb25lbnQsIF9CYXNlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBHbWFwQ29tcG9uZW50KGNvbXBvbmVudCwgb3B0aW9ucywgZGF0YSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHbWFwQ29tcG9uZW50KTtcblxuICAgIC8vIEdldCB0aGUgc291cmNlIGZvciBHb29nbGUgTWFwcyBBUElcbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoR21hcENvbXBvbmVudC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEdtYXBDb21wb25lbnQpKS5jYWxsKHRoaXMsIGNvbXBvbmVudCwgb3B0aW9ucywgZGF0YSkpO1xuXG4gICAgdmFyIHNyYyA9ICdodHRwczovL21hcHMuZ29vZ2xlYXBpcy5jb20vbWFwcy9hcGkvanM/dj0zJmxpYnJhcmllcz1wbGFjZXMmY2FsbGJhY2s9Z29vZ2xlTWFwc0NhbGxiYWNrJztcbiAgICBpZiAoY29tcG9uZW50Lm1hcCAmJiBjb21wb25lbnQubWFwLmtleSkge1xuICAgICAgc3JjICs9ICcma2V5PScgKyBjb21wb25lbnQubWFwLmtleTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudC5tYXAgJiYgY29tcG9uZW50Lm1hcC5yZWdpb24pIHtcbiAgICAgIHNyYyArPSAnJnJlZ2lvbj0nICsgY29tcG9uZW50Lm1hcC5yZWdpb247XG4gICAgfVxuICAgIF9CYXNlLkJhc2VDb21wb25lbnQucmVxdWlyZUxpYnJhcnkoJ2dvb2dsZU1hcHMnLCAnZ29vZ2xlLm1hcHMucGxhY2VzJywgc3JjKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoR21hcENvbXBvbmVudCwgW3tcbiAgICBrZXk6ICdidWlsZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkKCkge1xuICAgICAgdGhpcy5lbGVtZW50ID0gdGhpcy5jZSgnZWxlbWVudCcsICdkaXYnLCB7XG4gICAgICAgIGNsYXNzOiAnbWFwLWNvbnRhaW5lcidcbiAgICAgIH0pO1xuICAgICAgdGhpcy5pbml0R29vZ2xlTWFwKCk7XG4gICAgICB0aGlzLmlucHV0ID0gdGhpcy5jcmVhdGVJbnB1dCh0aGlzLmVsZW1lbnQpO1xuICAgICAgdGhpcy5hZGRJbnB1dCh0aGlzLmlucHV0LCB0aGlzLmVsZW1lbnQpO1xuICAgICAgdmFyIGdtYXBFbGVtZW50ID0gdGhpcy5jZSgnZ21hcEVsZW1lbnQnLCAnZGl2Jywge1xuICAgICAgICBpZDogdGhpcy5jb21wb25lbnQubWFwLmdtYXBJZCxcbiAgICAgICAgc3R5bGU6IFwibWluLWhlaWdodDogMzAwcHg7IGhlaWdodDogY2FsYygxMDB2aCAtIDYwMHB4KTtcIlxuICAgICAgfSk7XG4gICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoZ21hcEVsZW1lbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUodmFsdWUsIG5vVXBkYXRlKSB7XG4gICAgICBfZ2V0KEdtYXBDb21wb25lbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoR21hcENvbXBvbmVudC5wcm90b3R5cGUpLCAnc2V0VmFsdWUnLCB0aGlzKS5jYWxsKHRoaXMsIHZhbHVlLCBub1VwZGF0ZSwgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWRkSW5wdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJbnB1dChpbnB1dCwgY29udGFpbmVyKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgX2dldChHbWFwQ29tcG9uZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEdtYXBDb21wb25lbnQucHJvdG90eXBlKSwgJ2FkZElucHV0JywgdGhpcykuY2FsbCh0aGlzLCBpbnB1dCwgY29udGFpbmVyKTtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIF9CYXNlLkJhc2VDb21wb25lbnQubGlicmFyeVJlYWR5KCdnb29nbGVNYXBzJykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhdXRvY29tcGxldGVPcHRpb25zID0ge307XG4gICAgICAgIGlmIChfdGhpczIuY29tcG9uZW50Lm1hcCkge1xuICAgICAgICAgIGF1dG9jb21wbGV0ZU9wdGlvbnMgPSBfdGhpczIuY29tcG9uZW50Lm1hcC5hdXRvY29tcGxldGVPcHRpb25zIHx8IHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdXRvY29tcGxldGUgPSBuZXcgZ29vZ2xlLm1hcHMucGxhY2VzLkF1dG9jb21wbGV0ZShpbnB1dCwgYXV0b2NvbXBsZXRlT3B0aW9ucyk7XG4gICAgICAgIGF1dG9jb21wbGV0ZS5hZGRMaXN0ZW5lcigncGxhY2VfY2hhbmdlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0Lm1hcmtlci5zZXRWaXNpYmxlKGZhbHNlKTtcbiAgICAgICAgICB2YXIgcGxhY2UgPSBhdXRvY29tcGxldGUuZ2V0UGxhY2UoKTtcbiAgICAgICAgICBpZiAoIXBsYWNlLmdlb21ldHJ5KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkF1dG9jb21wbGV0ZSdzIHJldHVybmVkIHBsYWNlIGNvbnRhaW5zIG5vIGdlb21ldHJ5XCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSBwbGFjZSBoYXMgYSBnZW9tZXRyeSwgdGhlbiBwcmVzZW50IGl0IG9uIGEgbWFwLlxuICAgICAgICAgIGlmIChwbGFjZS5nZW9tZXRyeS52aWV3cG9ydCkge1xuICAgICAgICAgICAgdGhhdC5tYXAuZml0Qm91bmRzKHBsYWNlLmdlb21ldHJ5LnZpZXdwb3J0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhhdC5tYXAuc2V0Q2VudGVyKHBsYWNlLmdlb21ldHJ5LmxvY2F0aW9uKTtcbiAgICAgICAgICAgIHRoYXQubWFwLnNldFpvb20oMTcpOyAvLyBXaHkgMTc/IEJlY2F1c2UgaXQgbG9va3MgZ29vZC5cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhhdC5tYXJrZXIuc2V0SWNvbiggLyoqIEB0eXBlIHtnb29nbGUubWFwcy5JY29ufSAqL3tcbiAgICAgICAgICAgIHVybDogcGxhY2UuaWNvbixcbiAgICAgICAgICAgIHNpemU6IG5ldyBnb29nbGUubWFwcy5TaXplKDcxLCA3MSksXG4gICAgICAgICAgICBvcmlnaW46IG5ldyBnb29nbGUubWFwcy5Qb2ludCgwLCAwKSxcbiAgICAgICAgICAgIGFuY2hvcjogbmV3IGdvb2dsZS5tYXBzLlBvaW50KDE3LCAzNCksXG4gICAgICAgICAgICBzY2FsZWRTaXplOiBuZXcgZ29vZ2xlLm1hcHMuU2l6ZSgzNSwgMzUpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhhdC5tYXJrZXIuc2V0UG9zaXRpb24ocGxhY2UuZ2VvbWV0cnkubG9jYXRpb24pO1xuICAgICAgICAgIHRoYXQubWFya2VyLnNldFZpc2libGUodHJ1ZSk7XG4gICAgICAgICAgdmFyIGFkZHJlc3MgPSAnJztcbiAgICAgICAgICBpZiAocGxhY2UuYWRkcmVzc19jb21wb25lbnRzKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gW3BsYWNlLmFkZHJlc3NfY29tcG9uZW50c1swXSAmJiBwbGFjZS5hZGRyZXNzX2NvbXBvbmVudHNbMF0uc2hvcnRfbmFtZSB8fCAnJywgcGxhY2UuYWRkcmVzc19jb21wb25lbnRzWzFdICYmIHBsYWNlLmFkZHJlc3NfY29tcG9uZW50c1sxXS5zaG9ydF9uYW1lIHx8ICcnLCBwbGFjZS5hZGRyZXNzX2NvbXBvbmVudHNbMl0gJiYgcGxhY2UuYWRkcmVzc19jb21wb25lbnRzWzJdLnNob3J0X25hbWUgfHwgJyddLmpvaW4oJyAnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhhdC5zZXRWYWx1ZShwbGFjZS5uYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlbGVtZW50SW5mbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVsZW1lbnRJbmZvKCkge1xuICAgICAgdmFyIGluZm8gPSBfZ2V0KEdtYXBDb21wb25lbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoR21hcENvbXBvbmVudC5wcm90b3R5cGUpLCAnZWxlbWVudEluZm8nLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgaW5mby5hdHRyLmNsYXNzICs9ICcgR21hcC1zZWFyY2gnO1xuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5pdEdvb2dsZU1hcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRHb29nbGVNYXAoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgX0Jhc2UuQmFzZUNvbXBvbmVudC5saWJyYXJ5UmVhZHkoJ2dvb2dsZU1hcHMnKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRMYXRsbmcgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKDQ1LjUwNDE0ODIsIC03My41NTc0MTI1KTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgem9vbTogMTksXG4gICAgICAgICAgY2VudGVyOiBkZWZhdWx0TGF0bG5nLFxuICAgICAgICAgIG1hcFR5cGVJZDogZ29vZ2xlLm1hcHMuTWFwVHlwZUlkLlJPQURNQVAsXG4gICAgICAgICAgc3R5bGVzOiBbe1xuICAgICAgICAgICAgXCJmZWF0dXJlVHlwZVwiOiBcInBvaVwiLFxuICAgICAgICAgICAgXCJzdHlsZXJzXCI6IFt7XG4gICAgICAgICAgICAgIFwidmlzaWJpbGl0eVwiOiBcIm9mZlwiXG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwiZmVhdHVyZVR5cGVcIjogXCJ0cmFuc2l0XCIsXG4gICAgICAgICAgICBcInN0eWxlcnNcIjogW3tcbiAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5XCI6IFwib2ZmXCJcbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfV1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbWFwRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKF90aGlzMy5jb21wb25lbnQubWFwLmdtYXBJZCk7XG4gICAgICAgIGlmICghbWFwRWxlbWVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfdGhpczMubWFwID0gbmV3IGdvb2dsZS5tYXBzLk1hcChtYXBFbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgX3RoaXMzLmFkZE1hcmtlcihkZWZhdWx0TGF0bG5nLCAnRGVmYXVsdCBNYXJrZXInLCBfdGhpczMubWFwKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FkZE1hcmtlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE1hcmtlcihsYXRsbmcsIHRpdGxlLCBtYXApIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHRoaXMubWFya2VyID0gbmV3IGdvb2dsZS5tYXBzLk1hcmtlcih7XG4gICAgICAgIHBvc2l0aW9uOiBsYXRsbmcsXG4gICAgICAgIG1hcDogbWFwLFxuICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgIGRyYWdnYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLm1hcmtlci5hZGRMaXN0ZW5lcignZHJhZ2VuZCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgZ2VvY29kZXIgPSBuZXcgZ29vZ2xlLm1hcHMuR2VvY29kZXIoKTtcbiAgICAgICAgdmFyIGxhdGxuZyA9IHsgbGF0OiBwYXJzZUZsb2F0KGV2ZW50LmxhdExuZy5sYXQoKSksIGxuZzogcGFyc2VGbG9hdChldmVudC5sYXRMbmcubG5nKCkpIH07XG4gICAgICAgIGdlb2NvZGVyLmdlb2NvZGUoeyAnbG9jYXRpb24nOiBsYXRsbmcgfSwgZnVuY3Rpb24gKHJlc3VsdHMsIHN0YXR1cykge1xuICAgICAgICAgIGlmIChzdGF0dXMgPT09IGdvb2dsZS5tYXBzLkdlb2NvZGVyU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0c1sxXSkge1xuICAgICAgICAgICAgICB0aGF0LnNldFZhbHVlKHJlc3VsdHNbMF0uZm9ybWF0dGVkX2FkZHJlc3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ05vIHJlc3VsdHMgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0dlb2NvZGVyIGZhaWxlZCBkdWUgdG86ICcgKyBzdGF0dXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gR21hcENvbXBvbmVudDtcbn0oX0Jhc2UuQmFzZUNvbXBvbmVudCk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5IaWRkZW5Db21wb25lbnQgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9CYXNlID0gcmVxdWlyZSgnLi4vYmFzZS9CYXNlJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEhpZGRlbkNvbXBvbmVudCA9IGV4cG9ydHMuSGlkZGVuQ29tcG9uZW50ID0gZnVuY3Rpb24gKF9CYXNlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhIaWRkZW5Db21wb25lbnQsIF9CYXNlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBIaWRkZW5Db21wb25lbnQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhpZGRlbkNvbXBvbmVudCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEhpZGRlbkNvbXBvbmVudC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEhpZGRlbkNvbXBvbmVudCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEhpZGRlbkNvbXBvbmVudCwgW3tcbiAgICBrZXk6ICdlbGVtZW50SW5mbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVsZW1lbnRJbmZvKCkge1xuICAgICAgdmFyIGluZm8gPSBfZ2V0KEhpZGRlbkNvbXBvbmVudC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihIaWRkZW5Db21wb25lbnQucHJvdG90eXBlKSwgJ2VsZW1lbnRJbmZvJywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIGluZm8udHlwZSA9ICdpbnB1dCc7XG4gICAgICBpbmZvLmF0dHIudHlwZSA9ICdoaWRkZW4nO1xuICAgICAgaW5mby5jaGFuZ2VFdmVudCA9ICdjaGFuZ2UnO1xuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlTGFiZWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVMYWJlbChjb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSGlkZGVuQ29tcG9uZW50O1xufShfQmFzZS5CYXNlQ29tcG9uZW50KTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkhUTUxDb21wb25lbnQgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfQmFzZSA9IHJlcXVpcmUoJy4uL2Jhc2UvQmFzZScpO1xuXG52YXIgX2VhY2gyID0gcmVxdWlyZSgnbG9kYXNoL2VhY2gnKTtcblxudmFyIF9lYWNoMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2gyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgSFRNTENvbXBvbmVudCA9IGV4cG9ydHMuSFRNTENvbXBvbmVudCA9IGZ1bmN0aW9uIChfQmFzZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoSFRNTENvbXBvbmVudCwgX0Jhc2VDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEhUTUxDb21wb25lbnQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhUTUxDb21wb25lbnQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChIVE1MQ29tcG9uZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSFRNTENvbXBvbmVudCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEhUTUxDb21wb25lbnQsIFt7XG4gICAga2V5OiAnYnVpbGQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLmNlKCdlbGVtZW50JywgdGhpcy5jb21wb25lbnQudGFnLCB7XG4gICAgICAgIGNsYXNzOiB0aGlzLmNvbXBvbmVudC5jbGFzc05hbWVcbiAgICAgIH0pO1xuICAgICAgKDAsIF9lYWNoMy5kZWZhdWx0KSh0aGlzLmNvbXBvbmVudC5hdHRycywgZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgaWYgKGF0dHIuYXR0cikge1xuICAgICAgICAgIF90aGlzMi5lbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyLmF0dHIsIGF0dHIudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5jb250ZW50KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLmNvbXBvbmVudC5jb250ZW50O1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIVE1MQ29tcG9uZW50O1xufShfQmFzZS5CYXNlQ29tcG9uZW50KTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfQWRkcmVzcyA9IHJlcXVpcmUoJy4vYWRkcmVzcy9BZGRyZXNzJyk7XG5cbnZhciBfQmFzZSA9IHJlcXVpcmUoJy4vYmFzZS9CYXNlJyk7XG5cbnZhciBfQ29udGVudCA9IHJlcXVpcmUoJy4vY29udGVudC9Db250ZW50Jyk7XG5cbnZhciBfQ29udGFpbmVyID0gcmVxdWlyZSgnLi9jb250YWluZXIvQ29udGFpbmVyJyk7XG5cbnZhciBfRGF0YUdyaWQgPSByZXF1aXJlKCcuL2RhdGFncmlkL0RhdGFHcmlkJyk7XG5cbnZhciBfRGF0ZVRpbWUgPSByZXF1aXJlKCcuL2RhdGV0aW1lL0RhdGVUaW1lJyk7XG5cbnZhciBfRGF5ID0gcmVxdWlyZSgnLi9kYXkvRGF5Jyk7XG5cbnZhciBfSFRNTCA9IHJlcXVpcmUoJy4vaHRtbC9IVE1MJyk7XG5cbnZhciBfSGlkZGVuID0gcmVxdWlyZSgnLi9oaWRkZW4vSGlkZGVuJyk7XG5cbnZhciBfRm9ybSA9IHJlcXVpcmUoJy4vZm9ybS9Gb3JtJyk7XG5cbnZhciBfVGV4dEZpZWxkID0gcmVxdWlyZSgnLi90ZXh0ZmllbGQvVGV4dEZpZWxkJyk7XG5cbnZhciBfUGhvbmVOdW1iZXIgPSByZXF1aXJlKCcuL3Bob25lbnVtYmVyL1Bob25lTnVtYmVyJyk7XG5cbnZhciBfRW1haWwgPSByZXF1aXJlKCcuL2VtYWlsL0VtYWlsJyk7XG5cbnZhciBfQ2hlY2tib3ggPSByZXF1aXJlKCcuL2NoZWNrYm94L0NoZWNrYm94Jyk7XG5cbnZhciBfQ3VycmVuY3kgPSByZXF1aXJlKCcuL2N1cnJlbmN5L0N1cnJlbmN5Jyk7XG5cbnZhciBfRmllbGRzZXQgPSByZXF1aXJlKCcuL2ZpZWxkc2V0L0ZpZWxkc2V0Jyk7XG5cbnZhciBfU2lnbmF0dXJlID0gcmVxdWlyZSgnLi9zaWduYXR1cmUvU2lnbmF0dXJlJyk7XG5cbnZhciBfU2VsZWN0ID0gcmVxdWlyZSgnLi9zZWxlY3QvU2VsZWN0Jyk7XG5cbnZhciBfUmVzb3VyY2UgPSByZXF1aXJlKCcuL3Jlc291cmNlL1Jlc291cmNlJyk7XG5cbnZhciBfVGV4dEFyZWEgPSByZXF1aXJlKCcuL3RleHRhcmVhL1RleHRBcmVhJyk7XG5cbnZhciBfQnV0dG9uID0gcmVxdWlyZSgnLi9idXR0b24vQnV0dG9uJyk7XG5cbnZhciBfTnVtYmVyID0gcmVxdWlyZSgnLi9udW1iZXIvTnVtYmVyJyk7XG5cbnZhciBfUGFzc3dvcmQgPSByZXF1aXJlKCcuL3Bhc3N3b3JkL1Bhc3N3b3JkJyk7XG5cbnZhciBfUGFuZWwgPSByZXF1aXJlKCcuL3BhbmVsL1BhbmVsJyk7XG5cbnZhciBfQ29sdW1uID0gcmVxdWlyZSgnLi9jb2x1bW5zL0NvbHVtbicpO1xuXG52YXIgX0NvbHVtbnMgPSByZXF1aXJlKCcuL2NvbHVtbnMvQ29sdW1ucycpO1xuXG52YXIgX1RhYmxlID0gcmVxdWlyZSgnLi90YWJsZS9UYWJsZScpO1xuXG52YXIgX1Vua25vd24gPSByZXF1aXJlKCcuL3Vua25vd24vVW5rbm93bicpO1xuXG52YXIgX1JhZGlvID0gcmVxdWlyZSgnLi9yYWRpby9SYWRpbycpO1xuXG52YXIgX1NlbGVjdEJveGVzID0gcmVxdWlyZSgnLi9zZWxlY3Rib3hlcy9TZWxlY3RCb3hlcycpO1xuXG52YXIgX1N1cnZleSA9IHJlcXVpcmUoJy4vc3VydmV5L1N1cnZleScpO1xuXG52YXIgX1dlbGwgPSByZXF1aXJlKCcuL3dlbGwvV2VsbCcpO1xuXG52YXIgX0dtYXAgPSByZXF1aXJlKCcuL2dtYXAvR21hcCcpO1xuXG52YXIgX0pvcm5heWEgPSByZXF1aXJlKCcuL2pvcm5heWEvSm9ybmF5YScpO1xuXG52YXIgX0J1dHRvblZhbHVlID0gcmVxdWlyZSgnLi9idXR0b252YWx1ZS9CdXR0b25WYWx1ZScpO1xuXG52YXIgX1NsaWRlciA9IHJlcXVpcmUoJy4vc2xpZGVyL1NsaWRlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRkcmVzczogX0FkZHJlc3MuQWRkcmVzc0NvbXBvbmVudCxcbiAgYmFzZTogX0Jhc2UuQmFzZUNvbXBvbmVudCxcbiAgY29udGVudDogX0NvbnRlbnQuQ29udGVudENvbXBvbmVudCxcbiAgY29udGFpbmVyOiBfQ29udGFpbmVyLkNvbnRhaW5lckNvbXBvbmVudCxcbiAgZGF0YWdyaWQ6IF9EYXRhR3JpZC5EYXRhR3JpZENvbXBvbmVudCxcbiAgZGF0ZXRpbWU6IF9EYXRlVGltZS5EYXRlVGltZUNvbXBvbmVudCxcbiAgZGF5OiBfRGF5LkRheUNvbXBvbmVudCxcbiAgaHRtbGVsZW1lbnQ6IF9IVE1MLkhUTUxDb21wb25lbnQsXG4gIGhpZGRlbjogX0hpZGRlbi5IaWRkZW5Db21wb25lbnQsXG4gIGZvcm06IF9Gb3JtLkZvcm1Db21wb25lbnQsXG4gIHRleHRmaWVsZDogX1RleHRGaWVsZC5UZXh0RmllbGRDb21wb25lbnQsXG4gIHBob25lTnVtYmVyOiBfUGhvbmVOdW1iZXIuUGhvbmVOdW1iZXJDb21wb25lbnQsXG4gIGVtYWlsOiBfRW1haWwuRW1haWxDb21wb25lbnQsXG4gIGNoZWNrYm94OiBfQ2hlY2tib3guQ2hlY2tCb3hDb21wb25lbnQsXG4gIGN1cnJlbmN5OiBfQ3VycmVuY3kuQ3VycmVuY3lDb21wb25lbnQsXG4gIGZpZWxkc2V0OiBfRmllbGRzZXQuRmllbGRzZXRDb21wb25lbnQsXG4gIHNpZ25hdHVyZTogX1NpZ25hdHVyZS5TaWduYXR1cmVDb21wb25lbnQsXG4gIHNlbGVjdDogX1NlbGVjdC5TZWxlY3RDb21wb25lbnQsXG4gIHJlc291cmNlOiBfUmVzb3VyY2UuUmVzb3VyY2VDb21wb25lbnQsXG4gIHRleHRhcmVhOiBfVGV4dEFyZWEuVGV4dEFyZWFDb21wb25lbnQsXG4gIGJ1dHRvbjogX0J1dHRvbi5CdXR0b25Db21wb25lbnQsXG4gIG51bWJlcjogX051bWJlci5OdW1iZXJDb21wb25lbnQsXG4gIHBhc3N3b3JkOiBfUGFzc3dvcmQuUGFzc3dvcmRDb21wb25lbnQsXG4gIHBhbmVsOiBfUGFuZWwuUGFuZWxDb21wb25lbnQsXG4gIGNvbHVtbjogX0NvbHVtbi5Db2x1bW5Db21wb25lbnQsXG4gIGNvbHVtbnM6IF9Db2x1bW5zLkNvbHVtbnNDb21wb25lbnQsXG4gIHRhYmxlOiBfVGFibGUuVGFibGVDb21wb25lbnQsXG4gIHVua25vd246IF9Vbmtub3duLlVua25vd25Db21wb25lbnQsXG4gIHJhZGlvOiBfUmFkaW8uUmFkaW9Db21wb25lbnQsXG4gIHNlbGVjdGJveGVzOiBfU2VsZWN0Qm94ZXMuU2VsZWN0Qm94ZXNDb21wb25lbnQsXG4gIHN1cnZleTogX1N1cnZleS5TdXJ2ZXlDb21wb25lbnQsXG4gIHdlbGw6IF9XZWxsLldlbGxDb21wb25lbnQsXG4gIGdtYXA6IF9HbWFwLkdtYXBDb21wb25lbnQsXG4gIGpvcm5heWE6IF9Kb3JuYXlhLkpvcm5heWFDb21wb25lbnQsXG4gIGJ1dHRvbnZhbHVlOiBfQnV0dG9uVmFsdWUuQnV0dG9uVmFsdWVDb21wb25lbnQsXG4gIHNsaWRlcjogX1NsaWRlci5TbGlkZXJDb21wb25lbnQsXG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKGNvbXBvbmVudCwgb3B0aW9ucywgZGF0YSkge1xuICAgIHZhciBjb21wID0gbnVsbDtcbiAgICBpZiAoIWNvbXBvbmVudC50eXBlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoY29tcG9uZW50LnR5cGUpKSB7XG4gICAgICBjb21wID0gbmV3IHRoaXNbY29tcG9uZW50LnR5cGVdKGNvbXBvbmVudCwgb3B0aW9ucywgZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXAgPSBuZXcgX1Vua25vd24uVW5rbm93bkNvbXBvbmVudChjb21wb25lbnQsIG9wdGlvbnMsIGRhdGEpO1xuICAgIH1cbiAgICBjb21wLmJ1aWxkKCk7XG4gICAgcmV0dXJuIGNvbXA7XG4gIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Kb3JuYXlhQ29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfQmFzZSA9IHJlcXVpcmUoJy4uL2Jhc2UvQmFzZScpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBKb3JuYXlhQ29tcG9uZW50ID0gZXhwb3J0cy5Kb3JuYXlhQ29tcG9uZW50ID0gZnVuY3Rpb24gKF9CYXNlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhKb3JuYXlhQ29tcG9uZW50LCBfQmFzZUNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gSm9ybmF5YUNvbXBvbmVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSm9ybmF5YUNvbXBvbmVudCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEpvcm5heWFDb21wb25lbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihKb3JuYXlhQ29tcG9uZW50KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSm9ybmF5YUNvbXBvbmVudCwgW3tcbiAgICBrZXk6ICdlbGVtZW50SW5mbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVsZW1lbnRJbmZvKCkge1xuICAgICAgdmFyIGluZm8gPSBfZ2V0KEpvcm5heWFDb21wb25lbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoSm9ybmF5YUNvbXBvbmVudC5wcm90b3R5cGUpLCAnZWxlbWVudEluZm8nLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgaW5mby50eXBlID0gJ2lucHV0JztcbiAgICAgIGluZm8uY2hhbmdlRXZlbnQgPSAnY2xpY2snO1xuICAgICAgaW5mby5hdHRyLnR5cGUgPSB0aGlzLmNvbXBvbmVudC5pbnB1dFR5cGU7XG4gICAgICBpbmZvLmF0dHIuY2xhc3MgPSAnJztcbiAgICAgIGluZm8uYXR0ci5pZCA9ICdsZWFkX3RjcGFfZGlzY2xvc3VyZSc7XG4gICAgICBpZiAodGhpcy5jb21wb25lbnQubmFtZSkge1xuICAgICAgICBpbmZvLmF0dHIubmFtZSA9ICdkYXRhWycgKyB0aGlzLmNvbXBvbmVudC5uYW1lICsgJ10nO1xuICAgICAgfVxuICAgICAgaW5mby5hdHRyLnZhbHVlID0gdGhpcy5jb21wb25lbnQudmFsdWUgPyB0aGlzLmNvbXBvbmVudC52YWx1ZSA6IDA7XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdidWlsZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkKCkge1xuICAgICAgaWYgKCF0aGlzLmNvbXBvbmVudC5pbnB1dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmNyZWF0ZUVsZW1lbnQoKTtcbiAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLmNyZWF0ZUlucHV0KHRoaXMuZWxlbWVudCk7XG4gICAgICB0aGlzLmNyZWF0ZUxhYmVsKHRoaXMuZWxlbWVudCwgdGhpcy5pbnB1dCk7XG4gICAgICBpZiAoIXRoaXMubGFiZWwpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dCh0aGlzLmlucHV0LCB0aGlzLmVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWFkT25seSkge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjcmVhdGVFbGVtZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlRWxlbWVudCgpIHtcbiAgICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZTtcbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5sYWJlbCkge1xuICAgICAgICBjbGFzc05hbWUgKz0gJyBjaGVja2JveCc7XG4gICAgICB9XG4gICAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLmNlKCdlbGVtZW50JywgJ2RpdicsIHtcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIGNsYXNzOiBjbGFzc05hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZUxhYmVsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlTGFiZWwoY29udGFpbmVyLCBpbnB1dCkge1xuICAgICAgaWYgKCF0aGlzLmNvbXBvbmVudC5sYWJlbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFiZWwgPSB0aGlzLmNlKCdsYWJlbCcsICdsYWJlbCcsIHtcbiAgICAgICAgY2xhc3M6ICdjb250cm9sLWxhYmVsJ1xuICAgICAgfSk7XG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgU1BBTiBhcm91bmQgdGhlIHRleHROb2RlIGZvciBiZXR0ZXIgc3R5bGUgaG9va3NcbiAgICAgIHRoaXMubGFiZWxTcGFuID0gdGhpcy5jZSgnbGFiZWxTcGFuJywgJ3NwYW4nKTtcblxuICAgICAgaWYgKHRoaXMuaW5mby5hdHRyLmlkKSB7XG4gICAgICAgIHRoaXMubGFiZWwuc2V0QXR0cmlidXRlKCdmb3InLCB0aGlzLmluZm8uYXR0ci5pZCk7XG4gICAgICB9XG4gICAgICB0aGlzLmFkZElucHV0KGlucHV0LCB0aGlzLmxhYmVsKTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmlucHV0c09ubHkpIHtcbiAgICAgICAgLy8gRE1TXG5cbiAgICAgICAgLy90aGlzLmxhYmVsU3Bhbi5hcHBlbmRDaGlsZCh0aGlzLnRleHQodGhpcy5jb21wb25lbnQubGFiZWwpKTtcbiAgICAgICAgLy90aGlzLmxhYmVsLmFwcGVuZENoaWxkKHRoaXMubGFiZWxTcGFuKTtcblxuICAgICAgICB2YXIgbGFiZWxFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGxhYmVsRWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLmNvbXBvbmVudC5sYWJlbDtcbiAgICAgICAgdGhpcy5sYWJlbC5hcHBlbmRDaGlsZChsYWJlbEVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubGFiZWwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZUlucHV0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlSW5wdXQoY29udGFpbmVyKSB7XG4gICAgICBpZiAoIXRoaXMuY29tcG9uZW50LmlucHV0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpbnB1dCA9IHRoaXMuY2UoJ2lucHV0JywgdGhpcy5pbmZvLnR5cGUsIHRoaXMuaW5mby5hdHRyKTtcbiAgICAgIHRoaXMuZXJyb3JDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWRkSW5wdXRFdmVudExpc3RlbmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5wdXRFdmVudExpc3RlbmVyKGlucHV0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGlucHV0LCB0aGlzLmluZm8uY2hhbmdlRXZlbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpbnB1dCBoYXMgYSBcIm5hbWVcIiwgdGhlbiBpdHMgb3RoZXIgaW5wdXQgZWxlbWVudHMgYXJlIGVsc2V3aGVyZSBvblxuICAgICAgICAvLyB0aGUgZm9ybS4gVG8gZ2V0IHRoZSBjb3JyZWN0IHN1Ym1pc3Npb24gb2JqZWN0LCB3ZSBuZWVkIHRvIHJlZnJlc2ggdGhlIHdob2xlXG4gICAgICAgIC8vIGRhdGEgb2JqZWN0LlxuICAgICAgICBpZiAoX3RoaXMyLmNvbXBvbmVudC5uYW1lKSB7XG4gICAgICAgICAgX3RoaXMyLmVtaXQoJ3JlZnJlc2hEYXRhJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMyLnVwZGF0ZVZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFZhbHVlQXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZUF0KGluZGV4KSB7XG4gICAgICByZXR1cm4gISF0aGlzLmlucHV0c1tpbmRleF0uY2hlY2tlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKHZhbHVlLCBub1VwZGF0ZSwgbm9WYWxpZGF0ZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKCF0aGlzLmlucHV0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gJ29uJykge1xuICAgICAgICB0aGlzLmlucHV0LnZhbHVlID0gMTtcbiAgICAgICAgdGhpcy5pbnB1dC5jaGVja2VkID0gMTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICdvZmYnKSB7XG4gICAgICAgIHRoaXMuaW5wdXQudmFsdWUgPSAwO1xuICAgICAgICB0aGlzLmlucHV0LmNoZWNrZWQgPSAwO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmlucHV0LnZhbHVlID0gMTtcbiAgICAgICAgdGhpcy5pbnB1dC5jaGVja2VkID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5wdXQudmFsdWUgPSAwO1xuICAgICAgICB0aGlzLmlucHV0LmNoZWNrZWQgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKCFub1VwZGF0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKG5vVmFsaWRhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBKb3JuYXlhQ29tcG9uZW50O1xufShfQmFzZS5CYXNlQ29tcG9uZW50KTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLk51bWJlckNvbXBvbmVudCA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX0Jhc2UgPSByZXF1aXJlKCcuLi9iYXNlL0Jhc2UnKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgTnVtYmVyQ29tcG9uZW50ID0gZXhwb3J0cy5OdW1iZXJDb21wb25lbnQgPSBmdW5jdGlvbiAoX0Jhc2VDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE51bWJlckNvbXBvbmVudCwgX0Jhc2VDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIE51bWJlckNvbXBvbmVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVyQ29tcG9uZW50KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTnVtYmVyQ29tcG9uZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVtYmVyQ29tcG9uZW50KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTnVtYmVyQ29tcG9uZW50LCBbe1xuICAgIGtleTogJ2VsZW1lbnRJbmZvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWxlbWVudEluZm8oKSB7XG4gICAgICB2YXIgaW5mbyA9IF9nZXQoTnVtYmVyQ29tcG9uZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWJlckNvbXBvbmVudC5wcm90b3R5cGUpLCAnZWxlbWVudEluZm8nLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgaW5mby50eXBlID0gJ2lucHV0JztcbiAgICAgIGluZm8uYXR0ci50eXBlID0gJ251bWJlcic7XG4gICAgICBpbmZvLmNoYW5nZUV2ZW50ID0gJ2lucHV0JztcbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudC52YWxpZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQudmFsaWRhdGUubWluICE9PSAnJykge1xuICAgICAgICAgIGluZm8uYXR0ci5taW4gPSB0aGlzLmNvbXBvbmVudC52YWxpZGF0ZS5taW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50LnZhbGlkYXRlLm1heCAhPT0gJycpIHtcbiAgICAgICAgICBpbmZvLmF0dHIubWF4ID0gdGhpcy5jb21wb25lbnQudmFsaWRhdGUubWF4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5zdGVwICE9PSAnJykge1xuICAgICAgICAgIGluZm8uYXR0ci5zdGVwID0gdGhpcy5jb21wb25lbnQudmFsaWRhdGUuc3RlcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VmFsdWVBdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlQXQoaW5kZXgpIHtcbiAgICAgIGlmICghdGhpcy5pbnB1dHMubGVuZ3RoIHx8ICF0aGlzLmlucHV0c1tpbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgdmFsID0gdGhpcy5pbnB1dHNbaW5kZXhdLnZhbHVlO1xuICAgICAgaWYgKCF2YWwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudC52YWxpZGF0ZSAmJiB0aGlzLmNvbXBvbmVudC52YWxpZGF0ZS5pbnRlZ2VyKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh2YWwsIDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0VmFsdWVBdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlQXQoaW5kZXgsIHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5jb21wb25lbnQudmFsaWRhdGUgJiYgdGhpcy5jb21wb25lbnQudmFsaWRhdGUuaW50ZWdlcikge1xuICAgICAgICB0aGlzLmlucHV0c1tpbmRleF0udmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbnB1dHNbaW5kZXhdLnZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE51bWJlckNvbXBvbmVudDtcbn0oX0Jhc2UuQmFzZUNvbXBvbmVudCk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5QYW5lbENvbXBvbmVudCA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9Db21wb25lbnRzID0gcmVxdWlyZSgnLi4vQ29tcG9uZW50cycpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBQYW5lbENvbXBvbmVudCA9IGV4cG9ydHMuUGFuZWxDb21wb25lbnQgPSBmdW5jdGlvbiAoX0Zvcm1pb0NvbXBvbmVudHMpIHtcbiAgX2luaGVyaXRzKFBhbmVsQ29tcG9uZW50LCBfRm9ybWlvQ29tcG9uZW50cyk7XG5cbiAgZnVuY3Rpb24gUGFuZWxDb21wb25lbnQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhbmVsQ29tcG9uZW50KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoUGFuZWxDb21wb25lbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihQYW5lbENvbXBvbmVudCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBhbmVsQ29tcG9uZW50LCBbe1xuICAgIGtleTogJ2J1aWxkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGQoKSB7XG4gICAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLmNlKCdlbGVtZW50JywgJ2RpdicsIHtcbiAgICAgICAgY2xhc3M6ICdwYW5lbCBwYW5lbC0nICsgdGhpcy5jb21wb25lbnQudGhlbWVcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuY29tcG9uZW50LnRpdGxlKSB7XG4gICAgICAgIHZhciBoZWFkaW5nID0gdGhpcy5jZSgnaGVhZGluZycsICdkaXYnLCB7XG4gICAgICAgICAgY2xhc3M6ICdwYW5lbC1oZWFkaW5nJ1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5jZSgndGl0bGUnLCAnaDMnLCB7XG4gICAgICAgICAgY2xhc3M6ICdwYW5lbC10aXRsZSdcbiAgICAgICAgfSk7XG4gICAgICAgIHRpdGxlLmFwcGVuZENoaWxkKHRoaXMudGV4dCh0aGlzLmNvbXBvbmVudC50aXRsZSkpO1xuICAgICAgICBoZWFkaW5nLmFwcGVuZENoaWxkKHRpdGxlKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGhlYWRpbmcpO1xuICAgICAgfVxuICAgICAgdmFyIGJvZHkgPSB0aGlzLmNlKCdib2R5JywgJ2RpdicsIHtcbiAgICAgICAgY2xhc3M6ICdwYW5lbC1ib2R5J1xuICAgICAgfSk7XG4gICAgICB0aGlzLmFkZENvbXBvbmVudHMoYm9keSk7XG4gICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoYm9keSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBhbmVsQ29tcG9uZW50O1xufShfQ29tcG9uZW50cy5Gb3JtaW9Db21wb25lbnRzKTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlBhc3N3b3JkQ29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfVGV4dEZpZWxkID0gcmVxdWlyZSgnLi4vdGV4dGZpZWxkL1RleHRGaWVsZCcpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBQYXNzd29yZENvbXBvbmVudCA9IGV4cG9ydHMuUGFzc3dvcmRDb21wb25lbnQgPSBmdW5jdGlvbiAoX1RleHRGaWVsZENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUGFzc3dvcmRDb21wb25lbnQsIF9UZXh0RmllbGRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFBhc3N3b3JkQ29tcG9uZW50KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYXNzd29yZENvbXBvbmVudCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFBhc3N3b3JkQ29tcG9uZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUGFzc3dvcmRDb21wb25lbnQpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQYXNzd29yZENvbXBvbmVudCwgW3tcbiAgICBrZXk6ICdlbGVtZW50SW5mbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVsZW1lbnRJbmZvKCkge1xuICAgICAgdmFyIGluZm8gPSBfZ2V0KFBhc3N3b3JkQ29tcG9uZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFBhc3N3b3JkQ29tcG9uZW50LnByb3RvdHlwZSksICdlbGVtZW50SW5mbycsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICBpbmZvLmF0dHIudHlwZSA9ICdwYXNzd29yZCc7XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGFzc3dvcmRDb21wb25lbnQ7XG59KF9UZXh0RmllbGQuVGV4dEZpZWxkQ29tcG9uZW50KTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlBob25lTnVtYmVyQ29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG52YXIgX1RleHRGaWVsZCA9IHJlcXVpcmUoJy4uL3RleHRmaWVsZC9UZXh0RmllbGQnKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgUGhvbmVOdW1iZXJDb21wb25lbnQgPSBleHBvcnRzLlBob25lTnVtYmVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKF9UZXh0RmllbGRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFBob25lTnVtYmVyQ29tcG9uZW50LCBfVGV4dEZpZWxkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBQaG9uZU51bWJlckNvbXBvbmVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGhvbmVOdW1iZXJDb21wb25lbnQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChQaG9uZU51bWJlckNvbXBvbmVudC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFBob25lTnVtYmVyQ29tcG9uZW50KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICByZXR1cm4gUGhvbmVOdW1iZXJDb21wb25lbnQ7XG59KF9UZXh0RmllbGQuVGV4dEZpZWxkQ29tcG9uZW50KTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlJhZGlvQ29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfQmFzZSA9IHJlcXVpcmUoJy4uL2Jhc2UvQmFzZScpO1xuXG52YXIgX2VhY2gyID0gcmVxdWlyZSgnbG9kYXNoL2VhY2gnKTtcblxudmFyIF9lYWNoMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2gyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgUmFkaW9Db21wb25lbnQgPSBleHBvcnRzLlJhZGlvQ29tcG9uZW50ID0gZnVuY3Rpb24gKF9CYXNlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhSYWRpb0NvbXBvbmVudCwgX0Jhc2VDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJhZGlvQ29tcG9uZW50KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSYWRpb0NvbXBvbmVudCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFJhZGlvQ29tcG9uZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUmFkaW9Db21wb25lbnQpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSYWRpb0NvbXBvbmVudCwgW3tcbiAgICBrZXk6ICdlbGVtZW50SW5mbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVsZW1lbnRJbmZvKCkge1xuICAgICAgdmFyIGluZm8gPSBfZ2V0KFJhZGlvQ29tcG9uZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFJhZGlvQ29tcG9uZW50LnByb3RvdHlwZSksICdlbGVtZW50SW5mbycsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICBpbmZvLnR5cGUgPSAnaW5wdXQnO1xuICAgICAgaW5mby5jaGFuZ2VFdmVudCA9ICdjbGljayc7XG4gICAgICBpbmZvLmF0dHIuY2xhc3MgPSAnJztcbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZUlucHV0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlSW5wdXQoY29udGFpbmVyKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGlucHV0R3JvdXAgPSB0aGlzLmNlKCdpbnB1dEdyb3VwJywgJ2RpdicsIHtcbiAgICAgICAgY2xhc3M6ICdpbnB1dC1ncm91cCdcbiAgICAgIH0pO1xuICAgICAgdmFyIGlucHV0VHlwZSA9IHRoaXMuY29tcG9uZW50LmlucHV0VHlwZTtcbiAgICAgICgwLCBfZWFjaDMuZGVmYXVsdCkodGhpcy5jb21wb25lbnQudmFsdWVzLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHdyYXBwZXJDbGFzcyA9IF90aGlzMi5jb21wb25lbnQuaW5saW5lID8gaW5wdXRUeXBlICsgJy1pbmxpbmUnIDogaW5wdXRUeXBlO1xuICAgICAgICB2YXIgbGFiZWxXcmFwcGVyID0gX3RoaXMyLmNlKCdsYWJlbFdyYXBwZXInLCAnZGl2Jywge1xuICAgICAgICAgIGNsYXNzOiB3cmFwcGVyQ2xhc3NcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsYWJlbCA9IF90aGlzMi5jZSgnbGFiZWwnLCAnbGFiZWwnLCB7XG4gICAgICAgICAgY2xhc3M6ICdjb250cm9sLWxhYmVsJ1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDcmVhdGUgdGhlIFNQQU4gYXJvdW5kIHRoZSB0ZXh0Tm9kZSBmb3IgYmV0dGVyIHN0eWxlIGhvb2tzXG4gICAgICAgIHZhciBsYWJlbFNwYW4gPSBfdGhpczIuY2UoJ2xhYmVsU3BhbicsICdzcGFuJyk7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBhdHRyaWJ1dGVzIGZvciB0aGlzIGlucHV0LlxuICAgICAgICB2YXIgaW5wdXRJZCA9IF90aGlzMi5jb21wb25lbnQua2V5ICsgX3RoaXMyLnJvdyArICctJyArIHZhbHVlLnZhbHVlO1xuICAgICAgICBfdGhpczIuaW5mby5hdHRyLmlkID0gaW5wdXRJZDtcbiAgICAgICAgX3RoaXMyLmluZm8uYXR0ci52YWx1ZSA9IHZhbHVlLnZhbHVlO1xuICAgICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoJ2ZvcicsIF90aGlzMi5pbmZvLmF0dHIuaWQpO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgaW5wdXQuXG4gICAgICAgIHZhciBpbnB1dCA9IF90aGlzMi5jZSgnaW5wdXQnLCAnaW5wdXQnKTtcbiAgICAgICAgKDAsIF9lYWNoMy5kZWZhdWx0KShfdGhpczIuaW5mby5hdHRyLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzMi5hZGRJbnB1dChpbnB1dCwgbGFiZWwpO1xuXG4gICAgICAgIGxhYmVsU3Bhbi5hcHBlbmRDaGlsZChfdGhpczIudGV4dCh2YWx1ZS5sYWJlbCkpO1xuXG4gICAgICAgIGxhYmVsV3JhcHBlci5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgICAgIGxhYmVsV3JhcHBlci5hcHBlbmRDaGlsZChsYWJlbFNwYW4pO1xuXG4gICAgICAgIGlucHV0R3JvdXAuYXBwZW5kQ2hpbGQobGFiZWxXcmFwcGVyKTtcbiAgICAgIH0pO1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGlucHV0R3JvdXApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICB2YXIgdmFsdWUgPSAnJztcbiAgICAgICgwLCBfZWFjaDMuZGVmYXVsdCkodGhpcy5pbnB1dHMsIGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hlY2tlZCkge1xuICAgICAgICAgIHZhbHVlID0gaW5wdXQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFZhbHVlQXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZUF0KGluZGV4LCB2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuaW5wdXRzICYmIHRoaXMuaW5wdXRzW2luZGV4XSkge1xuICAgICAgICB0aGlzLmlucHV0c1tpbmRleF0uY2hlY2tlZCA9IHRoaXMuaW5wdXRzW2luZGV4XS52YWx1ZSA9PT0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJhZGlvQ29tcG9uZW50O1xufShfQmFzZS5CYXNlQ29tcG9uZW50KTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlJlc291cmNlQ29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG52YXIgX1NlbGVjdCA9IHJlcXVpcmUoJy4uL3NlbGVjdC9TZWxlY3QnKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgUmVzb3VyY2VDb21wb25lbnQgPSBleHBvcnRzLlJlc291cmNlQ29tcG9uZW50ID0gZnVuY3Rpb24gKF9TZWxlY3RDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFJlc291cmNlQ29tcG9uZW50LCBfU2VsZWN0Q29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBSZXNvdXJjZUNvbXBvbmVudChjb21wb25lbnQsIG9wdGlvbnMsIGRhdGEpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFJlc291cmNlQ29tcG9uZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUmVzb3VyY2VDb21wb25lbnQpKS5jYWxsKHRoaXMsIGNvbXBvbmVudCwgb3B0aW9ucywgZGF0YSkpO1xuXG4gICAgX3RoaXMuY29tcG9uZW50LmRhdGFTcmMgPSAncmVzb3VyY2UnO1xuICAgIF90aGlzLmNvbXBvbmVudC5kYXRhID0ge1xuICAgICAgcmVzb3VyY2U6IF90aGlzLmNvbXBvbmVudC5yZXNvdXJjZVxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFJlc291cmNlQ29tcG9uZW50O1xufShfU2VsZWN0LlNlbGVjdENvbXBvbmVudCk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5TZWxlY3RDb21wb25lbnQgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfc2V0ID0gZnVuY3Rpb24gc2V0KG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcikgeyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ICE9PSBudWxsKSB7IHNldChwYXJlbnQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MgJiYgZGVzYy53cml0YWJsZSkgeyBkZXNjLnZhbHVlID0gdmFsdWU7IH0gZWxzZSB7IHZhciBzZXR0ZXIgPSBkZXNjLnNldDsgaWYgKHNldHRlciAhPT0gdW5kZWZpbmVkKSB7IHNldHRlci5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7IH0gfSByZXR1cm4gdmFsdWU7IH07XG5cbnZhciBfZ2V0MiA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfQmFzZSA9IHJlcXVpcmUoJy4uL2Jhc2UvQmFzZScpO1xuXG52YXIgX2Nob2ljZXMgPSByZXF1aXJlKCdjaG9pY2VzLmpzJyk7XG5cbnZhciBfY2hvaWNlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jaG9pY2VzKTtcblxudmFyIF9mb3JtaW8gPSByZXF1aXJlKCcuLi8uLi9mb3JtaW8nKTtcblxudmFyIF9mb3JtaW8yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9ybWlvKTtcblxudmFyIF9lYWNoMiA9IHJlcXVpcmUoJ2xvZGFzaC9lYWNoJyk7XG5cbnZhciBfZWFjaDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYWNoMik7XG5cbnZhciBfZ2V0MyA9IHJlcXVpcmUoJ2xvZGFzaC9nZXQnKTtcblxudmFyIF9nZXQ0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0Myk7XG5cbnZhciBfaXNFbXB0eTIgPSByZXF1aXJlKCdsb2Rhc2gvaXNFbXB0eScpO1xuXG52YXIgX2lzRW1wdHkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNFbXB0eTIpO1xuXG52YXIgX2lzQXJyYXkyID0gcmVxdWlyZSgnbG9kYXNoL2lzQXJyYXknKTtcblxudmFyIF9pc0FycmF5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzQXJyYXkyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgU2VsZWN0Q29tcG9uZW50ID0gZXhwb3J0cy5TZWxlY3RDb21wb25lbnQgPSBmdW5jdGlvbiAoX0Jhc2VDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFNlbGVjdENvbXBvbmVudCwgX0Jhc2VDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFNlbGVjdENvbXBvbmVudChjb21wb25lbnQsIG9wdGlvbnMsIGRhdGEpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VsZWN0Q29tcG9uZW50KTtcblxuICAgIC8vIElmIHRoZXkgd2lzaCB0byByZWZyZXNoIG9uIGEgdmFsdWUsIHRoZW4gYWRkIHRoYXQgaGVyZS5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU2VsZWN0Q29tcG9uZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2VsZWN0Q29tcG9uZW50KSkuY2FsbCh0aGlzLCBjb21wb25lbnQsIG9wdGlvbnMsIGRhdGEpKTtcblxuICAgIGlmIChfdGhpcy5jb21wb25lbnQucmVmcmVzaE9uKSB7XG4gICAgICBfdGhpcy5vbignY2hhbmdlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChfdGhpcy5jb21wb25lbnQucmVmcmVzaE9uID09PSAnZGF0YScpIHtcbiAgICAgICAgICBfdGhpcy51cGRhdGVJdGVtcygpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmNoYW5nZWQuY29tcG9uZW50LmtleSA9PT0gX3RoaXMuY29tcG9uZW50LnJlZnJlc2hPbikge1xuICAgICAgICAgIF90aGlzLnVwZGF0ZUl0ZW1zKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2VsZWN0Q29tcG9uZW50LCBbe1xuICAgIGtleTogJ2VsZW1lbnRJbmZvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWxlbWVudEluZm8oKSB7XG4gICAgICB2YXIgaW5mbyA9IF9nZXQyKFNlbGVjdENvbXBvbmVudC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTZWxlY3RDb21wb25lbnQucHJvdG90eXBlKSwgJ2VsZW1lbnRJbmZvJywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIGluZm8udHlwZSA9ICdzZWxlY3QnO1xuICAgICAgaW5mby5jaGFuZ2VFdmVudCA9ICdjaGFuZ2UnO1xuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlV3JhcHBlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVdyYXBwZXIoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaXRlbVRlbXBsYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXRlbVRlbXBsYXRlKGRhdGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC50ZW1wbGF0ZSA/IHRoaXMuaW50ZXJwb2xhdGUodGhpcy5jb21wb25lbnQudGVtcGxhdGUsIHsgaXRlbTogZGF0YSB9KSA6IGRhdGEubGFiZWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaXRlbVZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXRlbVZhbHVlKGRhdGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC52YWx1ZVByb3BlcnR5ID8gKDAsIF9nZXQ0LmRlZmF1bHQpKGRhdGEsIHRoaXMuY29tcG9uZW50LnZhbHVlUHJvcGVydHkpIDogZGF0YTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRJdGVtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEl0ZW1zKGl0ZW1zKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLmNob2ljZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5jaG9pY2VzLl9jbGVhckNob2ljZXMoKTtcblxuICAgICAgLy8gSWYgdGhleSBwcm92aWRlZCBzZWxlY3QgdmFsdWVzLCB0aGVuIHdlIG5lZWQgdG8gZ2V0IHRoZW0gaW5zdGVhZC5cbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5zZWxlY3RWYWx1ZXMpIHtcbiAgICAgICAgaXRlbXMgPSAoMCwgX2dldDQuZGVmYXVsdCkoaXRlbXMsIHRoaXMuY29tcG9uZW50LnNlbGVjdFZhbHVlcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIG9mIHRoZSBpdGVtcy5cbiAgICAgICgwLCBfZWFjaDMuZGVmYXVsdCkoaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG5cbiAgICAgICAgLy8gQWRkIHRoZSBjaG9pY2UgdG8gdGhlIHNlbGVjdCBsaXN0LlxuXG4gICAgICAgIC8vIERNU1xuXG4gICAgICAgIC8vdGhpcy5jaG9pY2VzLl9hZGRDaG9pY2UoZmFsc2UsIGZhbHNlLCB0aGlzLml0ZW1WYWx1ZShpdGVtKSwgdGhpcy5pdGVtVGVtcGxhdGUoaXRlbSkpO1xuICAgICAgICBfdGhpczIuY2hvaWNlcy5fYWRkQ2hvaWNlKGZhbHNlLCBpdGVtLmRpc2FibGVkLCBfdGhpczIuaXRlbVZhbHVlKGl0ZW0pLCBfdGhpczIuaXRlbVRlbXBsYXRlKGl0ZW0pKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBJZiBhIHZhbHVlIGlzIHByb3ZpZGVkLCB0aGVuIHNlbGVjdCBpdC5cbiAgICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy52YWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9hZEl0ZW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZEl0ZW1zKHVybCwgaW5wdXQsIGhlYWRlcnMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgcXVlcnkgPSB0aGlzLmNvbXBvbmVudC5kYXRhU3JjID09PSAndXJsJyA/IHt9IDoge1xuICAgICAgICBsaW1pdDogMTAwLFxuICAgICAgICBza2lwOiAwXG4gICAgICB9O1xuXG4gICAgICAvLyBBbGxvdyBmb3IgdXJsIGludGVycG9sYXRpb24uXG4gICAgICB1cmwgPSB0aGlzLmludGVycG9sYXRlKHVybCwge1xuICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgIGZvcm1pb0Jhc2U6IF9mb3JtaW8yLmRlZmF1bHQuZ2V0QmFzZVVybCgpXG4gICAgICB9KTtcblxuICAgICAgLy8gQWRkIHNlYXJjaCBjYXBhYmlsaXR5LlxuICAgICAgaWYgKHRoaXMuY29tcG9uZW50LnNlYXJjaEZpZWxkICYmIGlucHV0KSB7XG4gICAgICAgIHF1ZXJ5W3RoaXMuY29tcG9uZW50LnNlYXJjaEZpZWxkXSA9IGlucHV0O1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgZmlsdGVyIGNhcGFiaWxpdHlcbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5maWx0ZXIpIHtcbiAgICAgICAgdmFyIGZpbHRlciA9IHRoaXMuaW50ZXJwb2xhdGUodGhpcy5jb21wb25lbnQuZmlsdGVyLCB7IGRhdGE6IHRoaXMuZGF0YSB9KTtcbiAgICAgICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBmaWx0ZXI7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZXkgd2lzaCB0byByZXR1cm4gb25seSBzb21lIGZpZWxkcy5cbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5zZWxlY3RGaWVsZHMpIHtcbiAgICAgICAgcXVlcnkuc2VsZWN0ID0gdGhpcy5jb21wb25lbnQuc2VsZWN0RmllbGRzO1xuICAgICAgfVxuXG4gICAgICBpZiAoISgwLCBfaXNFbXB0eTMuZGVmYXVsdCkocXVlcnkpKSB7XG4gICAgICAgIC8vIEFkZCB0aGUgcXVlcnkgc3RyaW5nLlxuICAgICAgICB1cmwgKz0gJz8nICsgX2Zvcm1pbzIuZGVmYXVsdC5zZXJpYWxpemUocXVlcnkpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIHRoZSByZXF1ZXN0LlxuICAgICAgX2Zvcm1pbzIuZGVmYXVsdC5yZXF1ZXN0KHVybCwgbnVsbCwgbnVsbCwgaGVhZGVycywgb3B0aW9ucykudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5zZXRJdGVtcyhyZXNwb25zZSk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byBsb2FkIHJlc291cmNlcyBmb3IgJyArIF90aGlzMy5jb21wb25lbnQua2V5KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZUl0ZW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlSXRlbXMoKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuY29tcG9uZW50LmRhdGFTcmMpIHtcbiAgICAgICAgY2FzZSAndmFsdWVzJzpcbiAgICAgICAgICB0aGlzLmNvbXBvbmVudC52YWx1ZVByb3BlcnR5ID0gJ3ZhbHVlJztcbiAgICAgICAgICB0aGlzLnNldEl0ZW1zKHRoaXMuY29tcG9uZW50LmRhdGEudmFsdWVzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5jb21wb25lbnQuZGF0YS5qc29uID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2V0SXRlbXMoSlNPTi5wYXJzZSh0aGlzLmNvbXBvbmVudC5kYXRhLmpzb24pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuc2V0SXRlbXModGhpcy5jb21wb25lbnQuZGF0YS5qc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIHBhcnNlIEpTT04gZm9yICcgKyB0aGlzLmNvbXBvbmVudC5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmVzb3VyY2UnOlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRJdGVtcyhfZm9ybWlvMi5kZWZhdWx0LmdldEFwcFVybCgpICsgJy9mb3JtLycgKyB0aGlzLmNvbXBvbmVudC5kYXRhLnJlc291cmNlICsgJy9zdWJtaXNzaW9uJyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byBsb2FkIHJlc291cmNlcyBmb3IgJyArIHRoaXMuY29tcG9uZW50LmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd1cmwnOlxuICAgICAgICAgIHRoaXMubG9hZEl0ZW1zKHRoaXMuY29tcG9uZW50LmRhdGEudXJsLCBudWxsLCBuZXcgSGVhZGVycygpLCB7XG4gICAgICAgICAgICBub1Rva2VuOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWRkSW5wdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJbnB1dChpbnB1dCwgY29udGFpbmVyKSB7XG4gICAgICBfZ2V0MihTZWxlY3RDb21wb25lbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2VsZWN0Q29tcG9uZW50LnByb3RvdHlwZSksICdhZGRJbnB1dCcsIHRoaXMpLmNhbGwodGhpcywgaW5wdXQsIGNvbnRhaW5lciwgdHJ1ZSk7XG4gICAgICBpZiAodGhpcy5jb21wb25lbnQubXVsdGlwbGUpIHtcbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsIHRydWUpO1xuICAgICAgfVxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdGhpcy5jaG9pY2VzID0gbmV3IF9jaG9pY2VzMi5kZWZhdWx0KGlucHV0LCB7XG4gICAgICAgIHBsYWNlaG9sZGVyOiAhIXRoaXMuY29tcG9uZW50LnBsYWNlaG9sZGVyLFxuICAgICAgICBwbGFjZWhvbGRlclZhbHVlOiB0aGlzLmNvbXBvbmVudC5wbGFjZWhvbGRlcixcbiAgICAgICAgcmVtb3ZlSXRlbUJ1dHRvbjogdHJ1ZSxcblxuICAgICAgICAvLyBETVNcbiAgICAgICAgc2VhcmNoRW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHNob3VsZFNvcnQ6IGZhbHNlLFxuICAgICAgICByZW1vdmVJdGVtczogZmFsc2UsXG5cbiAgICAgICAgaXRlbVNlbGVjdFRleHQ6ICcnLFxuICAgICAgICBjbGFzc05hbWVzOiB7XG4gICAgICAgICAgY29udGFpbmVyT3V0ZXI6ICdjaG9pY2VzIGZvcm0tZ3JvdXAgZm9ybWlvLWNob2ljZXMnLFxuICAgICAgICAgIGNvbnRhaW5lcklubmVyOiAnZm9ybS1jb250cm9sJ1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuY2hvaWNlcy5kaXNhYmxlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZUl0ZW1zKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNob2ljZXMuZ2V0VmFsdWUodHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSwgbm9VcGRhdGUsIG5vVmFsaWRhdGUpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh2YWx1ZSAmJiB0aGlzLmNob2ljZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hvaWNlcy5zdG9yZSkge1xuICAgICAgICAgIC8vIFNlYXJjaCBmb3IgdGhlIGNob2ljZS5cbiAgICAgICAgICB2YXIgY2hvaWNlcyA9IHRoaXMuY2hvaWNlcy5zdG9yZS5nZXRDaG9pY2VzKCk7XG4gICAgICAgICAgdmFyIGZvdW5kQ2hvaWNlID0gY2hvaWNlcy5maW5kKGZ1bmN0aW9uIChjaG9pY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBjaG9pY2UudmFsdWUgPT09IHZhbHVlO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gSWYgaXQgaXMgbm90IGZvdW5kLCB0aGVuIGFkZCBpdC5cbiAgICAgICAgICBpZiAoIWZvdW5kQ2hvaWNlKSB7XG4gICAgICAgICAgICB0aGlzLmNob2ljZXMuX2FkZENob2ljZShmYWxzZSwgZmFsc2UsIHZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm93IHNldCB0aGUgdmFsdWUuXG4gICAgICAgIHRoaXMuY2hvaWNlcy5zZXRWYWx1ZUJ5Q2hvaWNlKCgwLCBfaXNBcnJheTMuZGVmYXVsdCkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdKTtcbiAgICAgIH1cbiAgICAgIGlmICghbm9VcGRhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZShub1ZhbGlkYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGlmICh0aGlzLmNob2ljZXMpIHtcbiAgICAgICAgdGhpcy5jaG9pY2VzLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkaXNhYmxlZCcsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoZGlzYWJsZWQpIHtcbiAgICAgIF9zZXQoU2VsZWN0Q29tcG9uZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNlbGVjdENvbXBvbmVudC5wcm90b3R5cGUpLCAnZGlzYWJsZWQnLCBkaXNhYmxlZCwgdGhpcyk7XG4gICAgICBpZiAoIXRoaXMuY2hvaWNlcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5jaG9pY2VzLmRpc2FibGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2hvaWNlcy5lbmFibGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2VsZWN0Q29tcG9uZW50O1xufShfQmFzZS5CYXNlQ29tcG9uZW50KTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlNlbGVjdEJveGVzQ29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfUmFkaW8gPSByZXF1aXJlKCcuLi9yYWRpby9SYWRpbycpO1xuXG52YXIgX2VhY2gyID0gcmVxdWlyZSgnbG9kYXNoL2VhY2gnKTtcblxudmFyIF9lYWNoMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2gyKTtcblxudmFyIF9pc0FycmF5MiA9IHJlcXVpcmUoJ2xvZGFzaC9pc0FycmF5Jyk7XG5cbnZhciBfaXNBcnJheTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0FycmF5Mik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFNlbGVjdEJveGVzQ29tcG9uZW50ID0gZXhwb3J0cy5TZWxlY3RCb3hlc0NvbXBvbmVudCA9IGZ1bmN0aW9uIChfUmFkaW9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFNlbGVjdEJveGVzQ29tcG9uZW50LCBfUmFkaW9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFNlbGVjdEJveGVzQ29tcG9uZW50KGNvbXBvbmVudCwgb3B0aW9ucywgZGF0YSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZWxlY3RCb3hlc0NvbXBvbmVudCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU2VsZWN0Qm94ZXNDb21wb25lbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTZWxlY3RCb3hlc0NvbXBvbmVudCkpLmNhbGwodGhpcywgY29tcG9uZW50LCBvcHRpb25zLCBkYXRhKSk7XG5cbiAgICBfdGhpcy5jb21wb25lbnQuaW5wdXRUeXBlID0gJ2NoZWNrYm94JztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2VsZWN0Qm94ZXNDb21wb25lbnQsIFt7XG4gICAga2V5OiAnZWxlbWVudEluZm8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbGVtZW50SW5mbygpIHtcbiAgICAgIHZhciBpbmZvID0gX2dldChTZWxlY3RCb3hlc0NvbXBvbmVudC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTZWxlY3RCb3hlc0NvbXBvbmVudC5wcm90b3R5cGUpLCAnZWxlbWVudEluZm8nLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgaW5mby5hdHRyLm5hbWUgKz0gJ1tdJztcbiAgICAgIGluZm8uYXR0ci50eXBlID0gJ2NoZWNrYm94JztcbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBbXTtcbiAgICAgICgwLCBfZWFjaDMuZGVmYXVsdCkodGhpcy5pbnB1dHMsIGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hlY2tlZCkge1xuICAgICAgICAgIHZhbHVlLnB1c2goaW5wdXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIG9mIHRoaXMgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKHZhbHVlLCBub1VwZGF0ZSwgbm9WYWxpZGF0ZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgdmFyIHRlbXBWYWx1ZSA9IFtdO1xuXG4gICAgICAoMCwgX2VhY2gzLmRlZmF1bHQpKHRoaXMuaW5wdXRzLCBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCgwLCBfaXNBcnJheTMuZGVmYXVsdCkodmFsdWUpKSB7XG4gICAgICAgICAgaW5wdXQuY2hlY2tlZCA9IHZhbHVlLmluZGV4T2YoaW5wdXQudmFsdWUpICE9PSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnB1dC5jaGVja2VkID0gdmFsdWVbaW5wdXQudmFsdWVdID09IHVuZGVmaW5lZCA/IGZhbHNlIDogdmFsdWVbaW5wdXQudmFsdWVdO1xuICAgICAgICAgIHRlbXBWYWx1ZS5wdXNoKGlucHV0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHZhbHVlID0gKDAsIF9pc0FycmF5My5kZWZhdWx0KSh2YWx1ZSkgPyB2YWx1ZSA6IHRlbXBWYWx1ZTtcblxuICAgICAgaWYgKCFub1VwZGF0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKG5vVmFsaWRhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTZWxlY3RCb3hlc0NvbXBvbmVudDtcbn0oX1JhZGlvLlJhZGlvQ29tcG9uZW50KTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlNpZ25hdHVyZUNvbXBvbmVudCA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9zZXQgPSBmdW5jdGlvbiBzZXQob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKSB7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgIT09IG51bGwpIHsgc2V0KHBhcmVudCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYyAmJiBkZXNjLndyaXRhYmxlKSB7IGRlc2MudmFsdWUgPSB2YWx1ZTsgfSBlbHNlIHsgdmFyIHNldHRlciA9IGRlc2Muc2V0OyBpZiAoc2V0dGVyICE9PSB1bmRlZmluZWQpIHsgc2V0dGVyLmNhbGwocmVjZWl2ZXIsIHZhbHVlKTsgfSB9IHJldHVybiB2YWx1ZTsgfTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX3NpZ25hdHVyZV9wYWQgPSByZXF1aXJlKCdzaWduYXR1cmVfcGFkJyk7XG5cbnZhciBfc2lnbmF0dXJlX3BhZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zaWduYXR1cmVfcGFkKTtcblxudmFyIF9CYXNlID0gcmVxdWlyZSgnLi4vYmFzZS9CYXNlJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFNpZ25hdHVyZUNvbXBvbmVudCA9IGV4cG9ydHMuU2lnbmF0dXJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKF9CYXNlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhTaWduYXR1cmVDb21wb25lbnQsIF9CYXNlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTaWduYXR1cmVDb21wb25lbnQoY29tcG9uZW50LCBvcHRpb25zLCBkYXRhKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNpZ25hdHVyZUNvbXBvbmVudCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU2lnbmF0dXJlQ29tcG9uZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2lnbmF0dXJlQ29tcG9uZW50KSkuY2FsbCh0aGlzLCBjb21wb25lbnQsIG9wdGlvbnMsIGRhdGEpKTtcblxuICAgIGlmICghX3RoaXMuY29tcG9uZW50LndpZHRoKSB7XG4gICAgICBfdGhpcy5jb21wb25lbnQud2lkdGggPSAnMTAwJSc7XG4gICAgfVxuICAgIGlmICghX3RoaXMuY29tcG9uZW50LmhlaWdodCkge1xuICAgICAgX3RoaXMuY29tcG9uZW50LmhlaWdodCA9ICcyMDBweCc7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTaWduYXR1cmVDb21wb25lbnQsIFt7XG4gICAga2V5OiAnZWxlbWVudEluZm8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbGVtZW50SW5mbygpIHtcbiAgICAgIHZhciBpbmZvID0gX2dldChTaWduYXR1cmVDb21wb25lbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2lnbmF0dXJlQ29tcG9uZW50LnByb3RvdHlwZSksICdlbGVtZW50SW5mbycsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICBpbmZvLnR5cGUgPSAnaW5wdXQnO1xuICAgICAgaW5mby5hdHRyLnR5cGUgPSAnaGlkZGVuJztcbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUodmFsdWUsIG5vVXBkYXRlLCBub1ZhbGlkYXRlLCBub1NpZ24pIHtcbiAgICAgIF9nZXQoU2lnbmF0dXJlQ29tcG9uZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNpZ25hdHVyZUNvbXBvbmVudC5wcm90b3R5cGUpLCAnc2V0VmFsdWUnLCB0aGlzKS5jYWxsKHRoaXMsIHZhbHVlLCBub1VwZGF0ZSwgbm9WYWxpZGF0ZSk7XG4gICAgICBpZiAoIW5vU2lnbiAmJiB0aGlzLnNpZ25hdHVyZVBhZCkge1xuICAgICAgICB0aGlzLnNpZ25hdHVyZVBhZC5mcm9tRGF0YVVSTCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0U2lnbmF0dXJlSW1hZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTaWduYXR1cmVJbWFnZSgpIHtcbiAgICAgIHZhciBpbWFnZSA9IHRoaXMuY2UoJ2ltYWdlJywgJ2ltZycsIHtcbiAgICAgICAgc3R5bGU6ICd3aWR0aDogJyArIHRoaXMuY29tcG9uZW50LndpZHRoICsgJztoZWlnaHQ6ICcgKyB0aGlzLmNvbXBvbmVudC5oZWlnaHRcbiAgICAgIH0pO1xuICAgICAgaW1hZ2Uuc2V0QXR0cmlidXRlKCdzcmMnLCB0aGlzLnZhbHVlKTtcbiAgICAgIHJldHVybiBpbWFnZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIF9nZXQoU2lnbmF0dXJlQ29tcG9uZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNpZ25hdHVyZUNvbXBvbmVudC5wcm90b3R5cGUpLCAnZGVzdHJveScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICBpZiAodGhpcy5zaWduYXR1cmVQYWQpIHtcbiAgICAgICAgdGhpcy5zaWduYXR1cmVQYWQub2ZmKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYnVpbGQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoKTtcbiAgICAgIHZhciBjbGFzc05hbWVzID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgIGNsYXNzTmFtZXMgKz0gJyBzaWduYXR1cmUtcGFkJztcbiAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xhc3NOYW1lcyk7XG5cbiAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLmNyZWF0ZUlucHV0KHRoaXMuZWxlbWVudCk7XG4gICAgICB2YXIgcGFkQm9keSA9IHRoaXMuY2UoJ3BhZCcsICdkaXYnLCB7XG4gICAgICAgIGNsYXNzOiAnc2lnbmF0dXJlLXBhZC1ib2R5JyxcbiAgICAgICAgc3R5bGU6ICd3aWR0aDogJyArIHRoaXMuY29tcG9uZW50LndpZHRoICsgJztoZWlnaHQ6ICcgKyB0aGlzLmNvbXBvbmVudC5oZWlnaHRcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDcmVhdGUgdGhlIHJlZnJlc2ggYnV0dG9uLlxuICAgICAgdmFyIHJlZnJlc2ggPSB0aGlzLmNlKCdyZWZyZXNoJywgJ2EnLCB7XG4gICAgICAgIGNsYXNzOiAnYnRuIGJ0bi1zbSBidG4tZGVmYXVsdCBzaWduYXR1cmUtcGFkLXJlZnJlc2gnXG4gICAgICB9KTtcbiAgICAgIHZhciByZWZyZXNoSWNvbiA9IHRoaXMuZ2V0SWNvbigncmVmcmVzaCcpO1xuICAgICAgcmVmcmVzaC5hcHBlbmRDaGlsZChyZWZyZXNoSWNvbik7XG4gICAgICBwYWRCb2R5LmFwcGVuZENoaWxkKHJlZnJlc2gpO1xuXG4gICAgICAvLyBUaGUgc2lnbmF0dXJlIGNhbnZhcy5cbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLmNlKCdjYW52YXMnLCAnY2FudmFzJywge1xuICAgICAgICBjbGFzczogJ3NpZ25hdHVyZS1wYWQtY2FudmFzJyxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmNvbXBvbmVudC5oZWlnaHRcbiAgICAgIH0pO1xuICAgICAgcGFkQm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHBhZEJvZHkpO1xuXG4gICAgICAvLyBBZGQgdGhlIGZvb3Rlci5cbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5mb290ZXIpIHtcbiAgICAgICAgdmFyIGZvb3RlciA9IHRoaXMuY2UoJ2Zvb3RlcicsICdkaXYnLCB7XG4gICAgICAgICAgY2xhc3M6ICdzaWduYXR1cmUtcGFkLWZvb3RlcidcbiAgICAgICAgfSk7XG4gICAgICAgIGZvb3Rlci5hcHBlbmRDaGlsZCh0aGlzLnRleHQodGhpcy5jb21wb25lbnQuZm9vdGVyKSk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChmb290ZXIpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgdGhlIHNpZ25hdHVyZSBwYWQuXG4gICAgICB0aGlzLnNpZ25hdHVyZVBhZCA9IG5ldyBfc2lnbmF0dXJlX3BhZDIuZGVmYXVsdChjYW52YXMsIHtcbiAgICAgICAgbWluV2lkdGg6IHRoaXMuY29tcG9uZW50Lm1pbldpZHRoLFxuICAgICAgICBtYXhXaWR0aDogdGhpcy5jb21wb25lbnQubWF4V2lkdGgsXG4gICAgICAgIHBlbkNvbG9yOiB0aGlzLmNvbXBvbmVudC5wZW5Db2xvcixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLmNvbXBvbmVudC5iYWNrZ3JvdW5kQ29sb3JcbiAgICAgIH0pO1xuICAgICAgcmVmcmVzaC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIF90aGlzMi5zaWduYXR1cmVQYWQuY2xlYXIoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zaWduYXR1cmVQYWQub25FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuc2V0VmFsdWUoX3RoaXMyLnNpZ25hdHVyZVBhZC50b0RhdGFVUkwoKSwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEVuc3VyZSB0aGUgc2lnbmF0dXJlIGlzIGFsd2F5cyB0aGUgc2l6ZSBvZiBpdHMgY29udGFpbmVyLlxuICAgICAgdmFyIGN1cnJlbnRXaWR0aCA9IDA7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uIGNoZWNrV2lkdGgoKSB7XG4gICAgICAgIGlmIChwYWRCb2R5Lm9mZnNldFdpZHRoICE9PSBjdXJyZW50V2lkdGgpIHtcbiAgICAgICAgICBjdXJyZW50V2lkdGggPSBwYWRCb2R5Lm9mZnNldFdpZHRoO1xuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGN1cnJlbnRXaWR0aDtcbiAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5zaWduYXR1cmVQYWQuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoY2hlY2tXaWR0aC5iaW5kKHRoaXMpLCAyMDApO1xuICAgICAgfS5iaW5kKHRoaXMpLCAyMDApO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJlYWRPbmx5KSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGVkJyxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChkaXNhYmxlZCkge1xuICAgICAgX3NldChTaWduYXR1cmVDb21wb25lbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2lnbmF0dXJlQ29tcG9uZW50LnByb3RvdHlwZSksICdkaXNhYmxlZCcsIGRpc2FibGVkLCB0aGlzKTtcbiAgICAgIHRoaXMuZWxlbWVudC5pbm5lckhUTUwgPSAnJztcbiAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmdldFNpZ25hdHVyZUltYWdlKCkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTaWduYXR1cmVDb21wb25lbnQ7XG59KF9CYXNlLkJhc2VDb21wb25lbnQpOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuU2xpZGVyQ29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX0Jhc2UgPSByZXF1aXJlKCcuLi9iYXNlL0Jhc2UnKTtcblxudmFyIF9udW1lcmFsID0gcmVxdWlyZSgnbnVtZXJhbCcpO1xuXG52YXIgX251bWVyYWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbnVtZXJhbCk7XG5cbnZhciBfcmFuZ2VzbGlkZXJKcyA9IHJlcXVpcmUoJ3Jhbmdlc2xpZGVyLWpzJyk7XG5cbnZhciBfcmFuZ2VzbGlkZXJKczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yYW5nZXNsaWRlckpzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgU2xpZGVyQ29tcG9uZW50ID0gZXhwb3J0cy5TbGlkZXJDb21wb25lbnQgPSBmdW5jdGlvbiAoX0Jhc2VDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFNsaWRlckNvbXBvbmVudCwgX0Jhc2VDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFNsaWRlckNvbXBvbmVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2xpZGVyQ29tcG9uZW50KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU2xpZGVyQ29tcG9uZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2xpZGVyQ29tcG9uZW50KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2xpZGVyQ29tcG9uZW50LCBbe1xuICAgIGtleTogJ2J1aWxkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGQoKSB7XG5cbiAgICAgIHRoaXMuY3JlYXRlRWxlbWVudCgpO1xuXG4gICAgICBpZiAodGhpcy5jb21wb25lbnQubGFiZWwpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5jZSgnbGFiZWwnLCAnbGFiZWwnLCB7XG4gICAgICAgICAgY2xhc3M6ICdjb250cm9sLWxhYmVsJ1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICAgICAgbGFiZWwuaW5uZXJUZXh0ID0gdGhpcy5jb21wb25lbnQubGFiZWw7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXRwdXQgPSB0aGlzLmNlKCdkaXYnLCAnZGl2JywgeyBjbGFzczogJ3NsaWRlci1vdXRwdXQnLCBpZDogJ3NsaWRlci1vdXRwdXQnIH0pO1xuICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKG91dHB1dCk7XG5cbiAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLmNyZWF0ZUlucHV0KHRoaXMuZWxlbWVudCk7XG4gICAgICBpZiAoIXRoaXMubGFiZWwpIHtcbiAgICAgICAgdGhpcy5hZGRJbnB1dCh0aGlzLmlucHV0LCB0aGlzLmVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2xpZGVyTGFiZWxzID0gdGhpcy5jZSgnZGl2JywgJ2RpdicsIHsgY2xhc3M6ICdzbGlkZXJMYWJlbHMnLCBpZDogJ3NsaWRlckxhYmVscycgfSk7XG4gICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoc2xpZGVyTGFiZWxzKTtcbiAgICAgIHZhciBtaW5MYWJlbCA9IHRoaXMuY2UoJ2RpdicsICdkaXYnLCB7IGNsYXNzOiAnbWluTGFiZWwnLCBpZDogJ21pbkxhYmVsJyB9KTtcbiAgICAgIHZhciBtYXhMYWJlbCA9IHRoaXMuY2UoJ2RpdicsICdkaXYnLCB7IGNsYXNzOiAnbWF4TGFiZWwnLCBpZDogJ21heExhYmVsJyB9KTtcblxuICAgICAgc2xpZGVyTGFiZWxzLmFwcGVuZENoaWxkKG1pbkxhYmVsKTtcbiAgICAgIHNsaWRlckxhYmVscy5hcHBlbmRDaGlsZChtYXhMYWJlbCk7XG4gICAgICB0aGlzLmVycm9yQ29udGFpbmVyID0gdGhpcy5lbGVtZW50O1xuXG4gICAgICB2YXIgbWluID0gdGhpcy5jb21wb25lbnQubWluO1xuICAgICAgdmFyIG1heCA9IHRoaXMuY29tcG9uZW50Lm1heDtcbiAgICAgIHZhciBzdGVwID0gdGhpcy5jb21wb25lbnQuc3RlcDtcblxuICAgICAgb3V0cHV0LmlubmVyVGV4dCA9IHRoaXMuaW5wdXQudmFsdWUgPT09IG1pbiA/IHRoaXMudG9DdXJyZW5jeSh0aGlzLmlucHV0LnZhbHVlKSArICcgb3IgbGVzcycgOiB0aGlzLmlucHV0LnZhbHVlID09PSBtYXggPyAoMCwgX251bWVyYWwyLmRlZmF1bHQpKHRoaXMuaW5wdXQudmFsdWUpLmZvcm1hdCgnJDAsMCcpICsgJyBvciBtb3JlJyA6ICgwLCBfbnVtZXJhbDIuZGVmYXVsdCkodGhpcy5pbnB1dC52YWx1ZSAtIHN0ZXApLmZvcm1hdCgnJDAsMCcpICsgJyAtICcgKyAoMCwgX251bWVyYWwyLmRlZmF1bHQpKHRoaXMuaW5wdXQudmFsdWUpLmZvcm1hdCgnJDAsMCcpO1xuICAgICAgdGhpcy5pbnB1dC5vbmlucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvdXRwdXQuaW5uZXJUZXh0ID0gdGhpcy52YWx1ZSA9PT0gbWluID8gKDAsIF9udW1lcmFsMi5kZWZhdWx0KSh0aGlzLnZhbHVlKS5mb3JtYXQoJyQwLDAnKSArICcgb3IgbGVzcycgOiB0aGlzLnZhbHVlID09PSBtYXggPyAoMCwgX251bWVyYWwyLmRlZmF1bHQpKHRoaXMudmFsdWUpLmZvcm1hdCgnJDAsMCcpICsgJyBvciBtb3JlJyA6ICgwLCBfbnVtZXJhbDIuZGVmYXVsdCkodGhpcy52YWx1ZSAtIHN0ZXApLmZvcm1hdCgnJDAsMCcpICsgJyAtICcgKyAoMCwgX251bWVyYWwyLmRlZmF1bHQpKHRoaXMudmFsdWUpLmZvcm1hdCgnJDAsMCcpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLmlucHV0LnZhbHVlKTtcblxuICAgICAgbWluTGFiZWwuaW5uZXJUZXh0ID0gdGhpcy50b0N1cnJlbmN5KHRoaXMuY29tcG9uZW50Lm1pbik7XG4gICAgICBtYXhMYWJlbC5pbm5lclRleHQgPSB0aGlzLnRvQ3VycmVuY3kodGhpcy5jb21wb25lbnQubWF4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjcmVhdGVJbnB1dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUlucHV0KGNvbnRhaW5lcikge1xuXG4gICAgICB2YXIgaW5wdXQgPSB0aGlzLmNlKCdpbnB1dCcsICdpbnB1dCcsIHtcbiAgICAgICAgdHlwZTogJ3JhbmdlJyxcbiAgICAgICAgY2xhc3M6ICdyYW5nZS1zbGlkZXJfX3JhbmdlJyxcbiAgICAgICAgbWluOiB0aGlzLmNvbXBvbmVudC5taW4sXG4gICAgICAgIG1heDogdGhpcy5jb21wb25lbnQubWF4LFxuICAgICAgICBzdGVwOiB0aGlzLmNvbXBvbmVudC5zdGVwLFxuICAgICAgICB2YWx1ZTogdGhpcy5jb21wb25lbnQuZGVmYXVsdFZhbHVlLFxuICAgICAgICBpZDogJ3JhbmdlLXNsaWRlcidcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9DdXJyZW5jeScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvQ3VycmVuY3koYW1vdW50KSB7XG4gICAgICByZXR1cm4gKDAsIF9udW1lcmFsMi5kZWZhdWx0KShhbW91bnQpLmZvcm1hdCgnJDAsMCcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZUVsZW1lbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KCkge1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lO1xuICAgICAgaWYgKHRoaXMuY29tcG9uZW50LmxhYmVsKSB7XG4gICAgICAgIGNsYXNzTmFtZSArPSAnIHJhbmdlLXNsaWRlcic7XG4gICAgICB9XG4gICAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLmNlKCdlbGVtZW50JywgJ2RpdicsIHtcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIGNsYXNzOiBjbGFzc05hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTbGlkZXJDb21wb25lbnQ7XG59KF9CYXNlLkJhc2VDb21wb25lbnQpOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuU3VydmV5Q29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2VhY2gyID0gcmVxdWlyZSgnbG9kYXNoL2VhY2gnKTtcblxudmFyIF9lYWNoMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2gyKTtcblxudmFyIF9CYXNlID0gcmVxdWlyZSgnLi4vYmFzZS9CYXNlJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFN1cnZleUNvbXBvbmVudCA9IGV4cG9ydHMuU3VydmV5Q29tcG9uZW50ID0gZnVuY3Rpb24gKF9CYXNlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhTdXJ2ZXlDb21wb25lbnQsIF9CYXNlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTdXJ2ZXlDb21wb25lbnQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN1cnZleUNvbXBvbmVudCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFN1cnZleUNvbXBvbmVudC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFN1cnZleUNvbXBvbmVudCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN1cnZleUNvbXBvbmVudCwgW3tcbiAgICBrZXk6ICdidWlsZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuY3JlYXRlRWxlbWVudCgpO1xuICAgICAgdGhpcy5jcmVhdGVMYWJlbCh0aGlzLmVsZW1lbnQpO1xuICAgICAgdGhpcy50YWJsZSA9IHRoaXMuY2UoJ3RhYmxlJywgJ3RhYmxlJywge1xuICAgICAgICBjbGFzczogJ3RhYmxlIHRhYmxlLXN0cmlwZWQgdGFibGUtYm9yZGVyZWQnXG4gICAgICB9KTtcblxuICAgICAgLy8gQnVpbGQgaGVhZGVyLlxuICAgICAgdmFyIHRoZWFkID0gdGhpcy5jZSgnaGVhZGVyJywgJ3RoZWFkJyk7XG4gICAgICB2YXIgdGhyID0gdGhpcy5jZSgnaGVhZGVyUm93JywgJ3RyJyk7XG4gICAgICB0aHIuYXBwZW5kQ2hpbGQodGhpcy5jZSgnaGVhZGVyQ29sdW1uJywgJ3RkJykpO1xuICAgICAgKDAsIF9lYWNoMy5kZWZhdWx0KSh0aGlzLmNvbXBvbmVudC52YWx1ZXMsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgdGggPSBfdGhpczIuY2UoJ2hlYWRlckNvbHVtbicsICd0aCcsIHtcbiAgICAgICAgICBzdHlsZTogJ3RleHQtYWxpZ246IGNlbnRlcjsnXG4gICAgICAgIH0pO1xuICAgICAgICB0aC5hcHBlbmRDaGlsZChfdGhpczIudGV4dCh2YWx1ZS5sYWJlbCkpO1xuICAgICAgICB0aHIuYXBwZW5kQ2hpbGQodGgpO1xuICAgICAgfSk7XG4gICAgICB0aGVhZC5hcHBlbmRDaGlsZCh0aHIpO1xuICAgICAgdGhpcy50YWJsZS5hcHBlbmRDaGlsZCh0aGVhZCk7XG4gICAgICAvLyBCdWlsZCB0aGUgYm9keS5cbiAgICAgIHZhciB0Ym9keSA9IHRoaXMuY2UoJ3RhYmxlJywgJ3Rib2R5Jyk7XG4gICAgICAoMCwgX2VhY2gzLmRlZmF1bHQpKHRoaXMuY29tcG9uZW50LnF1ZXN0aW9ucywgZnVuY3Rpb24gKHF1ZXN0aW9uKSB7XG4gICAgICAgIHZhciB0ciA9IF90aGlzMi5jZSgndGFibGVSb3cnLCAndHInKTtcbiAgICAgICAgdmFyIHRkID0gX3RoaXMyLmNlKCdxdWVzdGlvbkNvbHVtbicsICd0ZCcpO1xuICAgICAgICB0ZC5hcHBlbmRDaGlsZChfdGhpczIudGV4dChxdWVzdGlvbi5sYWJlbCkpO1xuICAgICAgICB0ci5hcHBlbmRDaGlsZCh0ZCk7XG4gICAgICAgICgwLCBfZWFjaDMuZGVmYXVsdCkoX3RoaXMyLmNvbXBvbmVudC52YWx1ZXMsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciB0ZCA9IF90aGlzMi5jZSgndmFsdWVDb2x1bW4nLCAndGQnLCB7XG4gICAgICAgICAgICBzdHlsZTogJ3RleHQtYWxpZ246IGNlbnRlcjsnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGlucHV0ID0gX3RoaXMyLmNlKCdpbnB1dCcsICdpbnB1dCcsIHtcbiAgICAgICAgICAgIHR5cGU6ICdyYWRpbycsXG4gICAgICAgICAgICBuYW1lOiAnZGF0YVsnICsgX3RoaXMyLmNvbXBvbmVudC5rZXkgKyAnXVsnICsgcXVlc3Rpb24udmFsdWUgKyAnXScsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUudmFsdWUsXG4gICAgICAgICAgICBpZDogX3RoaXMyLmlkICsgJy0nICsgcXVlc3Rpb24udmFsdWUgKyAnLScgKyB2YWx1ZS52YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIF90aGlzMi5hZGRJbnB1dChpbnB1dCwgdGQpO1xuICAgICAgICAgIHRyLmFwcGVuZENoaWxkKHRkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRib2R5LmFwcGVuZENoaWxkKHRyKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy50YWJsZS5hcHBlbmRDaGlsZCh0Ym9keSk7XG4gICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy50YWJsZSk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJlYWRPbmx5KSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUodmFsdWUsIG5vVXBkYXRlLCBub1ZhbGlkYXRlKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB2YXIga2V5ID0gJ2RhdGFbJyArIHRoaXMuY29tcG9uZW50LmtleSArICddJztcbiAgICAgICgwLCBfZWFjaDMuZGVmYXVsdCkodGhpcy5jb21wb25lbnQucXVlc3Rpb25zLCBmdW5jdGlvbiAocXVlc3Rpb24pIHtcbiAgICAgICAgKDAsIF9lYWNoMy5kZWZhdWx0KShfdGhpczMuaW5wdXRzLCBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQubmFtZSA9PT0ga2V5ICsgJ1snICsgcXVlc3Rpb24udmFsdWUgKyAnXScpIHtcbiAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSBpbnB1dC52YWx1ZSA9PT0gdmFsdWVbcXVlc3Rpb24udmFsdWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGlmICghbm9VcGRhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZShub1ZhbGlkYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciB2YWx1ZSA9IHt9O1xuICAgICAgdmFyIGtleSA9ICdkYXRhWycgKyB0aGlzLmNvbXBvbmVudC5rZXkgKyAnXSc7XG4gICAgICAoMCwgX2VhY2gzLmRlZmF1bHQpKHRoaXMuY29tcG9uZW50LnF1ZXN0aW9ucywgZnVuY3Rpb24gKHF1ZXN0aW9uKSB7XG4gICAgICAgICgwLCBfZWFjaDMuZGVmYXVsdCkoX3RoaXM0LmlucHV0cywgZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoZWNrZWQgJiYgaW5wdXQubmFtZSA9PT0ga2V5ICsgJ1snICsgcXVlc3Rpb24udmFsdWUgKyAnXScpIHtcbiAgICAgICAgICAgIHZhbHVlW3F1ZXN0aW9uLnZhbHVlXSA9IGlucHV0LnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3VydmV5Q29tcG9uZW50O1xufShfQmFzZS5CYXNlQ29tcG9uZW50KTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlRhYmxlQ29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2VhY2gyID0gcmVxdWlyZSgnbG9kYXNoL2VhY2gnKTtcblxudmFyIF9lYWNoMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2gyKTtcblxudmFyIF9Db21wb25lbnRzID0gcmVxdWlyZSgnLi4vQ29tcG9uZW50cycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBUYWJsZUNvbXBvbmVudCA9IGV4cG9ydHMuVGFibGVDb21wb25lbnQgPSBmdW5jdGlvbiAoX0Zvcm1pb0NvbXBvbmVudHMpIHtcbiAgX2luaGVyaXRzKFRhYmxlQ29tcG9uZW50LCBfRm9ybWlvQ29tcG9uZW50cyk7XG5cbiAgZnVuY3Rpb24gVGFibGVDb21wb25lbnQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRhYmxlQ29tcG9uZW50KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVGFibGVDb21wb25lbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUYWJsZUNvbXBvbmVudCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRhYmxlQ29tcG9uZW50LCBbe1xuICAgIGtleTogJ2J1aWxkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5lbGVtZW50ID0gdGhpcy5jZSgnZWxlbWVudCcsICdkaXYnLCB7XG4gICAgICAgIGNsYXNzOiAndGFibGUtcmVzcG9uc2l2ZSdcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgdGFibGVDbGFzcyA9ICd0YWJsZSAnO1xuICAgICAgKDAsIF9lYWNoMy5kZWZhdWx0KShbJ3N0cmlwZWQnLCAnYm9yZGVyZWQnLCAnaG92ZXInLCAnY29uZGVuc2VkJ10sIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIGlmIChfdGhpczIuY29tcG9uZW50W3Byb3BdKSB7XG4gICAgICAgICAgdGFibGVDbGFzcyArPSAndGFibGUtJyArIHByb3AgKyAnICc7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIHRhYmxlID0gdGhpcy5jZSgndGFibGUnLCAndGFibGUnLCB7XG4gICAgICAgIGNsYXNzOiB0YWJsZUNsYXNzXG4gICAgICB9KTtcblxuICAgICAgLy8gQnVpbGQgdGhlIGhlYWRlci5cbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5oZWFkZXIgJiYgdGhpcy5jb21wb25lbnQuaGVhZGVyLmxlbmd0aCkge1xuICAgICAgICB2YXIgdGhlYWQgPSB0aGlzLmNlKCdoZWFkZXInLCAndGhlYWQnKTtcbiAgICAgICAgdmFyIHRociA9IHRoaXMuY2UoJ2hlYWRlclJvdycsICd0cicpO1xuICAgICAgICAoMCwgX2VhY2gzLmRlZmF1bHQpKHRoaXMuY29tcG9uZW50LmhlYWRlciwgZnVuY3Rpb24gKGhlYWRlcikge1xuICAgICAgICAgIHZhciB0aCA9IF90aGlzMi5jZSgnaGVhZGVyQ29sdW1uJywgJ3RoJyk7XG4gICAgICAgICAgdGguYXBwZW5kQ2hpbGQoX3RoaXMyLnRleHQoaGVhZGVyKSk7XG4gICAgICAgICAgdGhyLmFwcGVuZENoaWxkKHRoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoZWFkLmFwcGVuZENoaWxkKHRocik7XG4gICAgICAgIHRhYmxlLmFwcGVuZENoaWxkKHRoZWFkKTtcbiAgICAgIH1cblxuICAgICAgLy8gQnVpbGQgdGhlIGJvZHkuXG4gICAgICB2YXIgdGJvZHkgPSB0aGlzLmNlKCd0YWJsZScsICd0Ym9keScpO1xuICAgICAgKDAsIF9lYWNoMy5kZWZhdWx0KSh0aGlzLmNvbXBvbmVudC5yb3dzLCBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciB0ciA9IF90aGlzMi5jZSgndGFibGVSb3cnLCAndHInKTtcbiAgICAgICAgKDAsIF9lYWNoMy5kZWZhdWx0KShyb3csIGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICB2YXIgdGQgPSBfdGhpczIuY2UoJ3RhYmxlQ29sdW1uJywgJ3RkJyk7XG4gICAgICAgICAgKDAsIF9lYWNoMy5kZWZhdWx0KShjb2x1bW4uY29tcG9uZW50cywgZnVuY3Rpb24gKGNvbXApIHtcbiAgICAgICAgICAgIF90aGlzMi5hZGRDb21wb25lbnQoY29tcCwgdGQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyLmFwcGVuZENoaWxkKHRkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRib2R5LmFwcGVuZENoaWxkKHRyKTtcbiAgICAgIH0pO1xuICAgICAgdGFibGUuYXBwZW5kQ2hpbGQodGJvZHkpO1xuICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRhYmxlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGFibGVDb21wb25lbnQ7XG59KF9Db21wb25lbnRzLkZvcm1pb0NvbXBvbmVudHMpOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuVGV4dEFyZWFDb21wb25lbnQgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9UZXh0RmllbGQgPSByZXF1aXJlKCcuLi90ZXh0ZmllbGQvVGV4dEZpZWxkJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFRleHRBcmVhQ29tcG9uZW50ID0gZXhwb3J0cy5UZXh0QXJlYUNvbXBvbmVudCA9IGZ1bmN0aW9uIChfVGV4dEZpZWxkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhUZXh0QXJlYUNvbXBvbmVudCwgX1RleHRGaWVsZENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVGV4dEFyZWFDb21wb25lbnQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRBcmVhQ29tcG9uZW50KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVGV4dEFyZWFDb21wb25lbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUZXh0QXJlYUNvbXBvbmVudCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRleHRBcmVhQ29tcG9uZW50LCBbe1xuICAgIGtleTogJ2VsZW1lbnRJbmZvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWxlbWVudEluZm8oKSB7XG4gICAgICB2YXIgaW5mbyA9IF9nZXQoVGV4dEFyZWFDb21wb25lbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGV4dEFyZWFDb21wb25lbnQucHJvdG90eXBlKSwgJ2VsZW1lbnRJbmZvJywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgIGluZm8udHlwZSA9ICd0ZXh0YXJlYSc7XG4gICAgICBpZiAodGhpcy5jb21wb25lbnQucm93cykge1xuICAgICAgICBpbmZvLmF0dHIucm93cyA9IHRoaXMuY29tcG9uZW50LnJvd3M7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGV4dEFyZWFDb21wb25lbnQ7XG59KF9UZXh0RmllbGQuVGV4dEZpZWxkQ29tcG9uZW50KTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlRleHRGaWVsZENvbXBvbmVudCA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX0Jhc2UgPSByZXF1aXJlKCcuLi9iYXNlL0Jhc2UnKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgVGV4dEZpZWxkQ29tcG9uZW50ID0gZXhwb3J0cy5UZXh0RmllbGRDb21wb25lbnQgPSBmdW5jdGlvbiAoX0Jhc2VDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFRleHRGaWVsZENvbXBvbmVudCwgX0Jhc2VDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRleHRGaWVsZENvbXBvbmVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dEZpZWxkQ29tcG9uZW50KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVGV4dEZpZWxkQ29tcG9uZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGV4dEZpZWxkQ29tcG9uZW50KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVGV4dEZpZWxkQ29tcG9uZW50LCBbe1xuICAgIGtleTogJ2VsZW1lbnRJbmZvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWxlbWVudEluZm8oKSB7XG4gICAgICB2YXIgaW5mbyA9IF9nZXQoVGV4dEZpZWxkQ29tcG9uZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRleHRGaWVsZENvbXBvbmVudC5wcm90b3R5cGUpLCAnZWxlbWVudEluZm8nLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgaW5mby50eXBlID0gJ2lucHV0JztcbiAgICAgIGluZm8uYXR0ci50eXBlID0gJ3RleHQnO1xuICAgICAgaW5mby5jaGFuZ2VFdmVudCA9ICdpbnB1dCc7XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGV4dEZpZWxkQ29tcG9uZW50O1xufShfQmFzZS5CYXNlQ29tcG9uZW50KTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlVua25vd25Db21wb25lbnQgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfQmFzZSA9IHJlcXVpcmUoJy4uL2Jhc2UvQmFzZScpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBVbmtub3duQ29tcG9uZW50ID0gZXhwb3J0cy5Vbmtub3duQ29tcG9uZW50ID0gZnVuY3Rpb24gKF9CYXNlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhVbmtub3duQ29tcG9uZW50LCBfQmFzZUNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVW5rbm93bkNvbXBvbmVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVW5rbm93bkNvbXBvbmVudCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFVua25vd25Db21wb25lbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihVbmtub3duQ29tcG9uZW50KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVW5rbm93bkNvbXBvbmVudCwgW3tcbiAgICBrZXk6ICdidWlsZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkKCkge1xuICAgICAgdGhpcy5lbGVtZW50ID0gdGhpcy5jZSgnZWxlbWVudCcsICdkaXYnLCB7XG4gICAgICAgIGlkOiB0aGlzLmlkXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnRleHQoJ1Vua25vd24gY29tcG9uZW50OiAnICsgdGhpcy5jb21wb25lbnQudHlwZSkpO1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVW5rbm93bkNvbXBvbmVudDtcbn0oX0Jhc2UuQmFzZUNvbXBvbmVudCk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5XZWxsQ29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX0NvbXBvbmVudHMgPSByZXF1aXJlKCcuLi9Db21wb25lbnRzJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFdlbGxDb21wb25lbnQgPSBleHBvcnRzLldlbGxDb21wb25lbnQgPSBmdW5jdGlvbiAoX0Zvcm1pb0NvbXBvbmVudHMpIHtcbiAgX2luaGVyaXRzKFdlbGxDb21wb25lbnQsIF9Gb3JtaW9Db21wb25lbnRzKTtcblxuICBmdW5jdGlvbiBXZWxsQ29tcG9uZW50KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWxsQ29tcG9uZW50KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoV2VsbENvbXBvbmVudC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFdlbGxDb21wb25lbnQpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhXZWxsQ29tcG9uZW50LCBbe1xuICAgIGtleTogJ2NsYXNzTmFtZScsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ3dlbGwgZm9ybWlvLWNvbXBvbmVudCBmb3JtaW8tY29tcG9uZW50LXdlbGwnO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBXZWxsQ29tcG9uZW50O1xufShfQ29tcG9uZW50cy5Gb3JtaW9Db21wb25lbnRzKTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRm9ybWlvRm9ybSA9IHVuZGVmaW5lZDtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX25hdGl2ZVByb21pc2VPbmx5ID0gcmVxdWlyZShcIm5hdGl2ZS1wcm9taXNlLW9ubHlcIik7XG5cbnZhciBfbmF0aXZlUHJvbWlzZU9ubHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbmF0aXZlUHJvbWlzZU9ubHkpO1xuXG52YXIgX2Zvcm1pbyA9IHJlcXVpcmUoXCIuL2Zvcm1pb1wiKTtcblxudmFyIF9mb3JtaW8yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9ybWlvKTtcblxudmFyIF9Db21wb25lbnRzID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9Db21wb25lbnRzXCIpO1xuXG52YXIgX2RlYm91bmNlMiA9IHJlcXVpcmUoXCJsb2Rhc2gvZGVib3VuY2VcIik7XG5cbnZhciBfZGVib3VuY2UzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVib3VuY2UyKTtcblxudmFyIF9lYWNoMiA9IHJlcXVpcmUoXCJsb2Rhc2gvZWFjaFwiKTtcblxudmFyIF9lYWNoMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2gyKTtcblxudmFyIF9jbG9uZTIgPSByZXF1aXJlKFwibG9kYXNoL2Nsb25lXCIpO1xuXG52YXIgX2Nsb25lMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nsb25lMik7XG5cbnZhciBfYXNzaWduMiA9IHJlcXVpcmUoXCJsb2Rhc2gvYXNzaWduXCIpO1xuXG52YXIgX2Fzc2lnbjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NpZ24yKTtcblxudmFyIF9ldmVudGVtaXR0ZXIgPSByZXF1aXJlKFwiZXZlbnRlbWl0dGVyMlwiKTtcblxudmFyIF9ldmVudGVtaXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRlbWl0dGVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIFRha2VuIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZFxuICpcbiAqIFRoaXMgaXMgbmVlZGVkIGZvciBQaGFudG9tSlMuXG4gKi9cbmlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcbiAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAob1RoaXMpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIGNsb3Nlc3QgdGhpbmcgcG9zc2libGUgdG8gdGhlIEVDTUFTY3JpcHQgNVxuICAgICAgLy8gaW50ZXJuYWwgSXNDYWxsYWJsZSBmdW5jdGlvblxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGUnKTtcbiAgICB9XG5cbiAgICB2YXIgYUFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICBmVG9CaW5kID0gdGhpcyxcbiAgICAgICAgZk5PUCA9IGZ1bmN0aW9uIGZOT1AoKSB7fSxcbiAgICAgICAgZkJvdW5kID0gZnVuY3Rpb24gZkJvdW5kKCkge1xuICAgICAgcmV0dXJuIGZUb0JpbmQuYXBwbHkodGhpcyBpbnN0YW5jZW9mIGZOT1AgPyB0aGlzIDogb1RoaXMsIGFBcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgfTtcblxuICAgIGlmICh0aGlzLnByb3RvdHlwZSkge1xuICAgICAgLy8gRnVuY3Rpb24ucHJvdG90eXBlIGRvZXNuJ3QgaGF2ZSBhIHByb3RvdHlwZSBwcm9wZXJ0eVxuICAgICAgZk5PUC5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcbiAgICB9XG4gICAgZkJvdW5kLnByb3RvdHlwZSA9IG5ldyBmTk9QKCk7XG5cbiAgICByZXR1cm4gZkJvdW5kO1xuICB9O1xufVxuXG52YXIgZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uIGdldE9wdGlvbnMob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCFvcHRpb25zLmV2ZW50cykge1xuICAgIG9wdGlvbnMuZXZlbnRzID0gbmV3IF9ldmVudGVtaXR0ZXIyLmRlZmF1bHQoe1xuICAgICAgd2lsZGNhcmQ6IGZhbHNlLFxuICAgICAgbWF4TGlzdGVuZXJzOiAwXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgYSBGb3JtLmlvIGZvcm0gd2l0aGluIHRoZSB3ZWJwYWdlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgRm9ybWlvRm9ybSBmcm9tICdmb3JtaW9qcy9mb3JtJztcbiAqIGxldCBmb3JtID0gbmV3IEZvcm1pb0Zvcm0oZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Zvcm1pbycpKTtcbiAqIGZvcm0uc3JjID0gJ2h0dHBzOi8vZXhhbXBsZXMuZm9ybS5pby9leGFtcGxlJztcbiAqL1xuXG52YXIgRm9ybWlvRm9ybSA9IGV4cG9ydHMuRm9ybWlvRm9ybSA9IGZ1bmN0aW9uIChfRm9ybWlvQ29tcG9uZW50cykge1xuICBfaW5oZXJpdHMoRm9ybWlvRm9ybSwgX0Zvcm1pb0NvbXBvbmVudHMpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEZvcm1pb0Zvcm0gaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0gVGhlIERPTSBlbGVtZW50IHlvdSB3aXNoIHRvIHJlbmRlciB0aGlzIGZvcm0gd2l0aGluLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNyZWF0ZSBhIG5ldyBmb3JtIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMucmVhZE9ubHkgLSBTZXQgdGhpcyBmb3JtIHRvIHJlYWRPbmx5XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5ub0FsZXJ0cyAtIFNldCB0byB0cnVlIHRvIGRpc2FibGUgdGhlIGFsZXJ0cyBkaWFsb2cuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5pMThuIC0gVGhlIHRyYW5zbGF0aW9uIGZpbGUgZm9yIHRoaXMgcmVuZGVyaW5nLiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtaW8vZm9ybWlvLmpzL2Jsb2IvbWFzdGVyL3NyYy9sb2NhbHMvZW4uanNcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnRlbXBsYXRlIC0gUHJvdmlkZXMgYSB3YXkgdG8gaW5qZWN0IGN1c3RvbSBsb2dpYyBpbnRvIHRoZSBjcmVhdGlvbiBvZiBldmVyeSBlbGVtZW50IHJlbmRlcmVkIHdpdGhpbiB0aGUgZm9ybS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IEZvcm1pb0Zvcm0gZnJvbSAnZm9ybWlvanMvZm9ybSc7XG4gICAqIGxldCBmb3JtID0gbmV3IEZvcm1pb0Zvcm0oZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Zvcm1pbycpLCB7XG4gICAqICAgcmVhZE9ubHk6IHRydWVcbiAgICogfSk7XG4gICAqIGZvcm0uc3JjID0gJ2h0dHBzOi8vZXhhbXBsZXMuZm9ybS5pby9leGFtcGxlJztcbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIEZvcm1pb0Zvcm0oZWxlbWVudCwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb3JtaW9Gb3JtKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoaXMgZWxlbWVudC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChGb3JtaW9Gb3JtLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRm9ybWlvRm9ybSkpLmNhbGwodGhpcywgbnVsbCwgZ2V0T3B0aW9ucyhvcHRpb25zKSkpO1xuXG4gICAgX3RoaXMudHlwZSA9ICdmb3JtJztcbiAgICBfdGhpcy5fc3JjID0gJyc7XG4gICAgX3RoaXMuX2xvYWRpbmcgPSBmYWxzZTtcbiAgICBfdGhpcy5fc3VibWlzc2lvbiA9IHt9O1xuICAgIF90aGlzLl9mb3JtID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBGb3JtaW8gaW5zdGFuY2UgZm9yIHRoaXMgZm9ybS5cbiAgICAgKiBAdHlwZSB7Rm9ybWlvfVxuICAgICAqL1xuICAgIF90aGlzLmZvcm1pbyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG9hZGVyIEhUTUwgZWxlbWVudC5cbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgX3RoaXMubG9hZGVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbGVydCBIVE1MIGVsZW1lbnRcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgX3RoaXMuYWxlcnQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogUHJvbWlzZSB0aGF0IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBzdWJtaXNzaW9uIGlzIGRvbmUgbG9hZGluZy5cbiAgICAgKiBAdHlwZSB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBfdGhpcy5vblN1Ym1pc3Npb24gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogUHJvbWlzZSB0aGF0IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBmb3JtIGlzIGRvbmUgYnVpbGRpbmcuXG4gICAgICogQHR5cGUge1Byb21pc2V9XG4gICAgICovXG4gICAgX3RoaXMub25Gb3JtQnVpbGQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogUHJvbWlzZSB0aGF0IGV4ZWN1dGVzIHdoZW4gdGhlIGZvcm0gaXMgcmVhZHkgYW5kIHJlbmRlcmVkLlxuICAgICAqIEB0eXBlIHtQcm9taXNlfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBsZXQgZm9ybSA9IG5ldyBGb3JtaW9Gb3JtKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmb3JtaW8nKSk7XG4gICAgICogZm9ybS5yZWFkeS50aGVuKCgpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdUaGUgZm9ybSBpcyByZWFkeSEnKTtcbiAgICAgKiB9KTtcbiAgICAgKiBmb3JtLnNyYyA9ICdodHRwczovL2V4YW1wbGVzLmZvcm0uaW8vZXhhbXBsZSc7XG4gICAgICovXG4gICAgX3RoaXMuZm9ybVJlYWR5ID0gbmV3IF9uYXRpdmVQcm9taXNlT25seTIuZGVmYXVsdChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCB3aGVuIHRoZSBmb3JtUmVhZHkgc3RhdGUgb2YgdGhpcyBmb3JtIGhhcyBiZWVuIHJlc29sdmVkLlxuICAgICAgICpcbiAgICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgICAqL1xuICAgICAgX3RoaXMuZm9ybVJlYWR5UmVzb2x2ZSA9IHJlc29sdmU7XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbGVkIHdoZW4gdGhpcyBmb3JtIGNvdWxkIG5vdCBsb2FkIGFuZCBpcyByZWplY3RlZC5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICAgKi9cbiAgICAgIF90aGlzLmZvcm1SZWFkeVJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFByb21pc2UgdGhhdCBleGVjdXRlcyB3aGVuIHRoZSBzdWJtaXNzaW9uIGlzIHJlYWR5IGFuZCByZW5kZXJlZC5cbiAgICAgKiBAdHlwZSB7UHJvbWlzZX1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbGV0IGZvcm0gPSBuZXcgRm9ybWlvRm9ybShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZm9ybWlvJykpO1xuICAgICAqIGZvcm0ucmVhZHkudGhlbigoKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygnVGhlIGZvcm0gaXMgcmVhZHkhJyk7XG4gICAgICogfSk7XG4gICAgICogZm9ybS5zcmMgPSAnaHR0cHM6Ly9leGFtcGxlcy5mb3JtLmlvL2V4YW1wbGUnO1xuICAgICAqL1xuICAgIF90aGlzLnN1Ym1pc3Npb25SZWFkeSA9IG5ldyBfbmF0aXZlUHJvbWlzZU9ubHkyLmRlZmF1bHQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgLyoqXG4gICAgICAgKiBDYWxsZWQgd2hlbiB0aGUgZm9ybVJlYWR5IHN0YXRlIG9mIHRoaXMgZm9ybSBoYXMgYmVlbiByZXNvbHZlZC5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICAgKi9cbiAgICAgIF90aGlzLnN1Ym1pc3Npb25SZWFkeVJlc29sdmUgPSByZXNvbHZlO1xuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxlZCB3aGVuIHRoaXMgZm9ybSBjb3VsZCBub3QgbG9hZCBhbmQgaXMgcmVqZWN0ZWQuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAgICovXG4gICAgICBfdGhpcy5zdWJtaXNzaW9uUmVhZHlSZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBhIG5ldyBzdWJtaXNzaW9uIGNoYW5nZSBhZnRlciBhIGNlcnRhaW4gZGVib3VuY2UgaW50ZXJ2YWwuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259IC0gQ2FsbCB0aGVuIHdoZW4geW91IHdpc2ggdG8gdHJpZ2dlciBhIHN1Ym1pc3Npb24gY2hhbmdlLlxuICAgICAqL1xuICAgIF90aGlzLnRyaWdnZXJTdWJtaXNzaW9uQ2hhbmdlID0gKDAsIF9kZWJvdW5jZTMuZGVmYXVsdCkoX3RoaXMub25TdWJtaXNzaW9uQ2hhbmdlLmJpbmQoX3RoaXMpLCAxMCk7XG5cbiAgICAvKipcbiAgICAgKiBQcm9taXNlIHRvIHRyaWdnZXIgd2hlbiB0aGUgZWxlbWVudCBmb3IgdGhpcyBmb3JtIGlzIGVzdGFibGlzaGVkLlxuICAgICAqXG4gICAgICogQHR5cGUge1Byb21pc2V9XG4gICAgICovXG4gICAgX3RoaXMub25FbGVtZW50ID0gbmV3IF9uYXRpdmVQcm9taXNlT25seTIuZGVmYXVsdChmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgLyoqXG4gICAgICAgKiBDYWxsZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgYmVlbiByZXNvbHZlZC5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICAgKi9cbiAgICAgIF90aGlzLmVsZW1lbnRSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIF90aGlzLnNldEVsZW1lbnQoZWxlbWVudCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRoZSBvdXRzaWRlIHdyYXBwZXIgZWxlbWVudCBvZiB0aGUgRm9ybS5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIHNldCBhcyB0aGUgb3V0c2lkZSB3cmFwcGVyIGVsZW1lbnQgZm9yIHRoaXMgZm9ybS5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRm9ybWlvRm9ybSwgW3tcbiAgICBrZXk6IFwic2V0RWxlbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdmFyIGNsYXNzTmFtZXMgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgY2xhc3NOYW1lcyArPSAnIGZvcm1pby1mb3JtJztcbiAgICAgIHRoaXMuYWRkQ2xhc3ModGhpcy5lbGVtZW50LCBjbGFzc05hbWVzKTtcbiAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG4gICAgICB0aGlzLnJlYWR5LnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5sb2FkaW5nID0gZmFsc2U7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIubG9hZGluZyA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmVsZW1lbnRSZXNvbHZlKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZW1iZWQgc291cmNlIG9mIHRoZSBmb3JtLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldEZvcm1cIixcblxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgSlNPTiBzY2hlbWEgZm9yIHRoZSBmb3JtIHRvIGJlIHJlbmRlcmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBsZXQgZm9ybSA9IG5ldyBGb3JtaW9Gb3JtKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmb3JtaW8nKSk7XG4gICAgICogZm9ybS5zZXRGb3JtKHtcbiAgICAgKiAgIGNvbXBvbmVudHM6IFtcbiAgICAgKiAgICAge1xuICAgICAqICAgICAgIHR5cGU6ICd0ZXh0ZmllbGQnLFxuICAgICAqICAgICAgIGtleTogJ2ZpcnN0TmFtZScsXG4gICAgICogICAgICAgbGFiZWw6ICdGaXJzdCBOYW1lJyxcbiAgICAgKiAgICAgICBwbGFjZWhvbGRlcjogJ0VudGVyIHlvdXIgZmlyc3QgbmFtZS4nLFxuICAgICAqICAgICAgIGlucHV0OiB0cnVlXG4gICAgICogICAgIH0sXG4gICAgICogICAgIHtcbiAgICAgKiAgICAgICB0eXBlOiAndGV4dGZpZWxkJyxcbiAgICAgKiAgICAgICBrZXk6ICdsYXN0TmFtZScsXG4gICAgICogICAgICAgbGFiZWw6ICdMYXN0IE5hbWUnLFxuICAgICAqICAgICAgIHBsYWNlaG9sZGVyOiAnRW50ZXIgeW91ciBsYXN0IG5hbWUnLFxuICAgICAqICAgICAgIGlucHV0OiB0cnVlXG4gICAgICogICAgIH0sXG4gICAgICogICAgIHtcbiAgICAgKiAgICAgICB0eXBlOiAnYnV0dG9uJyxcbiAgICAgKiAgICAgICBhY3Rpb246ICdzdWJtaXQnLFxuICAgICAqICAgICAgIGxhYmVsOiAnU3VibWl0JyxcbiAgICAgKiAgICAgICB0aGVtZTogJ3ByaW1hcnknXG4gICAgICogICAgIH1cbiAgICAgKiAgIF1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmb3JtIC0gVGhlIEpTT04gc2NoZW1hIG9mIHRoZSBmb3JtIEBzZWUgaHR0cHM6Ly9leGFtcGxlcy5mb3JtLmlvL2V4YW1wbGUgZm9yIGFuIGV4YW1wbGUgSlNPTiBzY2hlbWEuXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZvcm0oZm9ybSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmIChmb3JtLmRpc3BsYXkgPT09ICd3aXphcmQnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignWW91IG5lZWQgdG8gaW5zdGFudGlhdGUgdGhlIEZvcm1pb1dpemFyZCBjbGFzcyB0byB1c2UgdGhpcyBmb3JtIGFzIGEgd2l6YXJkLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vbkZvcm1CdWlsZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vbkZvcm1CdWlsZC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLmNyZWF0ZUZvcm0oZm9ybSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLmZvcm1SZWFkeVJlamVjdChlcnIpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5mb3JtUmVhZHlSZWplY3QoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB0aGUgZm9ybSBvYmplY3QuXG4gICAgICB0aGlzLl9mb3JtID0gZm9ybTtcblxuICAgICAgLy8gQ3JlYXRlIHRoZSBmb3JtLlxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRm9ybShmb3JtKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmb3JtIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IC0gVGhlIGZvcm0gSlNPTiBzY2hlbWEuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRTdWJtaXNzaW9uXCIsXG5cblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBzdWJtaXNzaW9uIGFuZCByZXR1cm5zIHRoZSBwcm9taXNlIHdoZW4gaXQgaXMgcmVhZHkuXG4gICAgICogQHBhcmFtIHN1Ym1pc3Npb25cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlLjxUUmVzdWx0Pn1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3VibWlzc2lvbihzdWJtaXNzaW9uKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMub25TdWJtaXNzaW9uID0gdGhpcy5mb3JtUmVhZHkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNC5zZXRWYWx1ZShzdWJtaXNzaW9uKTtcbiAgICAgICAgX3RoaXM0LnN1Ym1pc3Npb25SZWFkeVJlc29sdmUoKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNC5zdWJtaXNzaW9uUmVhZHlSZWplY3QoZXJyKTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNC5zdWJtaXNzaW9uUmVhZHlSZWplY3QoZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZShzdWJtaXNzaW9uLCBub1VwZGF0ZSwgbm9WYWxpZGF0ZSkge1xuICAgICAgdGhpcy5fc3VibWlzc2lvbiA9IHN1Ym1pc3Npb24gfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgcmV0dXJuIF9nZXQoRm9ybWlvRm9ybS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGb3JtaW9Gb3JtLnByb3RvdHlwZSksIFwic2V0VmFsdWVcIiwgdGhpcykuY2FsbCh0aGlzLCB0aGlzLl9zdWJtaXNzaW9uLmRhdGEsIG5vVXBkYXRlLCBub1ZhbGlkYXRlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICBpZiAoIXRoaXMuX3N1Ym1pc3Npb24uZGF0YSkge1xuICAgICAgICB0aGlzLl9zdWJtaXNzaW9uLmRhdGEgPSB7fTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N1Ym1pc3Npb24uZGF0YSA9ICgwLCBfYXNzaWduMy5kZWZhdWx0KSh0aGlzLmRhdGEsIF9nZXQoRm9ybWlvRm9ybS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGb3JtaW9Gb3JtLnByb3RvdHlwZSksIFwiZ2V0VmFsdWVcIiwgdGhpcykuY2FsbCh0aGlzKSk7XG4gICAgICByZXR1cm4gdGhpcy5fc3VibWlzc2lvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgZm9ybS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmb3JtIC0gVGhlIGZvcm0gb2JqZWN0IHRoYXQgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZS48VFJlc3VsdD59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVGb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUZvcm0oZm9ybSkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIC8qKlxuICAgICAgICoge0BsaW5rIEJhc2VDb21wb25lbnQuY29tcG9uZW50fVxuICAgICAgICovXG4gICAgICBpZiAodGhpcy5jb21wb25lbnQpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQuY29tcG9uZW50cyA9IGZvcm0uY29tcG9uZW50cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gZm9ybTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm9uRm9ybUJ1aWxkID0gdGhpcy5yZW5kZXIoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM1LmZvcm1SZWFkeVJlc29sdmUoKTtcbiAgICAgICAgaWYgKCFfdGhpczUub25TdWJtaXNzaW9uKSB7XG4gICAgICAgICAgX3RoaXM1LnN1Ym1pc3Npb25SZWFkeVJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpczUub25Gb3JtQnVpbGQgPSBudWxsO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICByZXR1cm4gX3RoaXM1LmZvcm1SZWFkeVJlamVjdChlcnIpO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICByZXR1cm4gX3RoaXM1LmZvcm1SZWFkeVJlamVjdChlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRoZSBmb3JtIHdpdGhpbiB0aGUgSFRNTCBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlLjxUUmVzdWx0Pn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMub25FbGVtZW50LnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczYuY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzNi5sb2NhbGl6ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNi5idWlsZCgpO1xuICAgICAgICAgIF90aGlzNi5vbigncmVzZXRGb3JtJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzNi5yZXNldCgpO1xuICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgIF90aGlzNi5vbignY29tcG9uZW50Q2hhbmdlJywgZnVuY3Rpb24gKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczYudHJpZ2dlclN1Ym1pc3Npb25DaGFuZ2UoY2hhbmdlZCk7XG4gICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgX3RoaXM2Lm9uKCdyZWZyZXNoRGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczYudXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBfdGhpczYuZW1pdCgncmVuZGVyJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIG5ldyBhbGVydCB0byBkaXNwbGF5IGluIHRoZSBlcnJvciBkaWFsb2cgb2YgdGhlIGZvcm0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIGFsZXJ0IHRvIGRpc3BsYXkuIFwiZGFuZ2VyXCIsIFwic3VjY2Vzc1wiLCBcIndhcm5pbmdcIiwgZXRjLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gVGhlIG1lc3NhZ2UgdG8gc2hvdyBpbiB0aGUgYWxlcnQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRBbGVydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBbGVydCh0eXBlLCBtZXNzYWdlKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm5vQWxlcnRzKSB7XG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYWxlcnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKHRoaXMuYWxlcnQpO1xuICAgICAgICAgIHRoaXMuYWxlcnQgPSBudWxsO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmFsZXJ0ID0gdGhpcy5jZSgnYWxlcnQtJyArIHR5cGUsICdkaXYnLCB7XG4gICAgICAgICAgY2xhc3M6ICdhbGVydCBhbGVydC0nICsgdHlwZSxcbiAgICAgICAgICByb2xlOiAnYWxlcnQnXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFsZXJ0LmlubmVySFRNTCA9IG1lc3NhZ2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuYWxlcnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmVwZW5kKHRoaXMuYWxlcnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ1aWxkIHRoZSBmb3JtLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYnVpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGQoKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgdGhpcy5vbignc3VibWl0QnV0dG9uJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM3LnN1Ym1pdCgpO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgICB0aGlzLmFkZENvbXBvbmVudHMoKTtcbiAgICAgIHRoaXMuY2hlY2tDb25kaXRpb25zKHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvdyB0aGUgZXJyb3JzIG9mIHRoaXMgZm9ybSB3aXRoaW4gdGhlIGFsZXJ0IGRpYWxvZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlcnJvciAtIEFuIG9wdGlvbmFsIGFkZGl0aW9uYWwgZXJyb3IgdG8gZGlzcGxheSBhbG9uZyB3aXRoIHRoZSBjb21wb25lbnQgZXJyb3JzLlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2hvd0Vycm9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93RXJyb3JzKGVycm9yKSB7XG4gICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgIHZhciBlcnJvcnMgPSB0aGlzLmVycm9ycztcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBlcnJvcnMucHVzaChlcnJvcik7XG4gICAgICB9XG4gICAgICBpZiAoIWVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zZXRBbGVydChmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBtZXNzYWdlID0gJzxwPicgKyB0aGlzLnQoJ2Vycm9yJykgKyAnPC9wPjx1bD4nO1xuICAgICAgKDAsIF9lYWNoMy5kZWZhdWx0KShlcnJvcnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBlcnIubWVzc2FnZSB8fCBlcnI7XG4gICAgICAgICAgbWVzc2FnZSArPSAnPGxpPjxzdHJvbmc+JyArIGVycm9yTWVzc2FnZSArICc8L3N0cm9uZz48L2xpPic7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbWVzc2FnZSArPSAnPC91bD4nO1xuICAgICAgdGhpcy5zZXRBbGVydCgnZGFuZ2VyJywgbWVzc2FnZSk7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3JzKTtcbiAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHN1Ym1pc3Npb24gaGFzIGNvbXBsZXRlZCwgb3IgaWYgdGhlIHN1Ym1pc3Npb24gbmVlZHMgdG8gYmUgc2VudCB0byBhbiBleHRlcm5hbCBsaWJyYXJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN1Ym1pc3Npb24gLSBUaGUgc3VibWlzc2lvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzYXZlZCAtIFdoZXRoZXIgb3Igbm90IHRoaXMgc3VibWlzc2lvbiB3YXMgc2F2ZWQgdG8gdGhlIHNlcnZlci5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSAtIFRoZSBzdWJtaXNzaW9uIG9iamVjdC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uU3VibWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uU3VibWl0KHN1Ym1pc3Npb24sIHNhdmVkKSB7XG4gICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2V0VmFsdWUoc3VibWlzc2lvbik7XG4gICAgICB0aGlzLnNldEFsZXJ0KCdzdWNjZXNzJywgJzxwPicgKyB0aGlzLnQoJ2NvbXBsZXRlJykgKyAnPC9wPicpO1xuICAgICAgdGhpcy5lbWl0KCdzdWJtaXQnLCBzdWJtaXNzaW9uKTtcbiAgICAgIGlmIChzYXZlZCkge1xuICAgICAgICB0aGlzLmVtaXQoJ3N1Ym1pdERvbmUnLCBzdWJtaXNzaW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdWJtaXNzaW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgdGhlIHN1Ym1pc3Npb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXJyb3IgLSBUaGUgZXJyb3IgdGhhdCBvY2N1cmVkLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25TdWJtaXNzaW9uRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25TdWJtaXNzaW9uRXJyb3IoZXJyb3IpIHtcbiAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3JtYWxpemUgdGhlIGVycm9yLlxuICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZXJyb3IgPSB7IG1lc3NhZ2U6IGVycm9yIH07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2hvd0Vycm9ycyhlcnJvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHN1Ym1pc3Npb24gaGFzIGNoYW5nZWQgaW4gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2hhbmdlZCAtIFRoZSBjaGFuZ2VkIHZhbHVlIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNoYW5nZWQuY29tcG9uZW50IC0gVGhlIGNvbXBvbmVudCB0aGF0IHdhcyBjaGFuZ2VkLlxuICAgICAqIEBwYXJhbSB7Kn0gY2hhbmdlZC52YWx1ZSAtIFRoZSBuZXcgdmFsdWUgb2YgdGhlIGNoYW5nZWQgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hhbmdlZC52YWxpZGF0ZSAtIElmIHRoZSBjaGFuZ2UgbmVlZHMgdG8gYmUgdmFsaWRhdGVkLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25TdWJtaXNzaW9uQ2hhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uU3VibWlzc2lvbkNoYW5nZShjaGFuZ2VkKSB7XG4gICAgICB2YXIgdmFsdWUgPSAoMCwgX2Nsb25lMy5kZWZhdWx0KSh0aGlzLnN1Ym1pc3Npb24pO1xuICAgICAgdmFsdWUuY2hhbmdlZCA9IGNoYW5nZWQ7XG4gICAgICB0aGlzLmNoZWNrRGF0YSh2YWx1ZS5kYXRhLCAhY2hhbmdlZC52YWxpZGF0ZSk7XG4gICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIHN1Ym1pc3Npb24gb2YgYSBmb3JtIGFuZCByZXN0b3JlcyBkZWZhdWx0cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbGV0IGZvcm0gPSBuZXcgRm9ybWlvRm9ybShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZm9ybWlvJykpO1xuICAgICAqIGZvcm0uc3JjID0gJ2h0dHBzOi8vZXhhbXBsZXMuZm9ybS5pby9leGFtcGxlJztcbiAgICAgKiBmb3JtLnN1Ym1pc3Npb24gPSB7ZGF0YToge1xuICAgICAqICAgZmlyc3ROYW1lOiAnSm9lJyxcbiAgICAgKiAgIGxhc3ROYW1lOiAnU21pdGgnLFxuICAgICAqICAgZW1haWw6ICdqb2VAZXhhbXBsZS5jb20nXG4gICAgICogfX07XG4gICAgICpcbiAgICAgKiAvLyBJbiB0d28gc2Vjb25kcywgcmVzZXQgdGhlIGRhdGEgaW4gdGhlIGZvcm0uXG4gICAgICogc2V0VGltZW91dCgoKSA9PiBmb3JtLnJlc2V0KCksIDIwMDApO1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAvLyBSZXNldCB0aGUgc3VibWlzc2lvbiBkYXRhLlxuICAgICAgdGhpcy5zZXRTdWJtaXNzaW9uKHsgZGF0YToge30gfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VscyB0aGUgc3VibWlzc2lvbi5cbiAgICAgKlxuICAgICAqIEBhbGlhcyByZXNldFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuY2VsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXhlY3V0ZVN1Ym1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleGVjdXRlU3VibWl0KCkge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICAgIC8vIERNU1xuICAgICAgdmFyIGNvbXAgPSBudWxsO1xuICAgICAgdGhpcy5ldmVyeUNvbXBvbmVudChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIGlmICgoY29tcG9uZW50LmNvbXBvbmVudC50eXBlID09PSAnY2hlY2tib3gnIHx8IGNvbXBvbmVudC5jb21wb25lbnQudHlwZSA9PT0gJ2pvcm5heWEnKSAmJiBjb21wb25lbnQuY29tcG9uZW50LnZhbGlkYXRlLnJlcXVpcmVkICYmICFjb21wb25lbnQuZ2V0VmFsdWUoKSkge1xuICAgICAgICAgIGNvbXAgPSBjb21wb25lbnQuY29tcG9uZW50LmtleTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChjb21wKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnN1Ym1pc3Npb24uZGF0YVtjb21wXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN1Ym1pc3Npb24gPSB0aGlzLnN1Ym1pc3Npb247XG4gICAgICBpZiAoc3VibWlzc2lvbiAmJiBzdWJtaXNzaW9uLmRhdGEgJiYgdGhpcy5jaGVja1ZhbGlkaXR5KHN1Ym1pc3Npb24uZGF0YSwgdHJ1ZSkpIHtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmZvcm1pbykge1xuICAgICAgICAgIHJldHVybiB0aGlzLm9uU3VibWl0KHN1Ym1pc3Npb24sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtaW8uc2F2ZVN1Ym1pc3Npb24oc3VibWlzc2lvbikudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzOC5vblN1Ym1pdChyZXN1bHQsIHRydWUpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzOC5vblN1Ym1pc3Npb25FcnJvcihlcnIpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzOC5vblN1Ym1pc3Npb25FcnJvcihlcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2hvd0Vycm9ycygpO1xuICAgICAgICByZXR1cm4gX25hdGl2ZVByb21pc2VPbmx5Mi5kZWZhdWx0LnJlamVjdCgnSW52YWxpZCBTdWJtaXNzaW9uJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3VibWl0cyB0aGUgZm9ybS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbGV0IGZvcm0gPSBuZXcgRm9ybWlvRm9ybShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZm9ybWlvJykpO1xuICAgICAqIGZvcm0uc3JjID0gJ2h0dHBzOi8vZXhhbXBsZXMuZm9ybS5pby9leGFtcGxlJztcbiAgICAgKiBmb3JtLnN1Ym1pc3Npb24gPSB7ZGF0YToge1xuICAgICAqICAgZmlyc3ROYW1lOiAnSm9lJyxcbiAgICAgKiAgIGxhc3ROYW1lOiAnU21pdGgnLFxuICAgICAqICAgZW1haWw6ICdqb2VAZXhhbXBsZS5jb20nXG4gICAgICogfX07XG4gICAgICogZm9ybS5zdWJtaXQoKS50aGVuKChzdWJtaXNzaW9uKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhzdWJtaXNzaW9uKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYmVmb3JlIC0gSWYgdGhpcyBzdWJtaXNzaW9uIG9jY3VyZWQgZnJvbSB0aGUgYmVmb3JlIGhhbmRsZXJzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IC0gQSBwcm9taXNlIHdoZW4gdGhlIGZvcm0gaXMgZG9uZSBzdWJtaXR0aW5nLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3VibWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1Ym1pdChiZWZvcmUpIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgICBpZiAoIWJlZm9yZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTdWJtaXQoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM5LmV4ZWN1dGVTdWJtaXQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlU3VibWl0KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNyY1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NyYztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIEZvcm0gc291cmNlLCB3aGljaCBpcyB0eXBpY2FsbHkgdGhlIEZvcm0uaW8gZW1iZWQgVVJMLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBmb3JtIGVtYmVkIHVybC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbGV0IGZvcm0gPSBuZXcgRm9ybWlvRm9ybShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZm9ybWlvJykpO1xuICAgICAqIGZvcm0uZm9ybVJlYWR5LnRoZW4oKCkgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ1RoZSBmb3JtIGlzIGZvcm1SZWFkeSEnKTtcbiAgICAgKiB9KTtcbiAgICAgKiBmb3JtLnNyYyA9ICdodHRwczovL2V4YW1wbGVzLmZvcm0uaW8vZXhhbXBsZSc7XG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG5cbiAgICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9zcmMgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZm9ybWlvID0gbmV3IF9mb3JtaW8yLmRlZmF1bHQodmFsdWUpO1xuXG4gICAgICBpZiAodGhpcy50eXBlID09PSAnZm9ybScpIHtcbiAgICAgICAgLy8gU2V0IHRoZSBvcHRpb25zIHNvdXJjZSBzbyB0aGlzIGNhbiBiZSBwYXNzZWQgdG8gb3RoZXIgY29tcG9uZW50cy5cbiAgICAgICAgdGhpcy5vcHRpb25zLnNyYyA9IHZhbHVlO1xuICAgICAgICB0aGlzLm9wdGlvbnMuZm9ybWlvID0gdGhpcy5mb3JtaW87XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZm9ybWlvLmxvYWRGb3JtKCkudGhlbihmdW5jdGlvbiAoZm9ybSkge1xuICAgICAgICByZXR1cm4gX3RoaXMxMC5zZXRGb3JtKGZvcm0pO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICByZXR1cm4gX3RoaXMxMC5mb3JtUmVhZHlSZWplY3QoZXJyKTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMTAuZm9ybVJlYWR5UmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLmZvcm1pby5zdWJtaXNzaW9uSWQpIHtcbiAgICAgICAgdGhpcy5vblN1Ym1pc3Npb24gPSB0aGlzLmZvcm1pby5sb2FkU3VibWlzc2lvbigpLnRoZW4oZnVuY3Rpb24gKHN1Ym1pc3Npb24pIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMxMC5zZXRTdWJtaXNzaW9uKHN1Ym1pc3Npb24pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMTAuc3VibWlzc2lvblJlYWR5UmVqZWN0KGVycik7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMxMC5zdWJtaXNzaW9uUmVhZHlSZWplY3QoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYm90aCB0aGUgZm9ybSBhbmQgc3VibWlzc2lvbiBoYXZlIGJlZW4gbG9hZGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IC0gVGhlIHByb21pc2UgdG8gdHJpZ2dlciB3aGVuIGJvdGggZm9ybSBhbmQgc3VibWlzc2lvbiBoYXZlIGxvYWRlZC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlYWR5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLmZvcm1SZWFkeS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMTEuc3VibWlzc2lvblJlYWR5O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiB0aGlzIGZvcm0gaXMgbG9hZGluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIFRSVUUgbWVhbnMgdGhlIGZvcm0gaXMgbG9hZGluZywgRkFMU0Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZGluZ1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvYWRpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBsb2FkaW5nIHN0YXRlIGZvciB0aGlzIGZvcm0sIGFuZCBhbHNvIHNob3cgdGhlIGxvYWRlciBzcGlubmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBsb2FkaW5nIC0gSWYgdGhpcyBmb3JtIHNob3VsZCBiZSBcImxvYWRpbmdcIiBvciBub3QuXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGxvYWRpbmcpIHtcbiAgICAgIGlmICh0aGlzLl9sb2FkaW5nICE9PSBsb2FkaW5nKSB7XG4gICAgICAgIHRoaXMuX2xvYWRpbmcgPSBsb2FkaW5nO1xuICAgICAgICBpZiAoIXRoaXMubG9hZGVyICYmIGxvYWRpbmcpIHtcbiAgICAgICAgICB0aGlzLmxvYWRlciA9IHRoaXMuY2UoJ2xvYWRlcldyYXBwZXInLCAnZGl2Jywge1xuICAgICAgICAgICAgY2xhc3M6ICdsb2FkZXItd3JhcHBlcidcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgc3Bpbm5lciA9IHRoaXMuY2UoJ2xvYWRlcicsICdkaXYnLCB7XG4gICAgICAgICAgICBjbGFzczogJ2xvYWRlciB0ZXh0LWNlbnRlcidcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmxvYWRlci5hcHBlbmRDaGlsZChzcGlubmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sb2FkZXIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgdGhpcy5wcmVwZW5kKHRoaXMubG9hZGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5sb2FkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JtXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZm9ybTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBmb3JtIHZhbHVlLlxuICAgICAqXG4gICAgICogQGFsaWFzIHNldEZvcm1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZm9ybSAtIFRoZSBmb3JtIHNjaGVtYSBvYmplY3QuXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGZvcm0pIHtcbiAgICAgIHRoaXMuc2V0Rm9ybShmb3JtKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdWJtaXNzaW9uIG9iamVjdCB0aGF0IHdhcyBzZXQgd2l0aGluIHRoaXMgZm9ybS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdWJtaXNzaW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN1Ym1pc3Npb24gb2YgYSBmb3JtLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBsZXQgZm9ybSA9IG5ldyBGb3JtaW9Gb3JtKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmb3JtaW8nKSk7XG4gICAgICogZm9ybS5zcmMgPSAnaHR0cHM6Ly9leGFtcGxlcy5mb3JtLmlvL2V4YW1wbGUnO1xuICAgICAqIGZvcm0uc3VibWlzc2lvbiA9IHtkYXRhOiB7XG4gICAgICogICBmaXJzdE5hbWU6ICdKb2UnLFxuICAgICAqICAgbGFzdE5hbWU6ICdTbWl0aCcsXG4gICAgICogICBlbWFpbDogJ2pvZUBleGFtcGxlLmNvbSdcbiAgICAgKiB9fTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdWJtaXNzaW9uIC0gVGhlIEZvcm0uaW8gc3VibWlzc2lvbiBvYmplY3QuXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHN1Ym1pc3Npb24pIHtcbiAgICAgIHRoaXMuc2V0U3VibWlzc2lvbihzdWJtaXNzaW9uKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRm9ybWlvRm9ybTtcbn0oX0NvbXBvbmVudHMuRm9ybWlvQ29tcG9uZW50cyk7XG5cbkZvcm1pb0Zvcm0uc2V0QmFzZVVybCA9IF9mb3JtaW8yLmRlZmF1bHQuc2V0QmFzZVVybDtcbkZvcm1pb0Zvcm0uc2V0QXBpVXJsID0gX2Zvcm1pbzIuZGVmYXVsdC5zZXRBcGlVcmw7XG5Gb3JtaW9Gb3JtLnNldEFwcFVybCA9IF9mb3JtaW8yLmRlZmF1bHQuc2V0QXBwVXJsO1xuXG4vKipcbiAqIEVtYmVkIHRoaXMgZm9ybSB3aXRoaW4gdGhlIGN1cnJlbnQgcGFnZS5cbiAqIEBwYXJhbSBlbWJlZFxuICovXG5Gb3JtaW9Gb3JtLmVtYmVkID0gZnVuY3Rpb24gKGVtYmVkKSB7XG4gIGlmICghZW1iZWQgfHwgIWVtYmVkLnNyYykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBpZCA9IGVtYmVkLmlkIHx8ICdmb3JtaW8tJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KTtcbiAgdmFyIGNsYXNzTmFtZSA9IGVtYmVkLmNsYXNzIHx8ICdmb3JtaW8tZm9ybS13cmFwcGVyJztcbiAgdmFyIGNvZGUgPSBlbWJlZC5zdHlsZXMgPyAnPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIGhyZWY9XCInICsgZW1iZWQuc3R5bGVzICsgJ1wiPicgOiAnJztcbiAgY29kZSArPSAnPGRpdiBpZD1cIicgKyBpZCArICdcIiBjbGFzcz1cIicgKyBjbGFzc05hbWUgKyAnXCI+PC9kaXY+JztcbiAgZG9jdW1lbnQud3JpdGUoY29kZSk7XG4gIHZhciBmb3JtRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgdmFyIGZvcm0gPSBuZXcgRm9ybWlvRm9ybShmb3JtRWxlbWVudCk7XG4gIGZvcm0uc3JjID0gZW1iZWQuc3JjO1xuICByZXR1cm4gZm9ybTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLkZvcm1pb0Zvcm0gPSBGb3JtaW9Gb3JtOyIsIid1c2Ugc3RyaWN0JztcblxuLy8gSW50ZW50aW9uYWxseSB1c2UgbmF0aXZlLXByb21pc2Utb25seSBoZXJlLi4uIE90aGVyIHByb21pc2UgbGlicmFyaWVzIChlczYtcHJvbWlzZSlcbi8vIGR1Y2stcHVuY2ggdGhlIGdsb2JhbCBQcm9taXNlIGRlZmluaXRpb24gd2hpY2ggbWVzc2VzIHVwIEFuZ3VsYXIgMiBzaW5jZSBpdFxuLy8gYWxzbyBkdWNrLXB1bmNoZXMgdGhlIGdsb2JhbCBQcm9taXNlIGRlZmluaXRpb24uIEZvciBub3csIGtlZXAgbmF0aXZlLXByb21pc2Utb25seS5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoXCJuYXRpdmUtcHJvbWlzZS1vbmx5XCIpO1xucmVxdWlyZSgnd2hhdHdnLWZldGNoJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRlbWl0dGVyMicpLkV2ZW50RW1pdHRlcjI7XG52YXIgY29weSA9IHJlcXVpcmUoJ3NoYWxsb3ctY29weScpO1xuXG4vKipcbiAqIFRoZSBGb3JtaW8gaW50ZXJmYWNlIGNsYXNzLlxuICpcbiAqICAgbGV0IGZvcm1pbyA9IG5ldyBGb3JtaW8oJ2h0dHBzOi8vZXhhbXBsZXMuZm9ybS5pby9leGFtcGxlJyk7XG4gKi9cblxudmFyIEZvcm1pbyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRm9ybWlvKHBhdGgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcm1pbyk7XG5cbiAgICAvLyBFbnN1cmUgd2UgaGF2ZSBhbiBpbnN0YW5jZSBvZiBGb3JtaW8uXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEZvcm1pbykpIHtcbiAgICAgIHJldHVybiBuZXcgRm9ybWlvKHBhdGgpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgb3VyIHZhcmlhYmxlcy5cbiAgICB0aGlzLmJhc2UgPSAnJztcbiAgICB0aGlzLnByb2plY3RzVXJsID0gJyc7XG4gICAgdGhpcy5wcm9qZWN0VXJsID0gJyc7XG4gICAgdGhpcy5wcm9qZWN0SWQgPSAnJztcbiAgICB0aGlzLmZvcm1VcmwgPSAnJztcbiAgICB0aGlzLmZvcm1zVXJsID0gJyc7XG4gICAgdGhpcy5mb3JtSWQgPSAnJztcbiAgICB0aGlzLnN1Ym1pc3Npb25zVXJsID0gJyc7XG4gICAgdGhpcy5zdWJtaXNzaW9uVXJsID0gJyc7XG4gICAgdGhpcy5zdWJtaXNzaW9uSWQgPSAnJztcbiAgICB0aGlzLmFjdGlvbnNVcmwgPSAnJztcbiAgICB0aGlzLmFjdGlvbklkID0gJyc7XG4gICAgdGhpcy5hY3Rpb25VcmwgPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0gJyc7XG5cbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnYmFzZScpKSB7XG4gICAgICB0aGlzLmJhc2UgPSBvcHRpb25zLmJhc2U7XG4gICAgfSBlbHNlIGlmIChGb3JtaW8uYmFzZVVybCkge1xuICAgICAgdGhpcy5iYXNlID0gRm9ybWlvLmJhc2VVcmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYmFzZSA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLm1hdGNoKC9odHRwW3NdPzpcXC9cXC9hcGkuLylbMF07XG4gICAgfVxuXG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICAvLyBBbGxvdyB1c2VyIHRvIGNyZWF0ZSBuZXcgcHJvamVjdHMgaWYgdGhpcyB3YXMgaW5zdGFudGlhdGVkIHdpdGhvdXRcbiAgICAgIC8vIGEgdXJsXG4gICAgICB0aGlzLnByb2plY3RVcmwgPSB0aGlzLmJhc2UgKyAnL3Byb2plY3QnO1xuICAgICAgdGhpcy5wcm9qZWN0c1VybCA9IHRoaXMuYmFzZSArICcvcHJvamVjdCc7XG4gICAgICB0aGlzLnByb2plY3RJZCA9IGZhbHNlO1xuICAgICAgdGhpcy5xdWVyeSA9ICcnO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdwcm9qZWN0JykpIHtcbiAgICAgIHRoaXMucHJvamVjdFVybCA9IG9wdGlvbnMucHJvamVjdDtcbiAgICB9XG5cbiAgICB2YXIgcHJvamVjdCA9IHRoaXMucHJvamVjdFVybCB8fCBGb3JtaW8ucHJvamVjdFVybDtcblxuICAgIC8vIFRoZSBiYXNlVVJMIGlzIHRoZSBzYW1lIGFzIHRoZSBwcm9qZWN0VXJsLiBUaGlzIGlzIGFsbW9zdCBjZXJ0YWlubHkgYWdhaW5zdFxuICAgIC8vIHRoZSBPcGVuIFNvdXJjZSBzZXJ2ZXIuXG4gICAgaWYgKHByb2plY3QgJiYgdGhpcy5iYXNlID09PSBwcm9qZWN0KSB7XG4gICAgICB0aGlzLm5vUHJvamVjdCA9IHRydWU7XG4gICAgICB0aGlzLnByb2plY3RVcmwgPSB0aGlzLmJhc2U7XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsaXplIHRvIGFuIGFic29sdXRlIHBhdGguXG4gICAgaWYgKHBhdGguaW5kZXhPZignaHR0cCcpICE9PSAwICYmIHBhdGguaW5kZXhPZignLy8nKSAhPT0gMCkge1xuICAgICAgcGF0aCA9IHRoaXMuYmFzZSArIHBhdGg7XG4gICAgfVxuXG4gICAgdmFyIGhvc3RwYXJ0cyA9IEZvcm1pby5nZXRVcmxQYXJ0cyhwYXRoKTtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICB2YXIgaG9zdE5hbWUgPSBob3N0cGFydHNbMV0gKyBob3N0cGFydHNbMl07XG4gICAgcGF0aCA9IGhvc3RwYXJ0cy5sZW5ndGggPiAzID8gaG9zdHBhcnRzWzNdIDogJyc7XG4gICAgdmFyIHF1ZXJ5cGFydHMgPSBwYXRoLnNwbGl0KCc/Jyk7XG4gICAgaWYgKHF1ZXJ5cGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgcGF0aCA9IHF1ZXJ5cGFydHNbMF07XG4gICAgICB0aGlzLnF1ZXJ5ID0gJz8nICsgcXVlcnlwYXJ0c1sxXTtcbiAgICB9XG5cbiAgICAvLyBSZWdpc3RlciBhIHNwZWNpZmljIHBhdGguXG4gICAgdmFyIHJlZ2lzdGVyUGF0aCA9IGZ1bmN0aW9uIHJlZ2lzdGVyUGF0aChuYW1lLCBiYXNlKSB7XG4gICAgICBfdGhpc1tuYW1lICsgJ3NVcmwnXSA9IGJhc2UgKyAnLycgKyBuYW1lO1xuICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnXFwvJyArIG5hbWUgKyAnXFwvKFteL10rKScpO1xuICAgICAgaWYgKHBhdGguc2VhcmNoKHJlZ2V4KSAhPT0gLTEpIHtcbiAgICAgICAgcGFydHMgPSBwYXRoLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgX3RoaXNbbmFtZSArICdVcmwnXSA9IHBhcnRzID8gYmFzZSArIHBhcnRzWzBdIDogJyc7XG4gICAgICAgIF90aGlzW25hbWUgKyAnSWQnXSA9IHBhcnRzLmxlbmd0aCA+IDEgPyBwYXJ0c1sxXSA6ICcnO1xuICAgICAgICBiYXNlICs9IHBhcnRzWzBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfTtcblxuICAgIC8vIFJlZ2lzdGVyIGFuIGFycmF5IG9mIGl0ZW1zLlxuICAgIHZhciByZWdpc3Rlckl0ZW1zID0gZnVuY3Rpb24gcmVnaXN0ZXJJdGVtcyhpdGVtcywgYmFzZSwgc3RhdGljQmFzZSkge1xuICAgICAgZm9yICh2YXIgaSBpbiBpdGVtcykge1xuICAgICAgICBpZiAoaXRlbXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHJlZ2lzdGVySXRlbXMoaXRlbSwgYmFzZSwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuZXdCYXNlID0gcmVnaXN0ZXJQYXRoKGl0ZW0sIGJhc2UpO1xuICAgICAgICAgICAgYmFzZSA9IHN0YXRpY0Jhc2UgPyBiYXNlIDogbmV3QmFzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKCF0aGlzLnByb2plY3RVcmwgfHwgdGhpcy5wcm9qZWN0VXJsID09PSB0aGlzLmJhc2UpIHtcbiAgICAgIHRoaXMucHJvamVjdFVybCA9IGhvc3ROYW1lO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5ub1Byb2plY3QpIHtcbiAgICAgIC8vIERldGVybWluZSB0aGUgcHJvamVjdFVybCBhbmQgcHJvamVjdElkXG4gICAgICBpZiAocGF0aC5zZWFyY2goLyhefFxcLykocHJvamVjdCkoJHxcXC8pLykgIT09IC0xKSB7XG4gICAgICAgIC8vIEdldCBwcm9qZWN0IGlkIGFzIHByb2plY3QvOnByb2plY3RJZC5cbiAgICAgICAgcmVnaXN0ZXJJdGVtcyhbJ3Byb2plY3QnXSwgaG9zdE5hbWUpO1xuICAgICAgfSBlbHNlIGlmIChob3N0TmFtZSA9PT0gdGhpcy5iYXNlKSB7XG4gICAgICAgIC8vIEdldCBwcm9qZWN0IGlkIGFzIGZpcnN0IHBhcnQgb2YgcGF0aCAoc3ViZGlyZWN0b3J5KS5cbiAgICAgICAgaWYgKGhvc3RwYXJ0cy5sZW5ndGggPiAzICYmIHBhdGguc3BsaXQoJy8nKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdmFyIHBhdGhQYXJ0cyA9IHBhdGguc3BsaXQoJy8nKTtcbiAgICAgICAgICBwYXRoUGFydHMuc2hpZnQoKTsgLy8gVGhyb3cgYXdheSB0aGUgZmlyc3QgLy5cbiAgICAgICAgICB0aGlzLnByb2plY3RJZCA9IHBhdGhQYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgIHBhdGggPSAnLycgKyBwYXRoUGFydHMuam9pbignLycpO1xuICAgICAgICAgIHRoaXMucHJvamVjdFVybCA9IGhvc3ROYW1lICsgJy8nICsgdGhpcy5wcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEdldCBwcm9qZWN0IGlkIGZyb20gc3ViZG9tYWluLlxuICAgICAgICBpZiAoaG9zdHBhcnRzLmxlbmd0aCA+IDIgJiYgKGhvc3RwYXJ0c1syXS5zcGxpdCgnLicpLmxlbmd0aCA+IDIgfHwgaG9zdE5hbWUuaW5kZXhPZignbG9jYWxob3N0JykgIT09IC0xKSkge1xuICAgICAgICAgIHRoaXMucHJvamVjdFVybCA9IGhvc3ROYW1lO1xuICAgICAgICAgIHRoaXMucHJvamVjdElkID0gaG9zdHBhcnRzWzJdLnNwbGl0KCcuJylbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucHJvamVjdHNVcmwgPSB0aGlzLnByb2plY3RzVXJsIHx8IHRoaXMuYmFzZSArICcvcHJvamVjdCc7XG4gICAgfVxuXG4gICAgLy8gQ29uZmlndXJlIEZvcm0gdXJscyBhbmQgZm9ybSBpZHMuXG4gICAgaWYgKHBhdGguc2VhcmNoKC8oXnxcXC8pKHByb2plY3R8Zm9ybSkoJHxcXC8pLykgIT09IC0xKSB7XG4gICAgICByZWdpc3Rlckl0ZW1zKFsnZm9ybScsIFsnc3VibWlzc2lvbicsICdhY3Rpb24nXV0sIHRoaXMucHJvamVjdFVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdWJSZWdFeCA9IG5ldyBSZWdFeHAoJ1xcLyhzdWJtaXNzaW9ufGFjdGlvbikoJHxcXC8uKiknKTtcbiAgICAgIHZhciBzdWJzID0gcGF0aC5tYXRjaChzdWJSZWdFeCk7XG4gICAgICB0aGlzLnBhdGhUeXBlID0gc3VicyAmJiBzdWJzLmxlbmd0aCA+IDEgPyBzdWJzWzFdIDogJyc7XG4gICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKHN1YlJlZ0V4LCAnJyk7XG4gICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgICAgdGhpcy5mb3Jtc1VybCA9IHRoaXMucHJvamVjdFVybCArICcvZm9ybSc7XG4gICAgICB0aGlzLmZvcm1VcmwgPSB0aGlzLnByb2plY3RVcmwgKyBwYXRoO1xuICAgICAgdGhpcy5mb3JtSWQgPSBwYXRoLnJlcGxhY2UoL15cXC8rfFxcLyskL2csICcnKTtcbiAgICAgIHZhciBpdGVtcyA9IFsnc3VibWlzc2lvbicsICdhY3Rpb24nXTtcbiAgICAgIGZvciAodmFyIGkgaW4gaXRlbXMpIHtcbiAgICAgICAgaWYgKGl0ZW1zLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICB0aGlzW2l0ZW0gKyAnc1VybCddID0gdGhpcy5wcm9qZWN0VXJsICsgcGF0aCArICcvJyArIGl0ZW07XG4gICAgICAgICAgaWYgKHRoaXMucGF0aFR5cGUgPT09IGl0ZW0gJiYgc3Vicy5sZW5ndGggPiAyICYmIHN1YnNbMl0pIHtcbiAgICAgICAgICAgIHRoaXNbaXRlbSArICdJZCddID0gc3Vic1syXS5yZXBsYWNlKC9eXFwvK3xcXC8rJC9nLCAnJyk7XG4gICAgICAgICAgICB0aGlzW2l0ZW0gKyAnVXJsJ10gPSB0aGlzLnByb2plY3RVcmwgKyBwYXRoICsgc3Vic1swXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIGFwcCB1cmwgaWYgaXQgaXMgbm90IHNldC5cbiAgICBpZiAoIUZvcm1pby5wcm9qZWN0VXJsU2V0KSB7XG4gICAgICBGb3JtaW8ucHJvamVjdFVybCA9IHRoaXMucHJvamVjdFVybDtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRm9ybWlvLCBbe1xuICAgIGtleTogJ2RlbGV0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUodHlwZSwgb3B0cykge1xuICAgICAgdmFyIF9pZCA9IHR5cGUgKyAnSWQnO1xuICAgICAgdmFyIF91cmwgPSB0eXBlICsgJ1VybCc7XG4gICAgICBpZiAoIXRoaXNbX2lkXSkge1xuICAgICAgICBQcm9taXNlLnJlamVjdCgnTm90aGluZyB0byBkZWxldGUnKTtcbiAgICAgIH1cbiAgICAgIEZvcm1pby5jYWNoZSA9IHt9O1xuICAgICAgcmV0dXJuIHRoaXMubWFrZVJlcXVlc3QodHlwZSwgdGhpc1tfdXJsXSwgJ2RlbGV0ZScsIG51bGwsIG9wdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2luZGV4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5kZXgodHlwZSwgcXVlcnksIG9wdHMpIHtcbiAgICAgIHZhciBfdXJsID0gdHlwZSArICdVcmwnO1xuICAgICAgcXVlcnkgPSBxdWVyeSB8fCAnJztcbiAgICAgIGlmIChxdWVyeSAmJiAodHlwZW9mIHF1ZXJ5ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihxdWVyeSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBxdWVyeSA9ICc/JyArIEZvcm1pby5zZXJpYWxpemUocXVlcnkucGFyYW1zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0KHR5cGUsIHRoaXNbX3VybF0gKyBxdWVyeSwgJ2dldCcsIG51bGwsIG9wdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NhdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzYXZlKHR5cGUsIGRhdGEsIG9wdHMpIHtcbiAgICAgIHZhciBfaWQgPSB0eXBlICsgJ0lkJztcbiAgICAgIHZhciBfdXJsID0gdHlwZSArICdVcmwnO1xuICAgICAgdmFyIG1ldGhvZCA9IHRoaXNbX2lkXSB8fCBkYXRhLl9pZCA/ICdwdXQnIDogJ3Bvc3QnO1xuICAgICAgdmFyIHJlcVVybCA9IHRoaXNbX2lkXSA/IHRoaXNbX3VybF0gOiB0aGlzW3R5cGUgKyAnc1VybCddO1xuICAgICAgaWYgKCF0aGlzW19pZF0gJiYgZGF0YS5faWQgJiYgbWV0aG9kID09PSAncHV0JyAmJiByZXFVcmwuaW5kZXhPZihkYXRhLl9pZCkgPT09IC0xKSB7XG4gICAgICAgIHJlcVVybCArPSAnLycgKyBkYXRhLl9pZDtcbiAgICAgIH1cbiAgICAgIEZvcm1pby5jYWNoZSA9IHt9O1xuICAgICAgcmV0dXJuIHRoaXMubWFrZVJlcXVlc3QodHlwZSwgcmVxVXJsICsgdGhpcy5xdWVyeSwgbWV0aG9kLCBkYXRhLCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsb2FkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZCh0eXBlLCBxdWVyeSwgb3B0cykge1xuICAgICAgdmFyIF9pZCA9IHR5cGUgKyAnSWQnO1xuICAgICAgdmFyIF91cmwgPSB0eXBlICsgJ1VybCc7XG4gICAgICBpZiAocXVlcnkgJiYgKHR5cGVvZiBxdWVyeSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocXVlcnkpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcXVlcnkgPSBGb3JtaW8uc2VyaWFsaXplKHF1ZXJ5LnBhcmFtcyk7XG4gICAgICB9XG4gICAgICBpZiAocXVlcnkpIHtcbiAgICAgICAgcXVlcnkgPSB0aGlzLnF1ZXJ5ID8gdGhpcy5xdWVyeSArICcmJyArIHF1ZXJ5IDogJz8nICsgcXVlcnk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeSA9IHRoaXMucXVlcnk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXNbX2lkXSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ01pc3NpbmcgJyArIF9pZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tYWtlUmVxdWVzdCh0eXBlLCB0aGlzW191cmxdICsgcXVlcnksICdnZXQnLCBudWxsLCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtYWtlUmVxdWVzdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2VSZXF1ZXN0KHR5cGUsIHVybCwgbWV0aG9kLCBkYXRhLCBvcHRzKSB7XG4gICAgICBtZXRob2QgPSAobWV0aG9kIHx8ICdHRVQnKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKCFvcHRzIHx8ICh0eXBlb2Ygb3B0cyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob3B0cykpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRzID0ge307XG4gICAgICB9XG5cbiAgICAgIHZhciByZXF1ZXN0QXJncyA9IHtcbiAgICAgICAgZm9ybWlvOiB0aGlzLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIG9wdHM6IG9wdHNcbiAgICAgIH07XG5cbiAgICAgIHZhciByZXF1ZXN0ID0gRm9ybWlvLnBsdWdpbldhaXQoJ3ByZVJlcXVlc3QnLCByZXF1ZXN0QXJncykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBGb3JtaW8ucGx1Z2luR2V0KCdyZXF1ZXN0JywgcmVxdWVzdEFyZ3MpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBGb3JtaW8ucmVxdWVzdCh1cmwsIG1ldGhvZCwgZGF0YSwgb3B0cy5oZWFkZXIsIG9wdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gRm9ybWlvLnBsdWdpbkFsdGVyKCd3cmFwUmVxdWVzdFByb21pc2UnLCByZXF1ZXN0LCByZXF1ZXN0QXJncyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9hZFByb2plY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkUHJvamVjdChxdWVyeSwgb3B0cykge1xuICAgICAgcmV0dXJuIHRoaXMubG9hZCgncHJvamVjdCcsIHF1ZXJ5LCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzYXZlUHJvamVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNhdmVQcm9qZWN0KGRhdGEsIG9wdHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNhdmUoJ3Byb2plY3QnLCBkYXRhLCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWxldGVQcm9qZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlUHJvamVjdChvcHRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWxldGUoJ3Byb2plY3QnLCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsb2FkRm9ybScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRGb3JtKHF1ZXJ5LCBvcHRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2FkKCdmb3JtJywgcXVlcnksIG9wdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NhdmVGb3JtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2F2ZUZvcm0oZGF0YSwgb3B0cykge1xuICAgICAgcmV0dXJuIHRoaXMuc2F2ZSgnZm9ybScsIGRhdGEsIG9wdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlbGV0ZUZvcm0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVGb3JtKG9wdHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlbGV0ZSgnZm9ybScsIG9wdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xvYWRGb3JtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRGb3JtcyhxdWVyeSwgb3B0cykge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXgoJ2Zvcm1zJywgcXVlcnksIG9wdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xvYWRTdWJtaXNzaW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZFN1Ym1pc3Npb24ocXVlcnksIG9wdHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvYWQoJ3N1Ym1pc3Npb24nLCBxdWVyeSwgb3B0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2F2ZVN1Ym1pc3Npb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzYXZlU3VibWlzc2lvbihkYXRhLCBvcHRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5zYXZlKCdzdWJtaXNzaW9uJywgZGF0YSwgb3B0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVsZXRlU3VibWlzc2lvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZVN1Ym1pc3Npb24ob3B0cykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlKCdzdWJtaXNzaW9uJywgb3B0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9hZFN1Ym1pc3Npb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZFN1Ym1pc3Npb25zKHF1ZXJ5LCBvcHRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleCgnc3VibWlzc2lvbnMnLCBxdWVyeSwgb3B0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbG9hZEFjdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRBY3Rpb24ocXVlcnksIG9wdHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvYWQoJ2FjdGlvbicsIHF1ZXJ5LCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzYXZlQWN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2F2ZUFjdGlvbihkYXRhLCBvcHRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5zYXZlKCdhY3Rpb24nLCBkYXRhLCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWxldGVBY3Rpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVBY3Rpb24ob3B0cykge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlKCdhY3Rpb24nLCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsb2FkQWN0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRBY3Rpb25zKHF1ZXJ5LCBvcHRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleCgnYWN0aW9ucycsIHF1ZXJ5LCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhdmFpbGFibGVBY3Rpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXZhaWxhYmxlQWN0aW9ucygpIHtcbiAgICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0KCdhdmFpbGFibGVBY3Rpb25zJywgdGhpcy5mb3JtVXJsICsgJy9hY3Rpb25zJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWN0aW9uSW5mbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFjdGlvbkluZm8obmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMubWFrZVJlcXVlc3QoJ2FjdGlvbkluZm8nLCB0aGlzLmZvcm1VcmwgKyAnL2FjdGlvbnMvJyArIG5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB0ZW1wb3JhcnkgYXV0aGVudGljYXRpb24gdG9rZW4gZm9yIHNpbmdsZSBwdXJwb3NlIHRva2VuIGdlbmVyYXRpb24uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFRlbXBUb2tlbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRlbXBUb2tlbihleHBpcmUsIGFsbG93ZWQpIHtcbiAgICAgIHZhciB0b2tlbiA9IEZvcm1pby5nZXRUb2tlbigpO1xuICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ1lvdSBtdXN0IGJlIGF1dGhlbnRpY2F0ZWQgdG8gZ2VuZXJhdGUgYSB0ZW1wb3JhcnkgYXV0aCB0b2tlbi4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0KCd0ZW1wVG9rZW4nLCB0aGlzLnByb2plY3RVcmwgKyAnL3Rva2VuJywgJ0dFVCcsIG51bGwsIHtcbiAgICAgICAgaGVhZGVyOiBuZXcgSGVhZGVycyh7XG4gICAgICAgICAgJ3gtZXhwaXJlJzogZXhwaXJlLFxuICAgICAgICAgICd4LWFsbG93JzogYWxsb3dlZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBsb2FkRmlsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwbG9hZEZpbGUoc3RvcmFnZSwgZmlsZSwgZmlsZU5hbWUsIGRpciwgcHJvZ3Jlc3NDYWxsYmFjaywgdXJsKSB7XG4gICAgICB2YXIgcmVxdWVzdEFyZ3MgPSB7XG4gICAgICAgIHByb3ZpZGVyOiBzdG9yYWdlLFxuICAgICAgICBtZXRob2Q6ICd1cGxvYWQnLFxuICAgICAgICBmaWxlOiBmaWxlLFxuICAgICAgICBmaWxlTmFtZTogZmlsZU5hbWUsXG4gICAgICAgIGRpcjogZGlyXG4gICAgICB9O1xuICAgICAgdmFyIHJlcXVlc3QgPSBGb3JtaW8ucGx1Z2luV2FpdCgncHJlUmVxdWVzdCcsIHJlcXVlc3RBcmdzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1pby5wbHVnaW5HZXQoJ2ZpbGVSZXF1ZXN0JywgcmVxdWVzdEFyZ3MpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIGlmIChzdG9yYWdlICYmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICBpZiAoRm9ybWlvLnByb3ZpZGVycy5zdG9yYWdlLmhhc093blByb3BlcnR5KHN0b3JhZ2UpKSB7XG4gICAgICAgICAgICAgIHZhciBwcm92aWRlciA9IG5ldyBGb3JtaW8ucHJvdmlkZXJzLnN0b3JhZ2Vbc3RvcmFnZV0odGhpcyk7XG4gICAgICAgICAgICAgIHJldHVybiBwcm92aWRlci51cGxvYWRGaWxlKGZpbGUsIGZpbGVOYW1lLCBkaXIsIHByb2dyZXNzQ2FsbGJhY2ssIHVybCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyAnU3RvcmFnZSBwcm92aWRlciBub3QgZm91bmQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0IHx8IHsgdXJsOiAnJyB9O1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgcmV0dXJuIEZvcm1pby5wbHVnaW5BbHRlcignd3JhcEZpbGVSZXF1ZXN0UHJvbWlzZScsIHJlcXVlc3QsIHJlcXVlc3RBcmdzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkb3dubG9hZEZpbGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb3dubG9hZEZpbGUoZmlsZSkge1xuICAgICAgdmFyIHJlcXVlc3RBcmdzID0ge1xuICAgICAgICBtZXRob2Q6ICdkb3dubG9hZCcsXG4gICAgICAgIGZpbGU6IGZpbGVcbiAgICAgIH07XG5cbiAgICAgIHZhciByZXF1ZXN0ID0gRm9ybWlvLnBsdWdpbldhaXQoJ3ByZVJlcXVlc3QnLCByZXF1ZXN0QXJncykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBGb3JtaW8ucGx1Z2luR2V0KCdmaWxlUmVxdWVzdCcsIHJlcXVlc3RBcmdzKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAoZmlsZS5zdG9yYWdlICYmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICBpZiAoRm9ybWlvLnByb3ZpZGVycy5zdG9yYWdlLmhhc093blByb3BlcnR5KGZpbGUuc3RvcmFnZSkpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gbmV3IEZvcm1pby5wcm92aWRlcnMuc3RvcmFnZVtmaWxlLnN0b3JhZ2VdKHRoaXMpO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuZG93bmxvYWRGaWxlKGZpbGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgJ1N0b3JhZ2UgcHJvdmlkZXIgbm90IGZvdW5kJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCB7IHVybDogJycgfTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgIHJldHVybiBGb3JtaW8ucGx1Z2luQWx0ZXIoJ3dyYXBGaWxlUmVxdWVzdFByb21pc2UnLCByZXF1ZXN0LCByZXF1ZXN0QXJncyk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdsb2FkUHJvamVjdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkUHJvamVjdHMocXVlcnksIG9wdHMpIHtcbiAgICAgIHF1ZXJ5ID0gcXVlcnkgfHwgJyc7XG4gICAgICBpZiAoKHR5cGVvZiBxdWVyeSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocXVlcnkpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcXVlcnkgPSAnPycgKyBzZXJpYWxpemUocXVlcnkucGFyYW1zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBGb3JtaW8ubWFrZVN0YXRpY1JlcXVlc3QoRm9ybWlvLmJhc2VVcmwgKyAnL3Byb2plY3QnICsgcXVlcnkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFVybFBhcnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VXJsUGFydHModXJsKSB7XG4gICAgICB2YXIgcmVnZXggPSAnXihodHRwW3NdPzpcXFxcL1xcXFwvKSc7XG4gICAgICBpZiAodGhpcy5iYXNlICYmIHVybC5pbmRleE9mKHRoaXMuYmFzZSkgPT09IDApIHtcbiAgICAgICAgcmVnZXggKz0gJygnICsgdGhpcy5iYXNlLnJlcGxhY2UoL15odHRwW3NdPzpcXC9cXC8vLCAnJykgKyAnKSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWdleCArPSAnKFteL10rKSc7XG4gICAgICB9XG4gICAgICByZWdleCArPSAnKCR8XFxcXC8uKiknO1xuICAgICAgcmV0dXJuIHVybC5tYXRjaChuZXcgUmVnRXhwKHJlZ2V4KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2VyaWFsaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKG9iaikge1xuICAgICAgdmFyIHN0ciA9IFtdO1xuICAgICAgZm9yICh2YXIgcCBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgIHN0ci5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChwKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtwXSkpO1xuICAgICAgICB9XG4gICAgICB9cmV0dXJuIHN0ci5qb2luKFwiJlwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtYWtlU3RhdGljUmVxdWVzdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2VTdGF0aWNSZXF1ZXN0KHVybCwgbWV0aG9kLCBkYXRhLCBvcHRzKSB7XG4gICAgICBtZXRob2QgPSAobWV0aG9kIHx8ICdHRVQnKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKCFvcHRzIHx8ICh0eXBlb2Ygb3B0cyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob3B0cykpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRzID0ge307XG4gICAgICB9XG4gICAgICB2YXIgcmVxdWVzdEFyZ3MgPSB7XG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfTtcblxuICAgICAgdmFyIHJlcXVlc3QgPSBGb3JtaW8ucGx1Z2luV2FpdCgncHJlUmVxdWVzdCcsIHJlcXVlc3RBcmdzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1pby5wbHVnaW5HZXQoJ3N0YXRpY1JlcXVlc3QnLCByZXF1ZXN0QXJncykudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIEZvcm1pby5yZXF1ZXN0KHVybCwgbWV0aG9kLCBkYXRhLCBvcHRzLmhlYWRlciwgb3B0cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBGb3JtaW8ucGx1Z2luQWx0ZXIoJ3dyYXBTdGF0aWNSZXF1ZXN0UHJvbWlzZScsIHJlcXVlc3QsIHJlcXVlc3RBcmdzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXF1ZXN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVxdWVzdCh1cmwsIG1ldGhvZCwgZGF0YSwgaGVhZGVyLCBvcHRzKSB7XG4gICAgICBpZiAoIXVybCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ05vIHVybCBwcm92aWRlZCcpO1xuICAgICAgfVxuICAgICAgbWV0aG9kID0gKG1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKTtcblxuICAgICAgLy8gRm9yIHJldmVyc2UgY29tcGF0aWJpbGl0eSwgaWYgdGhleSBwcm92aWRlZCB0aGUgaWdub3JlQ2FjaGUgcGFyYW1ldGVyLFxuICAgICAgLy8gdGhlbiBjaGFuZ2UgaXQgYmFjayB0byB0aGUgb3B0aW9ucyBmb3JtYXQgd2hlcmUgdGhhdCBpcyBhIHBhcmFtZXRlci5cbiAgICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIG9wdHMgPSB7IGlnbm9yZUNhY2hlOiBvcHRzIH07XG4gICAgICB9XG4gICAgICBpZiAoIW9wdHMgfHwgKHR5cGVvZiBvcHRzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvcHRzKSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNhY2hlS2V5ID0gYnRvYSh1cmwpO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBHZXQgdGhlIGNhY2hlZCBwcm9taXNlIHRvIHNhdmUgbXVsdGlwbGUgbG9hZHMuXG4gICAgICAgIGlmICghb3B0cy5pZ25vcmVDYWNoZSAmJiBtZXRob2QgPT09ICdHRVQnICYmIEZvcm1pby5jYWNoZS5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShGb3JtaW8uY2FjaGVbY2FjaGVLZXldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXF1ZXN0VG9rZW4gPSAnJztcbiAgICAgICAgcmVzb2x2ZShuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgLy8gU2V0IHVwIGFuZCBmZXRjaCByZXF1ZXN0XG4gICAgICAgICAgdmFyIGhlYWRlcnMgPSBoZWFkZXIgfHwgbmV3IEhlYWRlcnMoe1xuICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdDb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD1VVEYtOCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgdG9rZW4gPSBGb3JtaW8uZ2V0VG9rZW4oKTtcbiAgICAgICAgICBpZiAodG9rZW4gJiYgIW9wdHMubm9Ub2tlbikge1xuICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoJ3gtand0LXRva2VuJywgdG9rZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgbW9kZTogJ2NvcnMnXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVxdWVzdFRva2VuID0gaGVhZGVycy5nZXQoJ3gtand0LXRva2VuJyk7XG4gICAgICAgICAgcmVzb2x2ZShmZXRjaCh1cmwsIG9wdGlvbnMpKTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGVyci5tZXNzYWdlID0gJ0NvdWxkIG5vdCBjb25uZWN0IHRvIEFQSSBzZXJ2ZXIgKCcgKyBlcnIubWVzc2FnZSArICcpJztcbiAgICAgICAgICBlcnIubmV0d29ya0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDQwKSB7XG4gICAgICAgICAgICAgIEZvcm1pby5zZXRUb2tlbihudWxsKTtcbiAgICAgICAgICAgICAgRm9ybWlvLmV2ZW50cy5lbWl0KCdmb3JtaW8uc2Vzc2lvbkV4cGlyZWQnLCByZXNwb25zZS5ib2R5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAgICAgRm9ybWlvLmV2ZW50cy5lbWl0KCdmb3JtaW8udW5hdXRob3JpemVkJywgcmVzcG9uc2UuYm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJzZSBhbmQgcmV0dXJuIHRoZSBlcnJvciBhcyBhIHJlamVjdGVkIHByb21pc2UgdG8gcmVqZWN0IHRoaXMgcHJvbWlzZVxuICAgICAgICAgICAgcmV0dXJuIChyZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpICE9PSAtMSA/IHJlc3BvbnNlLmpzb24oKSA6IHJlc3BvbnNlLnRleHQoKSkudGhlbihmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBIYW5kbGUgZmV0Y2ggcmVzdWx0c1xuICAgICAgICAgIHZhciB0b2tlbiA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LWp3dC10b2tlbicpO1xuXG4gICAgICAgICAgLy8gSW4gc29tZSBzdHJhbmdlIGNhc2VzLCB0aGUgZmV0Y2ggbGlicmFyeSB3aWxsIHJldHVybiBhbiB4LWp3dC10b2tlbiB3aXRob3V0IHNlbmRpbmdcbiAgICAgICAgICAvLyBvbmUgdG8gdGhlIHNlcnZlci4gVGhpcyBoYXMgZXZlbiBiZWVuIGRlYnVnZ2VkIG9uIHRoZSBzZXJ2ZXIgdG8gdmVyaWZ5IHRoYXQgbm8gdG9rZW5cbiAgICAgICAgICAvLyB3YXMgaW50cm9kdWNlZCB3aXRoIHRoZSByZXF1ZXN0LCBidXQgdGhlIHJlc3BvbnNlIGNvbnRhaW5zIGEgdG9rZW4uIFRoaXMgaXMgYW4gSW52YWxpZFxuICAgICAgICAgIC8vIGNhc2Ugd2hlcmUgd2UgZG8gbm90IHNlbmQgYW4geC1qd3QtdG9rZW4gYW5kIGdldCBvbmUgaW4gcmV0dXJuIGZvciBhbnkgR0VUIHJlcXVlc3QuXG4gICAgICAgICAgdmFyIHRva2VuSW50cm9kdWNlZCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChtZXRob2QgPT09ICdHRVQnICYmICFyZXF1ZXN0VG9rZW4gJiYgdG9rZW4gJiYgdXJsLmluZGV4T2YoJ3Rva2VuPScpID09PSAtMSAmJiB1cmwuaW5kZXhPZigneC1qd3QtdG9rZW49JyA9PT0gLTEpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1Rva2VuIHdhcyBpbnRyb2R1Y2VkIGluIHJlcXVlc3QuJyk7XG4gICAgICAgICAgICB0b2tlbkludHJvZHVjZWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gMjAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDMwMCAmJiB0b2tlbiAmJiB0b2tlbiAhPT0gJycgJiYgIXRva2VuSW50cm9kdWNlZCkge1xuICAgICAgICAgICAgRm9ybWlvLnNldFRva2VuKHRva2VuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gMjA0IGlzIG5vIGNvbnRlbnQuIERvbid0IHRyeSB0byAuanNvbigpIGl0LlxuICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwNCkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgIT09IC0xID8gcmVzcG9uc2UuanNvbigpIDogcmVzcG9uc2UudGV4dCgpKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIC8vIEFkZCBzb21lIGNvbnRlbnQtcmFuZ2UgbWV0YWRhdGEgdG8gdGhlIHJlc3VsdCBoZXJlXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC1yYW5nZScpO1xuICAgICAgICAgICAgaWYgKHJhbmdlICYmICh0eXBlb2YgcmVzdWx0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihyZXN1bHQpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgcmFuZ2UgPSByYW5nZS5zcGxpdCgnLycpO1xuICAgICAgICAgICAgICBpZiAocmFuZ2VbMF0gIT09ICcqJykge1xuICAgICAgICAgICAgICAgIHZhciBza2lwTGltaXQgPSByYW5nZVswXS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5za2lwID0gTnVtYmVyKHNraXBMaW1pdFswXSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmxpbWl0ID0gc2tpcExpbWl0WzFdIC0gc2tpcExpbWl0WzBdICsgMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQuc2VydmVyQ291bnQgPSByYW5nZVsxXSA9PT0gJyonID8gcmFuZ2VbMV0gOiBOdW1iZXIocmFuZ2VbMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW9wdHMuZ2V0SGVhZGVycykge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBrZXkpIHtcbiAgICAgICAgICAgICAgaGVhZGVyc1trZXldID0gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICByZXNvbHZlKHsgcmVzdWx0OiByZXN1bHQsIGhlYWRlcnM6IGhlYWRlcnMgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGlmIChlcnIgPT09ICdCYWQgVG9rZW4nKSB7XG4gICAgICAgICAgICBGb3JtaW8uc2V0VG9rZW4obnVsbCk7XG4gICAgICAgICAgICBGb3JtaW8uZXZlbnRzLmVtaXQoJ2Zvcm1pby5iYWRUb2tlbicsIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChGb3JtaW8uY2FjaGUuaGFzT3duUHJvcGVydHkoY2FjaGVLZXkpKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgZmFpbGVkIHByb21pc2VzIGZyb20gY2FjaGVcbiAgICAgICAgICAgIGRlbGV0ZSBGb3JtaW8uY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBQcm9wYWdhdGUgZXJyb3Igc28gY2xpZW50IGNhbiBoYW5kbGUgYWNjb3JkaW5nbHlcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAvLyBTYXZlIHRoZSBjYWNoZVxuICAgICAgICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgIEZvcm1pby5jYWNoZVtjYWNoZUtleV0gPSBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNoYWxsb3cgY29weSByZXN1bHQgc28gbW9kaWZpY2F0aW9ucyBkb24ndCBlbmQgdXAgaW4gY2FjaGVcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgIHZhciByZXN1bHRDb3B5ID0gcmVzdWx0Lm1hcChjb3B5KTtcbiAgICAgICAgICByZXN1bHRDb3B5LnNraXAgPSByZXN1bHQuc2tpcDtcbiAgICAgICAgICByZXN1bHRDb3B5LmxpbWl0ID0gcmVzdWx0LmxpbWl0O1xuICAgICAgICAgIHJlc3VsdENvcHkuc2VydmVyQ291bnQgPSByZXN1bHQuc2VydmVyQ291bnQ7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdENvcHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvcHkocmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFRva2VuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VG9rZW4odG9rZW4pIHtcbiAgICAgIHRva2VuID0gdG9rZW4gfHwgJyc7XG4gICAgICBpZiAodG9rZW4gPT09IHRoaXMudG9rZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICBGb3JtaW8uc2V0VXNlcihudWxsKTtcbiAgICAgICAgLy8gaU9TIGluIHByaXZhdGUgYnJvd3NlIG1vZGUgd2lsbCB0aHJvdyBhbiBlcnJvciBidXQgd2UgY2FuJ3QgZGV0ZWN0IGFoZWFkIG9mIHRpbWUgdGhhdCB3ZSBhcmUgaW4gcHJpdmF0ZSBtb2RlLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnZm9ybWlvVG9rZW4nKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBpT1MgaW4gcHJpdmF0ZSBicm93c2UgbW9kZSB3aWxsIHRocm93IGFuIGVycm9yIGJ1dCB3ZSBjYW4ndCBkZXRlY3QgYWhlYWQgb2YgdGltZSB0aGF0IHdlIGFyZSBpbiBwcml2YXRlIG1vZGUuXG4gICAgICB0cnkge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnZm9ybWlvVG9rZW4nLCB0b2tlbik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICAgIH1cbiAgICAgIHJldHVybiBGb3JtaW8uY3VycmVudFVzZXIoKTsgLy8gUnVuIHRoaXMgc28gdXNlciBpcyB1cGRhdGVkIGlmIG51bGxcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRUb2tlbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRva2VuKCkge1xuICAgICAgaWYgKHRoaXMudG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW47XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZm9ybWlvVG9rZW4nKSB8fCAnJztcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRVc2VyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VXNlcih1c2VyKSB7XG4gICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgdGhpcy5zZXRUb2tlbihudWxsKTtcbiAgICAgICAgLy8gaU9TIGluIHByaXZhdGUgYnJvd3NlIG1vZGUgd2lsbCB0aHJvdyBhbiBlcnJvciBidXQgd2UgY2FuJ3QgZGV0ZWN0IGFoZWFkIG9mIHRpbWUgdGhhdCB3ZSBhcmUgaW4gcHJpdmF0ZSBtb2RlLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnZm9ybWlvVXNlcicpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGlPUyBpbiBwcml2YXRlIGJyb3dzZSBtb2RlIHdpbGwgdGhyb3cgYW4gZXJyb3IgYnV0IHdlIGNhbid0IGRldGVjdCBhaGVhZCBvZiB0aW1lIHRoYXQgd2UgYXJlIGluIHByaXZhdGUgbW9kZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdmb3JtaW9Vc2VyJywgSlNPTi5zdHJpbmdpZnkodXNlcikpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VXNlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVzZXIoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZm9ybWlvVXNlcicpIHx8IG51bGwpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0QmFzZVVybCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEJhc2VVcmwodXJsKSB7XG4gICAgICBGb3JtaW8uYmFzZVVybCA9IHVybDtcbiAgICAgIGlmICghRm9ybWlvLnByb2plY3RVcmxTZXQpIHtcbiAgICAgICAgRm9ybWlvLnByb2plY3RVcmwgPSB1cmw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0QmFzZVVybCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhc2VVcmwoKSB7XG4gICAgICByZXR1cm4gRm9ybWlvLmJhc2VVcmw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0QXBpVXJsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QXBpVXJsKHVybCkge1xuICAgICAgcmV0dXJuIEZvcm1pby5zZXRCYXNlVXJsKHVybCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0QXBpVXJsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXBpVXJsKCkge1xuICAgICAgcmV0dXJuIEZvcm1pby5nZXRCYXNlVXJsKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0QXBwVXJsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QXBwVXJsKHVybCkge1xuICAgICAgY29uc29sZS53YXJuKCdGb3JtaW8uc2V0QXBwVXJsKCkgaXMgZGVwcmVjYXRlZC4gVXNlIEZvcm1pby5zZXRQcm9qZWN0VXJsIGluc3RlYWQuJyk7XG4gICAgICBGb3JtaW8ucHJvamVjdFVybCA9IHVybDtcbiAgICAgIEZvcm1pby5wcm9qZWN0VXJsU2V0ID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRQcm9qZWN0VXJsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UHJvamVjdFVybCh1cmwpIHtcbiAgICAgIEZvcm1pby5wcm9qZWN0VXJsID0gdXJsO1xuICAgICAgRm9ybWlvLnByb2plY3RVcmxTZXQgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldEFwcFVybCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFwcFVybCgpIHtcbiAgICAgIGNvbnNvbGUud2FybignRm9ybWlvLmdldEFwcFVybCgpIGlzIGRlcHJlY2F0ZWQuIFVzZSBGb3JtaW8uZ2V0UHJvamVjdFVybCBpbnN0ZWFkLicpO1xuICAgICAgcmV0dXJuIEZvcm1pby5wcm9qZWN0VXJsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFByb2plY3RVcmwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcm9qZWN0VXJsKCkge1xuICAgICAgcmV0dXJuIEZvcm1pby5wcm9qZWN0VXJsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NsZWFyQ2FjaGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xuICAgICAgRm9ybWlvLmNhY2hlID0ge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbm9vcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vb3AoKSB7fVxuICB9LCB7XG4gICAga2V5OiAnaWRlbnRpdHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RlcmVnaXN0ZXJQbHVnaW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXJlZ2lzdGVyUGx1Z2luKHBsdWdpbikge1xuICAgICAgdmFyIGJlZm9yZUxlbmd0aCA9IEZvcm1pby5wbHVnaW5zLmxlbmd0aDtcbiAgICAgIEZvcm1pby5wbHVnaW5zID0gRm9ybWlvLnBsdWdpbnMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIGlmIChwICE9PSBwbHVnaW4gJiYgcC5fX25hbWUgIT09IHBsdWdpbikgcmV0dXJuIHRydWU7XG4gICAgICAgIChwLmRlcmVnaXN0ZXIgfHwgRm9ybWlvLm5vb3ApLmNhbGwocCwgRm9ybWlvKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYmVmb3JlTGVuZ3RoICE9PSBGb3JtaW8ucGx1Z2lucy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVnaXN0ZXJQbHVnaW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlclBsdWdpbihwbHVnaW4sIG5hbWUpIHtcbiAgICAgIEZvcm1pby5wbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgIEZvcm1pby5wbHVnaW5zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChiLnByaW9yaXR5IHx8IDApIC0gKGEucHJpb3JpdHkgfHwgMCk7XG4gICAgICB9KTtcbiAgICAgIHBsdWdpbi5fX25hbWUgPSBuYW1lO1xuICAgICAgKHBsdWdpbi5pbml0IHx8IEZvcm1pby5ub29wKS5jYWxsKHBsdWdpbiwgRm9ybWlvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRQbHVnaW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQbHVnaW4obmFtZSkge1xuICAgICAgcmV0dXJuIEZvcm1pby5wbHVnaW5zLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBwbHVnaW4pIHtcbiAgICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgaWYgKHBsdWdpbi5fX25hbWUgPT09IG5hbWUpIHJldHVybiBwbHVnaW47XG4gICAgICB9LCBudWxsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwbHVnaW5XYWl0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGx1Z2luV2FpdChwbHVnaW5Gbikge1xuICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoRm9ybWlvLnBsdWdpbnMubWFwKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgcmV0dXJuIChwbHVnaW5bcGx1Z2luRm5dIHx8IEZvcm1pby5ub29wKS5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgICAgfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3BsdWdpbkdldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsdWdpbkdldChwbHVnaW5Gbikge1xuICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICB2YXIgY2FsbFBsdWdpbiA9IGZ1bmN0aW9uIGNhbGxQbHVnaW4oaW5kZXgsIHBsdWdpbkZuKSB7XG4gICAgICAgIHZhciBwbHVnaW4gPSBGb3JtaW8ucGx1Z2luc1tpbmRleF07XG4gICAgICAgIGlmICghcGx1Z2luKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKChwbHVnaW4gJiYgcGx1Z2luW3BsdWdpbkZuXSB8fCBGb3JtaW8ubm9vcCkuYXBwbHkocGx1Z2luLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikpKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsICYmIHJlc3VsdCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIHJldHVybiBjYWxsUGx1Z2luLmFwcGx5KG51bGwsIFtpbmRleCArIDFdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBjYWxsUGx1Z2luLmFwcGx5KG51bGwsIFswXS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3BsdWdpbkFsdGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGx1Z2luQWx0ZXIocGx1Z2luRm4sIHZhbHVlKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgIHJldHVybiBGb3JtaW8ucGx1Z2lucy5yZWR1Y2UoZnVuY3Rpb24gKHZhbHVlLCBwbHVnaW4pIHtcbiAgICAgICAgcmV0dXJuIChwbHVnaW5bcGx1Z2luRm5dIHx8IEZvcm1pby5pZGVudGl0eSkuYXBwbHkocGx1Z2luLCBbdmFsdWVdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9LCB2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY3VycmVudFVzZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXJyZW50VXNlcigpIHtcbiAgICAgIHZhciB1cmwgPSBGb3JtaW8uYmFzZVVybCArICcvY3VycmVudCc7XG4gICAgICB2YXIgdXNlciA9IHRoaXMuZ2V0VXNlcigpO1xuICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1pby5wbHVnaW5BbHRlcignd3JhcFN0YXRpY1JlcXVlc3RQcm9taXNlJywgUHJvbWlzZS5yZXNvbHZlKHVzZXIpLCB7XG4gICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgbWV0aG9kOiAnR0VUJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciB0b2tlbiA9IHRoaXMuZ2V0VG9rZW4oKTtcbiAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIEZvcm1pby5wbHVnaW5BbHRlcignd3JhcFN0YXRpY1JlcXVlc3RQcm9taXNlJywgUHJvbWlzZS5yZXNvbHZlKG51bGwpLCB7XG4gICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgbWV0aG9kOiAnR0VUJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBGb3JtaW8ubWFrZVN0YXRpY1JlcXVlc3QodXJsKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBGb3JtaW8uc2V0VXNlcihyZXNwb25zZSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xvZ291dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvZ291dCgpIHtcbiAgICAgIEZvcm1pby5zZXRUb2tlbihudWxsKTtcbiAgICAgIEZvcm1pby5zZXRVc2VyKG51bGwpO1xuICAgICAgRm9ybWlvLmNsZWFyQ2FjaGUoKTtcbiAgICAgIHJldHVybiBGb3JtaW8ubWFrZVN0YXRpY1JlcXVlc3QoRm9ybWlvLmJhc2VVcmwgKyAnL2xvZ291dCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBhbiBIVE1MIGZvcm0gdG8gRm9ybS5pby5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmb3JtXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Zvcm0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtKF9mb3JtLCBvcHRpb25zLCBkb25lKSB7XG4gICAgICAvLyBGaXggdGhlIHBhcmFtZXRlcnMuXG4gICAgICBpZiAoIWRvbmUgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZG9uZSA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgZG9uZSA9IGRvbmUgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAvLyBJRiB0aGV5IHByb3ZpZGUgYSBqcXVlcnkgb2JqZWN0LCB0aGVuIHNlbGVjdCB0aGUgZWxlbWVudC5cbiAgICAgIGlmIChfZm9ybS5qcXVlcnkpIHtcbiAgICAgICAgX2Zvcm0gPSBfZm9ybVswXTtcbiAgICAgIH1cbiAgICAgIGlmICghX2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoJ0ludmFsaWQgRm9ybScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZ2V0QWN0aW9uID0gZnVuY3Rpb24gZ2V0QWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5mb3JtIHx8IF9mb3JtLmdldEF0dHJpYnV0ZSgnYWN0aW9uJyk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3VibWlzc2lvbiBvYmplY3QuXG4gICAgICAgKiBAcmV0dXJucyB7e2RhdGE6IHt9fX1cbiAgICAgICAqL1xuICAgICAgdmFyIGdldFN1Ym1pc3Npb24gPSBmdW5jdGlvbiBnZXRTdWJtaXNzaW9uKCkge1xuICAgICAgICB2YXIgc3VibWlzc2lvbiA9IHsgZGF0YToge30gfTtcbiAgICAgICAgdmFyIHNldFZhbHVlID0gZnVuY3Rpb24gc2V0VmFsdWUocGF0aCwgdmFsdWUpIHtcbiAgICAgICAgICB2YXIgaXNBcnJheSA9IHBhdGguc3Vic3RyKC0yKSA9PT0gJ1tdJztcbiAgICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgnW10nLCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwYXRocyA9IHBhdGgucmVwbGFjZSgvXFxbfFxcXVxcWy9nLCAnLicpLnJlcGxhY2UoL1xcXSQvZywgJycpLnNwbGl0KCcuJyk7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBzdWJtaXNzaW9uO1xuICAgICAgICAgIHdoaWxlIChwYXRoID0gcGF0aHMuc2hpZnQoKSkge1xuICAgICAgICAgICAgaWYgKCFwYXRocy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRbcGF0aF0pIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRbcGF0aF0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudFtwYXRoXS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50W3BhdGhdID0gdmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghY3VycmVudFtwYXRoXSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRbcGF0aF0gPSB7fTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFtwYXRoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gR2V0IHRoZSBmb3JtIGRhdGEgZnJvbSB0aGlzIGZvcm0uXG4gICAgICAgIHZhciBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShfZm9ybSk7XG4gICAgICAgIHZhciBlbnRyaWVzID0gZm9ybURhdGEuZW50cmllcygpO1xuICAgICAgICB2YXIgZW50cnkgPSBudWxsO1xuICAgICAgICB3aGlsZSAoZW50cnkgPSBlbnRyaWVzLm5leHQoKS52YWx1ZSkge1xuICAgICAgICAgIHNldFZhbHVlKGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1Ym1pc3Npb247XG4gICAgICB9O1xuXG4gICAgICAvLyBTdWJtaXRzIHRoZSBmb3JtLlxuICAgICAgdmFyIHN1Ym1pdCA9IGZ1bmN0aW9uIHN1Ym1pdChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhY3Rpb24gPSBnZXRBY3Rpb24oKTtcbiAgICAgICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbmV3IEZvcm1pbyhhY3Rpb24pLnNhdmVTdWJtaXNzaW9uKGdldFN1Ym1pc3Npb24oKSkudGhlbihmdW5jdGlvbiAoc3ViKSB7XG4gICAgICAgICAgZG9uZShudWxsLCBzdWIpO1xuICAgICAgICB9LCBkb25lKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEF0dGFjaCBmb3JtaW8gdG8gdGhlIHByb3ZpZGVkIGZvcm0uXG4gICAgICBpZiAoX2Zvcm0uYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgX2Zvcm0uYXR0YWNoRXZlbnQoJ3N1Ym1pdCcsIHN1Ym1pdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfZm9ybS5hZGRFdmVudExpc3RlbmVyKCdzdWJtaXQnLCBzdWJtaXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWJtaXQ6IHN1Ym1pdCxcbiAgICAgICAgZ2V0QWN0aW9uOiBnZXRBY3Rpb24sXG4gICAgICAgIGdldFN1Ym1pc3Npb246IGdldFN1Ym1pc3Npb25cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZmllbGREYXRhJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmllbGREYXRhKGRhdGEsIGNvbXBvbmVudCkge1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIGlmICghY29tcG9uZW50IHx8ICFjb21wb25lbnQua2V5KSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBvbmVudC5rZXkuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBkYXRhO1xuICAgICAgICB2YXIgcGFydHMgPSBjb21wb25lbnQua2V5LnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciBrZXkgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGtleSA9IHBhcnRzW2ldO1xuXG4gICAgICAgICAgLy8gSGFuZGxlIG5lc3RlZCByZXNvdXJjZXNcbiAgICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoJ19pZCcpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmRhdGE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmV0dXJuIGlmIHRoZSBrZXkgaXMgbm90IGZvdW5kIG9uIHRoZSB2YWx1ZS5cbiAgICAgICAgICBpZiAoIXZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDb252ZXJ0IG9sZCBzaW5nbGUgZmllbGQgZGF0YSBpbiBzdWJtaXNzaW9ucyB0byBtdWx0aXBsZVxuICAgICAgICAgIGlmIChrZXkgPT09IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdICYmIGNvbXBvbmVudC5tdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZVtrZXldKSkge1xuICAgICAgICAgICAgdmFsdWVba2V5XSA9IFt2YWx1ZVtrZXldXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZXQgdGhlIHZhbHVlIG9mIHRoaXMga2V5LlxuICAgICAgICAgIHZhbHVlID0gdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb252ZXJ0IG9sZCBzaW5nbGUgZmllbGQgZGF0YSBpbiBzdWJtaXNzaW9ucyB0byBtdWx0aXBsZVxuICAgICAgICBpZiAoY29tcG9uZW50Lm11bHRpcGxlICYmICFBcnJheS5pc0FycmF5KGRhdGFbY29tcG9uZW50LmtleV0pKSB7XG4gICAgICAgICAgZGF0YVtjb21wb25lbnQua2V5XSA9IFtkYXRhW2NvbXBvbmVudC5rZXldXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YVtjb21wb25lbnQua2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRm9ybWlvO1xufSgpO1xuXG4vLyBEZWZpbmUgYWxsIHRoZSBzdGF0aWMgcHJvcGVydGllcy5cblxuXG5leHBvcnRzLkZvcm1pbyA9IEZvcm1pbztcbkZvcm1pby5iYXNlVXJsID0gJ2h0dHBzOi8vYXBpLmZvcm0uaW8nO1xuRm9ybWlvLnByb2plY3RVcmwgPSBGb3JtaW8uYmFzZVVybDtcbkZvcm1pby5wcm9qZWN0VXJsU2V0ID0gZmFsc2U7XG5Gb3JtaW8ucGx1Z2lucyA9IFtdO1xuRm9ybWlvLmNhY2hlID0ge307XG5Gb3JtaW8ucHJvdmlkZXJzID0gcmVxdWlyZSgnLi9wcm92aWRlcnMnKTtcbkZvcm1pby5ldmVudHMgPSBuZXcgRXZlbnRFbWl0dGVyKHtcbiAgd2lsZGNhcmQ6IGZhbHNlLFxuICBtYXhMaXN0ZW5lcnM6IDBcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5Gb3JtaW8gPSBGb3JtaW87IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Gb3JtaW9XaXphcmQgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9uYXRpdmVQcm9taXNlT25seSA9IHJlcXVpcmUoJ25hdGl2ZS1wcm9taXNlLW9ubHknKTtcblxudmFyIF9uYXRpdmVQcm9taXNlT25seTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9uYXRpdmVQcm9taXNlT25seSk7XG5cbnZhciBfZm9ybWlvID0gcmVxdWlyZSgnLi9mb3JtaW8uZm9ybScpO1xuXG52YXIgX2Zvcm1pbzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb3JtaW8pO1xuXG52YXIgX2Zvcm1pbzMgPSByZXF1aXJlKCcuL2Zvcm1pbycpO1xuXG52YXIgX2Zvcm1pbzQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb3JtaW8zKTtcblxudmFyIF9lYWNoID0gcmVxdWlyZSgnbG9kYXNoL2VhY2gnKTtcblxudmFyIF9lYWNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2gpO1xuXG52YXIgX2Nsb25lID0gcmVxdWlyZSgnbG9kYXNoL2Nsb25lJyk7XG5cbnZhciBfY2xvbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xvbmUpO1xuXG52YXIgX2pzb25Mb2dpY0pzID0gcmVxdWlyZSgnanNvbi1sb2dpYy1qcycpO1xuXG52YXIgX2pzb25Mb2dpY0pzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2pzb25Mb2dpY0pzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgRm9ybWlvV2l6YXJkID0gZXhwb3J0cy5Gb3JtaW9XaXphcmQgPSBmdW5jdGlvbiAoX0Zvcm1pb0Zvcm0pIHtcbiAgX2luaGVyaXRzKEZvcm1pb1dpemFyZCwgX0Zvcm1pb0Zvcm0pO1xuXG4gIGZ1bmN0aW9uIEZvcm1pb1dpemFyZChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcm1pb1dpemFyZCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRm9ybWlvV2l6YXJkLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRm9ybWlvV2l6YXJkKSkuY2FsbCh0aGlzLCBlbGVtZW50LCBvcHRpb25zKSk7XG5cbiAgICBfdGhpcy5wYWdlcyA9IFtdO1xuICAgIF90aGlzLnBhZ2UgPSAwO1xuICAgIF90aGlzLmhpc3RvcnkgPSBbXTtcbiAgICBfdGhpcy5hbGxDb21wb25lbnRzID0ge307XG4gICAgX3RoaXMuX25leHRQYWdlID0gMTtcbiAgICBfdGhpcy5idXR0b25zID0gW107XG5cbiAgICAvLyBETVNcblxuICAgIF90aGlzLndpemFyZE5hdiA9IGZhbHNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGb3JtaW9XaXphcmQsIFt7XG4gICAga2V5OiAnc2V0UGFnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBhZ2UobnVtKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKG51bSA+PSAwICYmIG51bSA8IHRoaXMucGFnZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucGFnZSA9IG51bTtcbiAgICAgICAgdGhpcy5idXR0b25zID0gW107XG4gICAgICAgIHZhciBwYWdlID0gdGhpcy5jdXJyZW50UGFnZSgpO1xuICAgICAgICB0aGlzLmJ1dHRvbnMgPSBwYWdlLmJ1dHRvbnM7XG4gICAgICAgIHJldHVybiBfZ2V0KEZvcm1pb1dpemFyZC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGb3JtaW9XaXphcmQucHJvdG90eXBlKSwgJ3NldEZvcm0nLCB0aGlzKS5jYWxsKHRoaXMsIHRoaXMuY3VycmVudFBhZ2UoKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gU2F2ZSB0aGUgY29tcG9uZW50cyBmb3Igd2hlbiB3ZSBmaW5hbGx5IHN1Ym1pdC5cbiAgICAgICAgICBfdGhpczIuYWxsQ29tcG9uZW50c1tfdGhpczIucGFnZV0gPSAoMCwgX2Nsb25lMi5kZWZhdWx0KShfdGhpczIuY29tcG9uZW50cyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9uYXRpdmVQcm9taXNlT25seTIuZGVmYXVsdC5yZWplY3QoJ1BhZ2Ugbm90IGZvdW5kJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0TmV4dFBhZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROZXh0UGFnZShkYXRhLCBjdXJyZW50UGFnZSkge1xuICAgICAgdmFyIGZvcm0gPSB0aGlzLnBhZ2VzW2N1cnJlbnRQYWdlXTtcbiAgICAgIC8vIENoZWNrIGNvbmRpdGlvbmFsIG5leHRQYWdlXG4gICAgICBpZiAoZm9ybSkge1xuICAgICAgICB2YXIgcGFnZSA9ICsrY3VycmVudFBhZ2U7XG4gICAgICAgIGlmIChmb3JtLm5leHRQYWdlKSB7XG4gICAgICAgICAgLy8gQWxsb3cgZm9yIHNjcmlwdCBleGVjdXRpb24uXG4gICAgICAgICAgaWYgKHR5cGVvZiBmb3JtLm5leHRQYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZXZhbChmb3JtLm5leHRQYWdlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICBpZiAoIWlzTmFOKHBhcnNlSW50KHBhZ2UsIDEwKSkgJiYgaXNGaW5pdGUocGFnZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFnZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhZ2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBBc3N1bWUgdGhleSBwYXNzZWQgYmFjayB0aGUga2V5IG9mIHRoZSBwYWdlIHRvIGdvIHRvLlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQYWdlSW5kZXhCeUtleShwYWdlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdBbiBlcnJvciBvY2N1cnJlZCBpbiBhIGN1c3RvbSBuZXh0UGFnZSBmdW5jdGlvbiBzdGF0ZW1lbnQgZm9yIGNvbXBvbmVudCAnICsgZm9ybS5rZXksIGUpO1xuICAgICAgICAgICAgICByZXR1cm4gcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gT3IgdXNlIEpTT04gTG9naWMuXG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBfanNvbkxvZ2ljSnMyLmRlZmF1bHQuYXBwbHkoZm9ybS5uZXh0UGFnZSwge1xuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgcGFnZTogcGFnZSxcbiAgICAgICAgICAgICAgICBmb3JtOiBmb3JtXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB2YXIgbmV3UGFnZSA9IHBhcnNlSW50KHJlc3VsdCwgMTApO1xuICAgICAgICAgICAgICBpZiAoIWlzTmFOKHBhcnNlSW50KG5ld1BhZ2UsIDEwKSkgJiYgaXNGaW5pdGUobmV3UGFnZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3UGFnZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFBhZ2VJbmRleEJ5S2V5KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFnZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0UHJldmlvdXNQYWdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJldmlvdXNQYWdlKCkge1xuICAgICAgdmFyIHByZXYgPSB0aGlzLmhpc3RvcnkucG9wKCk7XG4gICAgICBpZiAodHlwZW9mIHByZXYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5wYWdlIC0gMTtcbiAgICB9XG5cbiAgICAvLyBETVNcblxuICB9LCB7XG4gICAga2V5OiAnbmV4dFBhZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0UGFnZSgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAvLyBETVNcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50c1tpXS50eXBlID09PSAnY2hlY2tib3gnICYmIHRoaXMuY29tcG9uZW50c1tpXS5jb21wb25lbnQudmFsaWRhdGUucmVxdWlyZWQgJiYgKHRoaXMuY29tcG9uZW50c1tpXS52YWx1ZSA9PT0gbnVsbCB8fCAhdGhpcy5jb21wb25lbnRzW2ldLnZhbHVlKSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnN1Ym1pc3Npb24uZGF0YVt0aGlzLmNvbXBvbmVudHNbaV0uY29tcG9uZW50LmtleV07XG4gICAgICAgIH1cblxuICAgICAgICBpKys7XG4gICAgICB9XG5cbiAgICAgIC8vIFZhbGlkYXRlIHRoZSBmb3JtIGJ1aWxlZCwgYmVmb3JlIGdvIHRvIHRoZSBuZXh0IHBhZ2VcbiAgICAgIGlmICh0aGlzLmNoZWNrVmFsaWRpdHkodGhpcy5zdWJtaXNzaW9uLmRhdGEsIHRydWUpKSB7XG4gICAgICAgIC8vIERNU1xuXG4gICAgICAgIGlmICh0aGlzLmJlZm9yZU5leHRQYWdlQ2FsbGJhY2spIHtcbiAgICAgICAgICB0aGlzLmJlZm9yZU5leHRQYWdlQ2FsbGJhY2sodGhpcywgdGhpcy5zdWJtaXNzaW9uLmRhdGEsIHRoaXMubmV4dFBhZ2VXaXRoVmFsaWRhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jaGVja0RhdGEodGhpcy5zdWJtaXNzaW9uLmRhdGEsIHRydWUpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmJlZm9yZU5leHQoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5oaXN0b3J5LnB1c2goX3RoaXMzLnBhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5zZXRQYWdlKF90aGlzMy5nZXROZXh0UGFnZShfdGhpczMuc3VibWlzc2lvbi5kYXRhLCBfdGhpczMucGFnZSkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczMuX25leHRQYWdlID0gX3RoaXMzLmdldE5leHRQYWdlKF90aGlzMy5zdWJtaXNzaW9uLmRhdGEsIF90aGlzMy5wYWdlKTtcbiAgICAgICAgICAgICAgX3RoaXMzLmVtaXQoJ25leHRQYWdlJywgeyBwYWdlOiBfdGhpczMucGFnZSwgc3VibWlzc2lvbjogX3RoaXMzLnN1Ym1pc3Npb24gfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9uYXRpdmVQcm9taXNlT25seTIuZGVmYXVsdC5yZWplY3QodGhpcy5zaG93RXJyb3JzKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERNU1xuXG4gIH0sIHtcbiAgICBrZXk6ICduZXh0UGFnZVdpdGhWYWxpZGF0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV4dFBhZ2VXaXRoVmFsaWRhdGlvbih0aGlzSW5zdGFuY2UsIGFkZGl0aW9uYWxGaWVsZHNWYWxpZGF0aW9uRGF0YSkge1xuICAgICAgLy9jb25zb2xlLmxvZygnbmV4dFBhZ2VXaXRoVmFsaWRhdGlvbicpO1xuXG4gICAgICAvL2NvbnNvbGUubG9nKCctLS0tLSAtLS0tLSAtLS0tLSAtLS0tLSAtLS0tLScpO1xuICAgICAgLy9jb25zb2xlLmxvZyh0aGlzSW5zdGFuY2UpO1xuXG4gICAgICAvL2NvbnNvbGUubG9nKCdhZGRpdGlvbmFsRmllbGRzVmFsaWRhdGlvbkRhdGE6Jyk7XG4gICAgICAvL2NvbnNvbGUuZGlyKGFkZGl0aW9uYWxGaWVsZHNWYWxpZGF0aW9uRGF0YSk7XG5cbiAgICAgIC8vY29uc29sZS5sb2coJy0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tJyk7XG5cbiAgICAgIHZhciBwcm9jZWVkVG9OZXh0UGFnZSA9IGZhbHNlO1xuXG4gICAgICAvLyBJZiBubyBkYXRhIGdpdmVuLCB0aGVuIHByb2NlZWQgdG8gdGhlIG5leHQgcGFnZS5cbiAgICAgIGlmICh0eXBlb2YgYWRkaXRpb25hbEZpZWxkc1ZhbGlkYXRpb25EYXRhID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcm9jZWVkVG9OZXh0UGFnZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRpdGlvbmFsRmllbGRzVmFsaWRhdGlvbkRhdGEpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRLZXk7XG5cbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgY3VycmVudE9iaiA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciB2YWxpZCA9IHZvaWQgMDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBhbGxWYWxpZCA9IDE7XG5cbiAgICAgICAgICBmb3IgKGN1cnJlbnRLZXkgaW4gYWRkaXRpb25hbEZpZWxkc1ZhbGlkYXRpb25EYXRhKSB7XG4gICAgICAgICAgICBjdXJyZW50T2JqID0gYWRkaXRpb25hbEZpZWxkc1ZhbGlkYXRpb25EYXRhW2N1cnJlbnRLZXldO1xuXG4gICAgICAgICAgICB2YWxpZCA9IGN1cnJlbnRPYmoudmFsaWQ7XG4gICAgICAgICAgICBtZXNzYWdlID0gY3VycmVudE9iai5tZXNzYWdlO1xuXG4gICAgICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICAgIHRoaXNJbnN0YW5jZS5nZXRDb21wb25lbnQoY3VycmVudEtleSwgZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5jcmVhdGVFcnJvckVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuYWRkSW5wdXRFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgYWxsVmFsaWQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhbGxWYWxpZCkge1xuICAgICAgICAgICAgcHJvY2VlZFRvTmV4dFBhZ2UgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICAgIH1cblxuICAgICAgLy9jb25zb2xlLmxvZygncHJvY2VlZFRvTmV4dFBhZ2UnICsgJyA9ICcgKyBwcm9jZWVkVG9OZXh0UGFnZSk7XG5cbiAgICAgIGlmIChwcm9jZWVkVG9OZXh0UGFnZSkge1xuICAgICAgICB0aGlzSW5zdGFuY2UuY2hlY2tEYXRhKHRoaXNJbnN0YW5jZS5zdWJtaXNzaW9uLmRhdGEsIHRydWUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzSW5zdGFuY2UuYmVmb3JlTmV4dCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXNJbnN0YW5jZS5oaXN0b3J5LnB1c2godGhpc0luc3RhbmNlLnBhZ2UpO1xuXG4gICAgICAgICAgcmV0dXJuIHRoaXNJbnN0YW5jZS5zZXRQYWdlKHRoaXNJbnN0YW5jZS5nZXROZXh0UGFnZSh0aGlzSW5zdGFuY2Uuc3VibWlzc2lvbi5kYXRhLCB0aGlzSW5zdGFuY2UucGFnZSkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpc0luc3RhbmNlLl9uZXh0UGFnZSA9IHRoaXNJbnN0YW5jZS5nZXROZXh0UGFnZSh0aGlzSW5zdGFuY2Uuc3VibWlzc2lvbi5kYXRhLCB0aGlzSW5zdGFuY2UucGFnZSk7XG4gICAgICAgICAgICB0aGlzSW5zdGFuY2UuZW1pdCgnbmV4dFBhZ2UnLCB7IHBhZ2U6IHRoaXNJbnN0YW5jZS5wYWdlLCBzdWJtaXNzaW9uOiB0aGlzSW5zdGFuY2Uuc3VibWlzc2lvbiB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gX25hdGl2ZVByb21pc2VPbmx5Mi5kZWZhdWx0LnJlamVjdCh0aGlzSW5zdGFuY2Uuc2hvd0Vycm9ycygpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwcmV2UGFnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZXZQYWdlKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBwcmV2UGFnZSA9IHRoaXMuZ2V0UHJldmlvdXNQYWdlKCk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRQYWdlKHByZXZQYWdlKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM0LmVtaXQoJ3ByZXZQYWdlJywgeyBwYWdlOiBfdGhpczQucGFnZSwgc3VibWlzc2lvbjogX3RoaXM0LnN1Ym1pc3Npb24gfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjYW5jZWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICBfZ2V0KEZvcm1pb1dpemFyZC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGb3JtaW9XaXphcmQucHJvdG90eXBlKSwgJ2NhbmNlbCcsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmhpc3RvcnkgPSBbXTtcbiAgICAgIHJldHVybiB0aGlzLnNldFBhZ2UoMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0UGFnZUluZGV4QnlLZXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYWdlSW5kZXhCeUtleShrZXkpIHtcbiAgICAgIHZhciBwYWdlSW5kZXggPSAwO1xuICAgICAgKDAsIF9lYWNoMi5kZWZhdWx0KSh0aGlzLnBhZ2VzLCBmdW5jdGlvbiAoX3BhZ2UsIGluZGV4KSB7XG4gICAgICAgIGlmIChfcGFnZS5rZXkgPT09IGtleSkge1xuICAgICAgICAgIHBhZ2VJbmRleCA9IGluZGV4O1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGFnZUluZGV4O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFBhZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYWdlKHBhZ2VOdW0pIHtcbiAgICAgIGlmIChwYWdlTnVtID49IDAgJiYgcGFnZU51bSA8IHRoaXMucGFnZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VzW3BhZ2VOdW1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFnZXMubGVuZ3RoID8gdGhpcy5wYWdlc1swXSA6IHsgY29tcG9uZW50czogW10gfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjdXJyZW50UGFnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1cnJlbnRQYWdlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFnZSh0aGlzLnBhZ2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldEZvcm0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGb3JtKGZvcm0pIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB0aGlzLnBhZ2VzID0gW107XG4gICAgICB0aGlzLmJ1dHRvbnMgPSBbXTtcblxuICAgICAgLy8gRE1TXG5cbiAgICAgIHRoaXMud2l6YXJkTmF2ID0gZmFsc2U7XG5cbiAgICAgIGlmIChmb3JtLmVuYWJsZU5hdmlnYXRpb24pIHtcbiAgICAgICAgdGhpcy53aXphcmROYXYgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAoMCwgX2VhY2gyLmRlZmF1bHQpKGZvcm0uY29tcG9uZW50cywgZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoY29tcG9uZW50LnR5cGUgPT09ICdwYW5lbCcpIHtcbiAgICAgICAgICBfdGhpczUucGFnZXMucHVzaChjb21wb25lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvbmVudC5rZXkpIHtcbiAgICAgICAgICBfdGhpczUuYWxsQ29tcG9uZW50c1tjb21wb25lbnQua2V5XSA9IF90aGlzNS5hZGRDb21wb25lbnQoY29tcG9uZW50LCBfdGhpczUuZWxlbWVudCwgX3RoaXM1LmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLnNldFBhZ2UodGhpcy5wYWdlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdidWlsZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkKCkge1xuICAgICAgdGhpcy5jcmVhdGVXaXphcmRIZWFkZXIoKTtcbiAgICAgIF9nZXQoRm9ybWlvV2l6YXJkLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEZvcm1pb1dpemFyZC5wcm90b3R5cGUpLCAnYnVpbGQnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5jcmVhdGVXaXphcmROYXYoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoYXNCdXR0b24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNCdXR0b24obmFtZSkge1xuICAgICAgaWYgKG5hbWUgPT09ICdwcmV2aW91cycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZSA+IDA7XG4gICAgICB9XG4gICAgICB2YXIgbmV4dFBhZ2UgPSB0aGlzLmdldE5leHRQYWdlKHRoaXMuc3VibWlzc2lvbi5kYXRhLCB0aGlzLnBhZ2UpO1xuICAgICAgaWYgKG5hbWUgPT09ICduZXh0Jykge1xuICAgICAgICByZXR1cm4gbmV4dFBhZ2UgIT09IG51bGwgJiYgbmV4dFBhZ2UgPCB0aGlzLnBhZ2VzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lID09PSAnc3VibWl0Jykge1xuICAgICAgICByZXR1cm4gbmV4dFBhZ2UgPT09IG51bGwgfHwgdGhpcy5wYWdlID09PSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjcmVhdGVXaXphcmRIZWFkZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVXaXphcmRIZWFkZXIoKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgLy8gRE1TXG5cbiAgICAgIGlmICghdGhpcy53aXphcmROYXYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VycmVudFBhZ2UgPSB0aGlzLmN1cnJlbnRQYWdlKCk7XG4gICAgICBjdXJyZW50UGFnZS5icmVhZGNydW1iID0gY3VycmVudFBhZ2UuYnJlYWRjcnVtYiB8fCAnZGVmYXVsdCc7XG4gICAgICBpZiAoY3VycmVudFBhZ2UuYnJlYWRjcnVtYi50b0xvd2VyQ2FzZSgpID09PSAnbm9uZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy53aXphcmRIZWFkZXIgPSB0aGlzLmNlKCd3aXphcmRIZWFkZXInLCAndWwnLCB7XG4gICAgICAgIGNsYXNzOiAncGFnaW5hdGlvbidcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgc2hvd0hpc3RvcnkgPSBjdXJyZW50UGFnZS5icmVhZGNydW1iLnRvTG93ZXJDYXNlKCkgPT09ICdoaXN0b3J5JztcbiAgICAgICgwLCBfZWFjaDIuZGVmYXVsdCkodGhpcy5wYWdlcywgZnVuY3Rpb24gKHBhZ2UsIGkpIHtcbiAgICAgICAgLy8gU2VlIGlmIHRoaXMgcGFnZSBpcyBpbiBvdXIgaGlzdG9yeS5cbiAgICAgICAgaWYgKHNob3dIaXN0b3J5ICYmIF90aGlzNi5wYWdlICE9PSBpICYmIF90aGlzNi5oaXN0b3J5LmluZGV4T2YoaSkgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhZ2VCdXR0b24gPSBfdGhpczYuY2UoJ3BhZ2VCdXR0b24nLCAnbGknLCB7XG4gICAgICAgICAgY2xhc3M6IGkgPT09IF90aGlzNi5wYWdlID8gJ2FjdGl2ZScgOiAnJyxcbiAgICAgICAgICBzdHlsZTogaSA9PT0gX3RoaXM2LnBhZ2UgPyAnJyA6ICdjdXJzb3I6IHBvaW50ZXI7J1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBOYXZpZ2F0ZSB0byB0aGUgcGFnZSBhcyB0aGV5IGNsaWNrIG9uIGl0LlxuICAgICAgICBpZiAoX3RoaXM2LnBhZ2UgIT09IGkpIHtcbiAgICAgICAgICBfdGhpczYuYWRkRXZlbnRMaXN0ZW5lcihwYWdlQnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBfdGhpczYuc2V0UGFnZShpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYWdlTGFiZWwgPSBfdGhpczYuY2UoJ3BhZ2VMYWJlbCcsICdzcGFuJyk7XG4gICAgICAgIHZhciBwYWdlVGl0bGUgPSBpID09PSBfdGhpczYucGFnZSB8fCBzaG93SGlzdG9yeSA/IHBhZ2UudGl0bGUgOiBpICsgMTtcbiAgICAgICAgaWYgKCFwYWdlVGl0bGUpIHtcbiAgICAgICAgICBwYWdlVGl0bGUgPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgICBwYWdlTGFiZWwuYXBwZW5kQ2hpbGQoX3RoaXM2LnRleHQocGFnZVRpdGxlKSk7XG4gICAgICAgIHBhZ2VCdXR0b24uYXBwZW5kQ2hpbGQocGFnZUxhYmVsKTtcbiAgICAgICAgX3RoaXM2LndpemFyZEhlYWRlci5hcHBlbmRDaGlsZChwYWdlQnV0dG9uKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy53aXphcmRIZWFkZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uU3VibWlzc2lvbkNoYW5nZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uU3VibWlzc2lvbkNoYW5nZShjaGFuZ2VkKSB7XG4gICAgICBfZ2V0KEZvcm1pb1dpemFyZC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGb3JtaW9XaXphcmQucHJvdG90eXBlKSwgJ29uU3VibWlzc2lvbkNoYW5nZScsIHRoaXMpLmNhbGwodGhpcywgY2hhbmdlZCk7XG5cbiAgICAgIC8vIFVwZGF0ZSBXaXphcmQgTmF2XG4gICAgICB2YXIgbmV4dFBhZ2UgPSB0aGlzLmdldE5leHRQYWdlKHRoaXMuc3VibWlzc2lvbi5kYXRhLCB0aGlzLnBhZ2UpO1xuICAgICAgaWYgKHRoaXMuX25leHRQYWdlICE9IG5leHRQYWdlKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLndpemFyZE5hdik7XG4gICAgICAgIHRoaXMuY3JlYXRlV2l6YXJkTmF2KCk7XG4gICAgICAgIHRoaXMuZW1pdCgndXBkYXRlV2l6YXJkTmF2JywgeyBvbGRwYWdlOiB0aGlzLl9uZXh0UGFnZSwgbmV3cGFnZTogbmV4dFBhZ2UsIHN1Ym1pc3Npb246IHRoaXMuc3VibWlzc2lvbiB9KTtcbiAgICAgICAgdGhpcy5fbmV4dFBhZ2UgPSBuZXh0UGFnZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjcmVhdGVXaXphcmROYXYnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVXaXphcmROYXYoKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgdGhpcy53aXphcmROYXYgPSB0aGlzLmNlKCd3aXphcmROYXYnLCAndWwnLCB7XG4gICAgICAgIGNsYXNzOiAnbGlzdC1pbmxpbmUnXG4gICAgICB9KTtcblxuICAgICAgLy8gRE1TXG5cbiAgICAgIC8qZWFjaChbXG4gICAgICAgIHtuYW1lOiAnY2FuY2VsJywgICAgbWV0aG9kOiAnY2FuY2VsJywgICBjbGFzczogJ2J0biBidG4tZGVmYXVsdCd9LFxuICAgICAgICB7bmFtZTogJ3ByZXZpb3VzJywgIG1ldGhvZDogJ3ByZXZQYWdlJywgY2xhc3M6ICdidG4gYnRuLXByaW1hcnknfSxcbiAgICAgICAge25hbWU6ICduZXh0JywgICAgICBtZXRob2Q6ICduZXh0UGFnZScsIGNsYXNzOiAnYnRuIGJ0bi1wcmltYXJ5J30sXG4gICAgICAgIHtuYW1lOiAnc3VibWl0JywgICAgbWV0aG9kOiAnc3VibWl0JywgICBjbGFzczogJ2J0biBidG4tcHJpbWFyeSd9XG4gICAgICBdLCAoYnV0dG9uKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5oYXNCdXR0b24oYnV0dG9uLm5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBidXR0b25XcmFwcGVyID0gdGhpcy5jZSgnd2l6YXJkTmF2QnV0dG9uJywgJ2xpJyk7XG4gICAgICAgIGxldCBidXR0b25Qcm9wID0gYnV0dG9uLm5hbWUgKyAnQnV0dG9uJztcbiAgICAgICAgdGhpc1tidXR0b25Qcm9wXSA9IHRoaXMuY2UoYnV0dG9uUHJvcCwgJ2J1dHRvbicsIHtcbiAgICAgICAgICBjbGFzczogYnV0dG9uLmNsYXNzICsgJyBidG4td2l6YXJkLW5hdi0nICsgYnV0dG9uLm5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXNbYnV0dG9uUHJvcF0uYXBwZW5kQ2hpbGQodGhpcy50ZXh0KHRoaXMudChidXR0b24ubmFtZSkpKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHRoaXNbYnV0dG9uUHJvcF0sICdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpc1tidXR0b24ubWV0aG9kXSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnV0dG9uV3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzW2J1dHRvblByb3BdKTtcbiAgICAgICAgdGhpcy53aXphcmROYXYuYXBwZW5kQ2hpbGQoYnV0dG9uV3JhcHBlcik7XG4gICAgICB9KTsqL1xuXG4gICAgICBpZiAodGhpcy5idXR0b25zKSB7XG4gICAgICAgICgwLCBfZWFjaDIuZGVmYXVsdCkodGhpcy5idXR0b25zLCBmdW5jdGlvbiAoYnV0dG9uKSB7XG4gICAgICAgICAgaWYgKCFfdGhpczcuaGFzQnV0dG9uKGJ1dHRvbi5uYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBidXR0b25XcmFwcGVyID0gX3RoaXM3LmNlKCd3aXphcmROYXZCdXR0b24nLCAnbGknKTtcbiAgICAgICAgICB2YXIgYnV0dG9uUHJvcCA9IGJ1dHRvbi5uYW1lICsgJ0J1dHRvbic7XG5cbiAgICAgICAgICBfdGhpczdbYnV0dG9uUHJvcF0gPSBfdGhpczcuY2UoYnV0dG9uUHJvcCwgJ2J1dHRvbicsIHtcbiAgICAgICAgICAgIGNsYXNzOiBidXR0b24uY2xhc3NcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChidXR0b24uY3VzdG9tKSB7XG4gICAgICAgICAgICBfdGhpczdbYnV0dG9uUHJvcF0uYXBwZW5kQ2hpbGQoX3RoaXM3LnRleHQoX3RoaXM3LnQoYnV0dG9uLmN1c3RvbSkpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXM3W2J1dHRvblByb3BdLmFwcGVuZENoaWxkKF90aGlzNy50ZXh0KF90aGlzNy50KGJ1dHRvbi5uYW1lKSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzNy5hZGRFdmVudExpc3RlbmVyKF90aGlzN1tidXR0b25Qcm9wXSwgJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgX3RoaXM3W2J1dHRvbi5tZXRob2RdKCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBidXR0b25XcmFwcGVyLmFwcGVuZENoaWxkKF90aGlzN1tidXR0b25Qcm9wXSk7XG5cbiAgICAgICAgICBfdGhpczcud2l6YXJkTmF2LmFwcGVuZENoaWxkKGJ1dHRvbldyYXBwZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICgwLCBfZWFjaDIuZGVmYXVsdCkoW3sgbmFtZTogJ2NhbmNlbCcsIG1ldGhvZDogJ2NhbmNlbCcsIGNsYXNzOiAnYnRuIGJ0bi1kZWZhdWx0JyB9LCB7IG5hbWU6ICdwcmV2aW91cycsIG1ldGhvZDogJ3ByZXZQYWdlJywgY2xhc3M6ICdidG4gYnRuLXByaW1hcnknIH0sIHsgbmFtZTogJ25leHQnLCBtZXRob2Q6ICduZXh0UGFnZScsIGNsYXNzOiAnYnRuIGJ0bi1wcmltYXJ5JyB9LCB7IG5hbWU6ICdzdWJtaXQnLCBtZXRob2Q6ICdzdWJtaXQnLCBjbGFzczogJ2J0biBidG4tcHJpbWFyeScgfV0sIGZ1bmN0aW9uIChidXR0b24pIHtcbiAgICAgICAgICBpZiAoIV90aGlzNy5oYXNCdXR0b24oYnV0dG9uLm5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGJ1dHRvbldyYXBwZXIgPSBfdGhpczcuY2UoJ3dpemFyZE5hdkJ1dHRvbicsICdsaScpO1xuICAgICAgICAgIHZhciBidXR0b25Qcm9wID0gYnV0dG9uLm5hbWUgKyAnQnV0dG9uJztcblxuICAgICAgICAgIF90aGlzN1tidXR0b25Qcm9wXSA9IF90aGlzNy5jZShidXR0b25Qcm9wLCAnYnV0dG9uJywge1xuICAgICAgICAgICAgY2xhc3M6IGJ1dHRvbi5jbGFzc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgX3RoaXM3W2J1dHRvblByb3BdLmFwcGVuZENoaWxkKF90aGlzNy50ZXh0KF90aGlzNy50KGJ1dHRvbi5uYW1lKSkpO1xuXG4gICAgICAgICAgX3RoaXM3LmFkZEV2ZW50TGlzdGVuZXIoX3RoaXM3W2J1dHRvblByb3BdLCAnY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBfdGhpczdbYnV0dG9uLm1ldGhvZF0oKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGJ1dHRvbldyYXBwZXIuYXBwZW5kQ2hpbGQoX3RoaXM3W2J1dHRvblByb3BdKTtcbiAgICAgICAgICBfdGhpczcud2l6YXJkTmF2LmFwcGVuZENoaWxkKGJ1dHRvbldyYXBwZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHRoZSB3aXphcmQgbmF2aWdhdGlvblxuICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMud2l6YXJkTmF2KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDb21wb25lbnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29tcG9uZW50cygpIHtcbiAgICAgIC8vIFNldCB0aGUgY29tcG9uZW50cyBiYXNlZCBvbiBhbGwgY29tcG9uZW50cy5cbiAgICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgICAoMCwgX2VhY2gyLmRlZmF1bHQpKHRoaXMuYWxsQ29tcG9uZW50cywgZnVuY3Rpb24gKGNvbXBzKSB7XG4gICAgICAgIGNvbXBvbmVudHMgPSBjb21wb25lbnRzLmNvbmNhdChjb21wcyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGb3JtaW9XaXphcmQ7XG59KF9mb3JtaW8yLmRlZmF1bHQpO1xuXG5Gb3JtaW9XaXphcmQuc2V0QmFzZVVybCA9IF9mb3JtaW80LmRlZmF1bHQuc2V0QmFzZVVybDtcbkZvcm1pb1dpemFyZC5zZXRBcGlVcmwgPSBfZm9ybWlvNC5kZWZhdWx0LnNldEFwaVVybDtcbkZvcm1pb1dpemFyZC5zZXRBcHBVcmwgPSBfZm9ybWlvNC5kZWZhdWx0LnNldEFwcFVybDtcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuRm9ybWlvV2l6YXJkID0gRm9ybWlvV2l6YXJkOyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxuZzogJ2VuJyxcbiAgcmVzb3VyY2VzOiB7XG4gICAgZW46IHtcbiAgICAgIHRyYW5zbGF0aW9uOiB7XG4gICAgICAgIGNvbXBsZXRlOiAnU3VibWlzc2lvbiBDb21wbGV0ZScsXG4gICAgICAgIGVycm9yOiAnUGxlYXNlIGZpeCB0aGUgZm9sbG93aW5nIGVycm9ycyBiZWZvcmUgc3VibWl0dGluZy4nLFxuICAgICAgICByZXF1aXJlZDogJ3t7ZmllbGR9fSBpcyByZXF1aXJlZCcsXG4gICAgICAgIG1pbkxlbmd0aDogJ3t7ZmllbGR9fSBtdXN0IGJlIGxvbmdlciB0aGFuIHt7bGVuZ3RofX0gY2hhcmFjdGVycy4nLFxuICAgICAgICBtYXhMZW5ndGg6ICd7e2ZpZWxkfX0gbXVzdCBiZSBzaG9ydGVyIHRoYW4ge3tsZW5ndGh9fSBjaGFyYWN0ZXJzLicsXG4gICAgICAgIGludmFsaWRfZW1haWw6ICd7e2ZpZWxkfX0gbXVzdCBiZSBhIHZhbGlkIGVtYWlsLicsXG4gICAgICAgIGludmFsaWRfcmVnZXg6ICd7e2ZpZWxkfX0gZG9lcyBub3QgbWF0Y2ggdGhlIHBhdHRlcm4ge3tyZWdleH19LicsXG4gICAgICAgIGludmFsaWRfZGF0ZTogJ3t7ZmllbGR9fSBpcyBub3QgYSB2YWxpZCBkYXRlLicsXG4gICAgICAgIG1vbnRoOiAnTW9udGgnLFxuICAgICAgICBkYXk6ICdEYXknLFxuICAgICAgICB5ZWFyOiAnWWVhcicsXG4gICAgICAgIGphbnVhcnk6ICdKYW51YXJ5JyxcbiAgICAgICAgZmVicnVhcnk6ICdGZWJydWFyeScsXG4gICAgICAgIG1hcmNoOiAnTWFyY2gnLFxuICAgICAgICBhcHJpbDogJ0FwcmlsJyxcbiAgICAgICAgbWF5OiAnTWF5JyxcbiAgICAgICAganVuZTogJ0p1bmUnLFxuICAgICAgICBqdWx5OiAnSnVseScsXG4gICAgICAgIGF1Z3VzdDogJ0F1Z3VzdCcsXG4gICAgICAgIHNlcHRlbWJlcjogJ1NlcHRlbWJlcicsXG4gICAgICAgIG9jdG9iZXI6ICdPY3RvYmVyJyxcbiAgICAgICAgbm92ZW1iZXI6ICdOb3ZlbWJlcicsXG4gICAgICAgIGRlY2VtYmVyOiAnRGVjZW1iZXInLFxuICAgICAgICBuZXh0OiAnTmV4dCcsXG4gICAgICAgIHByZXZpb3VzOiAnUHJldmlvdXMnLFxuICAgICAgICBjYW5jZWw6ICdDYW5jZWwnLFxuICAgICAgICBzdWJtaXQ6ICdTdWJtaXQgRm9ybSdcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3RvcmFnZTogcmVxdWlyZSgnLi9zdG9yYWdlJylcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoXCJuYXRpdmUtcHJvbWlzZS1vbmx5XCIpO1xudmFyIGRyb3Bib3ggPSBmdW5jdGlvbiBkcm9wYm94KGZvcm1pbykge1xuICByZXR1cm4ge1xuICAgIHVwbG9hZEZpbGU6IGZ1bmN0aW9uIHVwbG9hZEZpbGUoZmlsZSwgZmlsZU5hbWUsIGRpciwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gU2VuZCB0aGUgZmlsZSB3aXRoIGRhdGEuXG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICBpZiAodHlwZW9mIHByb2dyZXNzQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBwcm9ncmVzc0NhbGxiYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZkID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIGZkLmFwcGVuZCgnbmFtZScsIGZpbGVOYW1lKTtcbiAgICAgICAgZmQuYXBwZW5kKCdkaXInLCBkaXIpO1xuICAgICAgICBmZC5hcHBlbmQoJ2ZpbGUnLCBmaWxlKTtcblxuICAgICAgICAvLyBGaXJlIG9uIG5ldHdvcmsgZXJyb3IuXG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGVyci5uZXR3b3JrRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0b3JhZ2UgPSAnZHJvcGJveCc7XG4gICAgICAgICAgICByZXNwb25zZS5zaXplID0gZmlsZS5zaXplO1xuICAgICAgICAgICAgcmVzcG9uc2UudHlwZSA9IGZpbGUudHlwZTtcbiAgICAgICAgICAgIHJlc3BvbnNlLnVybCA9IHJlc3BvbnNlLnBhdGhfbG93ZXI7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KHhoci5yZXNwb25zZSB8fCAnVW5hYmxlIHRvIHVwbG9hZCBmaWxlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHhoci5vcGVuKCdQT1NUJywgZm9ybWlvLmZvcm1VcmwgKyAnL3N0b3JhZ2UvZHJvcGJveCcpO1xuICAgICAgICB2YXIgdG9rZW4gPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdmb3JtaW9Ub2tlbicpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gU3dhbGxvdyBlcnJvci5cbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcigneC1qd3QtdG9rZW4nLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgeGhyLnNlbmQoZmQpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkb3dubG9hZEZpbGU6IGZ1bmN0aW9uIGRvd25sb2FkRmlsZShmaWxlKSB7XG4gICAgICB2YXIgdG9rZW4gPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2Zvcm1pb1Rva2VuJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFN3YWxsb3cgZXJyb3IuXG4gICAgICB9XG4gICAgICBmaWxlLnVybCA9IGZvcm1pby5mb3JtVXJsICsgJy9zdG9yYWdlL2Ryb3Bib3g/cGF0aF9sb3dlcj0nICsgZmlsZS5wYXRoX2xvd2VyICsgKHRva2VuID8gJyZ4LWp3dC10b2tlbj0nICsgdG9rZW4gOiAnJyk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZpbGUpO1xuICAgIH1cbiAgfTtcbn07XG5cbmRyb3Bib3gudGl0bGUgPSAnRHJvcGJveCc7XG5tb2R1bGUuZXhwb3J0cyA9IGRyb3Bib3g7IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZHJvcGJveDogcmVxdWlyZSgnLi9kcm9wYm94LmpzJyksXG4gIHMzOiByZXF1aXJlKCcuL3MzLmpzJyksXG4gIHVybDogcmVxdWlyZSgnLi91cmwuanMnKVxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBQcm9taXNlID0gcmVxdWlyZShcIm5hdGl2ZS1wcm9taXNlLW9ubHlcIik7XG52YXIgczMgPSBmdW5jdGlvbiBzMyhmb3JtaW8pIHtcbiAgcmV0dXJuIHtcbiAgICB1cGxvYWRGaWxlOiBmdW5jdGlvbiB1cGxvYWRGaWxlKGZpbGUsIGZpbGVOYW1lLCBkaXIsIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vIFNlbmQgdGhlIHByZSByZXNwb25zZSB0byBzaWduIHRoZSB1cGxvYWQuXG4gICAgICAgIHZhciBwcmUgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICB2YXIgcHJlZmQgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgcHJlZmQuYXBwZW5kKCduYW1lJywgZmlsZU5hbWUpO1xuICAgICAgICBwcmVmZC5hcHBlbmQoJ3NpemUnLCBmaWxlLnNpemUpO1xuICAgICAgICBwcmVmZC5hcHBlbmQoJ3R5cGUnLCBmaWxlLnR5cGUpO1xuXG4gICAgICAgIC8vIFRoaXMgb25seSBmaXJlcyBvbiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgICAgIHByZS5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGVyci5uZXR3b3JrRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHByZS5vbmFib3J0ID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHByZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHByZS5zdGF0dXMgPj0gMjAwICYmIHByZS5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IEpTT04ucGFyc2UocHJlLnJlc3BvbnNlKTtcblxuICAgICAgICAgICAgLy8gU2VuZCB0aGUgZmlsZSB3aXRoIGRhdGEuXG4gICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvZ3Jlc3NDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBwcm9ncmVzc0NhbGxiYWNrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNwb25zZS5kYXRhLmZpbGVOYW1lID0gZmlsZU5hbWU7XG4gICAgICAgICAgICByZXNwb25zZS5kYXRhLmtleSArPSBkaXIgKyBmaWxlTmFtZTtcblxuICAgICAgICAgICAgdmFyIGZkID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgICAgICBmZC5hcHBlbmQoa2V5LCByZXNwb25zZS5kYXRhW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmQuYXBwZW5kKCdmaWxlJywgZmlsZSk7XG5cbiAgICAgICAgICAgIC8vIEZpcmUgb24gbmV0d29yayBlcnJvci5cbiAgICAgICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICBlcnIubmV0d29ya0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgc3RvcmFnZTogJ3MzJyxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IGZpbGVOYW1lLFxuICAgICAgICAgICAgICAgICAgYnVja2V0OiByZXNwb25zZS5idWNrZXQsXG4gICAgICAgICAgICAgICAgICBrZXk6IHJlc3BvbnNlLmRhdGEua2V5LFxuICAgICAgICAgICAgICAgICAgdXJsOiByZXNwb25zZS51cmwgKyByZXNwb25zZS5kYXRhLmtleSxcbiAgICAgICAgICAgICAgICAgIGFjbDogcmVzcG9uc2UuZGF0YS5hY2wsXG4gICAgICAgICAgICAgICAgICBzaXplOiBmaWxlLnNpemUsXG4gICAgICAgICAgICAgICAgICB0eXBlOiBmaWxlLnR5cGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QoeGhyLnJlc3BvbnNlIHx8ICdVbmFibGUgdG8gdXBsb2FkIGZpbGUnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgeGhyLm9wZW4oJ1BPU1QnLCByZXNwb25zZS51cmwpO1xuXG4gICAgICAgICAgICB4aHIuc2VuZChmZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChwcmUucmVzcG9uc2UgfHwgJ1VuYWJsZSB0byBzaWduIGZpbGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcHJlLm9wZW4oJ1BPU1QnLCBmb3JtaW8uZm9ybVVybCArICcvc3RvcmFnZS9zMycpO1xuXG4gICAgICAgIHByZS5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICBwcmUuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgdmFyIHRva2VuID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZm9ybWlvVG9rZW4nKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIHN3YWxsb3cgZXJyb3IuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgcHJlLnNldFJlcXVlc3RIZWFkZXIoJ3gtand0LXRva2VuJywgdG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJlLnNlbmQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIG5hbWU6IGZpbGVOYW1lLFxuICAgICAgICAgIHNpemU6IGZpbGUuc2l6ZSxcbiAgICAgICAgICB0eXBlOiBmaWxlLnR5cGVcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkb3dubG9hZEZpbGU6IGZ1bmN0aW9uIGRvd25sb2FkRmlsZShmaWxlKSB7XG4gICAgICBpZiAoZmlsZS5hY2wgIT09ICdwdWJsaWMtcmVhZCcpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1pby5tYWtlUmVxdWVzdCgnZmlsZScsIGZvcm1pby5mb3JtVXJsICsgJy9zdG9yYWdlL3MzP2J1Y2tldD0nICsgZmlsZS5idWNrZXQgKyAnJmtleT0nICsgZmlsZS5rZXksICdHRVQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmlsZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuczMudGl0bGUgPSAnUzMnO1xubW9kdWxlLmV4cG9ydHMgPSBzMzsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBQcm9taXNlID0gcmVxdWlyZShcIm5hdGl2ZS1wcm9taXNlLW9ubHlcIik7XG52YXIgdXJsID0gZnVuY3Rpb24gdXJsKGZvcm1pbykge1xuICByZXR1cm4ge1xuICAgIHRpdGxlOiAnVXJsJyxcbiAgICBuYW1lOiAndXJsJyxcbiAgICB1cGxvYWRGaWxlOiBmdW5jdGlvbiB1cGxvYWRGaWxlKGZpbGUsIGZpbGVOYW1lLCBkaXIsIHByb2dyZXNzQ2FsbGJhY2ssIHVybCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgZGlyOiBkaXIsXG4gICAgICAgICAgbmFtZTogZmlsZU5hbWUsXG4gICAgICAgICAgZmlsZTogZmlsZVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNlbmQgdGhlIGZpbGUgd2l0aCBkYXRhLlxuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm9ncmVzc0NhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0gcHJvZ3Jlc3NDYWxsYmFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmZCA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGZkLmFwcGVuZChrZXksIGRhdGFba2V5XSk7XG4gICAgICAgIH1cblxuICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgICAvLyBOZWVkIHRvIHRlc3QgaWYgeGhyLnJlc3BvbnNlIGlzIGRlY29kZWQgb3Igbm90LlxuICAgICAgICAgICAgdmFyIHJlc3BEYXRhID0ge307XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXNwRGF0YSA9IHR5cGVvZiB4aHIucmVzcG9uc2UgPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2UpIDoge307XG4gICAgICAgICAgICAgIHJlc3BEYXRhID0gcmVzcERhdGEgJiYgcmVzcERhdGEuZGF0YSA/IHJlc3BEYXRhLmRhdGEgOiB7fTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICByZXNwRGF0YSA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgc3RvcmFnZTogJ3VybCcsXG4gICAgICAgICAgICAgIG5hbWU6IGZpbGVOYW1lLFxuICAgICAgICAgICAgICB1cmw6IHhoci5yZXNwb25zZVVSTCArICcvJyArIGZpbGVOYW1lLFxuICAgICAgICAgICAgICBzaXplOiBmaWxlLnNpemUsXG4gICAgICAgICAgICAgIHR5cGU6IGZpbGUudHlwZSxcbiAgICAgICAgICAgICAgZGF0YTogcmVzcERhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QoeGhyLnJlc3BvbnNlIHx8ICdVbmFibGUgdG8gdXBsb2FkIGZpbGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRmlyZSBvbiBuZXR3b3JrIGVycm9yLlxuICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZWplY3QoeGhyKTtcbiAgICAgICAgfTtcblxuICAgICAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZWplY3QoeGhyKTtcbiAgICAgICAgfTtcblxuICAgICAgICB4aHIub3BlbignUE9TVCcsIHVybCk7XG4gICAgICAgIHZhciB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdmb3JtaW9Ub2tlbicpO1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcigneC1qd3QtdG9rZW4nLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgeGhyLnNlbmQoZmQpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkb3dubG9hZEZpbGU6IGZ1bmN0aW9uIGRvd25sb2FkRmlsZShmaWxlKSB7XG4gICAgICAvLyBSZXR1cm4gdGhlIG9yaWdpbmFsIGFzIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG8uXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZpbGUpO1xuICAgIH1cbiAgfTtcbn07XG5cbnVybC50aXRsZSA9ICdVcmwnO1xubW9kdWxlLmV4cG9ydHMgPSB1cmw7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfanNvbkxvZ2ljSnMgPSByZXF1aXJlKCdqc29uLWxvZ2ljLWpzJyk7XG5cbnZhciBfanNvbkxvZ2ljSnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfanNvbkxvZ2ljSnMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgX2dldCA9IHJlcXVpcmUoJ2xvZGFzaC9nZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgYSBjb21wb25lbnQgaXMgYSBsYXlvdXQgY29tcG9uZW50IG9yIG5vdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbXBvbmVudFxuICAgKiAgIFRoZSBjb21wb25lbnQgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKiAgIFdoZXRoZXIgb3Igbm90IHRoZSBjb21wb25lbnQgaXMgYSBsYXlvdXQgY29tcG9uZW50LlxuICAgKi9cbiAgaXNMYXlvdXRDb21wb25lbnQ6IGZ1bmN0aW9uIGlzTGF5b3V0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgIHJldHVybiBjb21wb25lbnQuY29sdW1ucyAmJiBBcnJheS5pc0FycmF5KGNvbXBvbmVudC5jb2x1bW5zKSB8fCBjb21wb25lbnQucm93cyAmJiBBcnJheS5pc0FycmF5KGNvbXBvbmVudC5yb3dzKSB8fCBjb21wb25lbnQuY29tcG9uZW50cyAmJiBBcnJheS5pc0FycmF5KGNvbXBvbmVudC5jb21wb25lbnRzKSA/IHRydWUgOiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGVhY2ggY29tcG9uZW50IHdpdGhpbiBhIGZvcm0uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb21wb25lbnRzXG4gICAqICAgVGhlIGNvbXBvbmVudHMgdG8gaXRlcmF0ZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogICBUaGUgaXRlcmF0aW9uIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jbHVkZUFsbFxuICAgKiAgIFdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGUgbGF5b3V0IGNvbXBvbmVudHMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqICAgVGhlIGN1cnJlbnQgZGF0YSBwYXRoIG9mIHRoZSBlbGVtZW50LiBFeGFtcGxlOiBkYXRhLnVzZXIuZmlyc3ROYW1lXG4gICAqL1xuICBlYWNoQ29tcG9uZW50OiBmdW5jdGlvbiBlYWNoQ29tcG9uZW50KGNvbXBvbmVudHMsIGZuLCBpbmNsdWRlQWxsLCBwYXRoKSB7XG4gICAgaWYgKCFjb21wb25lbnRzKSByZXR1cm47XG4gICAgcGF0aCA9IHBhdGggfHwgJyc7XG4gICAgY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgIHZhciBoYXNDb2x1bW5zID0gY29tcG9uZW50LmNvbHVtbnMgJiYgQXJyYXkuaXNBcnJheShjb21wb25lbnQuY29sdW1ucyk7XG4gICAgICB2YXIgaGFzUm93cyA9IGNvbXBvbmVudC5yb3dzICYmIEFycmF5LmlzQXJyYXkoY29tcG9uZW50LnJvd3MpO1xuICAgICAgdmFyIGhhc0NvbXBzID0gY29tcG9uZW50LmNvbXBvbmVudHMgJiYgQXJyYXkuaXNBcnJheShjb21wb25lbnQuY29tcG9uZW50cyk7XG4gICAgICB2YXIgbm9SZWN1cnNlID0gZmFsc2U7XG4gICAgICB2YXIgbmV3UGF0aCA9IGNvbXBvbmVudC5rZXkgPyBwYXRoID8gcGF0aCArICcuJyArIGNvbXBvbmVudC5rZXkgOiBjb21wb25lbnQua2V5IDogJyc7XG5cbiAgICAgIGlmIChpbmNsdWRlQWxsIHx8IGNvbXBvbmVudC50cmVlIHx8ICFoYXNDb2x1bW5zICYmICFoYXNSb3dzICYmICFoYXNDb21wcykge1xuICAgICAgICBub1JlY3Vyc2UgPSBmbihjb21wb25lbnQsIG5ld1BhdGgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3ViUGF0aCA9IGZ1bmN0aW9uIHN1YlBhdGgoKSB7XG4gICAgICAgIGlmIChjb21wb25lbnQua2V5ICYmIChjb21wb25lbnQudHlwZSA9PT0gJ2RhdGFncmlkJyB8fCBjb21wb25lbnQudHlwZSA9PT0gJ2NvbnRhaW5lcicpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ld1BhdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9O1xuXG4gICAgICBpZiAoIW5vUmVjdXJzZSkge1xuICAgICAgICBpZiAoaGFzQ29sdW1ucykge1xuICAgICAgICAgIGNvbXBvbmVudC5jb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgZWFjaENvbXBvbmVudChjb2x1bW4uY29tcG9uZW50cywgZm4sIGluY2x1ZGVBbGwsIHN1YlBhdGgoKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzUm93cykge1xuICAgICAgICAgIFtdLmNvbmNhdC5hcHBseShbXSwgY29tcG9uZW50LnJvd3MpLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgZWFjaENvbXBvbmVudChyb3cuY29tcG9uZW50cywgZm4sIGluY2x1ZGVBbGwsIHN1YlBhdGgoKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzQ29tcHMpIHtcbiAgICAgICAgICBlYWNoQ29tcG9uZW50KGNvbXBvbmVudC5jb21wb25lbnRzLCBmbiwgaW5jbHVkZUFsbCwgc3ViUGF0aCgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSBjb21wb25lbnQgYnkgaXRzIGtleVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50c1xuICAgKiAgIFRoZSBjb21wb25lbnRzIHRvIGl0ZXJhdGUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogICBUaGUga2V5IG9mIHRoZSBjb21wb25lbnQgdG8gZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiAgIFRoZSBjb21wb25lbnQgdGhhdCBtYXRjaGVzIHRoZSBnaXZlbiBrZXksIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG4gICAqL1xuICBnZXRDb21wb25lbnQ6IGZ1bmN0aW9uIGdldENvbXBvbmVudChjb21wb25lbnRzLCBrZXkpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIG1vZHVsZS5leHBvcnRzLmVhY2hDb21wb25lbnQoY29tcG9uZW50cywgZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgaWYgKGNvbXBvbmVudC5rZXkgPT09IGtleSkge1xuICAgICAgICByZXN1bHQgPSBjb21wb25lbnQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogRmxhdHRlbiB0aGUgZm9ybSBjb21wb25lbnRzIGZvciBkYXRhIG1hbmlwdWxhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbXBvbmVudHNcbiAgICogICBUaGUgY29tcG9uZW50cyB0byBpdGVyYXRlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGluY2x1ZGVBbGxcbiAgICogICBXaGV0aGVyIG9yIG5vdCB0byBpbmNsdWRlIGxheW91dCBjb21wb25lbnRzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiAgIFRoZSBmbGF0dGVuZWQgY29tcG9uZW50cyBtYXAuXG4gICAqL1xuICBmbGF0dGVuQ29tcG9uZW50czogZnVuY3Rpb24gZmxhdHRlbkNvbXBvbmVudHMoY29tcG9uZW50cywgaW5jbHVkZUFsbCkge1xuICAgIHZhciBmbGF0dGVuZWQgPSB7fTtcbiAgICBtb2R1bGUuZXhwb3J0cy5lYWNoQ29tcG9uZW50KGNvbXBvbmVudHMsIGZ1bmN0aW9uIChjb21wb25lbnQsIHBhdGgpIHtcbiAgICAgIGZsYXR0ZW5lZFtwYXRoXSA9IGNvbXBvbmVudDtcbiAgICB9LCBpbmNsdWRlQWxsKTtcbiAgICByZXR1cm4gZmxhdHRlbmVkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHRoaXMgY29tcG9uZW50IGhhcyBhIGNvbmRpdGlvbmFsIHN0YXRlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIGNvbXBvbmVudCAtIFRoZSBjb21wb25lbnQgSlNPTiBzY2hlbWEuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIFRSVUUgLSBUaGlzIGNvbXBvbmVudCBoYXMgYSBjb25kaXRpb25hbCwgRkFMU0UgLSBObyBjb25kaXRpb25hbCBwcm92aWRlZC5cbiAgICovXG4gIGhhc0NvbmRpdGlvbjogZnVuY3Rpb24gaGFzQ29uZGl0aW9uKGNvbXBvbmVudCkge1xuICAgIHJldHVybiBjb21wb25lbnQuaGFzT3duUHJvcGVydHkoJ2N1c3RvbUNvbmRpdGlvbmFsJykgJiYgY29tcG9uZW50LmN1c3RvbUNvbmRpdGlvbmFsIHx8IGNvbXBvbmVudC5oYXNPd25Qcm9wZXJ0eSgnY29uZGl0aW9uYWwnKSAmJiBjb21wb25lbnQuY29uZGl0aW9uYWwgJiYgY29tcG9uZW50LmNvbmRpdGlvbmFsLndoZW4gfHwgY29tcG9uZW50Lmhhc093blByb3BlcnR5KCdjb25kaXRpb25hbCcpICYmIGNvbXBvbmVudC5jb25kaXRpb25hbCAmJiBjb21wb25lbnQuY29uZGl0aW9uYWwuanNvbjtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIHRoZSBjb25kaXRpb25zIGZvciBhIHByb3ZpZGVkIGNvbXBvbmVudCBhbmQgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIGNvbXBvbmVudFxuICAgKiAgIFRoZSBjb21wb25lbnQgdG8gY2hlY2sgZm9yIHRoZSBjb25kaXRpb24uXG4gICAqIEBwYXJhbSByb3dcbiAgICogICBUaGUgZGF0YSB3aXRoaW4gYSByb3dcbiAgICogQHBhcmFtIGRhdGFcbiAgICogICBUaGUgZnVsbCBzdWJtaXNzaW9uIGRhdGEuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY2hlY2tDb25kaXRpb246IGZ1bmN0aW9uIGNoZWNrQ29uZGl0aW9uKGNvbXBvbmVudCwgcm93LCBkYXRhKSB7XG4gICAgaWYgKGNvbXBvbmVudC5oYXNPd25Qcm9wZXJ0eSgnY3VzdG9tQ29uZGl0aW9uYWwnKSAmJiBjb21wb25lbnQuY3VzdG9tQ29uZGl0aW9uYWwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBzY3JpcHQgPSAnKGZ1bmN0aW9uKCkgeyB2YXIgc2hvdyA9IHRydWU7JztcbiAgICAgICAgc2NyaXB0ICs9IGNvbXBvbmVudC5jdXN0b21Db25kaXRpb25hbC50b1N0cmluZygpO1xuICAgICAgICBzY3JpcHQgKz0gJzsgcmV0dXJuIHNob3c7IH0pKCknO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZXZhbChzY3JpcHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCkgPT09ICd0cnVlJztcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdBbiBlcnJvciBvY2N1cnJlZCBpbiBhIGN1c3RvbSBjb25kaXRpb25hbCBzdGF0ZW1lbnQgZm9yIGNvbXBvbmVudCAnICsgY29tcG9uZW50LmtleSwgZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29tcG9uZW50Lmhhc093blByb3BlcnR5KCdjb25kaXRpb25hbCcpICYmIGNvbXBvbmVudC5jb25kaXRpb25hbCAmJiBjb21wb25lbnQuY29uZGl0aW9uYWwud2hlbikge1xuICAgICAgdmFyIGNvbmQgPSBjb21wb25lbnQuY29uZGl0aW9uYWw7XG4gICAgICB2YXIgdmFsdWUgPSBudWxsO1xuICAgICAgaWYgKHJvdykge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoeyBkYXRhOiByb3cgfSwgY29uZC53aGVuKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhICYmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoeyBkYXRhOiBkYXRhIH0sIGNvbmQud2hlbik7XG4gICAgICB9XG4gICAgICAvLyBGT1ItNDAwIC0gRml4IGlzc3VlIHdoZXJlIGZhbHNleSB2YWx1ZXMgd2VyZSBiZWluZyBldmFsdWF0ZWQgYXMgc2hvdz10cnVlXG4gICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBTcGVjaWFsIGNoZWNrIGZvciBzZWxlY3Rib3hlcyBjb21wb25lbnQuXG4gICAgICBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuaGFzT3duUHJvcGVydHkoY29uZC5lcSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlW2NvbmQuZXFdLnRvU3RyaW5nKCkgPT09IGNvbmQuc2hvdy50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgLy8gRk9SLTE3OSAtIENoZWNrIGZvciBtdWx0aXBsZSB2YWx1ZXMuXG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSAmJiB2YWx1ZS5pbmRleE9mKGNvbmQuZXEpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gY29uZC5zaG93LnRvU3RyaW5nKCkgPT09ICd0cnVlJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCkgPT09IGNvbmQuZXEudG9TdHJpbmcoKSA9PT0gKGNvbmQuc2hvdy50b1N0cmluZygpID09PSAndHJ1ZScpO1xuICAgIH0gZWxzZSBpZiAoY29tcG9uZW50Lmhhc093blByb3BlcnR5KCdjb25kaXRpb25hbCcpICYmIGNvbXBvbmVudC5jb25kaXRpb25hbCAmJiBjb21wb25lbnQuY29uZGl0aW9uYWwuanNvbikge1xuICAgICAgcmV0dXJuIF9qc29uTG9naWNKczIuZGVmYXVsdC5hcHBseShjb21wb25lbnQuY29uZGl0aW9uYWwuanNvbiwge1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICByb3c6IHJvd1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCB0byBzaG93LlxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIGZvciBhIGNvbXBvbmVudCBrZXksIGluIHRoZSBnaXZlbiBzdWJtaXNzaW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc3VibWlzc2lvblxuICAgKiAgIEEgc3VibWlzc2lvbiBvYmplY3QgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqICAgQSBmb3IgY29tcG9uZW50cyBBUEkga2V5IHRvIHNlYXJjaCBmb3IuXG4gICAqL1xuICBnZXRWYWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoc3VibWlzc2lvbiwga2V5KSB7XG4gICAgdmFyIGRhdGEgPSBzdWJtaXNzaW9uLmRhdGEgfHwge307XG5cbiAgICB2YXIgc2VhcmNoID0gZnVuY3Rpb24gc2VhcmNoKGRhdGEpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICgodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGRhdGEpKSA9PT0gJ29iamVjdCcgJiYgIShkYXRhIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoX3R5cGVvZihkYXRhW2tleXNbaV1dKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gc2VhcmNoKGRhdGFba2V5c1tpXV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gc2VhcmNoKGRhdGEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnRlcnBvbGF0ZSBhIHN0cmluZyBhbmQgYWRkIGRhdGEgcmVwbGFjZW1lbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gc3RyaW5nXG4gICAqIEBwYXJhbSBkYXRhXG4gICAqIEByZXR1cm5zIHtYTUx8c3RyaW5nfCp8dm9pZH1cbiAgICovXG4gIGludGVycG9sYXRlOiBmdW5jdGlvbiBpbnRlcnBvbGF0ZShzdHJpbmcsIGRhdGEpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1xce1xce1xccyooW15cXHNdKilcXHMqXFx9XFx9L2csIGZ1bmN0aW9uIChtYXRjaCwgdG9rZW4pIHtcbiAgICAgIHJldHVybiBfZ2V0KGRhdGEsIHRva2VuKTtcbiAgICB9KTtcbiAgfVxufTsiLCIvKiEgY2hvaWNlcy5qcyB2Mi44LjEyIHwgKGMpIDIwMTcgSm9zaCBKb2huc29uIHwgaHR0cHM6Ly9naXRodWIuY29tL2pzaGpvaG5zb24vQ2hvaWNlcyNyZWFkbWUgKi8gXG4hZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLkNob2ljZXM9dCgpOmUuQ2hvaWNlcz10KCl9KHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChuKXtpZihpW25dKXJldHVybiBpW25dLmV4cG9ydHM7dmFyIHM9aVtuXT17ZXhwb3J0czp7fSxpZDpuLGxvYWRlZDohMX07cmV0dXJuIGVbbl0uY2FsbChzLmV4cG9ydHMscyxzLmV4cG9ydHMsdCkscy5sb2FkZWQ9ITAscy5leHBvcnRzfXZhciBpPXt9O3JldHVybiB0Lm09ZSx0LmM9aSx0LnA9XCIvYXNzZXRzL3NjcmlwdHMvZGlzdC9cIix0KDApfShbZnVuY3Rpb24oZSx0LGkpe2UuZXhwb3J0cz1pKDEpfSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gcyhlLHQsaSl7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTppLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1pLGV9ZnVuY3Rpb24gcihlKXtpZihBcnJheS5pc0FycmF5KGUpKXtmb3IodmFyIHQ9MCxpPUFycmF5KGUubGVuZ3RoKTt0PGUubGVuZ3RoO3QrKylpW3RdPWVbdF07cmV0dXJuIGl9cmV0dXJuIEFycmF5LmZyb20oZSl9ZnVuY3Rpb24gbyhlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9dmFyIGE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciBpPTA7aTx0Lmxlbmd0aDtpKyspe3ZhciBuPXRbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4ua2V5LG4pfX1yZXR1cm4gZnVuY3Rpb24odCxpLG4pe3JldHVybiBpJiZlKHQucHJvdG90eXBlLGkpLG4mJmUodCxuKSx0fX0oKSxjPWkoMiksbD1uKGMpLGg9aSgzKSx1PW4oaCksZD1pKDQpLGY9bihkKSxwPWkoMzApLHY9aSgzMSk7aSgzMik7dmFyIG09ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOlwiW2RhdGEtY2hvaWNlXVwiLGk9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9O2lmKG8odGhpcyxlKSwoMCx2LmlzVHlwZSkoXCJTdHJpbmdcIix0KSl7dmFyIG49ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0KTtpZihuLmxlbmd0aD4xKWZvcih2YXIgcz0xO3M8bi5sZW5ndGg7cysrKXt2YXIgcj1uW3NdO25ldyBlKHIsaSl9fXZhciBhPXtzaWxlbnQ6ITEsaXRlbXM6W10sY2hvaWNlczpbXSxyZW5kZXJDaG9pY2VMaW1pdDotMSxtYXhJdGVtQ291bnQ6LTEsYWRkSXRlbXM6ITAscmVtb3ZlSXRlbXM6ITAscmVtb3ZlSXRlbUJ1dHRvbjohMSxlZGl0SXRlbXM6ITEsZHVwbGljYXRlSXRlbXM6ITAsZGVsaW1pdGVyOlwiLFwiLHBhc3RlOiEwLHNlYXJjaEVuYWJsZWQ6ITAsc2VhcmNoQ2hvaWNlczohMCxzZWFyY2hGbG9vcjoxLHNlYXJjaFJlc3VsdExpbWl0OjQsc2VhcmNoRmllbGRzOltcImxhYmVsXCIsXCJ2YWx1ZVwiXSxwb3NpdGlvbjpcImF1dG9cIixyZXNldFNjcm9sbFBvc2l0aW9uOiEwLHJlZ2V4RmlsdGVyOm51bGwsc2hvdWxkU29ydDohMCxzaG91bGRTb3J0SXRlbXM6ITEsc29ydEZpbHRlcjp2LnNvcnRCeUFscGhhLHBsYWNlaG9sZGVyOiEwLHBsYWNlaG9sZGVyVmFsdWU6bnVsbCxwcmVwZW5kVmFsdWU6bnVsbCxhcHBlbmRWYWx1ZTpudWxsLHJlbmRlclNlbGVjdGVkQ2hvaWNlczpcImF1dG9cIixsb2FkaW5nVGV4dDpcIkxvYWRpbmcuLi5cIixub1Jlc3VsdHNUZXh0OlwiTm8gcmVzdWx0cyBmb3VuZFwiLG5vQ2hvaWNlc1RleHQ6XCJObyBjaG9pY2VzIHRvIGNob29zZSBmcm9tXCIsaXRlbVNlbGVjdFRleHQ6XCJQcmVzcyB0byBzZWxlY3RcIixhZGRJdGVtVGV4dDpmdW5jdGlvbihlKXtyZXR1cm4nUHJlc3MgRW50ZXIgdG8gYWRkIDxiPlwiJytlKydcIjwvYj4nfSxtYXhJdGVtVGV4dDpmdW5jdGlvbihlKXtyZXR1cm5cIk9ubHkgXCIrZStcIiB2YWx1ZXMgY2FuIGJlIGFkZGVkLlwifSx1bmlxdWVJdGVtVGV4dDpcIk9ubHkgdW5pcXVlIHZhbHVlcyBjYW4gYmUgYWRkZWQuXCIsY2xhc3NOYW1lczp7Y29udGFpbmVyT3V0ZXI6XCJjaG9pY2VzXCIsY29udGFpbmVySW5uZXI6XCJjaG9pY2VzX19pbm5lclwiLGlucHV0OlwiY2hvaWNlc19faW5wdXRcIixpbnB1dENsb25lZDpcImNob2ljZXNfX2lucHV0LS1jbG9uZWRcIixsaXN0OlwiY2hvaWNlc19fbGlzdFwiLGxpc3RJdGVtczpcImNob2ljZXNfX2xpc3QtLW11bHRpcGxlXCIsbGlzdFNpbmdsZTpcImNob2ljZXNfX2xpc3QtLXNpbmdsZVwiLGxpc3REcm9wZG93bjpcImNob2ljZXNfX2xpc3QtLWRyb3Bkb3duXCIsaXRlbTpcImNob2ljZXNfX2l0ZW1cIixpdGVtU2VsZWN0YWJsZTpcImNob2ljZXNfX2l0ZW0tLXNlbGVjdGFibGVcIixpdGVtRGlzYWJsZWQ6XCJjaG9pY2VzX19pdGVtLS1kaXNhYmxlZFwiLGl0ZW1DaG9pY2U6XCJjaG9pY2VzX19pdGVtLS1jaG9pY2VcIixwbGFjZWhvbGRlcjpcImNob2ljZXNfX3BsYWNlaG9sZGVyXCIsZ3JvdXA6XCJjaG9pY2VzX19ncm91cFwiLGdyb3VwSGVhZGluZzpcImNob2ljZXNfX2hlYWRpbmdcIixidXR0b246XCJjaG9pY2VzX19idXR0b25cIixhY3RpdmVTdGF0ZTpcImlzLWFjdGl2ZVwiLGZvY3VzU3RhdGU6XCJpcy1mb2N1c2VkXCIsb3BlblN0YXRlOlwiaXMtb3BlblwiLGRpc2FibGVkU3RhdGU6XCJpcy1kaXNhYmxlZFwiLGhpZ2hsaWdodGVkU3RhdGU6XCJpcy1oaWdobGlnaHRlZFwiLGhpZGRlblN0YXRlOlwiaXMtaGlkZGVuXCIsZmxpcHBlZFN0YXRlOlwiaXMtZmxpcHBlZFwiLGxvYWRpbmdTdGF0ZTpcImlzLWxvYWRpbmdcIn0sZnVzZU9wdGlvbnM6e2luY2x1ZGU6XCJzY29yZVwifSxjYWxsYmFja09uSW5pdDpudWxsLGNhbGxiYWNrT25DcmVhdGVUZW1wbGF0ZXM6bnVsbH07aWYodGhpcy5pZE5hbWVzPXtpdGVtQ2hvaWNlOlwiaXRlbS1jaG9pY2VcIn0sdGhpcy5jb25maWc9KDAsdi5leHRlbmQpKGEsaSksXCJhdXRvXCIhPT10aGlzLmNvbmZpZy5yZW5kZXJTZWxlY3RlZENob2ljZXMmJlwiYWx3YXlzXCIhPT10aGlzLmNvbmZpZy5yZW5kZXJTZWxlY3RlZENob2ljZXMmJih0aGlzLmNvbmZpZy5zaWxlbnR8fGNvbnNvbGUud2FybihcInJlbmRlclNlbGVjdGVkQ2hvaWNlczogUG9zc2libGUgdmFsdWVzIGFyZSAnYXV0bycgYW5kICdhbHdheXMnLiBGYWxsaW5nIGJhY2sgdG8gJ2F1dG8nLlwiKSx0aGlzLmNvbmZpZy5yZW5kZXJTZWxlY3RlZENob2ljZXM9XCJhdXRvXCIpLHRoaXMuc3RvcmU9bmV3IGYuZGVmYXVsdCh0aGlzLnJlbmRlciksdGhpcy5pbml0aWFsaXNlZD0hMSx0aGlzLmN1cnJlbnRTdGF0ZT17fSx0aGlzLnByZXZTdGF0ZT17fSx0aGlzLmN1cnJlbnRWYWx1ZT1cIlwiLHRoaXMuZWxlbWVudD10LHRoaXMucGFzc2VkRWxlbWVudD0oMCx2LmlzVHlwZSkoXCJTdHJpbmdcIix0KT9kb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQpOnQsdGhpcy5pc1RleHRFbGVtZW50PVwidGV4dFwiPT09dGhpcy5wYXNzZWRFbGVtZW50LnR5cGUsdGhpcy5pc1NlbGVjdE9uZUVsZW1lbnQ9XCJzZWxlY3Qtb25lXCI9PT10aGlzLnBhc3NlZEVsZW1lbnQudHlwZSx0aGlzLmlzU2VsZWN0TXVsdGlwbGVFbGVtZW50PVwic2VsZWN0LW11bHRpcGxlXCI9PT10aGlzLnBhc3NlZEVsZW1lbnQudHlwZSx0aGlzLmlzU2VsZWN0RWxlbWVudD10aGlzLmlzU2VsZWN0T25lRWxlbWVudHx8dGhpcy5pc1NlbGVjdE11bHRpcGxlRWxlbWVudCx0aGlzLmlzVmFsaWRFbGVtZW50VHlwZT10aGlzLmlzVGV4dEVsZW1lbnR8fHRoaXMuaXNTZWxlY3RFbGVtZW50LHRoaXMuaXNJZTExPSEoIW5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1RyaWRlbnQvKXx8IW5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL3J2WyA6XTExLykpLHRoaXMuaXNTY3JvbGxpbmdPbkllPSExLCF0aGlzLnBhc3NlZEVsZW1lbnQpcmV0dXJuIHZvaWQodGhpcy5jb25maWcuc2lsZW50fHxjb25zb2xlLmVycm9yKFwiUGFzc2VkIGVsZW1lbnQgbm90IGZvdW5kXCIpKTt0aGlzLmNvbmZpZy5zaG91bGRTb3J0SXRlbXM9PT0hMCYmdGhpcy5pc1NlbGVjdE9uZUVsZW1lbnQmJih0aGlzLmNvbmZpZy5zaWxlbnR8fGNvbnNvbGUud2FybihcInNob3VsZFNvcnRFbGVtZW50czogVHlwZSBvZiBwYXNzZWQgZWxlbWVudCBpcyAnc2VsZWN0LW9uZScsIGZhbGxpbmcgYmFjayB0byBmYWxzZS5cIikpLHRoaXMuaGlnaGxpZ2h0UG9zaXRpb249MCx0aGlzLmNhblNlYXJjaD10aGlzLmNvbmZpZy5zZWFyY2hFbmFibGVkLHRoaXMucHJlc2V0Q2hvaWNlcz10aGlzLmNvbmZpZy5jaG9pY2VzLHRoaXMucHJlc2V0SXRlbXM9dGhpcy5jb25maWcuaXRlbXMsdGhpcy5wYXNzZWRFbGVtZW50LnZhbHVlJiYodGhpcy5wcmVzZXRJdGVtcz10aGlzLnByZXNldEl0ZW1zLmNvbmNhdCh0aGlzLnBhc3NlZEVsZW1lbnQudmFsdWUuc3BsaXQodGhpcy5jb25maWcuZGVsaW1pdGVyKSkpLHRoaXMuYmFzZUlkPSgwLHYuZ2VuZXJhdGVJZCkodGhpcy5wYXNzZWRFbGVtZW50LFwiY2hvaWNlcy1cIiksdGhpcy5yZW5kZXI9dGhpcy5yZW5kZXIuYmluZCh0aGlzKSx0aGlzLl9vbkZvY3VzPXRoaXMuX29uRm9jdXMuYmluZCh0aGlzKSx0aGlzLl9vbkJsdXI9dGhpcy5fb25CbHVyLmJpbmQodGhpcyksdGhpcy5fb25LZXlVcD10aGlzLl9vbktleVVwLmJpbmQodGhpcyksdGhpcy5fb25LZXlEb3duPXRoaXMuX29uS2V5RG93bi5iaW5kKHRoaXMpLHRoaXMuX29uQ2xpY2s9dGhpcy5fb25DbGljay5iaW5kKHRoaXMpLHRoaXMuX29uVG91Y2hNb3ZlPXRoaXMuX29uVG91Y2hNb3ZlLmJpbmQodGhpcyksdGhpcy5fb25Ub3VjaEVuZD10aGlzLl9vblRvdWNoRW5kLmJpbmQodGhpcyksdGhpcy5fb25Nb3VzZURvd249dGhpcy5fb25Nb3VzZURvd24uYmluZCh0aGlzKSx0aGlzLl9vbk1vdXNlT3Zlcj10aGlzLl9vbk1vdXNlT3Zlci5iaW5kKHRoaXMpLHRoaXMuX29uUGFzdGU9dGhpcy5fb25QYXN0ZS5iaW5kKHRoaXMpLHRoaXMuX29uSW5wdXQ9dGhpcy5fb25JbnB1dC5iaW5kKHRoaXMpLHRoaXMud2FzVGFwPSEwO3ZhciBjPVwiY2xhc3NMaXN0XCJpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7Y3x8dGhpcy5jb25maWcuc2lsZW50fHxjb25zb2xlLmVycm9yKFwiQ2hvaWNlczogWW91ciBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBDaG9pY2VzXCIpO3ZhciBsPSgwLHYuaXNFbGVtZW50KSh0aGlzLnBhc3NlZEVsZW1lbnQpJiZ0aGlzLmlzVmFsaWRFbGVtZW50VHlwZTtpZihsKXtpZihcImFjdGl2ZVwiPT09dGhpcy5wYXNzZWRFbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtY2hvaWNlXCIpKXJldHVybjt0aGlzLmluaXQoKX1lbHNlIHRoaXMuY29uZmlnLnNpbGVudHx8Y29uc29sZS5lcnJvcihcIkluY29tcGF0aWJsZSBpbnB1dCBwYXNzZWRcIil9cmV0dXJuIGEoZSxbe2tleTpcImluaXRcIix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMuaW5pdGlhbGlzZWQhPT0hMCl7dmFyIGU9dGhpcy5jb25maWcuY2FsbGJhY2tPbkluaXQ7dGhpcy5pbml0aWFsaXNlZD0hMCx0aGlzLl9jcmVhdGVUZW1wbGF0ZXMoKSx0aGlzLl9jcmVhdGVJbnB1dCgpLHRoaXMuc3RvcmUuc3Vic2NyaWJlKHRoaXMucmVuZGVyKSx0aGlzLnJlbmRlcigpLHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCksZSYmKDAsdi5pc1R5cGUpKFwiRnVuY3Rpb25cIixlKSYmZS5jYWxsKHRoaXMpfX19LHtrZXk6XCJkZXN0cm95XCIsdmFsdWU6ZnVuY3Rpb24oKXtpZih0aGlzLmluaXRpYWxpc2VkIT09ITEpe3RoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCksdGhpcy5wYXNzZWRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jb25maWcuY2xhc3NOYW1lcy5pbnB1dCx0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmhpZGRlblN0YXRlKSx0aGlzLnBhc3NlZEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwidGFiaW5kZXhcIik7dmFyIGU9dGhpcy5wYXNzZWRFbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtY2hvaWNlLW9yaWctc3R5bGVcIik7Qm9vbGVhbihlKT8odGhpcy5wYXNzZWRFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtY2hvaWNlLW9yaWctc3R5bGVcIiksdGhpcy5wYXNzZWRFbGVtZW50LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsZSkpOnRoaXMucGFzc2VkRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJzdHlsZVwiKSx0aGlzLnBhc3NlZEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiksdGhpcy5wYXNzZWRFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtY2hvaWNlXCIpLHRoaXMucGFzc2VkRWxlbWVudC52YWx1ZT10aGlzLnBhc3NlZEVsZW1lbnQudmFsdWUsdGhpcy5jb250YWluZXJPdXRlci5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLnBhc3NlZEVsZW1lbnQsdGhpcy5jb250YWluZXJPdXRlciksdGhpcy5jb250YWluZXJPdXRlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY29udGFpbmVyT3V0ZXIpLHRoaXMuY2xlYXJTdG9yZSgpLHRoaXMuY29uZmlnLnRlbXBsYXRlcz1udWxsLHRoaXMuaW5pdGlhbGlzZWQ9ITF9fX0se2tleTpcInJlbmRlckdyb3Vwc1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCxpKXt2YXIgbj10aGlzLHM9aXx8ZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLHI9dGhpcy5jb25maWcuc29ydEZpbHRlcjtyZXR1cm4gdGhpcy5jb25maWcuc2hvdWxkU29ydCYmZS5zb3J0KHIpLGUuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgaT10LmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gbi5pc1NlbGVjdE9uZUVsZW1lbnQ/dC5ncm91cElkPT09ZS5pZDp0Lmdyb3VwSWQ9PT1lLmlkJiYhdC5zZWxlY3RlZH0pO2lmKGkubGVuZ3RoPj0xKXt2YXIgcj1uLl9nZXRUZW1wbGF0ZShcImNob2ljZUdyb3VwXCIsZSk7cy5hcHBlbmRDaGlsZChyKSxuLnJlbmRlckNob2ljZXMoaSxzLCEwKX19KSxzfX0se2tleTpcInJlbmRlckNob2ljZXNcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBpPXRoaXMsbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzJdLHM9dHx8ZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLHI9dGhpcy5jb25maWcsbz1yLnJlbmRlclNlbGVjdGVkQ2hvaWNlcyxhPXIuc2VhcmNoUmVzdWx0TGltaXQsYz1yLnJlbmRlckNob2ljZUxpbWl0LGw9dGhpcy5pc1NlYXJjaGluZz92LnNvcnRCeVNjb3JlOnRoaXMuY29uZmlnLnNvcnRGaWx0ZXIsaD1mdW5jdGlvbihlKXt2YXIgdD1cImF1dG9cIiE9PW98fChpLmlzU2VsZWN0T25lRWxlbWVudHx8IWUuc2VsZWN0ZWQpO2lmKHQpe3ZhciBuPWkuX2dldFRlbXBsYXRlKFwiY2hvaWNlXCIsZSk7cy5hcHBlbmRDaGlsZChuKX19LHU9ZTtcImF1dG9cIiE9PW98fHRoaXMuaXNTZWxlY3RPbmVFbGVtZW50fHwodT1lLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4hZS5zZWxlY3RlZH0pKSwodGhpcy5jb25maWcuc2hvdWxkU29ydHx8dGhpcy5pc1NlYXJjaGluZykmJnUuc29ydChsKTt2YXIgZD11Lmxlbmd0aDt0aGlzLmlzU2VhcmNoaW5nP2Q9TWF0aC5taW4oYSx1Lmxlbmd0aC0xKTpjPjAmJiFuJiYoZD1NYXRoLm1pbihjLHUubGVuZ3RoLTEpKTtmb3IodmFyIGY9MDtmPGQ7ZisrKWgodVtmXSk7cmV0dXJuIHN9fSx7a2V5OlwicmVuZGVySXRlbXNcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLGk9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOm51bGwsbj1pfHxkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7aWYodGhpcy5jb25maWcuc2hvdWxkU29ydEl0ZW1zJiYhdGhpcy5pc1NlbGVjdE9uZUVsZW1lbnQmJmUuc29ydCh0aGlzLmNvbmZpZy5zb3J0RmlsdGVyKSx0aGlzLmlzVGV4dEVsZW1lbnQpe3ZhciBzPXRoaXMuc3RvcmUuZ2V0SXRlbXNSZWR1Y2VkVG9WYWx1ZXMoZSkscj1zLmpvaW4odGhpcy5jb25maWcuZGVsaW1pdGVyKTt0aGlzLnBhc3NlZEVsZW1lbnQuc2V0QXR0cmlidXRlKFwidmFsdWVcIixyKSx0aGlzLnBhc3NlZEVsZW1lbnQudmFsdWU9cn1lbHNle3ZhciBvPWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtlLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIGk9dC5fZ2V0VGVtcGxhdGUoXCJvcHRpb25cIixlKTtvLmFwcGVuZENoaWxkKGkpfSksdGhpcy5wYXNzZWRFbGVtZW50LmlubmVySFRNTD1cIlwiLHRoaXMucGFzc2VkRWxlbWVudC5hcHBlbmRDaGlsZChvKX1yZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciBpPXQuX2dldFRlbXBsYXRlKFwiaXRlbVwiLGUpO24uYXBwZW5kQ2hpbGQoaSl9KSxufX0se2tleTpcInJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodGhpcy5jdXJyZW50U3RhdGU9dGhpcy5zdG9yZS5nZXRTdGF0ZSgpLHRoaXMuY3VycmVudFN0YXRlIT09dGhpcy5wcmV2U3RhdGUpe2lmKCh0aGlzLmN1cnJlbnRTdGF0ZS5jaG9pY2VzIT09dGhpcy5wcmV2U3RhdGUuY2hvaWNlc3x8dGhpcy5jdXJyZW50U3RhdGUuZ3JvdXBzIT09dGhpcy5wcmV2U3RhdGUuZ3JvdXBzfHx0aGlzLmN1cnJlbnRTdGF0ZS5pdGVtcyE9PXRoaXMucHJldlN0YXRlLml0ZW1zKSYmdGhpcy5pc1NlbGVjdEVsZW1lbnQpe3ZhciBlPXRoaXMuc3RvcmUuZ2V0R3JvdXBzRmlsdGVyZWRCeUFjdGl2ZSgpLHQ9dGhpcy5zdG9yZS5nZXRDaG9pY2VzRmlsdGVyZWRCeUFjdGl2ZSgpLGk9ZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO3RoaXMuY2hvaWNlTGlzdC5pbm5lckhUTUw9XCJcIix0aGlzLmNvbmZpZy5yZXNldFNjcm9sbFBvc2l0aW9uJiYodGhpcy5jaG9pY2VMaXN0LnNjcm9sbFRvcD0wKSxlLmxlbmd0aD49MSYmdGhpcy5pc1NlYXJjaGluZyE9PSEwP2k9dGhpcy5yZW5kZXJHcm91cHMoZSx0LGkpOnQubGVuZ3RoPj0xJiYoaT10aGlzLnJlbmRlckNob2ljZXModCxpKSk7dmFyIG49dGhpcy5zdG9yZS5nZXRJdGVtc0ZpbHRlcmVkQnlBY3RpdmUoKSxzPXRoaXMuX2NhbkFkZEl0ZW0obix0aGlzLmlucHV0LnZhbHVlKTtpZihpLmNoaWxkTm9kZXMmJmkuY2hpbGROb2Rlcy5sZW5ndGg+MClzLnJlc3BvbnNlPyh0aGlzLmNob2ljZUxpc3QuYXBwZW5kQ2hpbGQoaSksdGhpcy5faGlnaGxpZ2h0Q2hvaWNlKCkpOnRoaXMuY2hvaWNlTGlzdC5hcHBlbmRDaGlsZCh0aGlzLl9nZXRUZW1wbGF0ZShcIm5vdGljZVwiLHMubm90aWNlKSk7ZWxzZXt2YXIgcj12b2lkIDAsbz12b2lkIDA7dGhpcy5pc1NlYXJjaGluZz8obz0oMCx2LmlzVHlwZSkoXCJGdW5jdGlvblwiLHRoaXMuY29uZmlnLm5vUmVzdWx0c1RleHQpP3RoaXMuY29uZmlnLm5vUmVzdWx0c1RleHQoKTp0aGlzLmNvbmZpZy5ub1Jlc3VsdHNUZXh0LHI9dGhpcy5fZ2V0VGVtcGxhdGUoXCJub3RpY2VcIixvKSk6KG89KDAsdi5pc1R5cGUpKFwiRnVuY3Rpb25cIix0aGlzLmNvbmZpZy5ub0Nob2ljZXNUZXh0KT90aGlzLmNvbmZpZy5ub0Nob2ljZXNUZXh0KCk6dGhpcy5jb25maWcubm9DaG9pY2VzVGV4dCxyPXRoaXMuX2dldFRlbXBsYXRlKFwibm90aWNlXCIsbykpLHRoaXMuY2hvaWNlTGlzdC5hcHBlbmRDaGlsZChyKX19aWYodGhpcy5jdXJyZW50U3RhdGUuaXRlbXMhPT10aGlzLnByZXZTdGF0ZS5pdGVtcyl7dmFyIGE9dGhpcy5zdG9yZS5nZXRJdGVtc0ZpbHRlcmVkQnlBY3RpdmUoKTtpZihhKXt2YXIgYz10aGlzLnJlbmRlckl0ZW1zKGEpO3RoaXMuaXRlbUxpc3QuaW5uZXJIVE1MPVwiXCIsYy5jaGlsZE5vZGVzJiZ0aGlzLml0ZW1MaXN0LmFwcGVuZENoaWxkKGMpfX10aGlzLnByZXZTdGF0ZT10aGlzLmN1cnJlbnRTdGF0ZX19fSx7a2V5OlwiaGlnaGxpZ2h0SXRlbVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PSEoYXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0pfHxhcmd1bWVudHNbMV07aWYoIWUpcmV0dXJuIHRoaXM7dmFyIGk9ZS5pZCxuPWUuZ3JvdXBJZCxzPW4+PTA/dGhpcy5zdG9yZS5nZXRHcm91cEJ5SWQobik6bnVsbDtyZXR1cm4gdGhpcy5zdG9yZS5kaXNwYXRjaCgoMCxwLmhpZ2hsaWdodEl0ZW0pKGksITApKSx0JiYocyYmcy52YWx1ZT8oMCx2LnRyaWdnZXJFdmVudCkodGhpcy5wYXNzZWRFbGVtZW50LFwiaGlnaGxpZ2h0SXRlbVwiLHtpZDppLHZhbHVlOmUudmFsdWUsbGFiZWw6ZS5sYWJlbCxncm91cFZhbHVlOnMudmFsdWV9KTooMCx2LnRyaWdnZXJFdmVudCkodGhpcy5wYXNzZWRFbGVtZW50LFwiaGlnaGxpZ2h0SXRlbVwiLHtpZDppLHZhbHVlOmUudmFsdWUsbGFiZWw6ZS5sYWJlbH0pKSx0aGlzfX0se2tleTpcInVuaGlnaGxpZ2h0SXRlbVwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKCFlKXJldHVybiB0aGlzO3ZhciB0PWUuaWQsaT1lLmdyb3VwSWQsbj1pPj0wP3RoaXMuc3RvcmUuZ2V0R3JvdXBCeUlkKGkpOm51bGw7cmV0dXJuIHRoaXMuc3RvcmUuZGlzcGF0Y2goKDAscC5oaWdobGlnaHRJdGVtKSh0LCExKSksbiYmbi52YWx1ZT8oMCx2LnRyaWdnZXJFdmVudCkodGhpcy5wYXNzZWRFbGVtZW50LFwidW5oaWdobGlnaHRJdGVtXCIse2lkOnQsdmFsdWU6ZS52YWx1ZSxsYWJlbDplLmxhYmVsLGdyb3VwVmFsdWU6bi52YWx1ZX0pOigwLHYudHJpZ2dlckV2ZW50KSh0aGlzLnBhc3NlZEVsZW1lbnQsXCJ1bmhpZ2hsaWdodEl0ZW1cIix7aWQ6dCx2YWx1ZTplLnZhbHVlLGxhYmVsOmUubGFiZWx9KSx0aGlzfX0se2tleTpcImhpZ2hsaWdodEFsbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PXRoaXMuc3RvcmUuZ2V0SXRlbXMoKTtyZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe2UuaGlnaGxpZ2h0SXRlbSh0KX0pLHRoaXN9fSx7a2V5OlwidW5oaWdobGlnaHRBbGxcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD10aGlzLnN0b3JlLmdldEl0ZW1zKCk7cmV0dXJuIHQuZm9yRWFjaChmdW5jdGlvbih0KXtlLnVuaGlnaGxpZ2h0SXRlbSh0KX0pLHRoaXN9fSx7a2V5OlwicmVtb3ZlSXRlbXNCeVZhbHVlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztpZighZXx8ISgwLHYuaXNUeXBlKShcIlN0cmluZ1wiLGUpKXJldHVybiB0aGlzO3ZhciBpPXRoaXMuc3RvcmUuZ2V0SXRlbXNGaWx0ZXJlZEJ5QWN0aXZlKCk7cmV0dXJuIGkuZm9yRWFjaChmdW5jdGlvbihpKXtpLnZhbHVlPT09ZSYmdC5fcmVtb3ZlSXRlbShpKX0pLHRoaXN9fSx7a2V5OlwicmVtb3ZlQWN0aXZlSXRlbXNcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLGk9dGhpcy5zdG9yZS5nZXRJdGVtc0ZpbHRlcmVkQnlBY3RpdmUoKTtyZXR1cm4gaS5mb3JFYWNoKGZ1bmN0aW9uKGkpe2kuYWN0aXZlJiZlIT09aS5pZCYmdC5fcmVtb3ZlSXRlbShpKX0pLHRoaXN9fSx7a2V5OlwicmVtb3ZlSGlnaGxpZ2h0ZWRJdGVtc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF0saT10aGlzLnN0b3JlLmdldEl0ZW1zRmlsdGVyZWRCeUFjdGl2ZSgpO3JldHVybiBpLmZvckVhY2goZnVuY3Rpb24oaSl7aS5oaWdobGlnaHRlZCYmaS5hY3RpdmUmJihlLl9yZW1vdmVJdGVtKGkpLHQmJmUuX3RyaWdnZXJDaGFuZ2UoaS52YWx1ZSkpfSksdGhpc319LHtrZXk6XCJzaG93RHJvcGRvd25cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF0sdD1kb2N1bWVudC5ib2R5LGk9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LG49TWF0aC5tYXgodC5zY3JvbGxIZWlnaHQsdC5vZmZzZXRIZWlnaHQsaS5jbGllbnRIZWlnaHQsaS5zY3JvbGxIZWlnaHQsaS5vZmZzZXRIZWlnaHQpO3RoaXMuY29udGFpbmVyT3V0ZXIuY2xhc3NMaXN0LmFkZCh0aGlzLmNvbmZpZy5jbGFzc05hbWVzLm9wZW5TdGF0ZSksdGhpcy5jb250YWluZXJPdXRlci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsXCJ0cnVlXCIpLHRoaXMuZHJvcGRvd24uY2xhc3NMaXN0LmFkZCh0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmFjdGl2ZVN0YXRlKSx0aGlzLmRyb3Bkb3duLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIixcInRydWVcIik7dmFyIHM9dGhpcy5kcm9wZG93bi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxyPU1hdGguY2VpbChzLnRvcCt3aW5kb3cuc2Nyb2xsWSt0aGlzLmRyb3Bkb3duLm9mZnNldEhlaWdodCksbz0hMTtyZXR1cm5cImF1dG9cIj09PXRoaXMuY29uZmlnLnBvc2l0aW9uP289cj49bjpcInRvcFwiPT09dGhpcy5jb25maWcucG9zaXRpb24mJihvPSEwKSxvJiZ0aGlzLmNvbnRhaW5lck91dGVyLmNsYXNzTGlzdC5hZGQodGhpcy5jb25maWcuY2xhc3NOYW1lcy5mbGlwcGVkU3RhdGUpLGUmJnRoaXMuY2FuU2VhcmNoJiZkb2N1bWVudC5hY3RpdmVFbGVtZW50IT09dGhpcy5pbnB1dCYmdGhpcy5pbnB1dC5mb2N1cygpLCgwLHYudHJpZ2dlckV2ZW50KSh0aGlzLnBhc3NlZEVsZW1lbnQsXCJzaG93RHJvcGRvd25cIix7fSksdGhpc319LHtrZXk6XCJoaWRlRHJvcGRvd25cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF0sdD10aGlzLmNvbnRhaW5lck91dGVyLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmZsaXBwZWRTdGF0ZSk7cmV0dXJuIHRoaXMuY29udGFpbmVyT3V0ZXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmNvbmZpZy5jbGFzc05hbWVzLm9wZW5TdGF0ZSksdGhpcy5jb250YWluZXJPdXRlci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsXCJmYWxzZVwiKSx0aGlzLmRyb3Bkb3duLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jb25maWcuY2xhc3NOYW1lcy5hY3RpdmVTdGF0ZSksdGhpcy5kcm9wZG93bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsXCJmYWxzZVwiKSx0JiZ0aGlzLmNvbnRhaW5lck91dGVyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jb25maWcuY2xhc3NOYW1lcy5mbGlwcGVkU3RhdGUpLGUmJnRoaXMuY2FuU2VhcmNoJiZkb2N1bWVudC5hY3RpdmVFbGVtZW50PT09dGhpcy5pbnB1dCYmdGhpcy5pbnB1dC5ibHVyKCksKDAsdi50cmlnZ2VyRXZlbnQpKHRoaXMucGFzc2VkRWxlbWVudCxcImhpZGVEcm9wZG93blwiLHt9KSx0aGlzfX0se2tleTpcInRvZ2dsZURyb3Bkb3duXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmRyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmFjdGl2ZVN0YXRlKTtyZXR1cm4gZT90aGlzLmhpZGVEcm9wZG93bigpOnRoaXMuc2hvd0Ryb3Bkb3duKCEwKSx0aGlzfX0se2tleTpcImdldFZhbHVlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0mJmFyZ3VtZW50c1swXSxpPXRoaXMuc3RvcmUuZ2V0SXRlbXNGaWx0ZXJlZEJ5QWN0aXZlKCksbj1bXTtyZXR1cm4gaS5mb3JFYWNoKGZ1bmN0aW9uKGkpe2UuaXNUZXh0RWxlbWVudD9uLnB1c2godD9pLnZhbHVlOmkpOmkuYWN0aXZlJiZuLnB1c2godD9pLnZhbHVlOmkpfSksdGhpcy5pc1NlbGVjdE9uZUVsZW1lbnQ/blswXTpufX0se2tleTpcInNldFZhbHVlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztpZih0aGlzLmluaXRpYWxpc2VkPT09ITApe3ZhciBpPVtdLmNvbmNhdChyKGUpKSxuPWZ1bmN0aW9uKGUpe3ZhciBpPSgwLHYuZ2V0VHlwZSkoZSk7aWYoXCJPYmplY3RcIj09PWkpe2lmKCFlLnZhbHVlKXJldHVybjt0LmlzVGV4dEVsZW1lbnQ/dC5fYWRkSXRlbShlLnZhbHVlLGUubGFiZWwsZS5pZCx2b2lkIDAsZS5jdXN0b21Qcm9wZXJ0aWVzLG51bGwpOnQuX2FkZENob2ljZShlLnZhbHVlLGUubGFiZWwsITAsITEsLTEsZS5jdXN0b21Qcm9wZXJ0aWVzLG51bGwpfWVsc2VcIlN0cmluZ1wiPT09aSYmKHQuaXNUZXh0RWxlbWVudD90Ll9hZGRJdGVtKGUpOnQuX2FkZENob2ljZShlLGUsITAsITEsLTEsbnVsbCkpfTtpLmxlbmd0aD4xP2kuZm9yRWFjaChmdW5jdGlvbihlKXtuKGUpfSk6bihpWzBdKX1yZXR1cm4gdGhpc319LHtrZXk6XCJzZXRWYWx1ZUJ5Q2hvaWNlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztpZighdGhpcy5pc1RleHRFbGVtZW50KXt2YXIgaT10aGlzLnN0b3JlLmdldENob2ljZXMoKSxuPSgwLHYuaXNUeXBlKShcIkFycmF5XCIsZSk/ZTpbZV07bi5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciBuPWkuZmluZChmdW5jdGlvbih0KXtyZXR1cm4gdC52YWx1ZT09PWV9KTtuP24uc2VsZWN0ZWQ/dC5jb25maWcuc2lsZW50fHxjb25zb2xlLndhcm4oXCJBdHRlbXB0aW5nIHRvIHNlbGVjdCBjaG9pY2UgYWxyZWFkeSBzZWxlY3RlZFwiKTp0Ll9hZGRJdGVtKG4udmFsdWUsbi5sYWJlbCxuLmlkLG4uZ3JvdXBJZCxuLmN1c3RvbVByb3BlcnRpZXMsbi5rZXlDb2RlKTp0LmNvbmZpZy5zaWxlbnR8fGNvbnNvbGUud2FybihcIkF0dGVtcHRpbmcgdG8gc2VsZWN0IGNob2ljZSB0aGF0IGRvZXMgbm90IGV4aXN0XCIpfSl9cmV0dXJuIHRoaXN9fSx7a2V5Olwic2V0Q2hvaWNlc1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCxpKXt2YXIgbj10aGlzLHM9YXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10mJmFyZ3VtZW50c1szXTtpZih0aGlzLmluaXRpYWxpc2VkPT09ITAmJnRoaXMuaXNTZWxlY3RFbGVtZW50KXtpZighKDAsdi5pc1R5cGUpKFwiQXJyYXlcIixlKXx8IXQpcmV0dXJuIHRoaXM7cyYmdGhpcy5fY2xlYXJDaG9pY2VzKCksZSYmZS5sZW5ndGgmJih0aGlzLmNvbnRhaW5lck91dGVyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jb25maWcuY2xhc3NOYW1lcy5sb2FkaW5nU3RhdGUpLGUuZm9yRWFjaChmdW5jdGlvbihlKXtlLmNob2ljZXM/bi5fYWRkR3JvdXAoZSxlLmlkfHxudWxsLHQsaSk6bi5fYWRkQ2hvaWNlKGVbdF0sZVtpXSxlLnNlbGVjdGVkLGUuZGlzYWJsZWQsdm9pZCAwLGUuY3VzdG9tUHJvcGVydGllcyxudWxsKX0pKX1yZXR1cm4gdGhpc319LHtrZXk6XCJjbGVhclN0b3JlXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdG9yZS5kaXNwYXRjaCgoMCxwLmNsZWFyQWxsKSgpKSx0aGlzfX0se2tleTpcImNsZWFySW5wdXRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlucHV0LnZhbHVlJiYodGhpcy5pbnB1dC52YWx1ZT1cIlwiKSx0aGlzLmlzU2VsZWN0T25lRWxlbWVudHx8dGhpcy5fc2V0SW5wdXRXaWR0aCgpLCF0aGlzLmlzVGV4dEVsZW1lbnQmJnRoaXMuY29uZmlnLnNlYXJjaEVuYWJsZWQmJih0aGlzLmlzU2VhcmNoaW5nPSExLHRoaXMuc3RvcmUuZGlzcGF0Y2goKDAscC5hY3RpdmF0ZUNob2ljZXMpKCEwKSkpLHRoaXN9fSx7a2V5OlwiZW5hYmxlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnBhc3NlZEVsZW1lbnQuZGlzYWJsZWQ9ITE7dmFyIGU9dGhpcy5jb250YWluZXJPdXRlci5jbGFzc0xpc3QuY29udGFpbnModGhpcy5jb25maWcuY2xhc3NOYW1lcy5kaXNhYmxlZFN0YXRlKTtyZXR1cm4gdGhpcy5pbml0aWFsaXNlZCYmZSYmKHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCksdGhpcy5wYXNzZWRFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpLHRoaXMuaW5wdXQucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIiksdGhpcy5jb250YWluZXJPdXRlci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuY29uZmlnLmNsYXNzTmFtZXMuZGlzYWJsZWRTdGF0ZSksdGhpcy5jb250YWluZXJPdXRlci5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWRpc2FibGVkXCIpLHRoaXMuaXNTZWxlY3RPbmVFbGVtZW50JiZ0aGlzLmNvbnRhaW5lck91dGVyLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsXCIwXCIpKSx0aGlzfX0se2tleTpcImRpc2FibGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucGFzc2VkRWxlbWVudC5kaXNhYmxlZD0hMDt2YXIgZT0hdGhpcy5jb250YWluZXJPdXRlci5jbGFzc0xpc3QuY29udGFpbnModGhpcy5jb25maWcuY2xhc3NOYW1lcy5kaXNhYmxlZFN0YXRlKTtyZXR1cm4gdGhpcy5pbml0aWFsaXNlZCYmZSYmKHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCksdGhpcy5wYXNzZWRFbGVtZW50LnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsXCJcIiksdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLFwiXCIpLHRoaXMuY29udGFpbmVyT3V0ZXIuY2xhc3NMaXN0LmFkZCh0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmRpc2FibGVkU3RhdGUpLHRoaXMuY29udGFpbmVyT3V0ZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1kaXNhYmxlZFwiLFwidHJ1ZVwiKSx0aGlzLmlzU2VsZWN0T25lRWxlbWVudCYmdGhpcy5jb250YWluZXJPdXRlci5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLFwiLTFcIikpLHRoaXN9fSx7a2V5OlwiYWpheFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7cmV0dXJuIHRoaXMuaW5pdGlhbGlzZWQ9PT0hMCYmdGhpcy5pc1NlbGVjdEVsZW1lbnQmJihyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXt0Ll9oYW5kbGVMb2FkaW5nU3RhdGUoITApfSksZSh0aGlzLl9hamF4Q2FsbGJhY2soKSkpLHRoaXN9fSx7a2V5OlwiX3RyaWdnZXJDaGFuZ2VcIix2YWx1ZTpmdW5jdGlvbihlKXtlJiYoMCx2LnRyaWdnZXJFdmVudCkodGhpcy5wYXNzZWRFbGVtZW50LFwiY2hhbmdlXCIse3ZhbHVlOmV9KX19LHtrZXk6XCJfaGFuZGxlQnV0dG9uQWN0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtpZihlJiZ0JiZ0aGlzLmNvbmZpZy5yZW1vdmVJdGVtcyYmdGhpcy5jb25maWcucmVtb3ZlSXRlbUJ1dHRvbil7dmFyIGk9dC5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZShcImRhdGEtaWRcIiksbj1lLmZpbmQoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaWQ9PT1wYXJzZUludChpLDEwKX0pO2lmKHRoaXMuX3JlbW92ZUl0ZW0obiksdGhpcy5fdHJpZ2dlckNoYW5nZShuLnZhbHVlKSx0aGlzLmlzU2VsZWN0T25lRWxlbWVudCl7dmFyIHM9ISF0aGlzLmNvbmZpZy5wbGFjZWhvbGRlciYmKHRoaXMuY29uZmlnLnBsYWNlaG9sZGVyVmFsdWV8fHRoaXMucGFzc2VkRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiKSk7aWYocyl7dmFyIHI9dGhpcy5fZ2V0VGVtcGxhdGUoXCJwbGFjZWhvbGRlclwiLHMpO3RoaXMuaXRlbUxpc3QuYXBwZW5kQ2hpbGQocil9fX19fSx7a2V5OlwiX2hhbmRsZUl0ZW1BY3Rpb25cIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBpPXRoaXMsbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzJdO2lmKGUmJnQmJnRoaXMuY29uZmlnLnJlbW92ZUl0ZW1zJiYhdGhpcy5pc1NlbGVjdE9uZUVsZW1lbnQpe3ZhciBzPXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1pZFwiKTtlLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5pZCE9PXBhcnNlSW50KHMsMTApfHxlLmhpZ2hsaWdodGVkP258fGUuaGlnaGxpZ2h0ZWQmJmkudW5oaWdobGlnaHRJdGVtKGUpOmkuaGlnaGxpZ2h0SXRlbShlKX0pLGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQhPT10aGlzLmlucHV0JiZ0aGlzLmlucHV0LmZvY3VzKCl9fX0se2tleTpcIl9oYW5kbGVDaG9pY2VBY3Rpb25cIix2YWx1ZTpmdW5jdGlvbihlLHQpe2lmKGUmJnQpe3ZhciBpPXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1pZFwiKSxuPXRoaXMuc3RvcmUuZ2V0Q2hvaWNlQnlJZChpKSxzPWVbMF0mJmVbMF0ua2V5Q29kZT9lWzBdLmtleUNvZGU6bnVsbCxyPXRoaXMuZHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuY29uZmlnLmNsYXNzTmFtZXMuYWN0aXZlU3RhdGUpO2lmKG4ua2V5Q29kZT1zLCgwLHYudHJpZ2dlckV2ZW50KSh0aGlzLnBhc3NlZEVsZW1lbnQsXCJjaG9pY2VcIix7Y2hvaWNlOm59KSxuJiYhbi5zZWxlY3RlZCYmIW4uZGlzYWJsZWQpe3ZhciBvPXRoaXMuX2NhbkFkZEl0ZW0oZSxuLnZhbHVlKTtvLnJlc3BvbnNlJiYodGhpcy5fYWRkSXRlbShuLnZhbHVlLG4ubGFiZWwsbi5pZCxuLmdyb3VwSWQsbi5jdXN0b21Qcm9wZXJ0aWVzLG4ua2V5Q29kZSksdGhpcy5fdHJpZ2dlckNoYW5nZShuLnZhbHVlKSl9dGhpcy5jbGVhcklucHV0KCksciYmdGhpcy5pc1NlbGVjdE9uZUVsZW1lbnQmJih0aGlzLmhpZGVEcm9wZG93bigpLHRoaXMuY29udGFpbmVyT3V0ZXIuZm9jdXMoKSl9fX0se2tleTpcIl9oYW5kbGVCYWNrc3BhY2VcIix2YWx1ZTpmdW5jdGlvbihlKXtpZih0aGlzLmNvbmZpZy5yZW1vdmVJdGVtcyYmZSl7dmFyIHQ9ZVtlLmxlbmd0aC0xXSxpPWUuc29tZShmdW5jdGlvbihlKXtyZXR1cm4gZS5oaWdobGlnaHRlZH0pO3RoaXMuY29uZmlnLmVkaXRJdGVtcyYmIWkmJnQ/KHRoaXMuaW5wdXQudmFsdWU9dC52YWx1ZSx0aGlzLl9zZXRJbnB1dFdpZHRoKCksdGhpcy5fcmVtb3ZlSXRlbSh0KSx0aGlzLl90cmlnZ2VyQ2hhbmdlKHQudmFsdWUpKTooaXx8dGhpcy5oaWdobGlnaHRJdGVtKHQsITEpLHRoaXMucmVtb3ZlSGlnaGxpZ2h0ZWRJdGVtcyghMCkpfX19LHtrZXk6XCJfY2FuQWRkSXRlbVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIGk9ITAsbj0oMCx2LmlzVHlwZSkoXCJGdW5jdGlvblwiLHRoaXMuY29uZmlnLmFkZEl0ZW1UZXh0KT90aGlzLmNvbmZpZy5hZGRJdGVtVGV4dCh0KTp0aGlzLmNvbmZpZy5hZGRJdGVtVGV4dDsodGhpcy5pc1NlbGVjdE11bHRpcGxlRWxlbWVudHx8dGhpcy5pc1RleHRFbGVtZW50KSYmdGhpcy5jb25maWcubWF4SXRlbUNvdW50PjAmJnRoaXMuY29uZmlnLm1heEl0ZW1Db3VudDw9ZS5sZW5ndGgmJihpPSExLG49KDAsdi5pc1R5cGUpKFwiRnVuY3Rpb25cIix0aGlzLmNvbmZpZy5tYXhJdGVtVGV4dCk/dGhpcy5jb25maWcubWF4SXRlbVRleHQodGhpcy5jb25maWcubWF4SXRlbUNvdW50KTp0aGlzLmNvbmZpZy5tYXhJdGVtVGV4dCksdGhpcy5pc1RleHRFbGVtZW50JiZ0aGlzLmNvbmZpZy5hZGRJdGVtcyYmaSYmdGhpcy5jb25maWcucmVnZXhGaWx0ZXImJihpPXRoaXMuX3JlZ2V4RmlsdGVyKHQpKTt2YXIgcz0hZS5zb21lKGZ1bmN0aW9uKGUpe3JldHVybigwLHYuaXNUeXBlKShcIlN0cmluZ1wiLHQpP2UudmFsdWU9PT10LnRyaW0oKTplLnZhbHVlPT09dH0pO3JldHVybiBzfHx0aGlzLmNvbmZpZy5kdXBsaWNhdGVJdGVtc3x8dGhpcy5pc1NlbGVjdE9uZUVsZW1lbnR8fCFpfHwoaT0hMSxuPSgwLHYuaXNUeXBlKShcIkZ1bmN0aW9uXCIsdGhpcy5jb25maWcudW5pcXVlSXRlbVRleHQpP3RoaXMuY29uZmlnLnVuaXF1ZUl0ZW1UZXh0KHQpOnRoaXMuY29uZmlnLnVuaXF1ZUl0ZW1UZXh0KSx7cmVzcG9uc2U6aSxub3RpY2U6bn19fSx7a2V5OlwiX2hhbmRsZUxvYWRpbmdTdGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9IShhcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXSl8fGFyZ3VtZW50c1swXSx0PXRoaXMuaXRlbUxpc3QucXVlcnlTZWxlY3RvcihcIi5cIit0aGlzLmNvbmZpZy5jbGFzc05hbWVzLnBsYWNlaG9sZGVyKTtpZihlKXRoaXMuY29udGFpbmVyT3V0ZXIuY2xhc3NMaXN0LmFkZCh0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmxvYWRpbmdTdGF0ZSksdGhpcy5jb250YWluZXJPdXRlci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWJ1c3lcIixcInRydWVcIiksdGhpcy5pc1NlbGVjdE9uZUVsZW1lbnQ/dD90LmlubmVySFRNTD10aGlzLmNvbmZpZy5sb2FkaW5nVGV4dDoodD10aGlzLl9nZXRUZW1wbGF0ZShcInBsYWNlaG9sZGVyXCIsdGhpcy5jb25maWcubG9hZGluZ1RleHQpLHRoaXMuaXRlbUxpc3QuYXBwZW5kQ2hpbGQodCkpOnRoaXMuaW5wdXQucGxhY2Vob2xkZXI9dGhpcy5jb25maWcubG9hZGluZ1RleHQ7ZWxzZXt0aGlzLmNvbnRhaW5lck91dGVyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jb25maWcuY2xhc3NOYW1lcy5sb2FkaW5nU3RhdGUpO3ZhciBpPSEhdGhpcy5jb25maWcucGxhY2Vob2xkZXImJih0aGlzLmNvbmZpZy5wbGFjZWhvbGRlclZhbHVlfHx0aGlzLnBhc3NlZEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIikpO3RoaXMuaXNTZWxlY3RPbmVFbGVtZW50P3QuaW5uZXJIVE1MPWl8fFwiXCI6dGhpcy5pbnB1dC5wbGFjZWhvbGRlcj1pfHxcIlwifX19LHtrZXk6XCJfYWpheENhbGxiYWNrXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiBmdW5jdGlvbih0LGksbil7aWYodCYmaSl7dmFyIHM9KDAsdi5pc1R5cGUpKFwiT2JqZWN0XCIsdCk/W3RdOnQ7cyYmKDAsdi5pc1R5cGUpKFwiQXJyYXlcIixzKSYmcy5sZW5ndGg/KGUuX2hhbmRsZUxvYWRpbmdTdGF0ZSghMSkscy5mb3JFYWNoKGZ1bmN0aW9uKHQpe2lmKHQuY2hvaWNlcyl7dmFyIHM9dC5pZHx8bnVsbDtlLl9hZGRHcm91cCh0LHMsaSxuKX1lbHNlIGUuX2FkZENob2ljZSh0W2ldLHRbbl0sdC5zZWxlY3RlZCx0LmRpc2FibGVkLHZvaWQgMCx0LmN1c3RvbVByb3BlcnRpZXMsbnVsbCl9KSk6ZS5faGFuZGxlTG9hZGluZ1N0YXRlKCExKSxlLmNvbnRhaW5lck91dGVyLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtYnVzeVwiKX19fX0se2tleTpcIl9zZWFyY2hDaG9pY2VzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9KDAsdi5pc1R5cGUpKFwiU3RyaW5nXCIsZSk/ZS50cmltKCk6ZSxpPSgwLHYuaXNUeXBlKShcIlN0cmluZ1wiLHRoaXMuY3VycmVudFZhbHVlKT90aGlzLmN1cnJlbnRWYWx1ZS50cmltKCk6dGhpcy5jdXJyZW50VmFsdWU7aWYodC5sZW5ndGg+PTEmJnQhPT1pK1wiIFwiKXt2YXIgbj10aGlzLnN0b3JlLmdldENob2ljZXNGaWx0ZXJlZEJ5U2VsZWN0YWJsZSgpLHM9dCxyPSgwLHYuaXNUeXBlKShcIkFycmF5XCIsdGhpcy5jb25maWcuc2VhcmNoRmllbGRzKT90aGlzLmNvbmZpZy5zZWFyY2hGaWVsZHM6W3RoaXMuY29uZmlnLnNlYXJjaEZpZWxkc10sbz1PYmplY3QuYXNzaWduKHRoaXMuY29uZmlnLmZ1c2VPcHRpb25zLHtrZXlzOnJ9KSxhPW5ldyBsLmRlZmF1bHQobixvKSxjPWEuc2VhcmNoKHMpO3JldHVybiB0aGlzLmN1cnJlbnRWYWx1ZT10LHRoaXMuaGlnaGxpZ2h0UG9zaXRpb249MCx0aGlzLmlzU2VhcmNoaW5nPSEwLHRoaXMuc3RvcmUuZGlzcGF0Y2goKDAscC5maWx0ZXJDaG9pY2VzKShjKSksYy5sZW5ndGh9cmV0dXJuIDB9fSx7a2V5OlwiX2hhbmRsZVNlYXJjaFwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKGUpe3ZhciB0PXRoaXMuc3RvcmUuZ2V0Q2hvaWNlcygpLGk9dC5zb21lKGZ1bmN0aW9uKGUpe3JldHVybiFlLmFjdGl2ZX0pO2lmKHRoaXMuaW5wdXQ9PT1kb2N1bWVudC5hY3RpdmVFbGVtZW50KWlmKGUmJmUubGVuZ3RoPj10aGlzLmNvbmZpZy5zZWFyY2hGbG9vcil7dmFyIG49MDt0aGlzLmNvbmZpZy5zZWFyY2hDaG9pY2VzJiYobj10aGlzLl9zZWFyY2hDaG9pY2VzKGUpKSwoMCx2LnRyaWdnZXJFdmVudCkodGhpcy5wYXNzZWRFbGVtZW50LFwic2VhcmNoXCIse3ZhbHVlOmUscmVzdWx0Q291bnQ6bn0pfWVsc2UgaSYmKHRoaXMuaXNTZWFyY2hpbmc9ITEsdGhpcy5zdG9yZS5kaXNwYXRjaCgoMCxwLmFjdGl2YXRlQ2hvaWNlcykoITApKSl9fX0se2tleTpcIl9hZGRFdmVudExpc3RlbmVyc1wiLHZhbHVlOmZ1bmN0aW9uKCl7ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsdGhpcy5fb25LZXlVcCksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIix0aGlzLl9vbktleURvd24pLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuX29uQ2xpY2spLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIix0aGlzLl9vblRvdWNoTW92ZSksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsdGhpcy5fb25Ub3VjaEVuZCksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLHRoaXMuX29uTW91c2VEb3duKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsdGhpcy5fb25Nb3VzZU92ZXIpLHRoaXMuaXNTZWxlY3RPbmVFbGVtZW50JiYodGhpcy5jb250YWluZXJPdXRlci5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIix0aGlzLl9vbkZvY3VzKSx0aGlzLmNvbnRhaW5lck91dGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsdGhpcy5fb25CbHVyKSksdGhpcy5pbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIix0aGlzLl9vbklucHV0KSx0aGlzLmlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJwYXN0ZVwiLHRoaXMuX29uUGFzdGUpLHRoaXMuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsdGhpcy5fb25Gb2N1cyksdGhpcy5pbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLHRoaXMuX29uQmx1cil9fSx7a2V5OlwiX3JlbW92ZUV2ZW50TGlzdGVuZXJzXCIsdmFsdWU6ZnVuY3Rpb24oKXtkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIix0aGlzLl9vbktleVVwKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLHRoaXMuX29uS2V5RG93biksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpcy5fb25DbGljayksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLHRoaXMuX29uVG91Y2hNb3ZlKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIix0aGlzLl9vblRvdWNoRW5kKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsdGhpcy5fb25Nb3VzZURvd24pLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIix0aGlzLl9vbk1vdXNlT3ZlciksdGhpcy5pc1NlbGVjdE9uZUVsZW1lbnQmJih0aGlzLmNvbnRhaW5lck91dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLHRoaXMuX29uRm9jdXMpLHRoaXMuY29udGFpbmVyT3V0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIix0aGlzLl9vbkJsdXIpKSx0aGlzLmlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLHRoaXMuX29uSW5wdXQpLHRoaXMuaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBhc3RlXCIsdGhpcy5fb25QYXN0ZSksdGhpcy5pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIix0aGlzLl9vbkZvY3VzKSx0aGlzLmlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsdGhpcy5fb25CbHVyKX19LHtrZXk6XCJfc2V0SW5wdXRXaWR0aFwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodGhpcy5jb25maWcucGxhY2Vob2xkZXJWYWx1ZXx8dGhpcy5wYXNzZWRFbGVtZW50LmdldEF0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIpJiZ0aGlzLmNvbmZpZy5wbGFjZWhvbGRlcil7dmFyIGU9ISF0aGlzLmNvbmZpZy5wbGFjZWhvbGRlciYmKHRoaXMuY29uZmlnLnBsYWNlaG9sZGVyVmFsdWV8fHRoaXMucGFzc2VkRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiKSk7dGhpcy5pbnB1dC52YWx1ZSYmdGhpcy5pbnB1dC52YWx1ZS5sZW5ndGg+PWUubGVuZ3RoLzEuMjUmJih0aGlzLmlucHV0LnN0eWxlLndpZHRoPSgwLHYuZ2V0V2lkdGhPZklucHV0KSh0aGlzLmlucHV0KSl9ZWxzZSB0aGlzLmlucHV0LnN0eWxlLndpZHRoPSgwLHYuZ2V0V2lkdGhPZklucHV0KSh0aGlzLmlucHV0KX19LHtrZXk6XCJfb25LZXlEb3duXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQsaT10aGlzO2lmKGUudGFyZ2V0PT09dGhpcy5pbnB1dHx8dGhpcy5jb250YWluZXJPdXRlci5jb250YWlucyhlLnRhcmdldCkpe3ZhciBuPWUudGFyZ2V0LHI9dGhpcy5zdG9yZS5nZXRJdGVtc0ZpbHRlcmVkQnlBY3RpdmUoKSxvPXRoaXMuaW5wdXQ9PT1kb2N1bWVudC5hY3RpdmVFbGVtZW50LGE9dGhpcy5kcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnModGhpcy5jb25maWcuY2xhc3NOYW1lcy5hY3RpdmVTdGF0ZSksYz10aGlzLml0ZW1MaXN0JiZ0aGlzLml0ZW1MaXN0LmNoaWxkcmVuLGw9U3RyaW5nLmZyb21DaGFyQ29kZShlLmtleUNvZGUpLGg9NDYsdT04LGQ9MTMsZj02NSxwPTI3LG09MzgsZz00MCx5PTMzLGI9MzQsRT1lLmN0cmxLZXl8fGUubWV0YUtleTt0aGlzLmlzVGV4dEVsZW1lbnR8fCEvW2EtekEtWjAtOS1fIF0vLnRlc3QobCl8fGF8fHRoaXMuc2hvd0Ryb3Bkb3duKCEwKSx0aGlzLmNhblNlYXJjaD10aGlzLmNvbmZpZy5zZWFyY2hFbmFibGVkO3ZhciBfPWZ1bmN0aW9uKCl7RSYmYyYmKGkuY2FuU2VhcmNoPSExLGkuY29uZmlnLnJlbW92ZUl0ZW1zJiYhaS5pbnB1dC52YWx1ZSYmaS5pbnB1dD09PWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQmJmkuaGlnaGxpZ2h0QWxsKCkpfSxTPWZ1bmN0aW9uKCl7aWYoaS5pc1RleHRFbGVtZW50JiZuLnZhbHVlKXt2YXIgdD1pLmlucHV0LnZhbHVlLHM9aS5fY2FuQWRkSXRlbShyLHQpO3MucmVzcG9uc2UmJihhJiZpLmhpZGVEcm9wZG93bigpLGkuX2FkZEl0ZW0odCksaS5fdHJpZ2dlckNoYW5nZSh0KSxpLmNsZWFySW5wdXQoKSl9aWYobi5oYXNBdHRyaWJ1dGUoXCJkYXRhLWJ1dHRvblwiKSYmKGkuX2hhbmRsZUJ1dHRvbkFjdGlvbihyLG4pLGUucHJldmVudERlZmF1bHQoKSksYSl7ZS5wcmV2ZW50RGVmYXVsdCgpO3ZhciBvPWkuZHJvcGRvd24ucXVlcnlTZWxlY3RvcihcIi5cIitpLmNvbmZpZy5jbGFzc05hbWVzLmhpZ2hsaWdodGVkU3RhdGUpO28mJihyWzBdJiYoclswXS5rZXlDb2RlPWQpLGkuX2hhbmRsZUNob2ljZUFjdGlvbihyLG8pKX1lbHNlIGkuaXNTZWxlY3RPbmVFbGVtZW50JiYoYXx8KGkuc2hvd0Ryb3Bkb3duKCEwKSxlLnByZXZlbnREZWZhdWx0KCkpKX0sST1mdW5jdGlvbigpe2EmJihpLnRvZ2dsZURyb3Bkb3duKCksaS5jb250YWluZXJPdXRlci5mb2N1cygpKX0sdz1mdW5jdGlvbigpe2lmKGF8fGkuaXNTZWxlY3RPbmVFbGVtZW50KXthfHxpLnNob3dEcm9wZG93bighMCksaS5jYW5TZWFyY2g9ITE7dmFyIHQ9ZS5rZXlDb2RlPT09Z3x8ZS5rZXlDb2RlPT09Yj8xOi0xLG49ZS5tZXRhS2V5fHxlLmtleUNvZGU9PT1ifHxlLmtleUNvZGU9PT15LHM9dm9pZCAwO2lmKG4pcz10PjA/QXJyYXkuZnJvbShpLmRyb3Bkb3duLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1jaG9pY2Utc2VsZWN0YWJsZV1cIikpLnBvcCgpOmkuZHJvcGRvd24ucXVlcnlTZWxlY3RvcihcIltkYXRhLWNob2ljZS1zZWxlY3RhYmxlXVwiKTtlbHNle3ZhciByPWkuZHJvcGRvd24ucXVlcnlTZWxlY3RvcihcIi5cIitpLmNvbmZpZy5jbGFzc05hbWVzLmhpZ2hsaWdodGVkU3RhdGUpO3M9cj8oMCx2LmdldEFkamFjZW50RWwpKHIsXCJbZGF0YS1jaG9pY2Utc2VsZWN0YWJsZV1cIix0KTppLmRyb3Bkb3duLnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1jaG9pY2Utc2VsZWN0YWJsZV1cIil9cyYmKCgwLHYuaXNTY3JvbGxlZEludG9WaWV3KShzLGkuY2hvaWNlTGlzdCx0KXx8aS5fc2Nyb2xsVG9DaG9pY2Uocyx0KSxpLl9oaWdobGlnaHRDaG9pY2UocykpLGUucHJldmVudERlZmF1bHQoKX19LFQ9ZnVuY3Rpb24oKXshb3x8ZS50YXJnZXQudmFsdWV8fGkuaXNTZWxlY3RPbmVFbGVtZW50fHwoaS5faGFuZGxlQmFja3NwYWNlKHIpLGUucHJldmVudERlZmF1bHQoKSl9LEE9KHQ9e30scyh0LGYsXykscyh0LGQsUykscyh0LHAsSSkscyh0LG0sdykscyh0LHksdykscyh0LGcsdykscyh0LGIsdykscyh0LHUsVCkscyh0LGgsVCksdCk7QVtlLmtleUNvZGVdJiZBW2Uua2V5Q29kZV0oKX19fSx7a2V5OlwiX29uS2V5VXBcIix2YWx1ZTpmdW5jdGlvbihlKXtpZihlLnRhcmdldD09PXRoaXMuaW5wdXQpe3ZhciB0PXRoaXMuaW5wdXQudmFsdWUsaT10aGlzLnN0b3JlLmdldEl0ZW1zRmlsdGVyZWRCeUFjdGl2ZSgpLG49dGhpcy5fY2FuQWRkSXRlbShpLHQpO2lmKHRoaXMuaXNUZXh0RWxlbWVudCl7dmFyIHM9dGhpcy5kcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnModGhpcy5jb25maWcuY2xhc3NOYW1lcy5hY3RpdmVTdGF0ZSk7aWYodCl7aWYobi5ub3RpY2Upe3ZhciByPXRoaXMuX2dldFRlbXBsYXRlKFwibm90aWNlXCIsbi5ub3RpY2UpO3RoaXMuZHJvcGRvd24uaW5uZXJIVE1MPXIub3V0ZXJIVE1MfW4ucmVzcG9uc2U9PT0hMD9zfHx0aGlzLnNob3dEcm9wZG93bigpOiFuLm5vdGljZSYmcyYmdGhpcy5oaWRlRHJvcGRvd24oKX1lbHNlIHMmJnRoaXMuaGlkZURyb3Bkb3duKCl9ZWxzZXt2YXIgbz00NixhPTg7ZS5rZXlDb2RlIT09byYmZS5rZXlDb2RlIT09YXx8ZS50YXJnZXQudmFsdWU/dGhpcy5jYW5TZWFyY2gmJm4ucmVzcG9uc2UmJnRoaXMuX2hhbmRsZVNlYXJjaCh0aGlzLmlucHV0LnZhbHVlKTohdGhpcy5pc1RleHRFbGVtZW50JiZ0aGlzLmlzU2VhcmNoaW5nJiYodGhpcy5pc1NlYXJjaGluZz0hMSx0aGlzLnN0b3JlLmRpc3BhdGNoKCgwLHAuYWN0aXZhdGVDaG9pY2VzKSghMCkpKX10aGlzLmNhblNlYXJjaD10aGlzLmNvbmZpZy5zZWFyY2hFbmFibGVkfX19LHtrZXk6XCJfb25JbnB1dFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5pc1NlbGVjdE9uZUVsZW1lbnR8fHRoaXMuX3NldElucHV0V2lkdGgoKX19LHtrZXk6XCJfb25Ub3VjaE1vdmVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMud2FzVGFwPT09ITAmJih0aGlzLndhc1RhcD0hMSl9fSx7a2V5OlwiX29uVG91Y2hFbmRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1lLnRhcmdldHx8ZS50b3VjaGVzWzBdLnRhcmdldCxpPXRoaXMuZHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuY29uZmlnLmNsYXNzTmFtZXMuYWN0aXZlU3RhdGUpO3RoaXMud2FzVGFwPT09ITAmJnRoaXMuY29udGFpbmVyT3V0ZXIuY29udGFpbnModCkmJih0IT09dGhpcy5jb250YWluZXJPdXRlciYmdCE9PXRoaXMuY29udGFpbmVySW5uZXJ8fHRoaXMuaXNTZWxlY3RPbmVFbGVtZW50fHwodGhpcy5pc1RleHRFbGVtZW50P2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQhPT10aGlzLmlucHV0JiZ0aGlzLmlucHV0LmZvY3VzKCk6aXx8dGhpcy5zaG93RHJvcGRvd24oITApKSxlLnN0b3BQcm9wYWdhdGlvbigpKSx0aGlzLndhc1RhcD0hMH19LHtrZXk6XCJfb25Nb3VzZURvd25cIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1lLnRhcmdldDtpZih0PT09dGhpcy5jaG9pY2VMaXN0JiZ0aGlzLmlzSWUxMSYmKHRoaXMuaXNTY3JvbGxpbmdPbkllPSEwKSx0aGlzLmNvbnRhaW5lck91dGVyLmNvbnRhaW5zKHQpJiZ0IT09dGhpcy5pbnB1dCl7dmFyIGk9dm9pZCAwLG49dGhpcy5zdG9yZS5nZXRJdGVtc0ZpbHRlcmVkQnlBY3RpdmUoKSxzPWUuc2hpZnRLZXk7KGk9KDAsdi5maW5kQW5jZXN0b3JCeUF0dHJOYW1lKSh0LFwiZGF0YS1idXR0b25cIikpP3RoaXMuX2hhbmRsZUJ1dHRvbkFjdGlvbihuLGkpOihpPSgwLHYuZmluZEFuY2VzdG9yQnlBdHRyTmFtZSkodCxcImRhdGEtaXRlbVwiKSk/dGhpcy5faGFuZGxlSXRlbUFjdGlvbihuLGkscyk6KGk9KDAsdi5maW5kQW5jZXN0b3JCeUF0dHJOYW1lKSh0LFwiZGF0YS1jaG9pY2VcIikpJiZ0aGlzLl9oYW5kbGVDaG9pY2VBY3Rpb24obixpKSxlLnByZXZlbnREZWZhdWx0KCl9fX0se2tleTpcIl9vbkNsaWNrXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS50YXJnZXQsaT10aGlzLmRyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyh0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmFjdGl2ZVN0YXRlKSxuPXRoaXMuc3RvcmUuZ2V0SXRlbXNGaWx0ZXJlZEJ5QWN0aXZlKCk7aWYodGhpcy5jb250YWluZXJPdXRlci5jb250YWlucyh0KSl0Lmhhc0F0dHJpYnV0ZShcImRhdGEtYnV0dG9uXCIpJiZ0aGlzLl9oYW5kbGVCdXR0b25BY3Rpb24obix0KSxpP3RoaXMuaXNTZWxlY3RPbmVFbGVtZW50JiZ0IT09dGhpcy5pbnB1dCYmIXRoaXMuZHJvcGRvd24uY29udGFpbnModCkmJnRoaXMuaGlkZURyb3Bkb3duKCEwKTp0aGlzLmlzVGV4dEVsZW1lbnQ/ZG9jdW1lbnQuYWN0aXZlRWxlbWVudCE9PXRoaXMuaW5wdXQmJnRoaXMuaW5wdXQuZm9jdXMoKTp0aGlzLmNhblNlYXJjaD90aGlzLnNob3dEcm9wZG93bighMCk6KHRoaXMuc2hvd0Ryb3Bkb3duKCksdGhpcy5jb250YWluZXJPdXRlci5mb2N1cygpKTtlbHNle3ZhciBzPW4uc29tZShmdW5jdGlvbihlKXtyZXR1cm4gZS5oaWdobGlnaHRlZH0pO3MmJnRoaXMudW5oaWdobGlnaHRBbGwoKSx0aGlzLmNvbnRhaW5lck91dGVyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jb25maWcuY2xhc3NOYW1lcy5mb2N1c1N0YXRlKSxpJiZ0aGlzLmhpZGVEcm9wZG93bigpfX19LHtrZXk6XCJfb25Nb3VzZU92ZXJcIix2YWx1ZTpmdW5jdGlvbihlKXsoZS50YXJnZXQ9PT10aGlzLmRyb3Bkb3dufHx0aGlzLmRyb3Bkb3duLmNvbnRhaW5zKGUudGFyZ2V0KSkmJmUudGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImRhdGEtY2hvaWNlXCIpJiZ0aGlzLl9oaWdobGlnaHRDaG9pY2UoZS50YXJnZXQpfX0se2tleTpcIl9vblBhc3RlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7ZS50YXJnZXQhPT10aGlzLmlucHV0fHx0aGlzLmNvbmZpZy5wYXN0ZXx8ZS5wcmV2ZW50RGVmYXVsdCgpfX0se2tleTpcIl9vbkZvY3VzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxpPWUudGFyZ2V0O2lmKHRoaXMuY29udGFpbmVyT3V0ZXIuY29udGFpbnMoaSkpe3ZhciBuPXRoaXMuZHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuY29uZmlnLmNsYXNzTmFtZXMuYWN0aXZlU3RhdGUpLHM9e3RleHQ6ZnVuY3Rpb24oKXtpPT09dC5pbnB1dCYmdC5jb250YWluZXJPdXRlci5jbGFzc0xpc3QuYWRkKHQuY29uZmlnLmNsYXNzTmFtZXMuZm9jdXNTdGF0ZSl9LFwic2VsZWN0LW9uZVwiOmZ1bmN0aW9uKCl7dC5jb250YWluZXJPdXRlci5jbGFzc0xpc3QuYWRkKHQuY29uZmlnLmNsYXNzTmFtZXMuZm9jdXNTdGF0ZSksaT09PXQuaW5wdXQmJihufHx0LnNob3dEcm9wZG93bigpKX0sXCJzZWxlY3QtbXVsdGlwbGVcIjpmdW5jdGlvbigpe2k9PT10LmlucHV0JiYodC5jb250YWluZXJPdXRlci5jbGFzc0xpc3QuYWRkKHQuY29uZmlnLmNsYXNzTmFtZXMuZm9jdXNTdGF0ZSksbnx8dC5zaG93RHJvcGRvd24oITApKX19O3NbdGhpcy5wYXNzZWRFbGVtZW50LnR5cGVdKCl9fX0se2tleTpcIl9vbkJsdXJcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLGk9ZS50YXJnZXQ7aWYodGhpcy5jb250YWluZXJPdXRlci5jb250YWlucyhpKSYmIXRoaXMuaXNTY3JvbGxpbmdPbkllKXt2YXIgbj10aGlzLnN0b3JlLmdldEl0ZW1zRmlsdGVyZWRCeUFjdGl2ZSgpLHM9dGhpcy5kcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnModGhpcy5jb25maWcuY2xhc3NOYW1lcy5hY3RpdmVTdGF0ZSkscj1uLnNvbWUoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaGlnaGxpZ2h0ZWR9KSxvPXt0ZXh0OmZ1bmN0aW9uKCl7aT09PXQuaW5wdXQmJih0LmNvbnRhaW5lck91dGVyLmNsYXNzTGlzdC5yZW1vdmUodC5jb25maWcuY2xhc3NOYW1lcy5mb2N1c1N0YXRlKSxyJiZ0LnVuaGlnaGxpZ2h0QWxsKCkscyYmdC5oaWRlRHJvcGRvd24oKSl9LFwic2VsZWN0LW9uZVwiOmZ1bmN0aW9uKCl7dC5jb250YWluZXJPdXRlci5jbGFzc0xpc3QucmVtb3ZlKHQuY29uZmlnLmNsYXNzTmFtZXMuZm9jdXNTdGF0ZSksaT09PXQuY29udGFpbmVyT3V0ZXImJnMmJiF0LmNhblNlYXJjaCYmdC5oaWRlRHJvcGRvd24oKSxpPT09dC5pbnB1dCYmcyYmdC5oaWRlRHJvcGRvd24oKX0sXCJzZWxlY3QtbXVsdGlwbGVcIjpmdW5jdGlvbigpe2k9PT10LmlucHV0JiYodC5jb250YWluZXJPdXRlci5jbGFzc0xpc3QucmVtb3ZlKHQuY29uZmlnLmNsYXNzTmFtZXMuZm9jdXNTdGF0ZSkscyYmdC5oaWRlRHJvcGRvd24oKSxyJiZ0LnVuaGlnaGxpZ2h0QWxsKCkpfX07b1t0aGlzLnBhc3NlZEVsZW1lbnQudHlwZV0oKX1lbHNlIHRoaXMuaXNTY3JvbGxpbmdPbkllPSExLHRoaXMuaW5wdXQuZm9jdXMoKX19LHtrZXk6XCJfcmVnZXhGaWx0ZXJcIix2YWx1ZTpmdW5jdGlvbihlKXtpZighZSlyZXR1cm4hMTt2YXIgdD10aGlzLmNvbmZpZy5yZWdleEZpbHRlcixpPW5ldyBSZWdFeHAodC5zb3VyY2UsXCJpXCIpO3JldHVybiBpLnRlc3QoZSl9fSx7a2V5OlwiX3Njcm9sbFRvQ2hvaWNlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgaT10aGlzO2lmKGUpe3ZhciBuPXRoaXMuY2hvaWNlTGlzdC5vZmZzZXRIZWlnaHQscz1lLm9mZnNldEhlaWdodCxyPWUub2Zmc2V0VG9wK3Msbz10aGlzLmNob2ljZUxpc3Quc2Nyb2xsVG9wK24sYT10PjA/dGhpcy5jaG9pY2VMaXN0LnNjcm9sbFRvcCtyLW86ZS5vZmZzZXRUb3AsYz1mdW5jdGlvbiBlKCl7dmFyIG49NCxzPWkuY2hvaWNlTGlzdC5zY3JvbGxUb3Ascj0hMSxvPXZvaWQgMCxjPXZvaWQgMDt0PjA/KG89KGEtcykvbixjPW8+MT9vOjEsaS5jaG9pY2VMaXN0LnNjcm9sbFRvcD1zK2MsczxhJiYocj0hMCkpOihvPShzLWEpL24sYz1vPjE/bzoxLGkuY2hvaWNlTGlzdC5zY3JvbGxUb3A9cy1jLHM+YSYmKHI9ITApKSxyJiZyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oaSl7ZShpLGEsdCl9KX07cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKGUpe2MoZSxhLHQpfSl9fX0se2tleTpcIl9oaWdobGlnaHRDaG9pY2VcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06bnVsbCxpPUFycmF5LmZyb20odGhpcy5kcm9wZG93bi5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtY2hvaWNlLXNlbGVjdGFibGVdXCIpKSxuPXQ7aWYoaSYmaS5sZW5ndGgpe3ZhciBzPUFycmF5LmZyb20odGhpcy5kcm9wZG93bi5xdWVyeVNlbGVjdG9yQWxsKFwiLlwiK3RoaXMuY29uZmlnLmNsYXNzTmFtZXMuaGlnaGxpZ2h0ZWRTdGF0ZSkpO3MuZm9yRWFjaChmdW5jdGlvbih0KXt0LmNsYXNzTGlzdC5yZW1vdmUoZS5jb25maWcuY2xhc3NOYW1lcy5oaWdobGlnaHRlZFN0YXRlKSx0LnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIixcImZhbHNlXCIpfSksbj90aGlzLmhpZ2hsaWdodFBvc2l0aW9uPWkuaW5kZXhPZihuKToobj1pLmxlbmd0aD50aGlzLmhpZ2hsaWdodFBvc2l0aW9uP2lbdGhpcy5oaWdobGlnaHRQb3NpdGlvbl06aVtpLmxlbmd0aC0xXSxufHwobj1pWzBdKSksbi5jbGFzc0xpc3QuYWRkKHRoaXMuY29uZmlnLmNsYXNzTmFtZXMuaGlnaGxpZ2h0ZWRTdGF0ZSksbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsXCJ0cnVlXCIpLHRoaXMuY29udGFpbmVyT3V0ZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIsbi5pZCksdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIixuLmlkKX19fSx7a2V5OlwiX2FkZEl0ZW1cIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06bnVsbCxpPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTotMSxuPWFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdP2FyZ3VtZW50c1szXTotMSxzPWFyZ3VtZW50cy5sZW5ndGg+NCYmdm9pZCAwIT09YXJndW1lbnRzWzRdP2FyZ3VtZW50c1s0XTpudWxsLHI9YXJndW1lbnRzLmxlbmd0aD41JiZ2b2lkIDAhPT1hcmd1bWVudHNbNV0/YXJndW1lbnRzWzVdOm51bGwsbz0oMCx2LmlzVHlwZSkoXCJTdHJpbmdcIixlKT9lLnRyaW0oKTplLGE9cixjPXRoaXMuc3RvcmUuZ2V0SXRlbXMoKSxsPXR8fG8saD1wYXJzZUludChpLDEwKXx8LTEsdT1uPj0wP3RoaXMuc3RvcmUuZ2V0R3JvdXBCeUlkKG4pOm51bGwsZD1jP2MubGVuZ3RoKzE6MTtyZXR1cm4gdGhpcy5jb25maWcucHJlcGVuZFZhbHVlJiYobz10aGlzLmNvbmZpZy5wcmVwZW5kVmFsdWUrby50b1N0cmluZygpKSx0aGlzLmNvbmZpZy5hcHBlbmRWYWx1ZSYmKG8rPXRoaXMuY29uZmlnLmFwcGVuZFZhbHVlLnRvU3RyaW5nKCkpLHRoaXMuc3RvcmUuZGlzcGF0Y2goKDAscC5hZGRJdGVtKShvLGwsZCxoLG4scyxhKSksdGhpcy5pc1NlbGVjdE9uZUVsZW1lbnQmJnRoaXMucmVtb3ZlQWN0aXZlSXRlbXMoZCksdSYmdS52YWx1ZT8oMCx2LnRyaWdnZXJFdmVudCkodGhpcy5wYXNzZWRFbGVtZW50LFwiYWRkSXRlbVwiLHtpZDpkLHZhbHVlOm8sbGFiZWw6bCxncm91cFZhbHVlOnUudmFsdWUsa2V5Q29kZTphfSk6KDAsdi50cmlnZ2VyRXZlbnQpKHRoaXMucGFzc2VkRWxlbWVudCxcImFkZEl0ZW1cIix7aWQ6ZCx2YWx1ZTpvLGxhYmVsOmwsa2V5Q29kZTphfSksdGhpc319LHtrZXk6XCJfcmVtb3ZlSXRlbVwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKCFlfHwhKDAsdi5pc1R5cGUpKFwiT2JqZWN0XCIsZSkpcmV0dXJuIHRoaXM7dmFyIHQ9ZS5pZCxpPWUudmFsdWUsbj1lLmxhYmVsLHM9ZS5jaG9pY2VJZCxyPWUuZ3JvdXBJZCxvPXI+PTA/dGhpcy5zdG9yZS5nZXRHcm91cEJ5SWQocik6bnVsbDtcbnJldHVybiB0aGlzLnN0b3JlLmRpc3BhdGNoKCgwLHAucmVtb3ZlSXRlbSkodCxzKSksbyYmby52YWx1ZT8oMCx2LnRyaWdnZXJFdmVudCkodGhpcy5wYXNzZWRFbGVtZW50LFwicmVtb3ZlSXRlbVwiLHtpZDp0LHZhbHVlOmksbGFiZWw6bixncm91cFZhbHVlOm8udmFsdWV9KTooMCx2LnRyaWdnZXJFdmVudCkodGhpcy5wYXNzZWRFbGVtZW50LFwicmVtb3ZlSXRlbVwiLHtpZDp0LHZhbHVlOmksbGFiZWw6bn0pLHRoaXN9fSx7a2V5OlwiX2FkZENob2ljZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTpudWxsLGk9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXSxuPWFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdJiZhcmd1bWVudHNbM10scz1hcmd1bWVudHMubGVuZ3RoPjQmJnZvaWQgMCE9PWFyZ3VtZW50c1s0XT9hcmd1bWVudHNbNF06LTEscj1hcmd1bWVudHMubGVuZ3RoPjUmJnZvaWQgMCE9PWFyZ3VtZW50c1s1XT9hcmd1bWVudHNbNV06bnVsbCxvPWFyZ3VtZW50cy5sZW5ndGg+NiYmdm9pZCAwIT09YXJndW1lbnRzWzZdP2FyZ3VtZW50c1s2XTpudWxsO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl7dmFyIGE9dGhpcy5zdG9yZS5nZXRDaG9pY2VzKCksYz10fHxlLGw9YT9hLmxlbmd0aCsxOjEsaD10aGlzLmJhc2VJZCtcIi1cIit0aGlzLmlkTmFtZXMuaXRlbUNob2ljZStcIi1cIitsO3RoaXMuc3RvcmUuZGlzcGF0Y2goKDAscC5hZGRDaG9pY2UpKGUsYyxsLHMsbixoLHIsbykpLGkmJnRoaXMuX2FkZEl0ZW0oZSxjLGwsdm9pZCAwLHIsbyl9fX0se2tleTpcIl9jbGVhckNob2ljZXNcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuc3RvcmUuZGlzcGF0Y2goKDAscC5jbGVhckNob2ljZXMpKCkpfX0se2tleTpcIl9hZGRHcm91cFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIGk9dGhpcyxuPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpcInZhbHVlXCIscz1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106XCJsYWJlbFwiLHI9KDAsdi5pc1R5cGUpKFwiT2JqZWN0XCIsZSk/ZS5jaG9pY2VzOkFycmF5LmZyb20oZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIk9QVElPTlwiKSksbz10P3Q6TWF0aC5mbG9vcigobmV3IERhdGUpLnZhbHVlT2YoKSpNYXRoLnJhbmRvbSgpKSxhPSEhZS5kaXNhYmxlZCYmZS5kaXNhYmxlZDtyPyh0aGlzLnN0b3JlLmRpc3BhdGNoKCgwLHAuYWRkR3JvdXApKGUubGFiZWwsbywhMCxhKSksci5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PWUuZGlzYWJsZWR8fGUucGFyZW50Tm9kZSYmZS5wYXJlbnROb2RlLmRpc2FibGVkLHI9KDAsdi5pc1R5cGUpKFwiT2JqZWN0XCIsZSk/ZVtzXTplLmlubmVySFRNTDtpLl9hZGRDaG9pY2UoZVtuXSxyLGUuc2VsZWN0ZWQsdCxvLGUuY3VzdG9tUHJvcGVydGllcyl9KSk6dGhpcy5zdG9yZS5kaXNwYXRjaCgoMCxwLmFkZEdyb3VwKShlLmxhYmVsLGUuaWQsITEsZS5kaXNhYmxlZCkpfX0se2tleTpcIl9nZXRUZW1wbGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKCFlKXJldHVybiBudWxsO2Zvcih2YXIgdD10aGlzLmNvbmZpZy50ZW1wbGF0ZXMsaT1hcmd1bWVudHMubGVuZ3RoLG49QXJyYXkoaT4xP2ktMTowKSxzPTE7czxpO3MrKyluW3MtMV09YXJndW1lbnRzW3NdO3JldHVybiB0W2VdLmFwcGx5KHQsbil9fSx7a2V5OlwiX2NyZWF0ZVRlbXBsYXRlc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PXRoaXMuY29uZmlnLmNsYXNzTmFtZXMsaT17Y29udGFpbmVyT3V0ZXI6ZnVuY3Rpb24oaSl7cmV0dXJuKDAsdi5zdHJUb0VsKSgnXFxuICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICBjbGFzcz1cIicrdC5jb250YWluZXJPdXRlcisnXCJcXG4gICAgICAgICAgICAnKyhlLmlzU2VsZWN0RWxlbWVudD9lLmNvbmZpZy5zZWFyY2hFbmFibGVkPydyb2xlPVwiY29tYm9ib3hcIiBhcmlhLWF1dG9jb21wbGV0ZT1cImxpc3RcIic6J3JvbGU9XCJsaXN0Ym94XCInOlwiXCIpKydcXG4gICAgICAgICAgICBkYXRhLXR5cGU9XCInK2UucGFzc2VkRWxlbWVudC50eXBlKydcIlxcbiAgICAgICAgICAgICcrKGUuaXNTZWxlY3RPbmVFbGVtZW50Pyd0YWJpbmRleD1cIjBcIic6XCJcIikrJ1xcbiAgICAgICAgICAgIGFyaWEtaGFzcG9wdXA9XCJ0cnVlXCJcXG4gICAgICAgICAgICBhcmlhLWV4cGFuZGVkPVwiZmFsc2VcIlxcbiAgICAgICAgICAgIGRpcj1cIicraSsnXCJcXG4gICAgICAgICAgICA+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgJyl9LGNvbnRhaW5lcklubmVyOmZ1bmN0aW9uKCl7cmV0dXJuKDAsdi5zdHJUb0VsKSgnXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XCInK3QuY29udGFpbmVySW5uZXIrJ1wiPjwvZGl2PlxcbiAgICAgICAgJyl9LGl0ZW1MaXN0OmZ1bmN0aW9uKCl7dmFyIGksbj0oMCx1LmRlZmF1bHQpKHQubGlzdCwoaT17fSxzKGksdC5saXN0U2luZ2xlLGUuaXNTZWxlY3RPbmVFbGVtZW50KSxzKGksdC5saXN0SXRlbXMsIWUuaXNTZWxlY3RPbmVFbGVtZW50KSxpKSk7cmV0dXJuKDAsdi5zdHJUb0VsKSgnXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XCInK24rJ1wiPjwvZGl2PlxcbiAgICAgICAgJyl9LHBsYWNlaG9sZGVyOmZ1bmN0aW9uKGUpe3JldHVybigwLHYuc3RyVG9FbCkoJ1xcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiJyt0LnBsYWNlaG9sZGVyKydcIj5cXG4gICAgICAgICAgICAnK2UrXCJcXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICBcIil9LGl0ZW06ZnVuY3Rpb24oaSl7dmFyIG4scj0oMCx1LmRlZmF1bHQpKHQuaXRlbSwobj17fSxzKG4sdC5oaWdobGlnaHRlZFN0YXRlLGkuaGlnaGxpZ2h0ZWQpLHMobix0Lml0ZW1TZWxlY3RhYmxlLCFpLmhpZ2hsaWdodGVkKSxuKSk7aWYoZS5jb25maWcucmVtb3ZlSXRlbUJ1dHRvbil7dmFyIG87cmV0dXJuIHI9KDAsdS5kZWZhdWx0KSh0Lml0ZW0sKG89e30scyhvLHQuaGlnaGxpZ2h0ZWRTdGF0ZSxpLmhpZ2hsaWdodGVkKSxzKG8sdC5pdGVtU2VsZWN0YWJsZSwhaS5kaXNhYmxlZCksbykpLCgwLHYuc3RyVG9FbCkoJ1xcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgIGNsYXNzPVwiJytyKydcIlxcbiAgICAgICAgICAgICAgZGF0YS1pdGVtXFxuICAgICAgICAgICAgICBkYXRhLWlkPVwiJytpLmlkKydcIlxcbiAgICAgICAgICAgICAgZGF0YS12YWx1ZT1cIicraS52YWx1ZSsnXCJcXG4gICAgICAgICAgICAgIGRhdGEtZGVsZXRhYmxlXFxuICAgICAgICAgICAgICAnKyhpLmFjdGl2ZT8nYXJpYS1zZWxlY3RlZD1cInRydWVcIic6XCJcIikrXCJcXG4gICAgICAgICAgICAgIFwiKyhpLmRpc2FibGVkPydhcmlhLWRpc2FibGVkPVwidHJ1ZVwiJzpcIlwiKStcIlxcbiAgICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgXCIraS5sYWJlbCsnPCEtLVxcbiAgICAgICAgICAgLS0+PGJ1dHRvblxcbiAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcXG4gICAgICAgICAgICAgICAgY2xhc3M9XCInK3QuYnV0dG9uKydcIlxcbiAgICAgICAgICAgICAgICBkYXRhLWJ1dHRvblxcbiAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiUmVtb3ZlIGl0ZW06IFxcJycraS52YWx1ZStcIidcXFwiXFxuICAgICAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgICAgUmVtb3ZlIGl0ZW1cXG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICBcIil9cmV0dXJuKDAsdi5zdHJUb0VsKSgnXFxuICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICBjbGFzcz1cIicrcisnXCJcXG4gICAgICAgICAgICBkYXRhLWl0ZW1cXG4gICAgICAgICAgICBkYXRhLWlkPVwiJytpLmlkKydcIlxcbiAgICAgICAgICAgIGRhdGEtdmFsdWU9XCInK2kudmFsdWUrJ1wiXFxuICAgICAgICAgICAgJysoaS5hY3RpdmU/J2FyaWEtc2VsZWN0ZWQ9XCJ0cnVlXCInOlwiXCIpK1wiXFxuICAgICAgICAgICAgXCIrKGkuZGlzYWJsZWQ/J2FyaWEtZGlzYWJsZWQ9XCJ0cnVlXCInOlwiXCIpK1wiXFxuICAgICAgICAgICAgPlxcbiAgICAgICAgICAgIFwiK2kubGFiZWwrXCJcXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICBcIil9LGNob2ljZUxpc3Q6ZnVuY3Rpb24oKXtyZXR1cm4oMCx2LnN0clRvRWwpKCdcXG4gICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgIGNsYXNzPVwiJyt0Lmxpc3QrJ1wiXFxuICAgICAgICAgICAgZGlyPVwibHRyXCJcXG4gICAgICAgICAgICByb2xlPVwibGlzdGJveFwiXFxuICAgICAgICAgICAgJysoZS5pc1NlbGVjdE9uZUVsZW1lbnQ/XCJcIjonYXJpYS1tdWx0aXNlbGVjdGFibGU9XCJ0cnVlXCInKStcIlxcbiAgICAgICAgICAgID5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICBcIil9LGNob2ljZUdyb3VwOmZ1bmN0aW9uKGUpe3ZhciBpPSgwLHUuZGVmYXVsdCkodC5ncm91cCxzKHt9LHQuaXRlbURpc2FibGVkLGUuZGlzYWJsZWQpKTtyZXR1cm4oMCx2LnN0clRvRWwpKCdcXG4gICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgIGNsYXNzPVwiJytpKydcIlxcbiAgICAgICAgICAgIGRhdGEtZ3JvdXBcXG4gICAgICAgICAgICBkYXRhLWlkPVwiJytlLmlkKydcIlxcbiAgICAgICAgICAgIGRhdGEtdmFsdWU9XCInK2UudmFsdWUrJ1wiXFxuICAgICAgICAgICAgcm9sZT1cImdyb3VwXCJcXG4gICAgICAgICAgICAnKyhlLmRpc2FibGVkPydhcmlhLWRpc2FibGVkPVwidHJ1ZVwiJzpcIlwiKSsnXFxuICAgICAgICAgICAgPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCInK3QuZ3JvdXBIZWFkaW5nKydcIj4nK2UudmFsdWUrXCI8L2Rpdj5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICBcIil9LGNob2ljZTpmdW5jdGlvbihpKXt2YXIgbixyPSgwLHUuZGVmYXVsdCkodC5pdGVtLHQuaXRlbUNob2ljZSwobj17fSxzKG4sdC5pdGVtRGlzYWJsZWQsaS5kaXNhYmxlZCkscyhuLHQuaXRlbVNlbGVjdGFibGUsIWkuZGlzYWJsZWQpLG4pKTtyZXR1cm4oMCx2LnN0clRvRWwpKCdcXG4gICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgIGNsYXNzPVwiJytyKydcIlxcbiAgICAgICAgICAgIGRhdGEtc2VsZWN0LXRleHQ9XCInK2UuY29uZmlnLml0ZW1TZWxlY3RUZXh0KydcIlxcbiAgICAgICAgICAgIGRhdGEtY2hvaWNlXFxuICAgICAgICAgICAgZGF0YS1pZD1cIicraS5pZCsnXCJcXG4gICAgICAgICAgICBkYXRhLXZhbHVlPVwiJytpLnZhbHVlKydcIlxcbiAgICAgICAgICAgICcrKGkuZGlzYWJsZWQ/J2RhdGEtY2hvaWNlLWRpc2FibGVkIGFyaWEtZGlzYWJsZWQ9XCJ0cnVlXCInOlwiZGF0YS1jaG9pY2Utc2VsZWN0YWJsZVwiKSsnXFxuICAgICAgICAgICAgaWQ9XCInK2kuZWxlbWVudElkKydcIlxcbiAgICAgICAgICAgICcrKGkuZ3JvdXBJZD4wPydyb2xlPVwidHJlZWl0ZW1cIic6J3JvbGU9XCJvcHRpb25cIicpK1wiXFxuICAgICAgICAgICAgPlxcbiAgICAgICAgICAgIFwiK2kubGFiZWwrXCJcXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICBcIil9LGlucHV0OmZ1bmN0aW9uKCl7dmFyIGU9KDAsdS5kZWZhdWx0KSh0LmlucHV0LHQuaW5wdXRDbG9uZWQpO3JldHVybigwLHYuc3RyVG9FbCkoJ1xcbiAgICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgICB0eXBlPVwidGV4dFwiXFxuICAgICAgICAgICAgY2xhc3M9XCInK2UrJ1wiXFxuICAgICAgICAgICAgYXV0b2NvbXBsZXRlPVwib2ZmXCJcXG4gICAgICAgICAgICBhdXRvY2FwaXRhbGl6ZT1cIm9mZlwiXFxuICAgICAgICAgICAgc3BlbGxjaGVjaz1cImZhbHNlXCJcXG4gICAgICAgICAgICByb2xlPVwidGV4dGJveFwiXFxuICAgICAgICAgICAgYXJpYS1hdXRvY29tcGxldGU9XCJsaXN0XCJcXG4gICAgICAgICAgICA+XFxuICAgICAgICAnKX0sZHJvcGRvd246ZnVuY3Rpb24oKXt2YXIgZT0oMCx1LmRlZmF1bHQpKHQubGlzdCx0Lmxpc3REcm9wZG93bik7cmV0dXJuKDAsdi5zdHJUb0VsKSgnXFxuICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICBjbGFzcz1cIicrZSsnXCJcXG4gICAgICAgICAgICBhcmlhLWV4cGFuZGVkPVwiZmFsc2VcIlxcbiAgICAgICAgICAgID5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICAnKX0sbm90aWNlOmZ1bmN0aW9uKGUpe3ZhciBpPSgwLHUuZGVmYXVsdCkodC5pdGVtLHQuaXRlbUNob2ljZSk7cmV0dXJuKDAsdi5zdHJUb0VsKSgnXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XCInK2krJ1wiPlxcbiAgICAgICAgICAgICcrZStcIlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIFwiKX0sb3B0aW9uOmZ1bmN0aW9uKGUpe3JldHVybigwLHYuc3RyVG9FbCkoJ1xcbiAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiJytlLnZhbHVlKydcIiBzZWxlY3RlZD4nK2UubGFiZWwrXCI8L29wdGlvbj5cXG4gICAgICAgIFwiKX19LG49dGhpcy5jb25maWcuY2FsbGJhY2tPbkNyZWF0ZVRlbXBsYXRlcyxyPXt9O24mJigwLHYuaXNUeXBlKShcIkZ1bmN0aW9uXCIsbikmJihyPW4uY2FsbCh0aGlzLHYuc3RyVG9FbCkpLHRoaXMuY29uZmlnLnRlbXBsYXRlcz0oMCx2LmV4dGVuZCkoaSxyKX19LHtrZXk6XCJfY3JlYXRlSW5wdXRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD10aGlzLnBhc3NlZEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGlyXCIpfHxcImx0clwiLGk9dGhpcy5fZ2V0VGVtcGxhdGUoXCJjb250YWluZXJPdXRlclwiLHQpLG49dGhpcy5fZ2V0VGVtcGxhdGUoXCJjb250YWluZXJJbm5lclwiKSxzPXRoaXMuX2dldFRlbXBsYXRlKFwiaXRlbUxpc3RcIikscj10aGlzLl9nZXRUZW1wbGF0ZShcImNob2ljZUxpc3RcIiksbz10aGlzLl9nZXRUZW1wbGF0ZShcImlucHV0XCIpLGE9dGhpcy5fZ2V0VGVtcGxhdGUoXCJkcm9wZG93blwiKSxjPSEhdGhpcy5jb25maWcucGxhY2Vob2xkZXImJih0aGlzLmNvbmZpZy5wbGFjZWhvbGRlclZhbHVlfHx0aGlzLnBhc3NlZEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIikpO3RoaXMuY29udGFpbmVyT3V0ZXI9aSx0aGlzLmNvbnRhaW5lcklubmVyPW4sdGhpcy5pbnB1dD1vLHRoaXMuY2hvaWNlTGlzdD1yLHRoaXMuaXRlbUxpc3Q9cyx0aGlzLmRyb3Bkb3duPWEsdGhpcy5wYXNzZWRFbGVtZW50LmNsYXNzTGlzdC5hZGQodGhpcy5jb25maWcuY2xhc3NOYW1lcy5pbnB1dCx0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmhpZGRlblN0YXRlKSx0aGlzLnBhc3NlZEVsZW1lbnQudGFiSW5kZXg9XCItMVwiO3ZhciBsPXRoaXMucGFzc2VkRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtpZihCb29sZWFuKGwpJiZ0aGlzLnBhc3NlZEVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1jaG9pY2Utb3JpZy1zdHlsZVwiLGwpLHRoaXMucGFzc2VkRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLFwiZGlzcGxheTpub25lO1wiKSx0aGlzLnBhc3NlZEVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIixcInRydWVcIiksdGhpcy5wYXNzZWRFbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtY2hvaWNlXCIsXCJhY3RpdmVcIiksKDAsdi53cmFwKSh0aGlzLnBhc3NlZEVsZW1lbnQsbiksKDAsdi53cmFwKShuLGkpLGMmJihvLnBsYWNlaG9sZGVyPWMsdGhpcy5pc1NlbGVjdE9uZUVsZW1lbnR8fChvLnN0eWxlLndpZHRoPSgwLHYuZ2V0V2lkdGhPZklucHV0KShvKSkpLHRoaXMuY29uZmlnLmFkZEl0ZW1zfHx0aGlzLmRpc2FibGUoKSxpLmFwcGVuZENoaWxkKG4pLGkuYXBwZW5kQ2hpbGQoYSksbi5hcHBlbmRDaGlsZChzKSx0aGlzLmlzVGV4dEVsZW1lbnR8fGEuYXBwZW5kQ2hpbGQociksdGhpcy5pc1NlbGVjdE11bHRpcGxlRWxlbWVudHx8dGhpcy5pc1RleHRFbGVtZW50P24uYXBwZW5kQ2hpbGQobyk6dGhpcy5jYW5TZWFyY2gmJmEuaW5zZXJ0QmVmb3JlKG8sYS5maXJzdENoaWxkKSx0aGlzLmlzU2VsZWN0RWxlbWVudCl7dmFyIGg9QXJyYXkuZnJvbSh0aGlzLnBhc3NlZEVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJPUFRHUk9VUFwiKSk7aWYodGhpcy5oaWdobGlnaHRQb3NpdGlvbj0wLHRoaXMuaXNTZWFyY2hpbmc9ITEsaCYmaC5sZW5ndGgpaC5mb3JFYWNoKGZ1bmN0aW9uKHQpe2UuX2FkZEdyb3VwKHQsdC5pZHx8bnVsbCl9KTtlbHNle3ZhciB1PUFycmF5LmZyb20odGhpcy5wYXNzZWRFbGVtZW50Lm9wdGlvbnMpLGQ9dGhpcy5jb25maWcuc29ydEZpbHRlcixmPXRoaXMucHJlc2V0Q2hvaWNlczt1LmZvckVhY2goZnVuY3Rpb24oZSl7Zi5wdXNoKHt2YWx1ZTplLnZhbHVlLGxhYmVsOmUuaW5uZXJIVE1MLHNlbGVjdGVkOmUuc2VsZWN0ZWQsZGlzYWJsZWQ6ZS5kaXNhYmxlZHx8ZS5wYXJlbnROb2RlLmRpc2FibGVkfSl9KSx0aGlzLmNvbmZpZy5zaG91bGRTb3J0JiZmLnNvcnQoZCk7dmFyIHA9Zi5zb21lKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNlbGVjdGVkfSk7Zi5mb3JFYWNoKGZ1bmN0aW9uKHQsaSl7ZS5pc1NlbGVjdE9uZUVsZW1lbnQ/cHx8IXAmJmk+MD9lLl9hZGRDaG9pY2UodC52YWx1ZSx0LmxhYmVsLHQuc2VsZWN0ZWQsdC5kaXNhYmxlZCx2b2lkIDAsdC5jdXN0b21Qcm9wZXJ0aWVzKTplLl9hZGRDaG9pY2UodC52YWx1ZSx0LmxhYmVsLCEwLCExLHZvaWQgMCx0LmN1c3RvbVByb3BlcnRpZXMpOmUuX2FkZENob2ljZSh0LnZhbHVlLHQubGFiZWwsdC5zZWxlY3RlZCx0LmRpc2FibGVkLHZvaWQgMCx0LmN1c3RvbVByb3BlcnRpZXMpfSl9fWVsc2UgdGhpcy5pc1RleHRFbGVtZW50JiZ0aGlzLnByZXNldEl0ZW1zLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIGk9KDAsdi5nZXRUeXBlKSh0KTtpZihcIk9iamVjdFwiPT09aSl7aWYoIXQudmFsdWUpcmV0dXJuO2UuX2FkZEl0ZW0odC52YWx1ZSx0LmxhYmVsLHQuaWQsdm9pZCAwLHQuY3VzdG9tUHJvcGVydGllcyl9ZWxzZVwiU3RyaW5nXCI9PT1pJiZlLl9hZGRJdGVtKHQpfSl9fV0pLGV9KCk7ZS5leHBvcnRzPW19LGZ1bmN0aW9uKGUsdCxpKXshZnVuY3Rpb24odCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaSgpe2NvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsYXJndW1lbnRzKX1mdW5jdGlvbiBuKGUsdCl7dmFyIGk7dGhpcy5saXN0PWUsdGhpcy5vcHRpb25zPXQ9dHx8e307Zm9yKGkgaW4gYSlhLmhhc093blByb3BlcnR5KGkpJiYoXCJib29sZWFuXCI9PXR5cGVvZiBhW2ldP3RoaXMub3B0aW9uc1tpXT1pIGluIHQ/dFtpXTphW2ldOnRoaXMub3B0aW9uc1tpXT10W2ldfHxhW2ldKX1mdW5jdGlvbiBzKGUsdCxpKXt2YXIgbixvLGEsYyxsLGg7aWYodCl7aWYoYT10LmluZGV4T2YoXCIuXCIpLGEhPT0tMT8obj10LnNsaWNlKDAsYSksbz10LnNsaWNlKGErMSkpOm49dCxjPWVbbl0sbnVsbCE9PWMmJnZvaWQgMCE9PWMpaWYob3x8XCJzdHJpbmdcIiE9dHlwZW9mIGMmJlwibnVtYmVyXCIhPXR5cGVvZiBjKWlmKHIoYykpZm9yKGw9MCxoPWMubGVuZ3RoO2w8aDtsKyspcyhjW2xdLG8saSk7ZWxzZSBvJiZzKGMsbyxpKTtlbHNlIGkucHVzaChjKX1lbHNlIGkucHVzaChlKTtyZXR1cm4gaX1mdW5jdGlvbiByKGUpe3JldHVyblwiW29iamVjdCBBcnJheV1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKX1mdW5jdGlvbiBvKGUsdCl7dD10fHx7fSx0aGlzLm9wdGlvbnM9dCx0aGlzLm9wdGlvbnMubG9jYXRpb249dC5sb2NhdGlvbnx8by5kZWZhdWx0T3B0aW9ucy5sb2NhdGlvbix0aGlzLm9wdGlvbnMuZGlzdGFuY2U9XCJkaXN0YW5jZVwiaW4gdD90LmRpc3RhbmNlOm8uZGVmYXVsdE9wdGlvbnMuZGlzdGFuY2UsdGhpcy5vcHRpb25zLnRocmVzaG9sZD1cInRocmVzaG9sZFwiaW4gdD90LnRocmVzaG9sZDpvLmRlZmF1bHRPcHRpb25zLnRocmVzaG9sZCx0aGlzLm9wdGlvbnMubWF4UGF0dGVybkxlbmd0aD10Lm1heFBhdHRlcm5MZW5ndGh8fG8uZGVmYXVsdE9wdGlvbnMubWF4UGF0dGVybkxlbmd0aCx0aGlzLnBhdHRlcm49dC5jYXNlU2Vuc2l0aXZlP2U6ZS50b0xvd2VyQ2FzZSgpLHRoaXMucGF0dGVybkxlbj1lLmxlbmd0aCx0aGlzLnBhdHRlcm5MZW48PXRoaXMub3B0aW9ucy5tYXhQYXR0ZXJuTGVuZ3RoJiYodGhpcy5tYXRjaG1hc2s9MTw8dGhpcy5wYXR0ZXJuTGVuLTEsdGhpcy5wYXR0ZXJuQWxwaGFiZXQ9dGhpcy5fY2FsY3VsYXRlUGF0dGVybkFscGhhYmV0KCkpfXZhciBhPXtpZDpudWxsLGNhc2VTZW5zaXRpdmU6ITEsaW5jbHVkZTpbXSxzaG91bGRTb3J0OiEwLHNlYXJjaEZuOm8sc29ydEZuOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuc2NvcmUtdC5zY29yZX0sZ2V0Rm46cyxrZXlzOltdLHZlcmJvc2U6ITEsdG9rZW5pemU6ITEsbWF0Y2hBbGxUb2tlbnM6ITEsdG9rZW5TZXBhcmF0b3I6LyArL2csbWluTWF0Y2hDaGFyTGVuZ3RoOjEsZmluZEFsbE1hdGNoZXM6ITF9O24uVkVSU0lPTj1cIjIuNy4zXCIsbi5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmxpc3Q9ZSxlfSxuLnByb3RvdHlwZS5zZWFyY2g9ZnVuY3Rpb24oZSl7dGhpcy5vcHRpb25zLnZlcmJvc2UmJmkoXCJcXG5TZWFyY2ggdGVybTpcIixlLFwiXFxuXCIpLHRoaXMucGF0dGVybj1lLHRoaXMucmVzdWx0cz1bXSx0aGlzLnJlc3VsdE1hcD17fSx0aGlzLl9rZXlNYXA9bnVsbCx0aGlzLl9wcmVwYXJlU2VhcmNoZXJzKCksdGhpcy5fc3RhcnRTZWFyY2goKSx0aGlzLl9jb21wdXRlU2NvcmUoKSx0aGlzLl9zb3J0KCk7dmFyIHQ9dGhpcy5fZm9ybWF0KCk7cmV0dXJuIHR9LG4ucHJvdG90eXBlLl9wcmVwYXJlU2VhcmNoZXJzPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5vcHRpb25zLHQ9dGhpcy5wYXR0ZXJuLGk9ZS5zZWFyY2hGbixuPXQuc3BsaXQoZS50b2tlblNlcGFyYXRvcikscz0wLHI9bi5sZW5ndGg7aWYodGhpcy5vcHRpb25zLnRva2VuaXplKWZvcih0aGlzLnRva2VuU2VhcmNoZXJzPVtdO3M8cjtzKyspdGhpcy50b2tlblNlYXJjaGVycy5wdXNoKG5ldyBpKG5bc10sZSkpO3RoaXMuZnVsbFNlYWNoZXI9bmV3IGkodCxlKX0sbi5wcm90b3R5cGUuX3N0YXJ0U2VhcmNoPWZ1bmN0aW9uKCl7dmFyIGUsdCxpLG4scz10aGlzLm9wdGlvbnMscj1zLmdldEZuLG89dGhpcy5saXN0LGE9by5sZW5ndGgsYz10aGlzLm9wdGlvbnMua2V5cyxsPWMubGVuZ3RoLGg9bnVsbDtpZihcInN0cmluZ1wiPT10eXBlb2Ygb1swXSlmb3IoaT0wO2k8YTtpKyspdGhpcy5fYW5hbHl6ZShcIlwiLG9baV0saSxpKTtlbHNlIGZvcih0aGlzLl9rZXlNYXA9e30saT0wO2k8YTtpKyspZm9yKGg9b1tpXSxuPTA7bjxsO24rKyl7aWYoZT1jW25dLFwic3RyaW5nXCIhPXR5cGVvZiBlKXtpZih0PTEtZS53ZWlnaHR8fDEsdGhpcy5fa2V5TWFwW2UubmFtZV09e3dlaWdodDp0fSxlLndlaWdodDw9MHx8ZS53ZWlnaHQ+MSl0aHJvdyBuZXcgRXJyb3IoXCJLZXkgd2VpZ2h0IGhhcyB0byBiZSA+IDAgYW5kIDw9IDFcIik7ZT1lLm5hbWV9ZWxzZSB0aGlzLl9rZXlNYXBbZV09e3dlaWdodDoxfTt0aGlzLl9hbmFseXplKGUscihoLGUsW10pLGgsaSl9fSxuLnByb3RvdHlwZS5fYW5hbHl6ZT1mdW5jdGlvbihlLHQsbixzKXt2YXIgbyxhLGMsbCxoLHUsZCxmLHAsdixtLGcseSxiLEUsXz10aGlzLm9wdGlvbnMsUz0hMTtpZih2b2lkIDAhPT10JiZudWxsIT09dCl7YT1bXTt2YXIgST0wO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXtpZihvPXQuc3BsaXQoXy50b2tlblNlcGFyYXRvciksXy52ZXJib3NlJiZpKFwiLS0tLS0tLS0tXFxuS2V5OlwiLGUpLHRoaXMub3B0aW9ucy50b2tlbml6ZSl7Zm9yKGI9MDtiPHRoaXMudG9rZW5TZWFyY2hlcnMubGVuZ3RoO2IrKyl7Zm9yKGY9dGhpcy50b2tlblNlYXJjaGVyc1tiXSxfLnZlcmJvc2UmJmkoXCJQYXR0ZXJuOlwiLGYucGF0dGVybikscD1bXSxnPSExLEU9MDtFPG8ubGVuZ3RoO0UrKyl7dj1vW0VdLG09Zi5zZWFyY2godik7dmFyIHc9e307bS5pc01hdGNoPyh3W3ZdPW0uc2NvcmUsUz0hMCxnPSEwLGEucHVzaChtLnNjb3JlKSk6KHdbdl09MSx0aGlzLm9wdGlvbnMubWF0Y2hBbGxUb2tlbnN8fGEucHVzaCgxKSkscC5wdXNoKHcpfWcmJkkrKyxfLnZlcmJvc2UmJmkoXCJUb2tlbiBzY29yZXM6XCIscCl9Zm9yKGw9YVswXSx1PWEubGVuZ3RoLGI9MTtiPHU7YisrKWwrPWFbYl07bC89dSxfLnZlcmJvc2UmJmkoXCJUb2tlbiBzY29yZSBhdmVyYWdlOlwiLGwpfWQ9dGhpcy5mdWxsU2VhY2hlci5zZWFyY2godCksXy52ZXJib3NlJiZpKFwiRnVsbCB0ZXh0IHNjb3JlOlwiLGQuc2NvcmUpLGg9ZC5zY29yZSx2b2lkIDAhPT1sJiYoaD0oaCtsKS8yKSxfLnZlcmJvc2UmJmkoXCJTY29yZSBhdmVyYWdlOlwiLGgpLHk9IXRoaXMub3B0aW9ucy50b2tlbml6ZXx8IXRoaXMub3B0aW9ucy5tYXRjaEFsbFRva2Vuc3x8ST49dGhpcy50b2tlblNlYXJjaGVycy5sZW5ndGgsXy52ZXJib3NlJiZpKFwiQ2hlY2sgTWF0Y2hlc1wiLHkpLChTfHxkLmlzTWF0Y2gpJiZ5JiYoYz10aGlzLnJlc3VsdE1hcFtzXSxjP2Mub3V0cHV0LnB1c2goe2tleTplLHNjb3JlOmgsbWF0Y2hlZEluZGljZXM6ZC5tYXRjaGVkSW5kaWNlc30pOih0aGlzLnJlc3VsdE1hcFtzXT17aXRlbTpuLG91dHB1dDpbe2tleTplLHNjb3JlOmgsbWF0Y2hlZEluZGljZXM6ZC5tYXRjaGVkSW5kaWNlc31dfSx0aGlzLnJlc3VsdHMucHVzaCh0aGlzLnJlc3VsdE1hcFtzXSkpKX1lbHNlIGlmKHIodCkpZm9yKGI9MDtiPHQubGVuZ3RoO2IrKyl0aGlzLl9hbmFseXplKGUsdFtiXSxuLHMpfX0sbi5wcm90b3R5cGUuX2NvbXB1dGVTY29yZT1mdW5jdGlvbigpe3ZhciBlLHQsbixzLHIsbyxhLGMsbCxoPXRoaXMuX2tleU1hcCx1PXRoaXMucmVzdWx0cztmb3IodGhpcy5vcHRpb25zLnZlcmJvc2UmJmkoXCJcXG5cXG5Db21wdXRpbmcgc2NvcmU6XFxuXCIpLGU9MDtlPHUubGVuZ3RoO2UrKyl7Zm9yKG49MCxzPXVbZV0ub3V0cHV0LHI9cy5sZW5ndGgsYz0xLHQ9MDt0PHI7dCsrKW89c1t0XS5zY29yZSxhPWg/aFtzW3RdLmtleV0ud2VpZ2h0OjEsbD1vKmEsMSE9PWE/Yz1NYXRoLm1pbihjLGwpOihuKz1sLHNbdF0ublNjb3JlPWwpOzE9PT1jP3VbZV0uc2NvcmU9bi9yOnVbZV0uc2NvcmU9Yyx0aGlzLm9wdGlvbnMudmVyYm9zZSYmaSh1W2VdKX19LG4ucHJvdG90eXBlLl9zb3J0PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5vcHRpb25zO2Uuc2hvdWxkU29ydCYmKGUudmVyYm9zZSYmaShcIlxcblxcblNvcnRpbmcuLi4uXCIpLHRoaXMucmVzdWx0cy5zb3J0KGUuc29ydEZuKSl9LG4ucHJvdG90eXBlLl9mb3JtYXQ9ZnVuY3Rpb24oKXt2YXIgZSx0LG4scyxyPXRoaXMub3B0aW9ucyxvPXIuZ2V0Rm4sYT1bXSxjPXRoaXMucmVzdWx0cyxsPXIuaW5jbHVkZTtmb3Ioci52ZXJib3NlJiZpKFwiXFxuXFxuT3V0cHV0OlxcblxcblwiLGMpLG49ci5pZD9mdW5jdGlvbihlKXtjW2VdLml0ZW09byhjW2VdLml0ZW0sci5pZCxbXSlbMF19OmZ1bmN0aW9uKCl7fSxzPWZ1bmN0aW9uKGUpe3ZhciB0LGksbixzLHIsbz1jW2VdO2lmKGwubGVuZ3RoPjApe2lmKHQ9e2l0ZW06by5pdGVtfSxsLmluZGV4T2YoXCJtYXRjaGVzXCIpIT09LTEpZm9yKG49by5vdXRwdXQsdC5tYXRjaGVzPVtdLGk9MDtpPG4ubGVuZ3RoO2krKylzPW5baV0scj17aW5kaWNlczpzLm1hdGNoZWRJbmRpY2VzfSxzLmtleSYmKHIua2V5PXMua2V5KSx0Lm1hdGNoZXMucHVzaChyKTtsLmluZGV4T2YoXCJzY29yZVwiKSE9PS0xJiYodC5zY29yZT1jW2VdLnNjb3JlKX1lbHNlIHQ9by5pdGVtO3JldHVybiB0fSxlPTAsdD1jLmxlbmd0aDtlPHQ7ZSsrKW4oZSksYS5wdXNoKHMoZSkpO3JldHVybiBhfSxvLmRlZmF1bHRPcHRpb25zPXtsb2NhdGlvbjowLGRpc3RhbmNlOjEwMCx0aHJlc2hvbGQ6LjYsbWF4UGF0dGVybkxlbmd0aDozMn0sby5wcm90b3R5cGUuX2NhbGN1bGF0ZVBhdHRlcm5BbHBoYWJldD1mdW5jdGlvbigpe3ZhciBlPXt9LHQ9MDtmb3IodD0wO3Q8dGhpcy5wYXR0ZXJuTGVuO3QrKyllW3RoaXMucGF0dGVybi5jaGFyQXQodCldPTA7Zm9yKHQ9MDt0PHRoaXMucGF0dGVybkxlbjt0KyspZVt0aGlzLnBhdHRlcm4uY2hhckF0KHQpXXw9MTw8dGhpcy5wYXR0ZXJuLmxlbmd0aC10LTE7cmV0dXJuIGV9LG8ucHJvdG90eXBlLl9iaXRhcFNjb3JlPWZ1bmN0aW9uKGUsdCl7dmFyIGk9ZS90aGlzLnBhdHRlcm5MZW4sbj1NYXRoLmFicyh0aGlzLm9wdGlvbnMubG9jYXRpb24tdCk7cmV0dXJuIHRoaXMub3B0aW9ucy5kaXN0YW5jZT9pK24vdGhpcy5vcHRpb25zLmRpc3RhbmNlOm4/MTppfSxvLnByb3RvdHlwZS5zZWFyY2g9ZnVuY3Rpb24oZSl7dmFyIHQsaSxuLHMscixvLGEsYyxsLGgsdSxkLGYscCx2LG0sZyx5LGIsRSxfLFMsSSx3PXRoaXMub3B0aW9ucztpZihlPXcuY2FzZVNlbnNpdGl2ZT9lOmUudG9Mb3dlckNhc2UoKSx0aGlzLnBhdHRlcm49PT1lKXJldHVybntpc01hdGNoOiEwLHNjb3JlOjAsbWF0Y2hlZEluZGljZXM6W1swLGUubGVuZ3RoLTFdXX07aWYodGhpcy5wYXR0ZXJuTGVuPncubWF4UGF0dGVybkxlbmd0aCl7aWYoeT1lLm1hdGNoKG5ldyBSZWdFeHAodGhpcy5wYXR0ZXJuLnJlcGxhY2Uody50b2tlblNlcGFyYXRvcixcInxcIikpKSxiPSEheSlmb3IoXz1bXSx0PTAsUz15Lmxlbmd0aDt0PFM7dCsrKUk9eVt0XSxfLnB1c2goW2UuaW5kZXhPZihJKSxJLmxlbmd0aC0xXSk7cmV0dXJue2lzTWF0Y2g6YixzY29yZTpiPy41OjEsbWF0Y2hlZEluZGljZXM6X319Zm9yKHM9dy5maW5kQWxsTWF0Y2hlcyxyPXcubG9jYXRpb24sbj1lLmxlbmd0aCxvPXcudGhyZXNob2xkLGE9ZS5pbmRleE9mKHRoaXMucGF0dGVybixyKSxFPVtdLHQ9MDt0PG47dCsrKUVbdF09MDtmb3IoYSE9LTEmJihvPU1hdGgubWluKHRoaXMuX2JpdGFwU2NvcmUoMCxhKSxvKSxhPWUubGFzdEluZGV4T2YodGhpcy5wYXR0ZXJuLHIrdGhpcy5wYXR0ZXJuTGVuKSxhIT0tMSYmKG89TWF0aC5taW4odGhpcy5fYml0YXBTY29yZSgwLGEpLG8pKSksYT0tMSxtPTEsZz1bXSxoPXRoaXMucGF0dGVybkxlbituLHQ9MDt0PHRoaXMucGF0dGVybkxlbjt0Kyspe2ZvcihjPTAsbD1oO2M8bDspdGhpcy5fYml0YXBTY29yZSh0LHIrbCk8PW8/Yz1sOmg9bCxsPU1hdGguZmxvb3IoKGgtYykvMitjKTtmb3IoaD1sLHU9TWF0aC5tYXgoMSxyLWwrMSksZD1zP246TWF0aC5taW4ocitsLG4pK3RoaXMucGF0dGVybkxlbixmPUFycmF5KGQrMiksZltkKzFdPSgxPDx0KS0xLGk9ZDtpPj11O2ktLSlpZih2PXRoaXMucGF0dGVybkFscGhhYmV0W2UuY2hhckF0KGktMSldLHYmJihFW2ktMV09MSksZltpXT0oZltpKzFdPDwxfDEpJnYsMCE9PXQmJihmW2ldfD0ocFtpKzFdfHBbaV0pPDwxfDF8cFtpKzFdKSxmW2ldJnRoaXMubWF0Y2htYXNrJiYobT10aGlzLl9iaXRhcFNjb3JlKHQsaS0xKSxtPD1vKSl7aWYobz1tLGE9aS0xLGcucHVzaChhKSxhPD1yKWJyZWFrO3U9TWF0aC5tYXgoMSwyKnItYSl9aWYodGhpcy5fYml0YXBTY29yZSh0KzEscik+bylicmVhaztwPWZ9cmV0dXJuIF89dGhpcy5fZ2V0TWF0Y2hlZEluZGljZXMoRSkse2lzTWF0Y2g6YT49MCxzY29yZTowPT09bT8uMDAxOm0sbWF0Y2hlZEluZGljZXM6X319LG8ucHJvdG90eXBlLl9nZXRNYXRjaGVkSW5kaWNlcz1mdW5jdGlvbihlKXtmb3IodmFyIHQsaT1bXSxuPS0xLHM9LTEscj0wLG89ZS5sZW5ndGg7cjxvO3IrKyl0PWVbcl0sdCYmbj09PS0xP249cjp0fHxuPT09LTF8fChzPXItMSxzLW4rMT49dGhpcy5vcHRpb25zLm1pbk1hdGNoQ2hhckxlbmd0aCYmaS5wdXNoKFtuLHNdKSxuPS0xKTtyZXR1cm4gZVtyLTFdJiZyLTEtbisxPj10aGlzLm9wdGlvbnMubWluTWF0Y2hDaGFyTGVuZ3RoJiZpLnB1c2goW24sci0xXSksaX0sZS5leHBvcnRzPW59KHRoaXMpfSxmdW5jdGlvbihlLHQsaSl7dmFyIG4sczshZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKCl7Zm9yKHZhciBlPVtdLHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXt2YXIgbj1hcmd1bWVudHNbdF07aWYobil7dmFyIHM9dHlwZW9mIG47aWYoXCJzdHJpbmdcIj09PXN8fFwibnVtYmVyXCI9PT1zKWUucHVzaChuKTtlbHNlIGlmKEFycmF5LmlzQXJyYXkobikpZS5wdXNoKGkuYXBwbHkobnVsbCxuKSk7ZWxzZSBpZihcIm9iamVjdFwiPT09cylmb3IodmFyIG8gaW4gbilyLmNhbGwobixvKSYmbltvXSYmZS5wdXNoKG8pfX1yZXR1cm4gZS5qb2luKFwiIFwiKX12YXIgcj17fS5oYXNPd25Qcm9wZXJ0eTtcInVuZGVmaW5lZFwiIT10eXBlb2YgZSYmZS5leHBvcnRzP2UuZXhwb3J0cz1pOihuPVtdLHM9ZnVuY3Rpb24oKXtyZXR1cm4gaX0uYXBwbHkodCxuKSwhKHZvaWQgMCE9PXMmJihlLmV4cG9ydHM9cykpKX0oKX0sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIHMoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgaT0wO2k8dC5sZW5ndGg7aSsrKXt2YXIgbj10W2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLmtleSxuKX19cmV0dXJuIGZ1bmN0aW9uKHQsaSxuKXtyZXR1cm4gaSYmZSh0LnByb3RvdHlwZSxpKSxuJiZlKHQsbiksdH19KCksbz1pKDUpLGE9aSgyNiksYz1uKGEpLGw9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7cyh0aGlzLGUpLHRoaXMuc3RvcmU9KDAsby5jcmVhdGVTdG9yZSkoYy5kZWZhdWx0LHdpbmRvdy5kZXZUb29sc0V4dGVuc2lvbj93aW5kb3cuZGV2VG9vbHNFeHRlbnNpb24oKTp2b2lkIDApfXJldHVybiByKGUsW3trZXk6XCJnZXRTdGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKX19LHtrZXk6XCJkaXNwYXRjaFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuc3RvcmUuZGlzcGF0Y2goZSl9fSx7a2V5Olwic3Vic2NyaWJlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5zdG9yZS5zdWJzY3JpYmUoZSl9fSx7a2V5OlwiZ2V0SXRlbXNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtyZXR1cm4gZS5pdGVtc319LHtrZXk6XCJnZXRJdGVtc0ZpbHRlcmVkQnlBY3RpdmVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMuZ2V0SXRlbXMoKSx0PWUuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLmFjdGl2ZT09PSEwfSxbXSk7cmV0dXJuIHR9fSx7a2V5OlwiZ2V0SXRlbXNSZWR1Y2VkVG9WYWx1ZXNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp0aGlzLmdldEl0ZW1zKCksdD1lLnJlZHVjZShmdW5jdGlvbihlLHQpe3JldHVybiBlLnB1c2godC52YWx1ZSksZX0sW10pO3JldHVybiB0fX0se2tleTpcImdldENob2ljZXNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtyZXR1cm4gZS5jaG9pY2VzfX0se2tleTpcImdldENob2ljZXNGaWx0ZXJlZEJ5QWN0aXZlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmdldENob2ljZXMoKSx0PWUuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLmFjdGl2ZT09PSEwfSxbXSk7cmV0dXJuIHR9fSx7a2V5OlwiZ2V0Q2hvaWNlc0ZpbHRlcmVkQnlTZWxlY3RhYmxlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmdldENob2ljZXMoKSx0PWUuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLmRpc2FibGVkIT09ITB9LFtdKTtyZXR1cm4gdH19LHtrZXk6XCJnZXRDaG9pY2VCeUlkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYoZSl7dmFyIHQ9dGhpcy5nZXRDaG9pY2VzRmlsdGVyZWRCeUFjdGl2ZSgpLGk9dC5maW5kKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlkPT09cGFyc2VJbnQoZSwxMCl9KTtyZXR1cm4gaX1yZXR1cm4hMX19LHtrZXk6XCJnZXRHcm91cHNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtyZXR1cm4gZS5ncm91cHN9fSx7a2V5OlwiZ2V0R3JvdXBzRmlsdGVyZWRCeUFjdGl2ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5nZXRHcm91cHMoKSx0PXRoaXMuZ2V0Q2hvaWNlcygpLGk9ZS5maWx0ZXIoZnVuY3Rpb24oZSl7dmFyIGk9ZS5hY3RpdmU9PT0hMCYmZS5kaXNhYmxlZD09PSExLG49dC5zb21lKGZ1bmN0aW9uKGUpe3JldHVybiBlLmFjdGl2ZT09PSEwJiZlLmRpc2FibGVkPT09ITF9KTtyZXR1cm4gaSYmbn0sW10pO3JldHVybiBpfX0se2tleTpcImdldEdyb3VwQnlJZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuZ2V0R3JvdXBzKCksaT10LmZpbmQoZnVuY3Rpb24odCl7cmV0dXJuIHQuaWQ9PT1lfSk7cmV0dXJuIGl9fV0pLGV9KCk7dC5kZWZhdWx0PWwsZS5leHBvcnRzPWx9LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBuKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX10Ll9fZXNNb2R1bGU9ITAsdC5jb21wb3NlPXQuYXBwbHlNaWRkbGV3YXJlPXQuYmluZEFjdGlvbkNyZWF0b3JzPXQuY29tYmluZVJlZHVjZXJzPXQuY3JlYXRlU3RvcmU9dm9pZCAwO3ZhciBzPWkoNikscj1uKHMpLG89aSgyMSksYT1uKG8pLGM9aSgyMyksbD1uKGMpLGg9aSgyNCksdT1uKGgpLGQ9aSgyNSksZj1uKGQpLHA9aSgyMik7bihwKTt0LmNyZWF0ZVN0b3JlPXIuZGVmYXVsdCx0LmNvbWJpbmVSZWR1Y2Vycz1hLmRlZmF1bHQsdC5iaW5kQWN0aW9uQ3JlYXRvcnM9bC5kZWZhdWx0LHQuYXBwbHlNaWRkbGV3YXJlPXUuZGVmYXVsdCx0LmNvbXBvc2U9Zi5kZWZhdWx0fSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gcyhlLHQsaSl7ZnVuY3Rpb24gbigpe2c9PT1tJiYoZz1tLnNsaWNlKCkpfWZ1bmN0aW9uIHIoKXtyZXR1cm4gdn1mdW5jdGlvbiBhKGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbi5cIik7dmFyIHQ9ITA7cmV0dXJuIG4oKSxnLnB1c2goZSksZnVuY3Rpb24oKXtpZih0KXt0PSExLG4oKTt2YXIgaT1nLmluZGV4T2YoZSk7Zy5zcGxpY2UoaSwxKX19fWZ1bmN0aW9uIGgoZSl7aWYoISgwLG8uZGVmYXVsdCkoZSkpdGhyb3cgbmV3IEVycm9yKFwiQWN0aW9ucyBtdXN0IGJlIHBsYWluIG9iamVjdHMuIFVzZSBjdXN0b20gbWlkZGxld2FyZSBmb3IgYXN5bmMgYWN0aW9ucy5cIik7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGUudHlwZSl0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbWF5IG5vdCBoYXZlIGFuIHVuZGVmaW5lZCBcInR5cGVcIiBwcm9wZXJ0eS4gSGF2ZSB5b3UgbWlzc3BlbGxlZCBhIGNvbnN0YW50PycpO2lmKHkpdGhyb3cgbmV3IEVycm9yKFwiUmVkdWNlcnMgbWF5IG5vdCBkaXNwYXRjaCBhY3Rpb25zLlwiKTt0cnl7eT0hMCx2PXAodixlKX1maW5hbGx5e3k9ITF9Zm9yKHZhciB0PW09ZyxpPTA7aTx0Lmxlbmd0aDtpKyspdFtpXSgpO3JldHVybiBlfWZ1bmN0aW9uIHUoZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSl0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCB0aGUgbmV4dFJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi5cIik7cD1lLGgoe3R5cGU6bC5JTklUfSl9ZnVuY3Rpb24gZCgpe3ZhciBlLHQ9YTtyZXR1cm4gZT17c3Vic2NyaWJlOmZ1bmN0aW9uKGUpe2Z1bmN0aW9uIGkoKXtlLm5leHQmJmUubmV4dChyKCkpfWlmKFwib2JqZWN0XCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCB0aGUgb2JzZXJ2ZXIgdG8gYmUgYW4gb2JqZWN0LlwiKTtpKCk7dmFyIG49dChpKTtyZXR1cm57dW5zdWJzY3JpYmU6bn19fSxlW2MuZGVmYXVsdF09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sZX12YXIgZjtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiZcInVuZGVmaW5lZFwiPT10eXBlb2YgaSYmKGk9dCx0PXZvaWQgMCksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGkpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGkpdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgdGhlIGVuaGFuY2VyIHRvIGJlIGEgZnVuY3Rpb24uXCIpO3JldHVybiBpKHMpKGUsdCl9aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSl0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCB0aGUgcmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLlwiKTt2YXIgcD1lLHY9dCxtPVtdLGc9bSx5PSExO3JldHVybiBoKHt0eXBlOmwuSU5JVH0pLGY9e2Rpc3BhdGNoOmgsc3Vic2NyaWJlOmEsZ2V0U3RhdGU6cixyZXBsYWNlUmVkdWNlcjp1fSxmW2MuZGVmYXVsdF09ZCxmfXQuX19lc01vZHVsZT0hMCx0LkFjdGlvblR5cGVzPXZvaWQgMCx0LmRlZmF1bHQ9czt2YXIgcj1pKDcpLG89bihyKSxhPWkoMTcpLGM9bihhKSxsPXQuQWN0aW9uVHlwZXM9e0lOSVQ6XCJAQHJlZHV4L0lOSVRcIn19LGZ1bmN0aW9uKGUsdCxpKXtmdW5jdGlvbiBuKGUpe2lmKCFvKGUpfHxzKGUpIT1hKXJldHVybiExO3ZhciB0PXIoZSk7aWYobnVsbD09PXQpcmV0dXJuITA7dmFyIGk9dS5jYWxsKHQsXCJjb25zdHJ1Y3RvclwiKSYmdC5jb25zdHJ1Y3RvcjtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBpJiZpIGluc3RhbmNlb2YgaSYmaC5jYWxsKGkpPT1kfXZhciBzPWkoOCkscj1pKDE0KSxvPWkoMTYpLGE9XCJbb2JqZWN0IE9iamVjdF1cIixjPUZ1bmN0aW9uLnByb3RvdHlwZSxsPU9iamVjdC5wcm90b3R5cGUsaD1jLnRvU3RyaW5nLHU9bC5oYXNPd25Qcm9wZXJ0eSxkPWguY2FsbChPYmplY3QpO2UuZXhwb3J0cz1ufSxmdW5jdGlvbihlLHQsaSl7ZnVuY3Rpb24gbihlKXtyZXR1cm4gbnVsbD09ZT92b2lkIDA9PT1lP2M6YTpsJiZsIGluIE9iamVjdChlKT9yKGUpOm8oZSl9dmFyIHM9aSg5KSxyPWkoMTIpLG89aSgxMyksYT1cIltvYmplY3QgTnVsbF1cIixjPVwiW29iamVjdCBVbmRlZmluZWRdXCIsbD1zP3MudG9TdHJpbmdUYWc6dm9pZCAwO2UuZXhwb3J0cz1ufSxmdW5jdGlvbihlLHQsaSl7dmFyIG49aSgxMCkscz1uLlN5bWJvbDtlLmV4cG9ydHM9c30sZnVuY3Rpb24oZSx0LGkpe3ZhciBuPWkoMTEpLHM9XCJvYmplY3RcIj09dHlwZW9mIHNlbGYmJnNlbGYmJnNlbGYuT2JqZWN0PT09T2JqZWN0JiZzZWxmLHI9bnx8c3x8RnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO2UuZXhwb3J0cz1yfSxmdW5jdGlvbihlLHQpeyhmdW5jdGlvbih0KXt2YXIgaT1cIm9iamVjdFwiPT10eXBlb2YgdCYmdCYmdC5PYmplY3Q9PT1PYmplY3QmJnQ7ZS5leHBvcnRzPWl9KS5jYWxsKHQsZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30oKSl9LGZ1bmN0aW9uKGUsdCxpKXtmdW5jdGlvbiBuKGUpe3ZhciB0PW8uY2FsbChlLGMpLGk9ZVtjXTt0cnl7ZVtjXT12b2lkIDA7dmFyIG49ITB9Y2F0Y2goZSl7fXZhciBzPWEuY2FsbChlKTtyZXR1cm4gbiYmKHQ/ZVtjXT1pOmRlbGV0ZSBlW2NdKSxzfXZhciBzPWkoOSkscj1PYmplY3QucHJvdG90eXBlLG89ci5oYXNPd25Qcm9wZXJ0eSxhPXIudG9TdHJpbmcsYz1zP3MudG9TdHJpbmdUYWc6dm9pZCAwO2UuZXhwb3J0cz1ufSxmdW5jdGlvbihlLHQpe2Z1bmN0aW9uIGkoZSl7cmV0dXJuIHMuY2FsbChlKX12YXIgbj1PYmplY3QucHJvdG90eXBlLHM9bi50b1N0cmluZztlLmV4cG9ydHM9aX0sZnVuY3Rpb24oZSx0LGkpe3ZhciBuPWkoMTUpLHM9bihPYmplY3QuZ2V0UHJvdG90eXBlT2YsT2JqZWN0KTtlLmV4cG9ydHM9c30sZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiBpKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGkpe3JldHVybiBlKHQoaSkpfX1lLmV4cG9ydHM9aX0sZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiBpKGUpe3JldHVybiBudWxsIT1lJiZcIm9iamVjdFwiPT10eXBlb2YgZX1lLmV4cG9ydHM9aX0sZnVuY3Rpb24oZSx0LGkpe2UuZXhwb3J0cz1pKDE4KX0sZnVuY3Rpb24oZSx0LGkpeyhmdW5jdGlvbihlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHMoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByLG89aSgyMCksYT1zKG8pO3I9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjpcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZT9lOm47dmFyIGM9KDAsYS5kZWZhdWx0KShyKTt0LmRlZmF1bHQ9Y30pLmNhbGwodCxmdW5jdGlvbigpe3JldHVybiB0aGlzfSgpLGkoMTkpKGUpKX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuIGUud2VicGFja1BvbHlmaWxsfHwoZS5kZXByZWNhdGU9ZnVuY3Rpb24oKXt9LGUucGF0aHM9W10sZS5jaGlsZHJlbj1bXSxlLndlYnBhY2tQb2x5ZmlsbD0xKSxlfX0sZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKGUpe3ZhciB0LGk9ZS5TeW1ib2w7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgaT9pLm9ic2VydmFibGU/dD1pLm9ic2VydmFibGU6KHQ9aShcIm9ic2VydmFibGVcIiksaS5vYnNlcnZhYmxlPXQpOnQ9XCJAQG9ic2VydmFibGVcIix0fU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD1pfSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gcyhlLHQpe3ZhciBpPXQmJnQudHlwZSxuPWkmJidcIicraS50b1N0cmluZygpKydcIid8fFwiYW4gYWN0aW9uXCI7cmV0dXJuXCJHaXZlbiBhY3Rpb24gXCIrbisnLCByZWR1Y2VyIFwiJytlKydcIiByZXR1cm5lZCB1bmRlZmluZWQuIFRvIGlnbm9yZSBhbiBhY3Rpb24sIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBwcmV2aW91cyBzdGF0ZS4nfWZ1bmN0aW9uIHIoZSl7T2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgaT1lW3RdLG49aSh2b2lkIDAse3R5cGU6YS5BY3Rpb25UeXBlcy5JTklUfSk7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIG4pdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VyIFwiJyt0KydcIiByZXR1cm5lZCB1bmRlZmluZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uLiBJZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZSByZWR1Y2VyIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgZXhwbGljaXRseSByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBub3QgYmUgdW5kZWZpbmVkLicpO3ZhciBzPVwiQEByZWR1eC9QUk9CRV9VTktOT1dOX0FDVElPTl9cIitNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNykuc3BsaXQoXCJcIikuam9pbihcIi5cIik7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGkodm9pZCAwLHt0eXBlOnN9KSl0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXIgXCInK3QrJ1wiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIHByb2JlZCB3aXRoIGEgcmFuZG9tIHR5cGUuICcrKFwiRG9uJ3QgdHJ5IHRvIGhhbmRsZSBcIithLkFjdGlvblR5cGVzLklOSVQrJyBvciBvdGhlciBhY3Rpb25zIGluIFwicmVkdXgvKlwiICcpK1wibmFtZXNwYWNlLiBUaGV5IGFyZSBjb25zaWRlcmVkIHByaXZhdGUuIEluc3RlYWQsIHlvdSBtdXN0IHJldHVybiB0aGUgY3VycmVudCBzdGF0ZSBmb3IgYW55IHVua25vd24gYWN0aW9ucywgdW5sZXNzIGl0IGlzIHVuZGVmaW5lZCwgaW4gd2hpY2ggY2FzZSB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUsIHJlZ2FyZGxlc3Mgb2YgdGhlIGFjdGlvbiB0eXBlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZC5cIil9KX1mdW5jdGlvbiBvKGUpe2Zvcih2YXIgdD1PYmplY3Qua2V5cyhlKSxpPXt9LG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dFtuXTtcImZ1bmN0aW9uXCI9PXR5cGVvZiBlW29dJiYoaVtvXT1lW29dKX12YXIgYSxjPU9iamVjdC5rZXlzKGkpO3RyeXtyKGkpfWNhdGNoKGUpe2E9ZX1yZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPD0wfHx2b2lkIDA9PT1hcmd1bWVudHNbMF0/e306YXJndW1lbnRzWzBdLHQ9YXJndW1lbnRzWzFdO2lmKGEpdGhyb3cgYTtmb3IodmFyIG49ITEscj17fSxvPTA7bzxjLmxlbmd0aDtvKyspe3ZhciBsPWNbb10saD1pW2xdLHU9ZVtsXSxkPWgodSx0KTtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgZCl7dmFyIGY9cyhsLHQpO3Rocm93IG5ldyBFcnJvcihmKX1yW2xdPWQsbj1ufHxkIT09dX1yZXR1cm4gbj9yOmV9fXQuX19lc01vZHVsZT0hMCx0LmRlZmF1bHQ9bzt2YXIgYT1pKDYpLGM9aSg3KSxsPShuKGMpLGkoMjIpKTtuKGwpfSxmdW5jdGlvbihlLHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGkoZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGNvbnNvbGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGNvbnNvbGUuZXJyb3ImJmNvbnNvbGUuZXJyb3IoZSk7dHJ5e3Rocm93IG5ldyBFcnJvcihlKX1jYXRjaChlKXt9fXQuX19lc01vZHVsZT0hMCx0LmRlZmF1bHQ9aX0sZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQoZS5hcHBseSh2b2lkIDAsYXJndW1lbnRzKSl9fWZ1bmN0aW9uIG4oZSx0KXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBlKXJldHVybiBpKGUsdCk7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGV8fG51bGw9PT1lKXRocm93IG5ldyBFcnJvcihcImJpbmRBY3Rpb25DcmVhdG9ycyBleHBlY3RlZCBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgaW5zdGVhZCByZWNlaXZlZCBcIisobnVsbD09PWU/XCJudWxsXCI6dHlwZW9mIGUpKycuIERpZCB5b3Ugd3JpdGUgXCJpbXBvcnQgQWN0aW9uQ3JlYXRvcnMgZnJvbVwiIGluc3RlYWQgb2YgXCJpbXBvcnQgKiBhcyBBY3Rpb25DcmVhdG9ycyBmcm9tXCI/Jyk7Zm9yKHZhciBuPU9iamVjdC5rZXlzKGUpLHM9e30scj0wO3I8bi5sZW5ndGg7cisrKXt2YXIgbz1uW3JdLGE9ZVtvXTtcImZ1bmN0aW9uXCI9PXR5cGVvZiBhJiYoc1tvXT1pKGEsdCkpfXJldHVybiBzfXQuX19lc01vZHVsZT0hMCx0LmRlZmF1bHQ9bn0sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIHMoKXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCx0PUFycmF5KGUpLGk9MDtpPGU7aSsrKXRbaV09YXJndW1lbnRzW2ldO3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24oaSxuLHMpe3ZhciBvPWUoaSxuLHMpLGM9by5kaXNwYXRjaCxsPVtdLGg9e2dldFN0YXRlOm8uZ2V0U3RhdGUsZGlzcGF0Y2g6ZnVuY3Rpb24oZSl7cmV0dXJuIGMoZSl9fTtyZXR1cm4gbD10Lm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZShoKX0pLGM9YS5kZWZhdWx0LmFwcGx5KHZvaWQgMCxsKShvLmRpc3BhdGNoKSxyKHt9LG8se2Rpc3BhdGNoOmN9KX19fXQuX19lc01vZHVsZT0hMDt2YXIgcj1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihlKXtmb3IodmFyIHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXt2YXIgaT1hcmd1bWVudHNbdF07Zm9yKHZhciBuIGluIGkpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGksbikmJihlW25dPWlbbl0pfXJldHVybiBlfTt0LmRlZmF1bHQ9czt2YXIgbz1pKDI1KSxhPW4obyl9LGZ1bmN0aW9uKGUsdCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaSgpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoLHQ9QXJyYXkoZSksaT0wO2k8ZTtpKyspdFtpXT1hcmd1bWVudHNbaV07aWYoMD09PXQubGVuZ3RoKXJldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gZX07aWYoMT09PXQubGVuZ3RoKXJldHVybiB0WzBdO3ZhciBuPXRbdC5sZW5ndGgtMV0scz10LnNsaWNlKDAsLTEpO3JldHVybiBmdW5jdGlvbigpe3JldHVybiBzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQoZSl9LG4uYXBwbHkodm9pZCAwLGFyZ3VtZW50cykpfX10Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PWl9LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBuKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1pKDUpLHI9aSgyNyksbz1uKHIpLGE9aSgyOCksYz1uKGEpLGw9aSgyOSksaD1uKGwpLHU9KDAscy5jb21iaW5lUmVkdWNlcnMpKHtpdGVtczpvLmRlZmF1bHQsZ3JvdXBzOmMuZGVmYXVsdCxjaG9pY2VzOmguZGVmYXVsdH0pLGQ9ZnVuY3Rpb24oZSx0KXt2YXIgaT1lO3JldHVyblwiQ0xFQVJfQUxMXCI9PT10LnR5cGUmJihpPXZvaWQgMCksdShpLHQpfTt0LmRlZmF1bHQ9ZH0sZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpe2Zvcih2YXIgdD0wLGk9QXJyYXkoZS5sZW5ndGgpO3Q8ZS5sZW5ndGg7dCsrKWlbdF09ZVt0XTtyZXR1cm4gaX1yZXR1cm4gQXJyYXkuZnJvbShlKX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbj1mdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpbXSx0PWFyZ3VtZW50c1sxXTtzd2l0Y2godC50eXBlKXtjYXNlXCJBRERfSVRFTVwiOnZhciBuPVtdLmNvbmNhdChpKGUpLFt7aWQ6dC5pZCxjaG9pY2VJZDp0LmNob2ljZUlkLGdyb3VwSWQ6dC5ncm91cElkLHZhbHVlOnQudmFsdWUsbGFiZWw6dC5sYWJlbCxhY3RpdmU6ITAsaGlnaGxpZ2h0ZWQ6ITEsY3VzdG9tUHJvcGVydGllczp0LmN1c3RvbVByb3BlcnRpZXMsa2V5Q29kZTpudWxsfV0pO3JldHVybiBuLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5oaWdobGlnaHRlZCYmKGUuaGlnaGxpZ2h0ZWQ9ITEpLGV9KTtjYXNlXCJSRU1PVkVfSVRFTVwiOnJldHVybiBlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5pZD09PXQuaWQmJihlLmFjdGl2ZT0hMSksZX0pO2Nhc2VcIkhJR0hMSUdIVF9JVEVNXCI6cmV0dXJuIGUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmlkPT09dC5pZCYmKGUuaGlnaGxpZ2h0ZWQ9dC5oaWdobGlnaHRlZCksZX0pO2RlZmF1bHQ6cmV0dXJuIGV9fTt0LmRlZmF1bHQ9bn0sZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpe2Zvcih2YXIgdD0wLGk9QXJyYXkoZS5sZW5ndGgpO3Q8ZS5sZW5ndGg7dCsrKWlbdF09ZVt0XTtyZXR1cm4gaX1yZXR1cm4gQXJyYXkuZnJvbShlKX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbj1mdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpbXSx0PWFyZ3VtZW50c1sxXTtzd2l0Y2godC50eXBlKXtjYXNlXCJBRERfR1JPVVBcIjpyZXR1cm5bXS5jb25jYXQoaShlKSxbe2lkOnQuaWQsdmFsdWU6dC52YWx1ZSxhY3RpdmU6dC5hY3RpdmUsZGlzYWJsZWQ6dC5kaXNhYmxlZH1dKTtjYXNlXCJDTEVBUl9DSE9JQ0VTXCI6cmV0dXJuIGUuZ3JvdXBzPVtdO2RlZmF1bHQ6cmV0dXJuIGV9fTt0LmRlZmF1bHQ9bn0sZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpe2Zvcih2YXIgdD0wLGk9QXJyYXkoZS5sZW5ndGgpO3Q8ZS5sZW5ndGg7dCsrKWlbdF09ZVt0XTtyZXR1cm4gaX1yZXR1cm4gQXJyYXkuZnJvbShlKX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbj1mdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpbXSx0PWFyZ3VtZW50c1sxXTtzd2l0Y2godC50eXBlKXtjYXNlXCJBRERfQ0hPSUNFXCI6cmV0dXJuW10uY29uY2F0KGkoZSksW3tpZDp0LmlkLGVsZW1lbnRJZDp0LmVsZW1lbnRJZCxncm91cElkOnQuZ3JvdXBJZCx2YWx1ZTp0LnZhbHVlLGxhYmVsOnQubGFiZWx8fHQudmFsdWUsZGlzYWJsZWQ6dC5kaXNhYmxlZHx8ITEsc2VsZWN0ZWQ6ITEsYWN0aXZlOiEwLHNjb3JlOjk5OTksY3VzdG9tUHJvcGVydGllczp0LmN1c3RvbVByb3BlcnRpZXMsa2V5Q29kZTpudWxsfV0pO2Nhc2VcIkFERF9JVEVNXCI6dmFyIG49ZTtyZXR1cm4gdC5hY3RpdmF0ZU9wdGlvbnMmJihuPWUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmFjdGl2ZT10LmFjdGl2ZSxlfSkpLHQuY2hvaWNlSWQ+LTEmJihuPWUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmlkPT09cGFyc2VJbnQodC5jaG9pY2VJZCwxMCkmJihlLnNlbGVjdGVkPSEwKSxlfSkpLG47Y2FzZVwiUkVNT1ZFX0lURU1cIjpyZXR1cm4gdC5jaG9pY2VJZD4tMT9lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5pZD09PXBhcnNlSW50KHQuY2hvaWNlSWQsMTApJiYoZS5zZWxlY3RlZD0hMSksZX0pOmU7Y2FzZVwiRklMVEVSX0NIT0lDRVNcIjp2YXIgcz10LnJlc3VsdHMscj1lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5hY3RpdmU9cy5zb21lKGZ1bmN0aW9uKHQpe3JldHVybiB0Lml0ZW0uaWQ9PT1lLmlkJiYoZS5zY29yZT10LnNjb3JlLCEwKX0pLGV9KTtyZXR1cm4gcjtjYXNlXCJBQ1RJVkFURV9DSE9JQ0VTXCI6cmV0dXJuIGUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmFjdGl2ZT10LmFjdGl2ZSxlfSk7Y2FzZVwiQ0xFQVJfQ0hPSUNFU1wiOnJldHVybiBlLmNob2ljZXM9W107ZGVmYXVsdDpyZXR1cm4gZX19O3QuZGVmYXVsdD1ufSxmdW5jdGlvbihlLHQpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3QuYWRkSXRlbT1mdW5jdGlvbihlLHQsaSxuLHMscixvKXtyZXR1cm57dHlwZTpcIkFERF9JVEVNXCIsdmFsdWU6ZSxsYWJlbDp0LGlkOmksY2hvaWNlSWQ6bixncm91cElkOnMsY3VzdG9tUHJvcGVydGllczpyLGtleUNvZGU6b319LHQucmVtb3ZlSXRlbT1mdW5jdGlvbihlLHQpe3JldHVybnt0eXBlOlwiUkVNT1ZFX0lURU1cIixpZDplLGNob2ljZUlkOnR9fSx0LmhpZ2hsaWdodEl0ZW09ZnVuY3Rpb24oZSx0KXtyZXR1cm57dHlwZTpcIkhJR0hMSUdIVF9JVEVNXCIsaWQ6ZSxoaWdobGlnaHRlZDp0fX0sdC5hZGRDaG9pY2U9ZnVuY3Rpb24oZSx0LGksbixzLHIsbyxhKXtyZXR1cm57dHlwZTpcIkFERF9DSE9JQ0VcIix2YWx1ZTplLGxhYmVsOnQsaWQ6aSxncm91cElkOm4sZGlzYWJsZWQ6cyxlbGVtZW50SWQ6cixjdXN0b21Qcm9wZXJ0aWVzOm8sa2V5Q29kZTphfX0sdC5maWx0ZXJDaG9pY2VzPWZ1bmN0aW9uKGUpe3JldHVybnt0eXBlOlwiRklMVEVSX0NIT0lDRVNcIixyZXN1bHRzOmV9fSx0LmFjdGl2YXRlQ2hvaWNlcz1mdW5jdGlvbigpe3ZhciBlPSEoYXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0pfHxhcmd1bWVudHNbMF07cmV0dXJue3R5cGU6XCJBQ1RJVkFURV9DSE9JQ0VTXCIsYWN0aXZlOmV9fSx0LmNsZWFyQ2hvaWNlcz1mdW5jdGlvbigpe3JldHVybnt0eXBlOlwiQ0xFQVJfQ0hPSUNFU1wifX0sdC5hZGRHcm91cD1mdW5jdGlvbihlLHQsaSxuKXtyZXR1cm57dHlwZTpcIkFERF9HUk9VUFwiLHZhbHVlOmUsaWQ6dCxhY3RpdmU6aSxkaXNhYmxlZDpufX0sdC5jbGVhckFsbD1mdW5jdGlvbigpe3JldHVybnt0eXBlOlwiQ0xFQVJfQUxMXCJ9fX0sZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfSxuPSh0LmNhcGl0YWxpc2U9ZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVwbGFjZSgvXFx3XFxTKi9nLGZ1bmN0aW9uKGUpe3JldHVybiBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Uuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCl9KX0sdC5nZW5lcmF0ZUNoYXJzPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1cIlwiLGk9MDtpPGU7aSsrKXt2YXIgbj1hKDAsMzYpO3QrPW4udG9TdHJpbmcoMzYpfXJldHVybiB0fSkscz0odC5nZW5lcmF0ZUlkPWZ1bmN0aW9uKGUsdCl7dmFyIGk9ZS5pZHx8ZS5uYW1lJiZlLm5hbWUrXCItXCIrbigyKXx8big0KTtyZXR1cm4gaT1pLnJlcGxhY2UoLyg6fFxcLnxcXFt8XFxdfCwpL2csXCJcIiksaT10K2l9LHQuZ2V0VHlwZT1mdW5jdGlvbihlKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsLTEpfSkscj10LmlzVHlwZT1mdW5jdGlvbihlLHQpe3ZhciBpPXModCk7cmV0dXJuIHZvaWQgMCE9PXQmJm51bGwhPT10JiZpPT09ZX0sbz0odC5pc05vZGU9ZnVuY3Rpb24oZSl7cmV0dXJuXCJvYmplY3RcIj09PShcInVuZGVmaW5lZFwiPT10eXBlb2YgTm9kZT9cInVuZGVmaW5lZFwiOmkoTm9kZSkpP2UgaW5zdGFuY2VvZiBOb2RlOmUmJlwib2JqZWN0XCI9PT0oXCJ1bmRlZmluZWRcIj09dHlwZW9mIGU/XCJ1bmRlZmluZWRcIjppKGUpKSYmXCJudW1iZXJcIj09dHlwZW9mIGUubm9kZVR5cGUmJlwic3RyaW5nXCI9PXR5cGVvZiBlLm5vZGVOYW1lfSx0LmlzRWxlbWVudD1mdW5jdGlvbihlKXtyZXR1cm5cIm9iamVjdFwiPT09KFwidW5kZWZpbmVkXCI9PXR5cGVvZiBIVE1MRWxlbWVudD9cInVuZGVmaW5lZFwiOmkoSFRNTEVsZW1lbnQpKT9lIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ6ZSYmXCJvYmplY3RcIj09PShcInVuZGVmaW5lZFwiPT10eXBlb2YgZT9cInVuZGVmaW5lZFwiOmkoZSkpJiZudWxsIT09ZSYmMT09PWUubm9kZVR5cGUmJlwic3RyaW5nXCI9PXR5cGVvZiBlLm5vZGVOYW1lfSx0LmV4dGVuZD1mdW5jdGlvbiBlKCl7Zm9yKHZhciB0PXt9LGk9YXJndW1lbnRzLmxlbmd0aCxuPWZ1bmN0aW9uKGkpe2Zvcih2YXIgbiBpbiBpKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLG4pJiYocihcIk9iamVjdFwiLGlbbl0pP3Rbbl09ZSghMCx0W25dLGlbbl0pOnRbbl09aVtuXSl9LHM9MDtzPGk7cysrKXt2YXIgbz1hcmd1bWVudHNbc107cihcIk9iamVjdFwiLG8pJiZuKG8pfXJldHVybiB0fSx0LndoaWNoVHJhbnNpdGlvbkV2ZW50PWZ1bmN0aW9uKCl7dmFyIGUsdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmFrZWVsZW1lbnRcIiksaT17dHJhbnNpdGlvbjpcInRyYW5zaXRpb25lbmRcIixPVHJhbnNpdGlvbjpcIm9UcmFuc2l0aW9uRW5kXCIsTW96VHJhbnNpdGlvbjpcInRyYW5zaXRpb25lbmRcIixXZWJraXRUcmFuc2l0aW9uOlwid2Via2l0VHJhbnNpdGlvbkVuZFwifTtmb3IoZSBpbiBpKWlmKHZvaWQgMCE9PXQuc3R5bGVbZV0pcmV0dXJuIGlbZV19LHQud2hpY2hBbmltYXRpb25FdmVudD1mdW5jdGlvbigpe3ZhciBlLHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZha2VlbGVtZW50XCIpLGk9e2FuaW1hdGlvbjpcImFuaW1hdGlvbmVuZFwiLE9BbmltYXRpb246XCJvQW5pbWF0aW9uRW5kXCIsTW96QW5pbWF0aW9uOlwiYW5pbWF0aW9uZW5kXCIsV2Via2l0QW5pbWF0aW9uOlwid2Via2l0QW5pbWF0aW9uRW5kXCJ9O2ZvcihlIGluIGkpaWYodm9pZCAwIT09dC5zdHlsZVtlXSlyZXR1cm4gaVtlXX0pLGE9KHQuZ2V0UGFyZW50c1VudGlsPWZ1bmN0aW9uKGUsdCxpKXtmb3IodmFyIG49W107ZSYmZSE9PWRvY3VtZW50O2U9ZS5wYXJlbnROb2RlKXtpZih0KXt2YXIgcz10LmNoYXJBdCgwKTtpZihcIi5cIj09PXMmJmUuY2xhc3NMaXN0LmNvbnRhaW5zKHQuc3Vic3RyKDEpKSlicmVhaztpZihcIiNcIj09PXMmJmUuaWQ9PT10LnN1YnN0cigxKSlicmVhaztpZihcIltcIj09PXMmJmUuaGFzQXR0cmlidXRlKHQuc3Vic3RyKDEsdC5sZW5ndGgtMSkpKWJyZWFrO2lmKGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpPT09dClicmVha31pZihpKXt2YXIgcj1pLmNoYXJBdCgwKTtcIi5cIj09PXImJmUuY2xhc3NMaXN0LmNvbnRhaW5zKGkuc3Vic3RyKDEpKSYmbi5wdXNoKGUpLFwiI1wiPT09ciYmZS5pZD09PWkuc3Vic3RyKDEpJiZuLnB1c2goZSksXCJbXCI9PT1yJiZlLmhhc0F0dHJpYnV0ZShpLnN1YnN0cigxLGkubGVuZ3RoLTEpKSYmbi5wdXNoKGUpLGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpPT09aSYmbi5wdXNoKGUpfWVsc2Ugbi5wdXNoKGUpfXJldHVybiAwPT09bi5sZW5ndGg/bnVsbDpufSx0LndyYXA9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdD10fHxkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGUubmV4dFNpYmxpbmc/ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LGUubmV4dFNpYmxpbmcpOmUucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0KSx0LmFwcGVuZENoaWxkKGUpfSx0LmdldFNpYmxpbmdzPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bXSxpPWUucGFyZW50Tm9kZS5maXJzdENoaWxkO2k7aT1pLm5leHRTaWJsaW5nKTE9PT1pLm5vZGVUeXBlJiZpIT09ZSYmdC5wdXNoKGkpO1xucmV0dXJuIHR9LHQuZmluZEFuY2VzdG9yPWZ1bmN0aW9uKGUsdCl7Zm9yKDsoZT1lLnBhcmVudEVsZW1lbnQpJiYhZS5jbGFzc0xpc3QuY29udGFpbnModCk7KTtyZXR1cm4gZX0sdC5maW5kQW5jZXN0b3JCeUF0dHJOYW1lPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBpPWU7aTspe2lmKGkuaGFzQXR0cmlidXRlKHQpKXJldHVybiBpO2k9aS5wYXJlbnRFbGVtZW50fXJldHVybiBudWxsfSx0LmRlYm91bmNlPWZ1bmN0aW9uKGUsdCxpKXt2YXIgbjtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgcz10aGlzLHI9YXJndW1lbnRzLG89ZnVuY3Rpb24oKXtuPW51bGwsaXx8ZS5hcHBseShzLHIpfSxhPWkmJiFuO2NsZWFyVGltZW91dChuKSxuPXNldFRpbWVvdXQobyx0KSxhJiZlLmFwcGx5KHMscil9fSx0LmdldEVsZW1EaXN0YW5jZT1mdW5jdGlvbihlKXt2YXIgdD0wO2lmKGUub2Zmc2V0UGFyZW50KWRvIHQrPWUub2Zmc2V0VG9wLGU9ZS5vZmZzZXRQYXJlbnQ7d2hpbGUoZSk7cmV0dXJuIHQ+PTA/dDowfSx0LmdldEVsZW1lbnRPZmZzZXQ9ZnVuY3Rpb24oZSx0KXt2YXIgaT10O3JldHVybiBpPjEmJihpPTEpLGk+MCYmKGk9MCksTWF0aC5tYXgoZS5vZmZzZXRIZWlnaHQqaSl9LHQuZ2V0QWRqYWNlbnRFbD1mdW5jdGlvbihlLHQpe3ZhciBpPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXToxO2lmKGUmJnQpe3ZhciBuPWUucGFyZW50Tm9kZS5wYXJlbnROb2RlLHM9QXJyYXkuZnJvbShuLnF1ZXJ5U2VsZWN0b3JBbGwodCkpLHI9cy5pbmRleE9mKGUpLG89aT4wPzE6LTE7cmV0dXJuIHNbcitvXX19LHQuZ2V0U2Nyb2xsUG9zaXRpb249ZnVuY3Rpb24oZSl7cmV0dXJuXCJib3R0b21cIj09PWU/TWF0aC5tYXgoKHdpbmRvdy5zY3JvbGxZfHx3aW5kb3cucGFnZVlPZmZzZXQpKyh3aW5kb3cuaW5uZXJIZWlnaHR8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpKTp3aW5kb3cuc2Nyb2xsWXx8d2luZG93LnBhZ2VZT2Zmc2V0fSx0LmlzSW5WaWV3PWZ1bmN0aW9uKGUsdCxpKXtyZXR1cm4gdGhpcy5nZXRTY3JvbGxQb3NpdGlvbih0KT50aGlzLmdldEVsZW1EaXN0YW5jZShlKSt0aGlzLmdldEVsZW1lbnRPZmZzZXQoZSxpKX0sdC5pc1Njcm9sbGVkSW50b1ZpZXc9ZnVuY3Rpb24oZSx0KXt2YXIgaT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06MTtpZihlKXt2YXIgbj12b2lkIDA7cmV0dXJuIG49aT4wP3Quc2Nyb2xsVG9wK3Qub2Zmc2V0SGVpZ2h0Pj1lLm9mZnNldFRvcCtlLm9mZnNldEhlaWdodDplLm9mZnNldFRvcD49dC5zY3JvbGxUb3B9fSx0LnN0cmlwSFRNTD1mdW5jdGlvbihlKXt2YXIgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpO3JldHVybiB0LmlubmVySFRNTD1lLHQudGV4dENvbnRlbnR8fHQuaW5uZXJUZXh0fHxcIlwifSx0LmFkZEFuaW1hdGlvbj1mdW5jdGlvbihlLHQpe3ZhciBpPW8oKSxuPWZ1bmN0aW9uIG4oKXtlLmNsYXNzTGlzdC5yZW1vdmUodCksZS5yZW1vdmVFdmVudExpc3RlbmVyKGksbiwhMSl9O2UuY2xhc3NMaXN0LmFkZCh0KSxlLmFkZEV2ZW50TGlzdGVuZXIoaSxuLCExKX0sdC5nZXRSYW5kb21OdW1iZXI9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKih0LWUpK2UpfSksYz10LnN0clRvRWw9ZnVuY3Rpb24oKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3JldHVybiBmdW5jdGlvbih0KXt2YXIgaT10LnRyaW0oKSxuPXZvaWQgMDtmb3IoZS5pbm5lckhUTUw9aSxuPWUuY2hpbGRyZW5bMF07ZS5maXJzdENoaWxkOyllLnJlbW92ZUNoaWxkKGUuZmlyc3RDaGlsZCk7cmV0dXJuIG59fSgpO3QuZ2V0V2lkdGhPZklucHV0PWZ1bmN0aW9uKGUpe3ZhciB0PWUudmFsdWV8fGUucGxhY2Vob2xkZXIsaT1lLm9mZnNldFdpZHRoO2lmKHQpe3ZhciBuPWMoXCI8c3Bhbj5cIit0K1wiPC9zcGFuPlwiKTtuLnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIixuLnN0eWxlLnBhZGRpbmc9XCIwXCIsbi5zdHlsZS50b3A9XCItOTk5OXB4XCIsbi5zdHlsZS5sZWZ0PVwiLTk5OTlweFwiLG4uc3R5bGUud2lkdGg9XCJhdXRvXCIsbi5zdHlsZS53aGl0ZVNwYWNlPVwicHJlXCIsZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChuKSx0JiZuLm9mZnNldFdpZHRoIT09ZS5vZmZzZXRXaWR0aCYmKGk9bi5vZmZzZXRXaWR0aCs0KSxkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG4pfXJldHVybiBpK1wicHhcIn0sdC5zb3J0QnlBbHBoYT1mdW5jdGlvbihlLHQpe3ZhciBpPShlLmxhYmVsfHxlLnZhbHVlKS50b0xvd2VyQ2FzZSgpLG49KHQubGFiZWx8fHQudmFsdWUpLnRvTG93ZXJDYXNlKCk7cmV0dXJuIGk8bj8tMTppPm4/MTowfSx0LnNvcnRCeVNjb3JlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuc2NvcmUtdC5zY29yZX0sdC50cmlnZ2VyRXZlbnQ9ZnVuY3Rpb24oZSx0KXt2YXIgaT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06bnVsbCxuPW5ldyBDdXN0b21FdmVudCh0LHtkZXRhaWw6aSxidWJibGVzOiEwLGNhbmNlbGFibGU6ITB9KTtyZXR1cm4gZS5kaXNwYXRjaEV2ZW50KG4pfX0sZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjshZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7dD10fHx7YnViYmxlczohMSxjYW5jZWxhYmxlOiExLGRldGFpbDp2b2lkIDB9O3ZhciBpPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7cmV0dXJuIGkuaW5pdEN1c3RvbUV2ZW50KGUsdC5idWJibGVzLHQuY2FuY2VsYWJsZSx0LmRldGFpbCksaX1BcnJheS5mcm9tfHwoQXJyYXkuZnJvbT1mdW5jdGlvbigpe3ZhciBlPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsdD1mdW5jdGlvbih0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0fHxcIltvYmplY3QgRnVuY3Rpb25dXCI9PT1lLmNhbGwodCl9LGk9ZnVuY3Rpb24oZSl7dmFyIHQ9TnVtYmVyKGUpO3JldHVybiBpc05hTih0KT8wOjAhPT10JiZpc0Zpbml0ZSh0KT8odD4wPzE6LTEpKk1hdGguZmxvb3IoTWF0aC5hYnModCkpOnR9LG49TWF0aC5wb3coMiw1MyktMSxzPWZ1bmN0aW9uKGUpe3ZhciB0PWkoZSk7cmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHQsMCksbil9O3JldHVybiBmdW5jdGlvbihlKXt2YXIgaT10aGlzLG49T2JqZWN0KGUpO2lmKG51bGw9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFycmF5LmZyb20gcmVxdWlyZXMgYW4gYXJyYXktbGlrZSBvYmplY3QgLSBub3QgbnVsbCBvciB1bmRlZmluZWRcIik7dmFyIHIsbz1hcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMDtpZihcInVuZGVmaW5lZFwiIT10eXBlb2Ygbyl7aWYoIXQobykpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFycmF5LmZyb206IHdoZW4gcHJvdmlkZWQsIHRoZSBzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO2FyZ3VtZW50cy5sZW5ndGg+MiYmKHI9YXJndW1lbnRzWzJdKX1mb3IodmFyIGEsYz1zKG4ubGVuZ3RoKSxsPXQoaSk/T2JqZWN0KG5ldyBpKGMpKTpuZXcgQXJyYXkoYyksaD0wO2g8YzspYT1uW2hdLG8/bFtoXT1cInVuZGVmaW5lZFwiPT10eXBlb2Ygcj9vKGEsaCk6by5jYWxsKHIsYSxoKTpsW2hdPWEsaCs9MTtyZXR1cm4gbC5sZW5ndGg9YyxsfX0oKSksQXJyYXkucHJvdG90eXBlLmZpbmR8fChBcnJheS5wcm90b3R5cGUuZmluZD1mdW5jdGlvbihlKXtpZihudWxsPT10aGlzKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcnJheS5wcm90b3R5cGUuZmluZCBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWRcIik7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwicHJlZGljYXRlIG11c3QgYmUgYSBmdW5jdGlvblwiKTtmb3IodmFyIHQsaT1PYmplY3QodGhpcyksbj1pLmxlbmd0aD4+PjAscz1hcmd1bWVudHNbMV0scj0wO3I8bjtyKyspaWYodD1pW3JdLGUuY2FsbChzLHQscixpKSlyZXR1cm4gdH0pLGUucHJvdG90eXBlPXdpbmRvdy5FdmVudC5wcm90b3R5cGUsd2luZG93LkN1c3RvbUV2ZW50PWV9KCl9XSl9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNob2ljZXMubWluLmpzLm1hcCIsIi8qIVxyXG4gKiBFdmVudEVtaXR0ZXIyXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9oaWoxbngvRXZlbnRFbWl0dGVyMlxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgaGlqMW54XHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cclxuICovXHJcbjshZnVuY3Rpb24odW5kZWZpbmVkKSB7XHJcblxyXG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSA/IEFycmF5LmlzQXJyYXkgOiBmdW5jdGlvbiBfaXNBcnJheShvYmopIHtcclxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xyXG4gIH07XHJcbiAgdmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcclxuXHJcbiAgZnVuY3Rpb24gaW5pdCgpIHtcclxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xyXG4gICAgaWYgKHRoaXMuX2NvbmYpIHtcclxuICAgICAgY29uZmlndXJlLmNhbGwodGhpcywgdGhpcy5fY29uZik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjb25maWd1cmUoY29uZikge1xyXG4gICAgaWYgKGNvbmYpIHtcclxuICAgICAgdGhpcy5fY29uZiA9IGNvbmY7XHJcblxyXG4gICAgICBjb25mLmRlbGltaXRlciAmJiAodGhpcy5kZWxpbWl0ZXIgPSBjb25mLmRlbGltaXRlcik7XHJcbiAgICAgIHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnMgPSBjb25mLm1heExpc3RlbmVycyAhPT0gdW5kZWZpbmVkID8gY29uZi5tYXhMaXN0ZW5lcnMgOiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xyXG4gICAgICBjb25mLndpbGRjYXJkICYmICh0aGlzLndpbGRjYXJkID0gY29uZi53aWxkY2FyZCk7XHJcbiAgICAgIGNvbmYubmV3TGlzdGVuZXIgJiYgKHRoaXMubmV3TGlzdGVuZXIgPSBjb25mLm5ld0xpc3RlbmVyKTtcclxuICAgICAgY29uZi52ZXJib3NlTWVtb3J5TGVhayAmJiAodGhpcy52ZXJib3NlTWVtb3J5TGVhayA9IGNvbmYudmVyYm9zZU1lbW9yeUxlYWspO1xyXG5cclxuICAgICAgaWYgKHRoaXMud2lsZGNhcmQpIHtcclxuICAgICAgICB0aGlzLmxpc3RlbmVyVHJlZSA9IHt9O1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzID0gZGVmYXVsdE1heExpc3RlbmVycztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGxvZ1Bvc3NpYmxlTWVtb3J5TGVhayhjb3VudCwgZXZlbnROYW1lKSB7XHJcbiAgICB2YXIgZXJyb3JNc2cgPSAnKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXHJcbiAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXHJcbiAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0Lic7XHJcblxyXG4gICAgaWYodGhpcy52ZXJib3NlTWVtb3J5TGVhayl7XHJcbiAgICAgIGVycm9yTXNnICs9ICcgRXZlbnQgbmFtZTogJXMuJztcclxuICAgICAgY29uc29sZS5lcnJvcihlcnJvck1zZywgY291bnQsIGV2ZW50TmFtZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yTXNnLCBjb3VudCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvbnNvbGUudHJhY2Upe1xyXG4gICAgICBjb25zb2xlLnRyYWNlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoY29uZikge1xyXG4gICAgdGhpcy5fZXZlbnRzID0ge307XHJcbiAgICB0aGlzLm5ld0xpc3RlbmVyID0gZmFsc2U7XHJcbiAgICB0aGlzLnZlcmJvc2VNZW1vcnlMZWFrID0gZmFsc2U7XHJcbiAgICBjb25maWd1cmUuY2FsbCh0aGlzLCBjb25mKTtcclxuICB9XHJcbiAgRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlcjIgPSBFdmVudEVtaXR0ZXI7IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciBleHBvcnRpbmcgRXZlbnRFbWl0dGVyIHByb3BlcnR5XHJcblxyXG4gIC8vXHJcbiAgLy8gQXR0ZW50aW9uLCBmdW5jdGlvbiByZXR1cm4gdHlwZSBub3cgaXMgYXJyYXksIGFsd2F5cyAhXHJcbiAgLy8gSXQgaGFzIHplcm8gZWxlbWVudHMgaWYgbm8gYW55IG1hdGNoZXMgZm91bmQgYW5kIG9uZSBvciBtb3JlXHJcbiAgLy8gZWxlbWVudHMgKGxlYWZzKSBpZiB0aGVyZSBhcmUgbWF0Y2hlc1xyXG4gIC8vXHJcbiAgZnVuY3Rpb24gc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlLCBpKSB7XHJcbiAgICBpZiAoIXRyZWUpIHtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgdmFyIGxpc3RlbmVycz1bXSwgbGVhZiwgbGVuLCBicmFuY2gsIHhUcmVlLCB4eFRyZWUsIGlzb2xhdGVkQnJhbmNoLCBlbmRSZWFjaGVkLFxyXG4gICAgICAgIHR5cGVMZW5ndGggPSB0eXBlLmxlbmd0aCwgY3VycmVudFR5cGUgPSB0eXBlW2ldLCBuZXh0VHlwZSA9IHR5cGVbaSsxXTtcclxuICAgIGlmIChpID09PSB0eXBlTGVuZ3RoICYmIHRyZWUuX2xpc3RlbmVycykge1xyXG4gICAgICAvL1xyXG4gICAgICAvLyBJZiBhdCB0aGUgZW5kIG9mIHRoZSBldmVudChzKSBsaXN0IGFuZCB0aGUgdHJlZSBoYXMgbGlzdGVuZXJzXHJcbiAgICAgIC8vIGludm9rZSB0aG9zZSBsaXN0ZW5lcnMuXHJcbiAgICAgIC8vXHJcbiAgICAgIGlmICh0eXBlb2YgdHJlZS5fbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgaGFuZGxlcnMgJiYgaGFuZGxlcnMucHVzaCh0cmVlLl9saXN0ZW5lcnMpO1xyXG4gICAgICAgIHJldHVybiBbdHJlZV07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yIChsZWFmID0gMCwgbGVuID0gdHJlZS5fbGlzdGVuZXJzLmxlbmd0aDsgbGVhZiA8IGxlbjsgbGVhZisrKSB7XHJcbiAgICAgICAgICBoYW5kbGVycyAmJiBoYW5kbGVycy5wdXNoKHRyZWUuX2xpc3RlbmVyc1tsZWFmXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbdHJlZV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoKGN1cnJlbnRUeXBlID09PSAnKicgfHwgY3VycmVudFR5cGUgPT09ICcqKicpIHx8IHRyZWVbY3VycmVudFR5cGVdKSB7XHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIElmIHRoZSBldmVudCBlbWl0dGVkIGlzICcqJyBhdCB0aGlzIHBhcnRcclxuICAgICAgLy8gb3IgdGhlcmUgaXMgYSBjb25jcmV0ZSBtYXRjaCBhdCB0aGlzIHBhdGNoXHJcbiAgICAgIC8vXHJcbiAgICAgIGlmIChjdXJyZW50VHlwZSA9PT0gJyonKSB7XHJcbiAgICAgICAgZm9yIChicmFuY2ggaW4gdHJlZSkge1xyXG4gICAgICAgICAgaWYgKGJyYW5jaCAhPT0gJ19saXN0ZW5lcnMnICYmIHRyZWUuaGFzT3duUHJvcGVydHkoYnJhbmNoKSkge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuY29uY2F0KHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVticmFuY2hdLCBpKzEpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVycztcclxuICAgICAgfSBlbHNlIGlmKGN1cnJlbnRUeXBlID09PSAnKionKSB7XHJcbiAgICAgICAgZW5kUmVhY2hlZCA9IChpKzEgPT09IHR5cGVMZW5ndGggfHwgKGkrMiA9PT0gdHlwZUxlbmd0aCAmJiBuZXh0VHlwZSA9PT0gJyonKSk7XHJcbiAgICAgICAgaWYoZW5kUmVhY2hlZCAmJiB0cmVlLl9saXN0ZW5lcnMpIHtcclxuICAgICAgICAgIC8vIFRoZSBuZXh0IGVsZW1lbnQgaGFzIGEgX2xpc3RlbmVycywgYWRkIGl0IHRvIHRoZSBoYW5kbGVycy5cclxuICAgICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5jb25jYXQoc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlLCB0eXBlTGVuZ3RoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGJyYW5jaCBpbiB0cmVlKSB7XHJcbiAgICAgICAgICBpZiAoYnJhbmNoICE9PSAnX2xpc3RlbmVycycgJiYgdHJlZS5oYXNPd25Qcm9wZXJ0eShicmFuY2gpKSB7XHJcbiAgICAgICAgICAgIGlmKGJyYW5jaCA9PT0gJyonIHx8IGJyYW5jaCA9PT0gJyoqJykge1xyXG4gICAgICAgICAgICAgIGlmKHRyZWVbYnJhbmNoXS5fbGlzdGVuZXJzICYmICFlbmRSZWFjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuY29uY2F0KHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVticmFuY2hdLCB0eXBlTGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5jb25jYXQoc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlW2JyYW5jaF0sIGkpKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmKGJyYW5jaCA9PT0gbmV4dFR5cGUpIHtcclxuICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuY29uY2F0KHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVticmFuY2hdLCBpKzIpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyBObyBtYXRjaCBvbiB0aGlzIG9uZSwgc2hpZnQgaW50byB0aGUgdHJlZSBidXQgbm90IGluIHRoZSB0eXBlIGFycmF5LlxyXG4gICAgICAgICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5jb25jYXQoc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlW2JyYW5jaF0sIGkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGlzdGVuZXJzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuY29uY2F0KHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVtjdXJyZW50VHlwZV0sIGkrMSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHhUcmVlID0gdHJlZVsnKiddO1xyXG4gICAgaWYgKHhUcmVlKSB7XHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIElmIHRoZSBsaXN0ZW5lciB0cmVlIHdpbGwgYWxsb3cgYW55IG1hdGNoIGZvciB0aGlzIHBhcnQsXHJcbiAgICAgIC8vIHRoZW4gcmVjdXJzaXZlbHkgZXhwbG9yZSBhbGwgYnJhbmNoZXMgb2YgdGhlIHRyZWVcclxuICAgICAgLy9cclxuICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4VHJlZSwgaSsxKTtcclxuICAgIH1cclxuXHJcbiAgICB4eFRyZWUgPSB0cmVlWycqKiddO1xyXG4gICAgaWYoeHhUcmVlKSB7XHJcbiAgICAgIGlmKGkgPCB0eXBlTGVuZ3RoKSB7XHJcbiAgICAgICAgaWYoeHhUcmVlLl9saXN0ZW5lcnMpIHtcclxuICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBsaXN0ZW5lciBvbiBhICcqKicsIGl0IHdpbGwgY2F0Y2ggYWxsLCBzbyBhZGQgaXRzIGhhbmRsZXIuXHJcbiAgICAgICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHh4VHJlZSwgdHlwZUxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBCdWlsZCBhcnJheXMgb2YgbWF0Y2hpbmcgbmV4dCBicmFuY2hlcyBhbmQgb3RoZXJzLlxyXG4gICAgICAgIGZvcihicmFuY2ggaW4geHhUcmVlKSB7XHJcbiAgICAgICAgICBpZihicmFuY2ggIT09ICdfbGlzdGVuZXJzJyAmJiB4eFRyZWUuaGFzT3duUHJvcGVydHkoYnJhbmNoKSkge1xyXG4gICAgICAgICAgICBpZihicmFuY2ggPT09IG5leHRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgLy8gV2Uga25vdyB0aGUgbmV4dCBlbGVtZW50IHdpbGwgbWF0Y2gsIHNvIGp1bXAgdHdpY2UuXHJcbiAgICAgICAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4eFRyZWVbYnJhbmNoXSwgaSsyKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmKGJyYW5jaCA9PT0gY3VycmVudFR5cGUpIHtcclxuICAgICAgICAgICAgICAvLyBDdXJyZW50IG5vZGUgbWF0Y2hlcywgbW92ZSBpbnRvIHRoZSB0cmVlLlxyXG4gICAgICAgICAgICAgIHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgeHhUcmVlW2JyYW5jaF0sIGkrMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaXNvbGF0ZWRCcmFuY2ggPSB7fTtcclxuICAgICAgICAgICAgICBpc29sYXRlZEJyYW5jaFticmFuY2hdID0geHhUcmVlW2JyYW5jaF07XHJcbiAgICAgICAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB7ICcqKic6IGlzb2xhdGVkQnJhbmNoIH0sIGkrMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZih4eFRyZWUuX2xpc3RlbmVycykge1xyXG4gICAgICAgIC8vIFdlIGhhdmUgcmVhY2hlZCB0aGUgZW5kIGFuZCBzdGlsbCBvbiBhICcqKidcclxuICAgICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHh4VHJlZSwgdHlwZUxlbmd0aCk7XHJcbiAgICAgIH0gZWxzZSBpZih4eFRyZWVbJyonXSAmJiB4eFRyZWVbJyonXS5fbGlzdGVuZXJzKSB7XHJcbiAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4eFRyZWVbJyonXSwgdHlwZUxlbmd0aCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGlzdGVuZXJzO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ3Jvd0xpc3RlbmVyVHJlZSh0eXBlLCBsaXN0ZW5lcikge1xyXG5cclxuICAgIHR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyB0eXBlLnNwbGl0KHRoaXMuZGVsaW1pdGVyKSA6IHR5cGUuc2xpY2UoKTtcclxuXHJcbiAgICAvL1xyXG4gICAgLy8gTG9va3MgZm9yIHR3byBjb25zZWN1dGl2ZSAnKionLCBpZiBzbywgZG9uJ3QgYWRkIHRoZSBldmVudCBhdCBhbGwuXHJcbiAgICAvL1xyXG4gICAgZm9yKHZhciBpID0gMCwgbGVuID0gdHlwZS5sZW5ndGg7IGkrMSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIGlmKHR5cGVbaV0gPT09ICcqKicgJiYgdHlwZVtpKzFdID09PSAnKionKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRyZWUgPSB0aGlzLmxpc3RlbmVyVHJlZTtcclxuICAgIHZhciBuYW1lID0gdHlwZS5zaGlmdCgpO1xyXG5cclxuICAgIHdoaWxlIChuYW1lICE9PSB1bmRlZmluZWQpIHtcclxuXHJcbiAgICAgIGlmICghdHJlZVtuYW1lXSkge1xyXG4gICAgICAgIHRyZWVbbmFtZV0gPSB7fTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdHJlZSA9IHRyZWVbbmFtZV07XHJcblxyXG4gICAgICBpZiAodHlwZS5sZW5ndGggPT09IDApIHtcclxuXHJcbiAgICAgICAgaWYgKCF0cmVlLl9saXN0ZW5lcnMpIHtcclxuICAgICAgICAgIHRyZWUuX2xpc3RlbmVycyA9IGxpc3RlbmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIGlmICh0eXBlb2YgdHJlZS5fbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRyZWUuX2xpc3RlbmVycyA9IFt0cmVlLl9saXN0ZW5lcnNdO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRyZWUuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuXHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICF0cmVlLl9saXN0ZW5lcnMud2FybmVkICYmXHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnMgPiAwICYmXHJcbiAgICAgICAgICAgIHRyZWUuX2xpc3RlbmVycy5sZW5ndGggPiB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgdHJlZS5fbGlzdGVuZXJzLndhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGxvZ1Bvc3NpYmxlTWVtb3J5TGVhay5jYWxsKHRoaXMsIHRyZWUuX2xpc3RlbmVycy5sZW5ndGgsIG5hbWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICBuYW1lID0gdHlwZS5zaGlmdCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuXHJcbiAgLy8gMTAgbGlzdGVuZXJzIGFyZSBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoXHJcbiAgLy8gaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXHJcbiAgLy9cclxuICAvLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3NcclxuICAvLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cclxuXHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5kZWxpbWl0ZXIgPSAnLic7XHJcblxyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xyXG4gICAgaWYgKG4gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLl9ldmVudHMgfHwgaW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgICB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzID0gbjtcclxuICAgICAgaWYgKCF0aGlzLl9jb25mKSB0aGlzLl9jb25mID0ge307XHJcbiAgICAgIHRoaXMuX2NvbmYubWF4TGlzdGVuZXJzID0gbjtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50ID0gJyc7XHJcblxyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbikge1xyXG4gICAgdGhpcy5tYW55KGV2ZW50LCAxLCBmbik7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm1hbnkgPSBmdW5jdGlvbihldmVudCwgdHRsLCBmbikge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYW55IG9ubHkgYWNjZXB0cyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsaXN0ZW5lcigpIHtcclxuICAgICAgaWYgKC0tdHRsID09PSAwKSB7XHJcbiAgICAgICAgc2VsZi5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcclxuICAgICAgfVxyXG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG5cclxuICAgIGxpc3RlbmVyLl9vcmlnaW4gPSBmbjtcclxuXHJcbiAgICB0aGlzLm9uKGV2ZW50LCBsaXN0ZW5lcik7XHJcblxyXG4gICAgcmV0dXJuIHNlbGY7XHJcbiAgfTtcclxuXHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdGhpcy5fZXZlbnRzIHx8IGluaXQuY2FsbCh0aGlzKTtcclxuXHJcbiAgICB2YXIgdHlwZSA9IGFyZ3VtZW50c1swXTtcclxuXHJcbiAgICBpZiAodHlwZSA9PT0gJ25ld0xpc3RlbmVyJyAmJiAhdGhpcy5uZXdMaXN0ZW5lcikge1xyXG4gICAgICBpZiAoIXRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcikge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBhbCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcbiAgICB2YXIgYXJncyxsLGksajtcclxuICAgIHZhciBoYW5kbGVyO1xyXG5cclxuICAgIGlmICh0aGlzLl9hbGwgJiYgdGhpcy5fYWxsLmxlbmd0aCkge1xyXG4gICAgICBoYW5kbGVyID0gdGhpcy5fYWxsLnNsaWNlKCk7XHJcbiAgICAgIGlmIChhbCA+IDMpIHtcclxuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGFsKTtcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgYWw7IGorKykgYXJnc1tqXSA9IGFyZ3VtZW50c1tqXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChpID0gMCwgbCA9IGhhbmRsZXIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudCA9IHR5cGU7XHJcbiAgICAgICAgc3dpdGNoIChhbCkge1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgIGhhbmRsZXJbaV0uY2FsbCh0aGlzLCB0eXBlKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgIGhhbmRsZXJbaV0uY2FsbCh0aGlzLCB0eXBlLCBhcmd1bWVudHNbMV0pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgaGFuZGxlcltpXS5jYWxsKHRoaXMsIHR5cGUsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBoYW5kbGVyW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLndpbGRjYXJkKSB7XHJcbiAgICAgIGhhbmRsZXIgPSBbXTtcclxuICAgICAgdmFyIG5zID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gdHlwZS5zcGxpdCh0aGlzLmRlbGltaXRlcikgOiB0eXBlLnNsaWNlKCk7XHJcbiAgICAgIHNlYXJjaExpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIGhhbmRsZXIsIG5zLCB0aGlzLmxpc3RlbmVyVHJlZSwgMCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xyXG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aGlzLmV2ZW50ID0gdHlwZTtcclxuICAgICAgICBzd2l0Y2ggKGFsKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYWwgLSAxKTtcclxuICAgICAgICAgIGZvciAoaiA9IDE7IGogPCBhbDsgaisrKSBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcclxuICAgICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9IGVsc2UgaWYgKGhhbmRsZXIpIHtcclxuICAgICAgICAvLyBuZWVkIHRvIG1ha2UgY29weSBvZiBoYW5kbGVycyBiZWNhdXNlIGxpc3QgY2FuIGNoYW5nZSBpbiB0aGUgbWlkZGxlXHJcbiAgICAgICAgLy8gb2YgZW1pdCBjYWxsXHJcbiAgICAgICAgaGFuZGxlciA9IGhhbmRsZXIuc2xpY2UoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChoYW5kbGVyICYmIGhhbmRsZXIubGVuZ3RoKSB7XHJcbiAgICAgIGlmIChhbCA+IDMpIHtcclxuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGFsIC0gMSk7XHJcbiAgICAgICAgZm9yIChqID0gMTsgaiA8IGFsOyBqKyspIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBoYW5kbGVyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIHRoaXMuZXZlbnQgPSB0eXBlO1xyXG4gICAgICAgIHN3aXRjaCAoYWwpIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICBoYW5kbGVyW2ldLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICBoYW5kbGVyW2ldLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgIGhhbmRsZXJbaV0uY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgaGFuZGxlcltpXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGVsc2UgaWYgKCF0aGlzLl9hbGwgJiYgdHlwZSA9PT0gJ2Vycm9yJykge1xyXG4gICAgICBpZiAoYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICB0aHJvdyBhcmd1bWVudHNbMV07IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5jYXVnaHQsIHVuc3BlY2lmaWVkICdlcnJvcicgZXZlbnQuXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gISF0aGlzLl9hbGw7XHJcbiAgfTtcclxuXHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0QXN5bmMgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB0aGlzLl9ldmVudHMgfHwgaW5pdC5jYWxsKHRoaXMpO1xyXG5cclxuICAgIHZhciB0eXBlID0gYXJndW1lbnRzWzBdO1xyXG5cclxuICAgIGlmICh0eXBlID09PSAnbmV3TGlzdGVuZXInICYmICF0aGlzLm5ld0xpc3RlbmVyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbZmFsc2VdKTsgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBwcm9taXNlcz0gW107XHJcblxyXG4gICAgdmFyIGFsID0gYXJndW1lbnRzLmxlbmd0aDtcclxuICAgIHZhciBhcmdzLGwsaSxqO1xyXG4gICAgdmFyIGhhbmRsZXI7XHJcblxyXG4gICAgaWYgKHRoaXMuX2FsbCkge1xyXG4gICAgICBpZiAoYWwgPiAzKSB7XHJcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShhbCk7XHJcbiAgICAgICAgZm9yIChqID0gMTsgaiA8IGFsOyBqKyspIGFyZ3Nbal0gPSBhcmd1bWVudHNbal07XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuX2FsbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICB0aGlzLmV2ZW50ID0gdHlwZTtcclxuICAgICAgICBzd2l0Y2ggKGFsKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9hbGxbaV0uY2FsbCh0aGlzLCB0eXBlKSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2FsbFtpXS5jYWxsKHRoaXMsIHR5cGUsIGFyZ3VtZW50c1sxXSkpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9hbGxbaV0uY2FsbCh0aGlzLCB0eXBlLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSkpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fYWxsW2ldLmFwcGx5KHRoaXMsIGFyZ3MpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy53aWxkY2FyZCkge1xyXG4gICAgICBoYW5kbGVyID0gW107XHJcbiAgICAgIHZhciBucyA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUuc3BsaXQodGhpcy5kZWxpbWl0ZXIpIDogdHlwZS5zbGljZSgpO1xyXG4gICAgICBzZWFyY2hMaXN0ZW5lclRyZWUuY2FsbCh0aGlzLCBoYW5kbGVyLCBucywgdGhpcy5saXN0ZW5lclRyZWUsIDApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhpcy5ldmVudCA9IHR5cGU7XHJcbiAgICAgIHN3aXRjaCAoYWwpIHtcclxuICAgICAgY2FzZSAxOlxyXG4gICAgICAgIHByb21pc2VzLnB1c2goaGFuZGxlci5jYWxsKHRoaXMpKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAyOlxyXG4gICAgICAgIHByb21pc2VzLnB1c2goaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSkpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDM6XHJcbiAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGFsIC0gMSk7XHJcbiAgICAgICAgZm9yIChqID0gMTsgaiA8IGFsOyBqKyspIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xyXG4gICAgICAgIHByb21pc2VzLnB1c2goaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoaGFuZGxlciAmJiBoYW5kbGVyLmxlbmd0aCkge1xyXG4gICAgICBpZiAoYWwgPiAzKSB7XHJcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShhbCAtIDEpO1xyXG4gICAgICAgIGZvciAoaiA9IDE7IGogPCBhbDsgaisrKSBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGkgPSAwLCBsID0gaGFuZGxlci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICB0aGlzLmV2ZW50ID0gdHlwZTtcclxuICAgICAgICBzd2l0Y2ggKGFsKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyW2ldLmNhbGwodGhpcykpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyW2ldLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXJbaV0uY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSkpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHByb21pc2VzLnB1c2goaGFuZGxlcltpXS5hcHBseSh0aGlzLCBhcmdzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKCF0aGlzLl9hbGwgJiYgdHlwZSA9PT0gJ2Vycm9yJykge1xyXG4gICAgICBpZiAoYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoYXJndW1lbnRzWzFdKTsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJVbmNhdWdodCwgdW5zcGVjaWZpZWQgJ2Vycm9yJyBldmVudC5cIik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xyXG4gIH07XHJcblxyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xyXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRoaXMub25BbnkodHlwZSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbiBvbmx5IGFjY2VwdHMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9ldmVudHMgfHwgaW5pdC5jYWxsKHRoaXMpO1xyXG5cclxuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT0gXCJuZXdMaXN0ZW5lcnNcIiEgQmVmb3JlXHJcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyc1wiLlxyXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcclxuXHJcbiAgICBpZiAodGhpcy53aWxkY2FyZCkge1xyXG4gICAgICBncm93TGlzdGVuZXJUcmVlLmNhbGwodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkge1xyXG4gICAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cclxuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9ldmVudHNbdHlwZV0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAvLyBDaGFuZ2UgdG8gYXJyYXkuXHJcbiAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cclxuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcclxuICAgICAgaWYgKFxyXG4gICAgICAgICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkICYmXHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyA+IDAgJiZcclxuICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gdGhpcy5fZXZlbnRzLm1heExpc3RlbmVyc1xyXG4gICAgICApIHtcclxuICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcclxuICAgICAgICBsb2dQb3NzaWJsZU1lbW9yeUxlYWsuY2FsbCh0aGlzLCB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoLCB0eXBlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25BbnkgPSBmdW5jdGlvbihmbikge1xyXG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29uQW55IG9ubHkgYWNjZXB0cyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuX2FsbCkge1xyXG4gICAgICB0aGlzLl9hbGwgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgdGhlIGZ1bmN0aW9uIHRvIHRoZSBldmVudCBsaXN0ZW5lciBjb2xsZWN0aW9uLlxyXG4gICAgdGhpcy5fYWxsLnB1c2goZm4pO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XHJcblxyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcclxuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVMaXN0ZW5lciBvbmx5IHRha2VzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBoYW5kbGVycyxsZWFmcz1bXTtcclxuXHJcbiAgICBpZih0aGlzLndpbGRjYXJkKSB7XHJcbiAgICAgIHZhciBucyA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUuc3BsaXQodGhpcy5kZWxpbWl0ZXIpIDogdHlwZS5zbGljZSgpO1xyXG4gICAgICBsZWFmcyA9IHNlYXJjaExpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIG51bGwsIG5zLCB0aGlzLmxpc3RlbmVyVHJlZSwgMCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdXHJcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSByZXR1cm4gdGhpcztcclxuICAgICAgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XHJcbiAgICAgIGxlYWZzLnB1c2goe19saXN0ZW5lcnM6aGFuZGxlcnN9KTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBpTGVhZj0wOyBpTGVhZjxsZWFmcy5sZW5ndGg7IGlMZWFmKyspIHtcclxuICAgICAgdmFyIGxlYWYgPSBsZWFmc1tpTGVhZl07XHJcbiAgICAgIGhhbmRsZXJzID0gbGVhZi5fbGlzdGVuZXJzO1xyXG4gICAgICBpZiAoaXNBcnJheShoYW5kbGVycykpIHtcclxuXHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gLTE7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgaWYgKGhhbmRsZXJzW2ldID09PSBsaXN0ZW5lciB8fFxyXG4gICAgICAgICAgICAoaGFuZGxlcnNbaV0ubGlzdGVuZXIgJiYgaGFuZGxlcnNbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB8fFxyXG4gICAgICAgICAgICAoaGFuZGxlcnNbaV0uX29yaWdpbiAmJiBoYW5kbGVyc1tpXS5fb3JpZ2luID09PSBsaXN0ZW5lcikpIHtcclxuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy53aWxkY2FyZCkge1xyXG4gICAgICAgICAgbGVhZi5fbGlzdGVuZXJzLnNwbGljZShwb3NpdGlvbiwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLnNwbGljZShwb3NpdGlvbiwgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaGFuZGxlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICBpZih0aGlzLndpbGRjYXJkKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBsZWFmLl9saXN0ZW5lcnM7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsIHR5cGUsIGxpc3RlbmVyKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoaGFuZGxlcnMgPT09IGxpc3RlbmVyIHx8XHJcbiAgICAgICAgKGhhbmRsZXJzLmxpc3RlbmVyICYmIGhhbmRsZXJzLmxpc3RlbmVyID09PSBsaXN0ZW5lcikgfHxcclxuICAgICAgICAoaGFuZGxlcnMuX29yaWdpbiAmJiBoYW5kbGVycy5fb3JpZ2luID09PSBsaXN0ZW5lcikpIHtcclxuICAgICAgICBpZih0aGlzLndpbGRjYXJkKSB7XHJcbiAgICAgICAgICBkZWxldGUgbGVhZi5fbGlzdGVuZXJzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmVtaXQoXCJyZW1vdmVMaXN0ZW5lclwiLCB0eXBlLCBsaXN0ZW5lcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseUdhcmJhZ2VDb2xsZWN0KHJvb3QpIHtcclxuICAgICAgaWYgKHJvb3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJvb3QpO1xyXG4gICAgICBmb3IgKHZhciBpIGluIGtleXMpIHtcclxuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICB2YXIgb2JqID0gcm9vdFtrZXldO1xyXG4gICAgICAgIGlmICgob2JqIGluc3RhbmNlb2YgRnVuY3Rpb24pIHx8ICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSB8fCAob2JqID09PSBudWxsKSlcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIHJlY3Vyc2l2ZWx5R2FyYmFnZUNvbGxlY3Qocm9vdFtrZXldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICBkZWxldGUgcm9vdFtrZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVjdXJzaXZlbHlHYXJiYWdlQ29sbGVjdCh0aGlzLmxpc3RlbmVyVHJlZSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmZBbnkgPSBmdW5jdGlvbihmbikge1xyXG4gICAgdmFyIGkgPSAwLCBsID0gMCwgZm5zO1xyXG4gICAgaWYgKGZuICYmIHRoaXMuX2FsbCAmJiB0aGlzLl9hbGwubGVuZ3RoID4gMCkge1xyXG4gICAgICBmbnMgPSB0aGlzLl9hbGw7XHJcbiAgICAgIGZvcihpID0gMCwgbCA9IGZucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZihmbiA9PT0gZm5zW2ldKSB7XHJcbiAgICAgICAgICBmbnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJBbnlcIiwgZm4pO1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmbnMgPSB0aGlzLl9hbGw7XHJcbiAgICAgIGZvcihpID0gMCwgbCA9IGZucy5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJBbnlcIiwgZm5zW2ldKTtcclxuICAgICAgdGhpcy5fYWxsID0gW107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmY7XHJcblxyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgIXRoaXMuX2V2ZW50cyB8fCBpbml0LmNhbGwodGhpcyk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLndpbGRjYXJkKSB7XHJcbiAgICAgIHZhciBucyA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUuc3BsaXQodGhpcy5kZWxpbWl0ZXIpIDogdHlwZS5zbGljZSgpO1xyXG4gICAgICB2YXIgbGVhZnMgPSBzZWFyY2hMaXN0ZW5lclRyZWUuY2FsbCh0aGlzLCBudWxsLCBucywgdGhpcy5saXN0ZW5lclRyZWUsIDApO1xyXG5cclxuICAgICAgZm9yICh2YXIgaUxlYWY9MDsgaUxlYWY8bGVhZnMubGVuZ3RoOyBpTGVhZisrKSB7XHJcbiAgICAgICAgdmFyIGxlYWYgPSBsZWFmc1tpTGVhZl07XHJcbiAgICAgICAgbGVhZi5fbGlzdGVuZXJzID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzKSB7XHJcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgIGlmICh0aGlzLndpbGRjYXJkKSB7XHJcbiAgICAgIHZhciBoYW5kbGVycyA9IFtdO1xyXG4gICAgICB2YXIgbnMgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyB0eXBlLnNwbGl0KHRoaXMuZGVsaW1pdGVyKSA6IHR5cGUuc2xpY2UoKTtcclxuICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlLmNhbGwodGhpcywgaGFuZGxlcnMsIG5zLCB0aGlzLmxpc3RlbmVyVHJlZSwgMCk7XHJcbiAgICAgIHJldHVybiBoYW5kbGVycztcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9ldmVudHMgfHwgaW5pdC5jYWxsKHRoaXMpO1xyXG5cclxuICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSB0aGlzLl9ldmVudHNbdHlwZV0gPSBbXTtcclxuICAgIGlmICghaXNBcnJheSh0aGlzLl9ldmVudHNbdHlwZV0pKSB7XHJcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX2V2ZW50c1t0eXBlXTtcclxuICB9O1xyXG5cclxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xyXG4gIH07XHJcblxyXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzQW55ID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgaWYodGhpcy5fYWxsKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9hbGw7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG5cclxuICB9O1xyXG5cclxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxyXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xyXG4gICAgfSk7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcclxuICAgIC8vIENvbW1vbkpTXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICAvLyBCcm93c2VyIGdsb2JhbC5cclxuICAgIHdpbmRvdy5FdmVudEVtaXR0ZXIyID0gRXZlbnRFbWl0dGVyO1xyXG4gIH1cclxufSgpO1xyXG4iLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbi8qISBmbGF0cGlja3IgdjIuNi4zLCBAbGljZW5zZSBNSVQgKi9cbmZ1bmN0aW9uIEZsYXRwaWNrcihlbGVtZW50LCBjb25maWcpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdHNlbGYuXyA9IHt9O1xuXHRzZWxmLl8uYWZ0ZXJEYXlBbmltID0gYWZ0ZXJEYXlBbmltO1xuXHRzZWxmLmNoYW5nZU1vbnRoID0gY2hhbmdlTW9udGg7XG5cdHNlbGYuY2hhbmdlWWVhciA9IGNoYW5nZVllYXI7XG5cdHNlbGYuY2xlYXIgPSBjbGVhcjtcblx0c2VsZi5jbG9zZSA9IGNsb3NlO1xuXHRzZWxmLl9jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudDtcblx0c2VsZi5kZXN0cm95ID0gZGVzdHJveTtcblx0c2VsZi5pc0VuYWJsZWQgPSBpc0VuYWJsZWQ7XG5cdHNlbGYuanVtcFRvRGF0ZSA9IGp1bXBUb0RhdGU7XG5cdHNlbGYub3BlbiA9IG9wZW47XG5cdHNlbGYucmVkcmF3ID0gcmVkcmF3O1xuXHRzZWxmLnNldCA9IHNldDtcblx0c2VsZi5zZXREYXRlID0gc2V0RGF0ZTtcblx0c2VsZi50b2dnbGUgPSB0b2dnbGU7XG5cblx0ZnVuY3Rpb24gaW5pdCgpIHtcblx0XHRzZWxmLmVsZW1lbnQgPSBzZWxmLmlucHV0ID0gZWxlbWVudDtcblx0XHRzZWxmLmluc3RhbmNlQ29uZmlnID0gY29uZmlnIHx8IHt9O1xuXHRcdHNlbGYucGFyc2VEYXRlID0gRmxhdHBpY2tyLnByb3RvdHlwZS5wYXJzZURhdGUuYmluZChzZWxmKTtcblx0XHRzZWxmLmZvcm1hdERhdGUgPSBGbGF0cGlja3IucHJvdG90eXBlLmZvcm1hdERhdGUuYmluZChzZWxmKTtcblxuXHRcdHNldHVwRm9ybWF0cygpO1xuXHRcdHBhcnNlQ29uZmlnKCk7XG5cdFx0c2V0dXBMb2NhbGUoKTtcblx0XHRzZXR1cElucHV0cygpO1xuXHRcdHNldHVwRGF0ZXMoKTtcblx0XHRzZXR1cEhlbHBlckZ1bmN0aW9ucygpO1xuXG5cdFx0c2VsZi5pc09wZW4gPSBmYWxzZTtcblxuXHRcdHNlbGYuaXNNb2JpbGUgPSAhc2VsZi5jb25maWcuZGlzYWJsZU1vYmlsZSAmJiAhc2VsZi5jb25maWcuaW5saW5lICYmIHNlbGYuY29uZmlnLm1vZGUgPT09IFwic2luZ2xlXCIgJiYgIXNlbGYuY29uZmlnLmRpc2FibGUubGVuZ3RoICYmICFzZWxmLmNvbmZpZy5lbmFibGUubGVuZ3RoICYmICFzZWxmLmNvbmZpZy53ZWVrTnVtYmVycyAmJiAvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cblx0XHRpZiAoIXNlbGYuaXNNb2JpbGUpIGJ1aWxkKCk7XG5cblx0XHRiaW5kRXZlbnRzKCk7XG5cblx0XHRpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCB8fCBzZWxmLmNvbmZpZy5ub0NhbGVuZGFyKSB7XG5cdFx0XHRpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSkge1xuXHRcdFx0XHRzZXRIb3Vyc0Zyb21EYXRlKHNlbGYuY29uZmlnLm5vQ2FsZW5kYXIgPyBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiB8fCBzZWxmLmNvbmZpZy5taW5EYXRlIDogbnVsbCk7XG5cdFx0XHR9XG5cdFx0XHR1cGRhdGVWYWx1ZSgpO1xuXHRcdH1cblxuXHRcdGlmIChzZWxmLmNvbmZpZy53ZWVrTnVtYmVycykge1xuXHRcdFx0c2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS53aWR0aCA9IHNlbGYuZGF5c0NvbnRhaW5lci5vZmZzZXRXaWR0aCArIHNlbGYud2Vla1dyYXBwZXIub2Zmc2V0V2lkdGggKyBcInB4XCI7XG5cdFx0fVxuXG5cdFx0c2VsZi5zaG93VGltZUlucHV0ID0gc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA+IDAgfHwgc2VsZi5jb25maWcubm9DYWxlbmRhcjtcblxuXHRcdGlmICghc2VsZi5pc01vYmlsZSkgcG9zaXRpb25DYWxlbmRhcigpO1xuXG5cdFx0dHJpZ2dlckV2ZW50KFwiUmVhZHlcIik7XG5cdH1cblxuXHQvKipcbiAgKiBCaW5kcyBhIGZ1bmN0aW9uIHRvIHRoZSBjdXJyZW50IGZsYXRwaWNrciBpbnN0YW5jZVxuICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIHRoZSBmdW5jdGlvblxuICAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aGUgZnVuY3Rpb24gYm91bmQgdG8gdGhlIGluc3RhbmNlXG4gICovXG5cdGZ1bmN0aW9uIGJpbmRUb0luc3RhbmNlKGZuKSB7XG5cdFx0cmV0dXJuIGZuLmJpbmQoc2VsZik7XG5cdH1cblxuXHQvKipcbiAgKiBUaGUgaGFuZGxlciBmb3IgYWxsIGV2ZW50cyB0YXJnZXRpbmcgdGhlIHRpbWUgaW5wdXRzXG4gICogQHBhcmFtIHtFdmVudH0gZSB0aGUgZXZlbnQgLSBcImlucHV0XCIsIFwid2hlZWxcIiwgXCJpbmNyZW1lbnRcIiwgZXRjXG4gICovXG5cdGZ1bmN0aW9uIHVwZGF0ZVRpbWUoZSkge1xuXHRcdGlmIChzZWxmLmNvbmZpZy5ub0NhbGVuZGFyICYmICFzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoKVxuXHRcdFx0Ly8gcGlja2luZyB0aW1lIG9ubHlcblx0XHRcdHNlbGYuc2VsZWN0ZWREYXRlcyA9IFtzZWxmLm5vd107XG5cblx0XHR0aW1lV3JhcHBlcihlKTtcblxuXHRcdGlmICghc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCkgcmV0dXJuO1xuXG5cdFx0aWYgKCFzZWxmLm1pbkRhdGVIYXNUaW1lIHx8IGUudHlwZSAhPT0gXCJpbnB1dFwiIHx8IGUudGFyZ2V0LnZhbHVlLmxlbmd0aCA+PSAyKSB7XG5cdFx0XHRzZXRIb3Vyc0Zyb21JbnB1dHMoKTtcblx0XHRcdHVwZGF0ZVZhbHVlKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzZXRIb3Vyc0Zyb21JbnB1dHMoKTtcblx0XHRcdFx0dXBkYXRlVmFsdWUoKTtcblx0XHRcdH0sIDEwMDApO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuICAqIFN5bmNzIHRoZSBzZWxlY3RlZCBkYXRlIG9iamVjdCB0aW1lIHdpdGggdXNlcidzIHRpbWUgaW5wdXRcbiAgKi9cblx0ZnVuY3Rpb24gc2V0SG91cnNGcm9tSW5wdXRzKCkge1xuXHRcdGlmICghc2VsZi5jb25maWcuZW5hYmxlVGltZSkgcmV0dXJuO1xuXG5cdFx0dmFyIGhvdXJzID0gKHBhcnNlSW50KHNlbGYuaG91ckVsZW1lbnQudmFsdWUsIDEwKSB8fCAwKSAlIChzZWxmLmFtUE0gPyAxMiA6IDI0KSxcblx0XHQgICAgbWludXRlcyA9IChwYXJzZUludChzZWxmLm1pbnV0ZUVsZW1lbnQudmFsdWUsIDEwKSB8fCAwKSAlIDYwLFxuXHRcdCAgICBzZWNvbmRzID0gc2VsZi5jb25maWcuZW5hYmxlU2Vjb25kcyA/IChwYXJzZUludChzZWxmLnNlY29uZEVsZW1lbnQudmFsdWUsIDEwKSB8fCAwKSAlIDYwIDogMDtcblxuXHRcdGlmIChzZWxmLmFtUE0gIT09IHVuZGVmaW5lZCkgaG91cnMgPSBob3VycyAlIDEyICsgMTIgKiAoc2VsZi5hbVBNLnRleHRDb250ZW50ID09PSBcIlBNXCIpO1xuXG5cdFx0aWYgKHNlbGYubWluRGF0ZUhhc1RpbWUgJiYgY29tcGFyZURhdGVzKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLCBzZWxmLmNvbmZpZy5taW5EYXRlKSA9PT0gMCkge1xuXG5cdFx0XHRob3VycyA9IE1hdGgubWF4KGhvdXJzLCBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEhvdXJzKCkpO1xuXHRcdFx0aWYgKGhvdXJzID09PSBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEhvdXJzKCkpIG1pbnV0ZXMgPSBNYXRoLm1heChtaW51dGVzLCBzZWxmLmNvbmZpZy5taW5EYXRlLmdldE1pbnV0ZXMoKSk7XG5cdFx0fVxuXG5cdFx0aWYgKHNlbGYubWF4RGF0ZUhhc1RpbWUgJiYgY29tcGFyZURhdGVzKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLCBzZWxmLmNvbmZpZy5tYXhEYXRlKSA9PT0gMCkge1xuXHRcdFx0aG91cnMgPSBNYXRoLm1pbihob3Vycywgc2VsZi5jb25maWcubWF4RGF0ZS5nZXRIb3VycygpKTtcblx0XHRcdGlmIChob3VycyA9PT0gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRIb3VycygpKSBtaW51dGVzID0gTWF0aC5taW4obWludXRlcywgc2VsZi5jb25maWcubWF4RGF0ZS5nZXRNaW51dGVzKCkpO1xuXHRcdH1cblxuXHRcdHNldEhvdXJzKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKTtcblx0fVxuXG5cdC8qKlxuICAqIFN5bmNzIHRpbWUgaW5wdXQgdmFsdWVzIHdpdGggYSBkYXRlXG4gICogQHBhcmFtIHtEYXRlfSBkYXRlT2JqIHRoZSBkYXRlIHRvIHN5bmMgd2l0aFxuICAqL1xuXHRmdW5jdGlvbiBzZXRIb3Vyc0Zyb21EYXRlKGRhdGVPYmopIHtcblx0XHR2YXIgZGF0ZSA9IGRhdGVPYmogfHwgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmo7XG5cblx0XHRpZiAoZGF0ZSkgc2V0SG91cnMoZGF0ZS5nZXRIb3VycygpLCBkYXRlLmdldE1pbnV0ZXMoKSwgZGF0ZS5nZXRTZWNvbmRzKCkpO1xuXHR9XG5cblx0LyoqXG4gICogU2V0cyB0aGUgaG91cnMsIG1pbnV0ZXMsIGFuZCBvcHRpb25hbGx5IHNlY29uZHNcbiAgKiBvZiB0aGUgbGF0ZXN0IHNlbGVjdGVkIGRhdGUgb2JqZWN0IGFuZCB0aGVcbiAgKiBjb3JyZXNwb25kaW5nIHRpbWUgaW5wdXRzXG4gICogQHBhcmFtIHtOdW1iZXJ9IGhvdXJzIHRoZSBob3VyLiB3aGV0aGVyIGl0cyBtaWxpdGFyeVxuICAqICAgICAgICAgICAgICAgICBvciBhbS1wbSBnZXRzIGluZmVycmVkIGZyb20gY29uZmlnXG4gICogQHBhcmFtIHtOdW1iZXJ9IG1pbnV0ZXMgdGhlIG1pbnV0ZXNcbiAgKiBAcGFyYW0ge051bWJlcn0gc2Vjb25kcyB0aGUgc2Vjb25kcyAob3B0aW9uYWwpXG4gICovXG5cdGZ1bmN0aW9uIHNldEhvdXJzKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKSB7XG5cdFx0aWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGgpIHtcblx0XHRcdHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLnNldEhvdXJzKGhvdXJzICUgMjQsIG1pbnV0ZXMsIHNlY29uZHMgfHwgMCwgMCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFzZWxmLmNvbmZpZy5lbmFibGVUaW1lIHx8IHNlbGYuaXNNb2JpbGUpIHJldHVybjtcblxuXHRcdHNlbGYuaG91ckVsZW1lbnQudmFsdWUgPSBzZWxmLnBhZCghc2VsZi5jb25maWcudGltZV8yNGhyID8gKDEyICsgaG91cnMpICUgMTIgKyAxMiAqIChob3VycyAlIDEyID09PSAwKSA6IGhvdXJzKTtcblxuXHRcdHNlbGYubWludXRlRWxlbWVudC52YWx1ZSA9IHNlbGYucGFkKG1pbnV0ZXMpO1xuXG5cdFx0aWYgKCFzZWxmLmNvbmZpZy50aW1lXzI0aHIpIHNlbGYuYW1QTS50ZXh0Q29udGVudCA9IGhvdXJzID49IDEyID8gXCJQTVwiIDogXCJBTVwiO1xuXG5cdFx0aWYgKHNlbGYuY29uZmlnLmVuYWJsZVNlY29uZHMgPT09IHRydWUpIHNlbGYuc2Vjb25kRWxlbWVudC52YWx1ZSA9IHNlbGYucGFkKHNlY29uZHMpO1xuXHR9XG5cblx0LyoqXG4gICogSGFuZGxlcyB0aGUgeWVhciBpbnB1dCBhbmQgaW5jcmVtZW50aW5nIGV2ZW50c1xuICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IHRoZSBrZXl1cCBvciBpbmNyZW1lbnQgZXZlbnRcbiAgKi9cblx0ZnVuY3Rpb24gb25ZZWFySW5wdXQoZXZlbnQpIHtcblx0XHR2YXIgeWVhciA9IGV2ZW50LnRhcmdldC52YWx1ZTtcblx0XHRpZiAoZXZlbnQuZGVsdGEpIHllYXIgPSAocGFyc2VJbnQoeWVhcikgKyBldmVudC5kZWx0YSkudG9TdHJpbmcoKTtcblxuXHRcdGlmICh5ZWFyLmxlbmd0aCA9PT0gNCB8fCBldmVudC5rZXkgPT09IFwiRW50ZXJcIikge1xuXHRcdFx0c2VsZi5jdXJyZW50WWVhckVsZW1lbnQuYmx1cigpO1xuXHRcdFx0aWYgKCEvW15cXGRdLy50ZXN0KHllYXIpKSBjaGFuZ2VZZWFyKHllYXIpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuICAqIEVzc2VudGlhbGx5IGFkZEV2ZW50TGlzdGVuZXIgKyB0cmFja2luZ1xuICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBhZGRFdmVudExpc3RlbmVyIHRvXG4gICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IHRoZSBldmVudCBuYW1lXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciB0aGUgZXZlbnQgaGFuZGxlclxuICAqL1xuXHRmdW5jdGlvbiBiaW5kKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyKSB7XG5cdFx0aWYgKGV2ZW50IGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBldmVudC5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuXHRcdFx0cmV0dXJuIGJpbmQoZWxlbWVudCwgZXYsIGhhbmRsZXIpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBBcnJheSkgcmV0dXJuIGVsZW1lbnQuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcblx0XHRcdHJldHVybiBiaW5kKGVsLCBldmVudCwgaGFuZGxlcik7XG5cdFx0fSk7XG5cblx0XHRlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpO1xuXHRcdHNlbGYuX2hhbmRsZXJzLnB1c2goeyBlbGVtZW50OiBlbGVtZW50LCBldmVudDogZXZlbnQsIGhhbmRsZXI6IGhhbmRsZXIgfSk7XG5cdH1cblxuXHQvKipcbiAgKiBBIG1vdXNlZG93biBoYW5kbGVyIHdoaWNoIG1pbWljcyBjbGljay5cbiAgKiBNaW5pbWl6ZXMgbGF0ZW5jeSwgc2luY2Ugd2UgZG9uJ3QgbmVlZCB0byB3YWl0IGZvciBtb3VzZXVwIGluIG1vc3QgY2FzZXMuXG4gICogQWxzbywgYXZvaWRzIGhhbmRsaW5nIHJpZ2h0IGNsaWNrcy5cbiAgKlxuICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgdGhlIGV2ZW50IGhhbmRsZXJcbiAgKi9cblx0ZnVuY3Rpb24gb25DbGljayhoYW5kbGVyKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChldnQpIHtcblx0XHRcdHJldHVybiBldnQud2hpY2ggPT09IDEgJiYgaGFuZGxlcihldnQpO1xuXHRcdH07XG5cdH1cblxuXHQvKipcbiAgKiBBZGRzIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVyc1xuICAqL1xuXHRmdW5jdGlvbiBiaW5kRXZlbnRzKCkge1xuXHRcdHNlbGYuX2hhbmRsZXJzID0gW107XG5cdFx0c2VsZi5fYW5pbWF0aW9uTG9vcCA9IFtdO1xuXHRcdGlmIChzZWxmLmNvbmZpZy53cmFwKSB7XG5cdFx0XHRbXCJvcGVuXCIsIFwiY2xvc2VcIiwgXCJ0b2dnbGVcIiwgXCJjbGVhclwiXS5mb3JFYWNoKGZ1bmN0aW9uIChldnQpIHtcblx0XHRcdFx0QXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChzZWxmLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLVwiICsgZXZ0ICsgXCJdXCIpLCBmdW5jdGlvbiAoZWwpIHtcblx0XHRcdFx0XHRyZXR1cm4gYmluZChlbCwgXCJtb3VzZWRvd25cIiwgb25DbGljayhzZWxmW2V2dF0pKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoc2VsZi5pc01vYmlsZSkgcmV0dXJuIHNldHVwTW9iaWxlKCk7XG5cblx0XHRzZWxmLmRlYm91bmNlZFJlc2l6ZSA9IGRlYm91bmNlKG9uUmVzaXplLCA1MCk7XG5cdFx0c2VsZi50cmlnZ2VyQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dHJpZ2dlckV2ZW50KFwiQ2hhbmdlXCIpO1xuXHRcdH07XG5cdFx0c2VsZi5kZWJvdW5jZWRDaGFuZ2UgPSBkZWJvdW5jZShzZWxmLnRyaWdnZXJDaGFuZ2UsIDMwMCk7XG5cblx0XHRpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiICYmIHNlbGYuZGF5c0NvbnRhaW5lcikgYmluZChzZWxmLmRheXNDb250YWluZXIsIFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRyZXR1cm4gb25Nb3VzZU92ZXIoZS50YXJnZXQpO1xuXHRcdH0pO1xuXG5cdFx0YmluZCh3aW5kb3cuZG9jdW1lbnQuYm9keSwgXCJrZXlkb3duXCIsIG9uS2V5RG93bik7XG5cblx0XHRpZiAoIXNlbGYuY29uZmlnLnN0YXRpYykgYmluZChzZWxmLl9pbnB1dCwgXCJrZXlkb3duXCIsIG9uS2V5RG93bik7XG5cblx0XHRpZiAoIXNlbGYuY29uZmlnLmlubGluZSAmJiAhc2VsZi5jb25maWcuc3RhdGljKSBiaW5kKHdpbmRvdywgXCJyZXNpemVcIiwgc2VsZi5kZWJvdW5jZWRSZXNpemUpO1xuXG5cdFx0aWYgKHdpbmRvdy5vbnRvdWNoc3RhcnQgIT09IHVuZGVmaW5lZCkgYmluZCh3aW5kb3cuZG9jdW1lbnQsIFwidG91Y2hzdGFydFwiLCBkb2N1bWVudENsaWNrKTtcblxuXHRcdGJpbmQod2luZG93LmRvY3VtZW50LCBcIm1vdXNlZG93blwiLCBvbkNsaWNrKGRvY3VtZW50Q2xpY2spKTtcblx0XHRiaW5kKHNlbGYuX2lucHV0LCBcImJsdXJcIiwgZG9jdW1lbnRDbGljayk7XG5cblx0XHRpZiAoc2VsZi5jb25maWcuY2xpY2tPcGVucyA9PT0gdHJ1ZSkgYmluZChzZWxmLl9pbnB1dCwgXCJmb2N1c1wiLCBzZWxmLm9wZW4pO1xuXG5cdFx0aWYgKCFzZWxmLmNvbmZpZy5ub0NhbGVuZGFyKSB7XG5cdFx0XHRzZWxmLm1vbnRoTmF2LmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRyZXR1cm4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fSk7XG5cdFx0XHRiaW5kKHNlbGYubW9udGhOYXYsIFwid2hlZWxcIiwgZGVib3VuY2Uob25Nb250aE5hdlNjcm9sbCwgMTApKTtcblx0XHRcdGJpbmQoc2VsZi5tb250aE5hdiwgXCJtb3VzZWRvd25cIiwgb25DbGljayhvbk1vbnRoTmF2Q2xpY2spKTtcblxuXHRcdFx0YmluZChzZWxmLm1vbnRoTmF2LCBbXCJrZXl1cFwiLCBcImluY3JlbWVudFwiXSwgb25ZZWFySW5wdXQpO1xuXHRcdFx0YmluZChzZWxmLmRheXNDb250YWluZXIsIFwibW91c2Vkb3duXCIsIG9uQ2xpY2soc2VsZWN0RGF0ZSkpO1xuXG5cdFx0XHRpZiAoc2VsZi5jb25maWcuYW5pbWF0ZSkge1xuXHRcdFx0XHRiaW5kKHNlbGYuZGF5c0NvbnRhaW5lciwgW1wid2Via2l0QW5pbWF0aW9uRW5kXCIsIFwiYW5pbWF0aW9uZW5kXCJdLCBhbmltYXRlRGF5cyk7XG5cdFx0XHRcdGJpbmQoc2VsZi5tb250aE5hdiwgW1wid2Via2l0QW5pbWF0aW9uRW5kXCIsIFwiYW5pbWF0aW9uZW5kXCJdLCBhbmltYXRlTW9udGhzKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSkge1xuXHRcdFx0dmFyIHNlbFRleHQgPSBmdW5jdGlvbiBzZWxUZXh0KGUpIHtcblx0XHRcdFx0cmV0dXJuIGUudGFyZ2V0LnNlbGVjdCgpO1xuXHRcdFx0fTtcblx0XHRcdGJpbmQoc2VsZi50aW1lQ29udGFpbmVyLCBbXCJ3aGVlbFwiLCBcImlucHV0XCIsIFwiaW5jcmVtZW50XCJdLCB1cGRhdGVUaW1lKTtcblx0XHRcdGJpbmQoc2VsZi50aW1lQ29udGFpbmVyLCBcIm1vdXNlZG93blwiLCBvbkNsaWNrKHRpbWVJbmNyZW1lbnQpKTtcblxuXHRcdFx0YmluZChzZWxmLnRpbWVDb250YWluZXIsIFtcIndoZWVsXCIsIFwiaW5jcmVtZW50XCJdLCBzZWxmLmRlYm91bmNlZENoYW5nZSk7XG5cdFx0XHRiaW5kKHNlbGYudGltZUNvbnRhaW5lciwgXCJpbnB1dFwiLCBzZWxmLnRyaWdnZXJDaGFuZ2UpO1xuXG5cdFx0XHRiaW5kKFtzZWxmLmhvdXJFbGVtZW50LCBzZWxmLm1pbnV0ZUVsZW1lbnRdLCBcImZvY3VzXCIsIHNlbFRleHQpO1xuXG5cdFx0XHRpZiAoc2VsZi5zZWNvbmRFbGVtZW50ICE9PSB1bmRlZmluZWQpIGJpbmQoc2VsZi5zZWNvbmRFbGVtZW50LCBcImZvY3VzXCIsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHNlbGYuc2Vjb25kRWxlbWVudC5zZWxlY3QoKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoc2VsZi5hbVBNICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0YmluZChzZWxmLmFtUE0sIFwibW91c2Vkb3duXCIsIG9uQ2xpY2soZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0XHR1cGRhdGVUaW1lKGUpO1xuXHRcdFx0XHRcdHNlbGYudHJpZ2dlckNoYW5nZShlKTtcblx0XHRcdFx0fSkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHByb2Nlc3NQb3N0RGF5QW5pbWF0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSBzZWxmLl9hbmltYXRpb25Mb29wLmxlbmd0aDsgaS0tOykge1xuXHRcdFx0c2VsZi5fYW5pbWF0aW9uTG9vcFtpXSgpO1xuXHRcdFx0c2VsZi5fYW5pbWF0aW9uTG9vcC5zcGxpY2UoaSwgMSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG4gICogUmVtb3ZlcyB0aGUgZGF5IGNvbnRhaW5lciB0aGF0IHNsaWRlZCBvdXQgb2Ygdmlld1xuICAqIEBwYXJhbSB7RXZlbnR9IGUgdGhlIGFuaW1hdGlvbiBldmVudFxuICAqL1xuXHRmdW5jdGlvbiBhbmltYXRlRGF5cyhlKSB7XG5cdFx0aWYgKHNlbGYuZGF5c0NvbnRhaW5lci5jaGlsZE5vZGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdHN3aXRjaCAoZS5hbmltYXRpb25OYW1lKSB7XG5cdFx0XHRcdGNhc2UgXCJmcFNsaWRlTGVmdFwiOlxuXHRcdFx0XHRcdHNlbGYuZGF5c0NvbnRhaW5lci5sYXN0Q2hpbGQuY2xhc3NMaXN0LnJlbW92ZShcInNsaWRlTGVmdE5ld1wiKTtcblx0XHRcdFx0XHRzZWxmLmRheXNDb250YWluZXIucmVtb3ZlQ2hpbGQoc2VsZi5kYXlzQ29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHRcdHNlbGYuZGF5cyA9IHNlbGYuZGF5c0NvbnRhaW5lci5maXJzdENoaWxkO1xuXHRcdFx0XHRcdHByb2Nlc3NQb3N0RGF5QW5pbWF0aW9uKCk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFwiZnBTbGlkZVJpZ2h0XCI6XG5cdFx0XHRcdFx0c2VsZi5kYXlzQ29udGFpbmVyLmZpcnN0Q2hpbGQuY2xhc3NMaXN0LnJlbW92ZShcInNsaWRlUmlnaHROZXdcIik7XG5cdFx0XHRcdFx0c2VsZi5kYXlzQ29udGFpbmVyLnJlbW92ZUNoaWxkKHNlbGYuZGF5c0NvbnRhaW5lci5sYXN0Q2hpbGQpO1xuXHRcdFx0XHRcdHNlbGYuZGF5cyA9IHNlbGYuZGF5c0NvbnRhaW5lci5maXJzdENoaWxkO1xuXHRcdFx0XHRcdHByb2Nlc3NQb3N0RGF5QW5pbWF0aW9uKCk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuICAqIFJlbW92ZXMgdGhlIG1vbnRoIGVsZW1lbnQgdGhhdCBhbmltYXRlZCBvdXQgb2Ygdmlld1xuICAqIEBwYXJhbSB7RXZlbnR9IGUgdGhlIGFuaW1hdGlvbiBldmVudFxuICAqL1xuXHRmdW5jdGlvbiBhbmltYXRlTW9udGhzKGUpIHtcblx0XHRzd2l0Y2ggKGUuYW5pbWF0aW9uTmFtZSkge1xuXHRcdFx0Y2FzZSBcImZwU2xpZGVMZWZ0TmV3XCI6XG5cdFx0XHRjYXNlIFwiZnBTbGlkZVJpZ2h0TmV3XCI6XG5cdFx0XHRcdHNlbGYubmF2aWdhdGlvbkN1cnJlbnRNb250aC5jbGFzc0xpc3QucmVtb3ZlKFwic2xpZGVMZWZ0TmV3XCIpO1xuXHRcdFx0XHRzZWxmLm5hdmlnYXRpb25DdXJyZW50TW9udGguY2xhc3NMaXN0LnJlbW92ZShcInNsaWRlUmlnaHROZXdcIik7XG5cdFx0XHRcdHZhciBuYXYgPSBzZWxmLm5hdmlnYXRpb25DdXJyZW50TW9udGg7XG5cblx0XHRcdFx0d2hpbGUgKG5hdi5uZXh0U2libGluZyAmJiAvY3Vyci8udGVzdChuYXYubmV4dFNpYmxpbmcuY2xhc3NOYW1lKSkge1xuXHRcdFx0XHRcdHNlbGYubW9udGhOYXYucmVtb3ZlQ2hpbGQobmF2Lm5leHRTaWJsaW5nKTtcblx0XHRcdFx0fXdoaWxlIChuYXYucHJldmlvdXNTaWJsaW5nICYmIC9jdXJyLy50ZXN0KG5hdi5wcmV2aW91c1NpYmxpbmcuY2xhc3NOYW1lKSkge1xuXHRcdFx0XHRcdHNlbGYubW9udGhOYXYucmVtb3ZlQ2hpbGQobmF2LnByZXZpb3VzU2libGluZyk7XG5cdFx0XHRcdH1zZWxmLm9sZEN1ck1vbnRoID0gbnVsbDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG4gICogU2V0IHRoZSBjYWxlbmRhciB2aWV3IHRvIGEgcGFydGljdWxhciBkYXRlLlxuICAqIEBwYXJhbSB7RGF0ZX0ganVtcERhdGUgdGhlIGRhdGUgdG8gc2V0IHRoZSB2aWV3IHRvXG4gICovXG5cdGZ1bmN0aW9uIGp1bXBUb0RhdGUoanVtcERhdGUpIHtcblx0XHRqdW1wRGF0ZSA9IGp1bXBEYXRlID8gc2VsZi5wYXJzZURhdGUoanVtcERhdGUpIDogc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogfHwgKHNlbGYuY29uZmlnLm1pbkRhdGUgPiBzZWxmLm5vdyA/IHNlbGYuY29uZmlnLm1pbkRhdGUgOiBzZWxmLmNvbmZpZy5tYXhEYXRlICYmIHNlbGYuY29uZmlnLm1heERhdGUgPCBzZWxmLm5vdyA/IHNlbGYuY29uZmlnLm1heERhdGUgOiBzZWxmLm5vdyk7XG5cblx0XHR0cnkge1xuXHRcdFx0c2VsZi5jdXJyZW50WWVhciA9IGp1bXBEYXRlLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHRzZWxmLmN1cnJlbnRNb250aCA9IGp1bXBEYXRlLmdldE1vbnRoKCk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0XHRcdGNvbnNvbGUuZXJyb3IoZS5zdGFjayk7XG5cdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRcdFx0Y29uc29sZS53YXJuKFwiSW52YWxpZCBkYXRlIHN1cHBsaWVkOiBcIiArIGp1bXBEYXRlKTtcblx0XHR9XG5cblx0XHRzZWxmLnJlZHJhdygpO1xuXHR9XG5cblx0LyoqXG4gICogVGhlIHVwL2Rvd24gYXJyb3cgaGFuZGxlciBmb3IgdGltZSBpbnB1dHNcbiAgKiBAcGFyYW0ge0V2ZW50fSBlIHRoZSBjbGljayBldmVudFxuICAqL1xuXHRmdW5jdGlvbiB0aW1lSW5jcmVtZW50KGUpIHtcblx0XHRpZiAofmUudGFyZ2V0LmNsYXNzTmFtZS5pbmRleE9mKFwiYXJyb3dcIikpIGluY3JlbWVudE51bUlucHV0KGUsIGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImFycm93VXBcIikgPyAxIDogLTEpO1xuXHR9XG5cblx0LyoqXG4gICogSW5jcmVtZW50cy9kZWNyZW1lbnRzIHRoZSB2YWx1ZSBvZiBpbnB1dCBhc3NvY2ktXG4gICogYXRlZCB3aXRoIHRoZSB1cC9kb3duIGFycm93IGJ5IGRpc3BhdGNoaW5nIGFuXG4gICogXCJpbmNyZW1lbnRcIiBldmVudCBvbiB0aGUgaW5wdXQuXG4gICpcbiAgKiBAcGFyYW0ge0V2ZW50fSBlIHRoZSBjbGljayBldmVudFxuICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YSB0aGUgZGlmZiAodXN1YWxseSAxIG9yIC0xKVxuICAqIEBwYXJhbSB7RWxlbWVudH0gaW5wdXRFbGVtIHRoZSBpbnB1dCBlbGVtZW50XG4gICovXG5cdGZ1bmN0aW9uIGluY3JlbWVudE51bUlucHV0KGUsIGRlbHRhLCBpbnB1dEVsZW0pIHtcblx0XHR2YXIgaW5wdXQgPSBpbnB1dEVsZW0gfHwgZS50YXJnZXQucGFyZW50Tm9kZS5jaGlsZE5vZGVzWzBdO1xuXHRcdHZhciBldmVudCA9IGNyZWF0ZUV2ZW50KFwiaW5jcmVtZW50XCIpO1xuXHRcdGV2ZW50LmRlbHRhID0gZGVsdGE7XG5cdFx0aW5wdXQuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVOdW1iZXJJbnB1dChpbnB1dENsYXNzTmFtZSkge1xuXHRcdHZhciB3cmFwcGVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcIm51bUlucHV0V3JhcHBlclwiKSxcblx0XHQgICAgbnVtSW5wdXQgPSBjcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgXCJudW1JbnB1dCBcIiArIGlucHV0Q2xhc3NOYW1lKSxcblx0XHQgICAgYXJyb3dVcCA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiYXJyb3dVcFwiKSxcblx0XHQgICAgYXJyb3dEb3duID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJhcnJvd0Rvd25cIik7XG5cblx0XHRudW1JbnB1dC50eXBlID0gXCJ0ZXh0XCI7XG5cdFx0bnVtSW5wdXQucGF0dGVybiA9IFwiXFxcXGQqXCI7XG5cblx0XHR3cmFwcGVyLmFwcGVuZENoaWxkKG51bUlucHV0KTtcblx0XHR3cmFwcGVyLmFwcGVuZENoaWxkKGFycm93VXApO1xuXHRcdHdyYXBwZXIuYXBwZW5kQ2hpbGQoYXJyb3dEb3duKTtcblxuXHRcdHJldHVybiB3cmFwcGVyO1xuXHR9XG5cblx0ZnVuY3Rpb24gYnVpbGQoKSB7XG5cdFx0dmFyIGZyYWdtZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRzZWxmLmNhbGVuZGFyQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1jYWxlbmRhclwiKTtcblx0XHRzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnRhYkluZGV4ID0gLTE7XG5cblx0XHRpZiAoIXNlbGYuY29uZmlnLm5vQ2FsZW5kYXIpIHtcblx0XHRcdGZyYWdtZW50LmFwcGVuZENoaWxkKGJ1aWxkTW9udGhOYXYoKSk7XG5cdFx0XHRzZWxmLmlubmVyQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1pbm5lckNvbnRhaW5lclwiKTtcblxuXHRcdFx0aWYgKHNlbGYuY29uZmlnLndlZWtOdW1iZXJzKSBzZWxmLmlubmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKGJ1aWxkV2Vla3MoKSk7XG5cblx0XHRcdHNlbGYuckNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3ItckNvbnRhaW5lclwiKTtcblx0XHRcdHNlbGYuckNvbnRhaW5lci5hcHBlbmRDaGlsZChidWlsZFdlZWtkYXlzKCkpO1xuXG5cdFx0XHRpZiAoIXNlbGYuZGF5c0NvbnRhaW5lcikge1xuXHRcdFx0XHRzZWxmLmRheXNDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLWRheXNcIik7XG5cdFx0XHRcdHNlbGYuZGF5c0NvbnRhaW5lci50YWJJbmRleCA9IC0xO1xuXHRcdFx0fVxuXG5cdFx0XHRidWlsZERheXMoKTtcblx0XHRcdHNlbGYuckNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWxmLmRheXNDb250YWluZXIpO1xuXG5cdFx0XHRzZWxmLmlubmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHNlbGYuckNvbnRhaW5lcik7XG5cdFx0XHRmcmFnbWVudC5hcHBlbmRDaGlsZChzZWxmLmlubmVyQ29udGFpbmVyKTtcblx0XHR9XG5cblx0XHRpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSkgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoYnVpbGRUaW1lKCkpO1xuXG5cdFx0dG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJyYW5nZU1vZGVcIiwgc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiKTtcblx0XHR0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcImFuaW1hdGVcIiwgc2VsZi5jb25maWcuYW5pbWF0ZSk7XG5cblx0XHRzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcblxuXHRcdHZhciBjdXN0b21BcHBlbmQgPSBzZWxmLmNvbmZpZy5hcHBlbmRUbyAmJiBzZWxmLmNvbmZpZy5hcHBlbmRUby5ub2RlVHlwZTtcblxuXHRcdGlmIChzZWxmLmNvbmZpZy5pbmxpbmUgfHwgc2VsZi5jb25maWcuc3RhdGljKSB7XG5cdFx0XHRzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoc2VsZi5jb25maWcuaW5saW5lID8gXCJpbmxpbmVcIiA6IFwic3RhdGljXCIpO1xuXG5cdFx0XHRpZiAoc2VsZi5jb25maWcuaW5saW5lICYmICFjdXN0b21BcHBlbmQpIHtcblx0XHRcdFx0cmV0dXJuIHNlbGYuZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBzZWxmLl9pbnB1dC5uZXh0U2libGluZyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzZWxmLmNvbmZpZy5zdGF0aWMpIHtcblx0XHRcdFx0dmFyIHdyYXBwZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLXdyYXBwZXJcIik7XG5cdFx0XHRcdHNlbGYuZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh3cmFwcGVyLCBzZWxmLmVsZW1lbnQpO1xuXHRcdFx0XHR3cmFwcGVyLmFwcGVuZENoaWxkKHNlbGYuZWxlbWVudCk7XG5cblx0XHRcdFx0aWYgKHNlbGYuYWx0SW5wdXQpIHdyYXBwZXIuYXBwZW5kQ2hpbGQoc2VsZi5hbHRJbnB1dCk7XG5cblx0XHRcdFx0d3JhcHBlci5hcHBlbmRDaGlsZChzZWxmLmNhbGVuZGFyQ29udGFpbmVyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdChjdXN0b21BcHBlbmQgPyBzZWxmLmNvbmZpZy5hcHBlbmRUbyA6IHdpbmRvdy5kb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZChzZWxmLmNhbGVuZGFyQ29udGFpbmVyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZURheShjbGFzc05hbWUsIGRhdGUsIGRheU51bWJlciwgaSkge1xuXHRcdHZhciBkYXRlSXNFbmFibGVkID0gaXNFbmFibGVkKGRhdGUsIHRydWUpLFxuXHRcdCAgICBkYXlFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJmbGF0cGlja3ItZGF5IFwiICsgY2xhc3NOYW1lLCBkYXRlLmdldERhdGUoKSk7XG5cblx0XHRkYXlFbGVtZW50LmRhdGVPYmogPSBkYXRlO1xuXHRcdGRheUVsZW1lbnQuJGkgPSBpO1xuXHRcdGRheUVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBzZWxmLmZvcm1hdERhdGUoZGF0ZSwgc2VsZi5jb25maWcuYXJpYURhdGVGb3JtYXQpKTtcblxuXHRcdGlmIChjb21wYXJlRGF0ZXMoZGF0ZSwgc2VsZi5ub3cpID09PSAwKSB7XG5cdFx0XHRzZWxmLnRvZGF5RGF0ZUVsZW0gPSBkYXlFbGVtZW50O1xuXHRcdFx0ZGF5RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwidG9kYXlcIik7XG5cdFx0fVxuXG5cdFx0aWYgKGRhdGVJc0VuYWJsZWQpIHtcblx0XHRcdGRheUVsZW1lbnQudGFiSW5kZXggPSAtMTtcblx0XHRcdGlmIChpc0RhdGVTZWxlY3RlZChkYXRlKSkge1xuXHRcdFx0XHRkYXlFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcblx0XHRcdFx0c2VsZi5zZWxlY3RlZERhdGVFbGVtID0gZGF5RWxlbWVudDtcblx0XHRcdFx0aWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIikge1xuXHRcdFx0XHRcdHRvZ2dsZUNsYXNzKGRheUVsZW1lbnQsIFwic3RhcnRSYW5nZVwiLCBjb21wYXJlRGF0ZXMoZGF0ZSwgc2VsZi5zZWxlY3RlZERhdGVzWzBdKSA9PT0gMCk7XG5cblx0XHRcdFx0XHR0b2dnbGVDbGFzcyhkYXlFbGVtZW50LCBcImVuZFJhbmdlXCIsIGNvbXBhcmVEYXRlcyhkYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMV0pID09PSAwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXlFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJkaXNhYmxlZFwiKTtcblx0XHRcdGlmIChzZWxmLnNlbGVjdGVkRGF0ZXNbMF0gJiYgZGF0ZSA+IHNlbGYubWluUmFuZ2VEYXRlICYmIGRhdGUgPCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0pIHNlbGYubWluUmFuZ2VEYXRlID0gZGF0ZTtlbHNlIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXNbMF0gJiYgZGF0ZSA8IHNlbGYubWF4UmFuZ2VEYXRlICYmIGRhdGUgPiBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0pIHNlbGYubWF4UmFuZ2VEYXRlID0gZGF0ZTtcblx0XHR9XG5cblx0XHRpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiKSB7XG5cdFx0XHRpZiAoaXNEYXRlSW5SYW5nZShkYXRlKSAmJiAhaXNEYXRlU2VsZWN0ZWQoZGF0ZSkpIGRheUVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImluUmFuZ2VcIik7XG5cblx0XHRcdGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAxICYmIChkYXRlIDwgc2VsZi5taW5SYW5nZURhdGUgfHwgZGF0ZSA+IHNlbGYubWF4UmFuZ2VEYXRlKSkgZGF5RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibm90QWxsb3dlZFwiKTtcblx0XHR9XG5cblx0XHRpZiAoc2VsZi5jb25maWcud2Vla051bWJlcnMgJiYgY2xhc3NOYW1lICE9PSBcInByZXZNb250aERheVwiICYmIGRheU51bWJlciAlIDcgPT09IDEpIHtcblx0XHRcdHNlbGYud2Vla051bWJlcnMuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIFwiPHNwYW4gY2xhc3M9J2Rpc2FibGVkIGZsYXRwaWNrci1kYXknPlwiICsgc2VsZi5jb25maWcuZ2V0V2VlayhkYXRlKSArIFwiPC9zcGFuPlwiKTtcblx0XHR9XG5cblx0XHR0cmlnZ2VyRXZlbnQoXCJEYXlDcmVhdGVcIiwgZGF5RWxlbWVudCk7XG5cblx0XHRyZXR1cm4gZGF5RWxlbWVudDtcblx0fVxuXG5cdGZ1bmN0aW9uIGZvY3VzT25EYXkoY3VycmVudEluZGV4LCBvZmZzZXQpIHtcblx0XHR2YXIgbmV3SW5kZXggPSBjdXJyZW50SW5kZXggKyBvZmZzZXQgfHwgMCxcblx0XHQgICAgdGFyZ2V0Tm9kZSA9IGN1cnJlbnRJbmRleCAhPT0gdW5kZWZpbmVkID8gc2VsZi5kYXlzLmNoaWxkTm9kZXNbbmV3SW5kZXhdIDogc2VsZi5zZWxlY3RlZERhdGVFbGVtIHx8IHNlbGYudG9kYXlEYXRlRWxlbSB8fCBzZWxmLmRheXMuY2hpbGROb2Rlc1swXSxcblx0XHQgICAgZm9jdXMgPSBmdW5jdGlvbiBmb2N1cygpIHtcblx0XHRcdHRhcmdldE5vZGUgPSB0YXJnZXROb2RlIHx8IHNlbGYuZGF5cy5jaGlsZE5vZGVzW25ld0luZGV4XTtcblx0XHRcdHRhcmdldE5vZGUuZm9jdXMoKTtcblxuXHRcdFx0aWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIikgb25Nb3VzZU92ZXIodGFyZ2V0Tm9kZSk7XG5cdFx0fTtcblxuXHRcdGlmICh0YXJnZXROb2RlID09PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSAwKSB7XG5cdFx0XHRpZiAob2Zmc2V0ID4gMCkge1xuXHRcdFx0XHRzZWxmLmNoYW5nZU1vbnRoKDEpO1xuXHRcdFx0XHRuZXdJbmRleCA9IG5ld0luZGV4ICUgNDI7XG5cdFx0XHR9IGVsc2UgaWYgKG9mZnNldCA8IDApIHtcblx0XHRcdFx0c2VsZi5jaGFuZ2VNb250aCgtMSk7XG5cdFx0XHRcdG5ld0luZGV4ICs9IDQyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYWZ0ZXJEYXlBbmltKGZvY3VzKTtcblx0XHR9XG5cblx0XHRmb2N1cygpO1xuXHR9XG5cblx0ZnVuY3Rpb24gYWZ0ZXJEYXlBbmltKGZuKSB7XG5cdFx0aWYgKHNlbGYuY29uZmlnLmFuaW1hdGUgPT09IHRydWUpIHJldHVybiBzZWxmLl9hbmltYXRpb25Mb29wLnB1c2goZm4pO1xuXHRcdGZuKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBidWlsZERheXMoZGVsdGEpIHtcblx0XHR2YXIgZmlyc3RPZk1vbnRoID0gKG5ldyBEYXRlKHNlbGYuY3VycmVudFllYXIsIHNlbGYuY3VycmVudE1vbnRoLCAxKS5nZXREYXkoKSAtIHNlbGYubDEwbi5maXJzdERheU9mV2VlayArIDcpICUgNyxcblx0XHQgICAgaXNSYW5nZU1vZGUgPSBzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCI7XG5cblx0XHRzZWxmLnByZXZNb250aERheXMgPSBzZWxmLnV0aWxzLmdldERheXNpbk1vbnRoKChzZWxmLmN1cnJlbnRNb250aCAtIDEgKyAxMikgJSAxMik7XG5cdFx0c2VsZi5zZWxlY3RlZERhdGVFbGVtID0gdW5kZWZpbmVkO1xuXHRcdHNlbGYudG9kYXlEYXRlRWxlbSA9IHVuZGVmaW5lZDtcblxuXHRcdHZhciBkYXlzSW5Nb250aCA9IHNlbGYudXRpbHMuZ2V0RGF5c2luTW9udGgoKSxcblx0XHQgICAgZGF5cyA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cblx0XHR2YXIgZGF5TnVtYmVyID0gc2VsZi5wcmV2TW9udGhEYXlzICsgMSAtIGZpcnN0T2ZNb250aCxcblx0XHQgICAgZGF5SW5kZXggPSAwO1xuXG5cdFx0aWYgKHNlbGYuY29uZmlnLndlZWtOdW1iZXJzICYmIHNlbGYud2Vla051bWJlcnMuZmlyc3RDaGlsZCkgc2VsZi53ZWVrTnVtYmVycy50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0XHRpZiAoaXNSYW5nZU1vZGUpIHtcblx0XHRcdC8vIGNvbnN0IGRhdGVMaW1pdHMgPSBzZWxmLmNvbmZpZy5lbmFibGUubGVuZ3RoIHx8IHNlbGYuY29uZmlnLmRpc2FibGUubGVuZ3RoIHx8IHNlbGYuY29uZmlnLm1peERhdGUgfHwgc2VsZi5jb25maWcubWF4RGF0ZTtcblx0XHRcdHNlbGYubWluUmFuZ2VEYXRlID0gbmV3IERhdGUoc2VsZi5jdXJyZW50WWVhciwgc2VsZi5jdXJyZW50TW9udGggLSAxLCBkYXlOdW1iZXIpO1xuXHRcdFx0c2VsZi5tYXhSYW5nZURhdGUgPSBuZXcgRGF0ZShzZWxmLmN1cnJlbnRZZWFyLCBzZWxmLmN1cnJlbnRNb250aCArIDEsICg0MiAtIGZpcnN0T2ZNb250aCkgJSBkYXlzSW5Nb250aCk7XG5cdFx0fVxuXG5cdFx0Ly8gcHJlcGVuZCBkYXlzIGZyb20gdGhlIGVuZGluZyBvZiBwcmV2aW91cyBtb250aFxuXHRcdGZvciAoOyBkYXlOdW1iZXIgPD0gc2VsZi5wcmV2TW9udGhEYXlzOyBkYXlOdW1iZXIrKywgZGF5SW5kZXgrKykge1xuXHRcdFx0ZGF5cy5hcHBlbmRDaGlsZChjcmVhdGVEYXkoXCJwcmV2TW9udGhEYXlcIiwgbmV3IERhdGUoc2VsZi5jdXJyZW50WWVhciwgc2VsZi5jdXJyZW50TW9udGggLSAxLCBkYXlOdW1iZXIpLCBkYXlOdW1iZXIsIGRheUluZGV4KSk7XG5cdFx0fVxuXG5cdFx0Ly8gU3RhcnQgYXQgMSBzaW5jZSB0aGVyZSBpcyBubyAwdGggZGF5XG5cdFx0Zm9yIChkYXlOdW1iZXIgPSAxOyBkYXlOdW1iZXIgPD0gZGF5c0luTW9udGg7IGRheU51bWJlcisrLCBkYXlJbmRleCsrKSB7XG5cdFx0XHRkYXlzLmFwcGVuZENoaWxkKGNyZWF0ZURheShcIlwiLCBuZXcgRGF0ZShzZWxmLmN1cnJlbnRZZWFyLCBzZWxmLmN1cnJlbnRNb250aCwgZGF5TnVtYmVyKSwgZGF5TnVtYmVyLCBkYXlJbmRleCkpO1xuXHRcdH1cblxuXHRcdC8vIGFwcGVuZCBkYXlzIGZyb20gdGhlIG5leHQgbW9udGhcblx0XHRmb3IgKHZhciBkYXlOdW0gPSBkYXlzSW5Nb250aCArIDE7IGRheU51bSA8PSA0MiAtIGZpcnN0T2ZNb250aDsgZGF5TnVtKyssIGRheUluZGV4KyspIHtcblx0XHRcdGRheXMuYXBwZW5kQ2hpbGQoY3JlYXRlRGF5KFwibmV4dE1vbnRoRGF5XCIsIG5ldyBEYXRlKHNlbGYuY3VycmVudFllYXIsIHNlbGYuY3VycmVudE1vbnRoICsgMSwgZGF5TnVtICUgZGF5c0luTW9udGgpLCBkYXlOdW0sIGRheUluZGV4KSk7XG5cdFx0fVxuXG5cdFx0aWYgKGlzUmFuZ2VNb2RlICYmIHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDEgJiYgZGF5cy5jaGlsZE5vZGVzWzBdKSB7XG5cdFx0XHRzZWxmLl9oaWRlUHJldk1vbnRoQXJyb3cgPSBzZWxmLl9oaWRlUHJldk1vbnRoQXJyb3cgfHwgc2VsZi5taW5SYW5nZURhdGUgPiBkYXlzLmNoaWxkTm9kZXNbMF0uZGF0ZU9iajtcblxuXHRcdFx0c2VsZi5faGlkZU5leHRNb250aEFycm93ID0gc2VsZi5faGlkZU5leHRNb250aEFycm93IHx8IHNlbGYubWF4UmFuZ2VEYXRlIDwgbmV3IERhdGUoc2VsZi5jdXJyZW50WWVhciwgc2VsZi5jdXJyZW50TW9udGggKyAxLCAxKTtcblx0XHR9IGVsc2UgdXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpO1xuXG5cdFx0dmFyIGRheUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJkYXlDb250YWluZXJcIik7XG5cdFx0ZGF5Q29udGFpbmVyLmFwcGVuZENoaWxkKGRheXMpO1xuXG5cdFx0aWYgKCFzZWxmLmNvbmZpZy5hbmltYXRlIHx8IGRlbHRhID09PSB1bmRlZmluZWQpIGNsZWFyTm9kZShzZWxmLmRheXNDb250YWluZXIpO2Vsc2Uge1xuXHRcdFx0d2hpbGUgKHNlbGYuZGF5c0NvbnRhaW5lci5jaGlsZE5vZGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0c2VsZi5kYXlzQ29udGFpbmVyLnJlbW92ZUNoaWxkKHNlbGYuZGF5c0NvbnRhaW5lci5maXJzdENoaWxkKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZGVsdGEgPj0gMCkgc2VsZi5kYXlzQ29udGFpbmVyLmFwcGVuZENoaWxkKGRheUNvbnRhaW5lcik7ZWxzZSBzZWxmLmRheXNDb250YWluZXIuaW5zZXJ0QmVmb3JlKGRheUNvbnRhaW5lciwgc2VsZi5kYXlzQ29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuXG5cdFx0c2VsZi5kYXlzID0gc2VsZi5kYXlzQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG5cdFx0cmV0dXJuIHNlbGYuZGF5c0NvbnRhaW5lcjtcblx0fVxuXG5cdGZ1bmN0aW9uIGNsZWFyTm9kZShub2RlKSB7XG5cdFx0d2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0bm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGJ1aWxkTW9udGhOYXYoKSB7XG5cdFx0dmFyIG1vbnRoTmF2RnJhZ21lbnQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdHNlbGYubW9udGhOYXYgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLW1vbnRoXCIpO1xuXG5cdFx0c2VsZi5wcmV2TW9udGhOYXYgPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImZsYXRwaWNrci1wcmV2LW1vbnRoXCIpO1xuXHRcdHNlbGYucHJldk1vbnRoTmF2LmlubmVySFRNTCA9IHNlbGYuY29uZmlnLnByZXZBcnJvdztcblxuXHRcdHNlbGYuY3VycmVudE1vbnRoRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiY3VyLW1vbnRoXCIpO1xuXHRcdHNlbGYuY3VycmVudE1vbnRoRWxlbWVudC50aXRsZSA9IHNlbGYubDEwbi5zY3JvbGxUaXRsZTtcblxuXHRcdHZhciB5ZWFySW5wdXQgPSBjcmVhdGVOdW1iZXJJbnB1dChcImN1ci15ZWFyXCIpO1xuXHRcdHNlbGYuY3VycmVudFllYXJFbGVtZW50ID0geWVhcklucHV0LmNoaWxkTm9kZXNbMF07XG5cdFx0c2VsZi5jdXJyZW50WWVhckVsZW1lbnQudGl0bGUgPSBzZWxmLmwxMG4uc2Nyb2xsVGl0bGU7XG5cblx0XHRpZiAoc2VsZi5jb25maWcubWluRGF0ZSkgc2VsZi5jdXJyZW50WWVhckVsZW1lbnQubWluID0gc2VsZi5jb25maWcubWluRGF0ZS5nZXRGdWxsWWVhcigpO1xuXG5cdFx0aWYgKHNlbGYuY29uZmlnLm1heERhdGUpIHtcblx0XHRcdHNlbGYuY3VycmVudFllYXJFbGVtZW50Lm1heCA9IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0RnVsbFllYXIoKTtcblxuXHRcdFx0c2VsZi5jdXJyZW50WWVhckVsZW1lbnQuZGlzYWJsZWQgPSBzZWxmLmNvbmZpZy5taW5EYXRlICYmIHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdH1cblxuXHRcdHNlbGYubmV4dE1vbnRoTmF2ID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJmbGF0cGlja3ItbmV4dC1tb250aFwiKTtcblx0XHRzZWxmLm5leHRNb250aE5hdi5pbm5lckhUTUwgPSBzZWxmLmNvbmZpZy5uZXh0QXJyb3c7XG5cblx0XHRzZWxmLm5hdmlnYXRpb25DdXJyZW50TW9udGggPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImZsYXRwaWNrci1jdXJyZW50LW1vbnRoXCIpO1xuXHRcdHNlbGYubmF2aWdhdGlvbkN1cnJlbnRNb250aC5hcHBlbmRDaGlsZChzZWxmLmN1cnJlbnRNb250aEVsZW1lbnQpO1xuXHRcdHNlbGYubmF2aWdhdGlvbkN1cnJlbnRNb250aC5hcHBlbmRDaGlsZCh5ZWFySW5wdXQpO1xuXG5cdFx0bW9udGhOYXZGcmFnbWVudC5hcHBlbmRDaGlsZChzZWxmLnByZXZNb250aE5hdik7XG5cdFx0bW9udGhOYXZGcmFnbWVudC5hcHBlbmRDaGlsZChzZWxmLm5hdmlnYXRpb25DdXJyZW50TW9udGgpO1xuXHRcdG1vbnRoTmF2RnJhZ21lbnQuYXBwZW5kQ2hpbGQoc2VsZi5uZXh0TW9udGhOYXYpO1xuXHRcdHNlbGYubW9udGhOYXYuYXBwZW5kQ2hpbGQobW9udGhOYXZGcmFnbWVudCk7XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgXCJfaGlkZVByZXZNb250aEFycm93XCIsIHtcblx0XHRcdGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fX2hpZGVQcmV2TW9udGhBcnJvdztcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uIHNldChib29sKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9faGlkZVByZXZNb250aEFycm93ICE9PSBib29sKSBzZWxmLnByZXZNb250aE5hdi5zdHlsZS5kaXNwbGF5ID0gYm9vbCA/IFwibm9uZVwiIDogXCJibG9ja1wiO1xuXHRcdFx0XHR0aGlzLl9faGlkZVByZXZNb250aEFycm93ID0gYm9vbDtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBcIl9oaWRlTmV4dE1vbnRoQXJyb3dcIiwge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9faGlkZU5leHRNb250aEFycm93O1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gc2V0KGJvb2wpIHtcblx0XHRcdFx0aWYgKHRoaXMuX19oaWRlTmV4dE1vbnRoQXJyb3cgIT09IGJvb2wpIHNlbGYubmV4dE1vbnRoTmF2LnN0eWxlLmRpc3BsYXkgPSBib29sID8gXCJub25lXCIgOiBcImJsb2NrXCI7XG5cdFx0XHRcdHRoaXMuX19oaWRlTmV4dE1vbnRoQXJyb3cgPSBib29sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpO1xuXG5cdFx0cmV0dXJuIHNlbGYubW9udGhOYXY7XG5cdH1cblxuXHRmdW5jdGlvbiBidWlsZFRpbWUoKSB7XG5cdFx0c2VsZi5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGFzVGltZVwiKTtcblx0XHRpZiAoc2VsZi5jb25maWcubm9DYWxlbmRhcikgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibm9DYWxlbmRhclwiKTtcblx0XHRzZWxmLnRpbWVDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLXRpbWVcIik7XG5cdFx0c2VsZi50aW1lQ29udGFpbmVyLnRhYkluZGV4ID0gLTE7XG5cdFx0dmFyIHNlcGFyYXRvciA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLXRpbWUtc2VwYXJhdG9yXCIsIFwiOlwiKTtcblxuXHRcdHZhciBob3VySW5wdXQgPSBjcmVhdGVOdW1iZXJJbnB1dChcImZsYXRwaWNrci1ob3VyXCIpO1xuXHRcdHNlbGYuaG91ckVsZW1lbnQgPSBob3VySW5wdXQuY2hpbGROb2Rlc1swXTtcblxuXHRcdHZhciBtaW51dGVJbnB1dCA9IGNyZWF0ZU51bWJlcklucHV0KFwiZmxhdHBpY2tyLW1pbnV0ZVwiKTtcblx0XHRzZWxmLm1pbnV0ZUVsZW1lbnQgPSBtaW51dGVJbnB1dC5jaGlsZE5vZGVzWzBdO1xuXG5cdFx0c2VsZi5ob3VyRWxlbWVudC50YWJJbmRleCA9IHNlbGYubWludXRlRWxlbWVudC50YWJJbmRleCA9IC0xO1xuXG5cdFx0c2VsZi5ob3VyRWxlbWVudC52YWx1ZSA9IHNlbGYucGFkKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqID8gc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmouZ2V0SG91cnMoKSA6IHNlbGYuY29uZmlnLmRlZmF1bHRIb3VyKTtcblxuXHRcdHNlbGYubWludXRlRWxlbWVudC52YWx1ZSA9IHNlbGYucGFkKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqID8gc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmouZ2V0TWludXRlcygpIDogc2VsZi5jb25maWcuZGVmYXVsdE1pbnV0ZSk7XG5cblx0XHRzZWxmLmhvdXJFbGVtZW50LnN0ZXAgPSBzZWxmLmNvbmZpZy5ob3VySW5jcmVtZW50O1xuXHRcdHNlbGYubWludXRlRWxlbWVudC5zdGVwID0gc2VsZi5jb25maWcubWludXRlSW5jcmVtZW50O1xuXG5cdFx0c2VsZi5ob3VyRWxlbWVudC5taW4gPSBzZWxmLmNvbmZpZy50aW1lXzI0aHIgPyAwIDogMTtcblx0XHRzZWxmLmhvdXJFbGVtZW50Lm1heCA9IHNlbGYuY29uZmlnLnRpbWVfMjRociA/IDIzIDogMTI7XG5cblx0XHRzZWxmLm1pbnV0ZUVsZW1lbnQubWluID0gMDtcblx0XHRzZWxmLm1pbnV0ZUVsZW1lbnQubWF4ID0gNTk7XG5cblx0XHRzZWxmLmhvdXJFbGVtZW50LnRpdGxlID0gc2VsZi5taW51dGVFbGVtZW50LnRpdGxlID0gc2VsZi5sMTBuLnNjcm9sbFRpdGxlO1xuXG5cdFx0c2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKGhvdXJJbnB1dCk7XG5cdFx0c2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKHNlcGFyYXRvcik7XG5cdFx0c2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKG1pbnV0ZUlucHV0KTtcblxuXHRcdGlmIChzZWxmLmNvbmZpZy50aW1lXzI0aHIpIHNlbGYudGltZUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidGltZTI0aHJcIik7XG5cblx0XHRpZiAoc2VsZi5jb25maWcuZW5hYmxlU2Vjb25kcykge1xuXHRcdFx0c2VsZi50aW1lQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoYXNTZWNvbmRzXCIpO1xuXG5cdFx0XHR2YXIgc2Vjb25kSW5wdXQgPSBjcmVhdGVOdW1iZXJJbnB1dChcImZsYXRwaWNrci1zZWNvbmRcIik7XG5cdFx0XHRzZWxmLnNlY29uZEVsZW1lbnQgPSBzZWNvbmRJbnB1dC5jaGlsZE5vZGVzWzBdO1xuXG5cdFx0XHRzZWxmLnNlY29uZEVsZW1lbnQudmFsdWUgPSBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiA/IHNlbGYucGFkKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLmdldFNlY29uZHMoKSkgOiBcIjAwXCI7XG5cblx0XHRcdHNlbGYuc2Vjb25kRWxlbWVudC5zdGVwID0gc2VsZi5taW51dGVFbGVtZW50LnN0ZXA7XG5cdFx0XHRzZWxmLnNlY29uZEVsZW1lbnQubWluID0gc2VsZi5taW51dGVFbGVtZW50Lm1pbjtcblx0XHRcdHNlbGYuc2Vjb25kRWxlbWVudC5tYXggPSBzZWxmLm1pbnV0ZUVsZW1lbnQubWF4O1xuXG5cdFx0XHRzZWxmLnRpbWVDb250YWluZXIuYXBwZW5kQ2hpbGQoY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJmbGF0cGlja3ItdGltZS1zZXBhcmF0b3JcIiwgXCI6XCIpKTtcblx0XHRcdHNlbGYudGltZUNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWNvbmRJbnB1dCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFzZWxmLmNvbmZpZy50aW1lXzI0aHIpIHtcblx0XHRcdC8vIGFkZCBzZWxmLmFtUE0gaWYgYXBwcm9wcmlhdGVcblx0XHRcdHNlbGYuYW1QTSA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLWFtLXBtXCIsIFtcIkFNXCIsIFwiUE1cIl1bc2VsZi5ob3VyRWxlbWVudC52YWx1ZSA+IDExIHwgMF0pO1xuXHRcdFx0c2VsZi5hbVBNLnRpdGxlID0gc2VsZi5sMTBuLnRvZ2dsZVRpdGxlO1xuXHRcdFx0c2VsZi5hbVBNLnRhYkluZGV4ID0gLTE7XG5cdFx0XHRzZWxmLnRpbWVDb250YWluZXIuYXBwZW5kQ2hpbGQoc2VsZi5hbVBNKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc2VsZi50aW1lQ29udGFpbmVyO1xuXHR9XG5cblx0ZnVuY3Rpb24gYnVpbGRXZWVrZGF5cygpIHtcblx0XHRpZiAoIXNlbGYud2Vla2RheUNvbnRhaW5lcikgc2VsZi53ZWVrZGF5Q29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci13ZWVrZGF5c1wiKTtcblxuXHRcdHZhciBmaXJzdERheU9mV2VlayA9IHNlbGYubDEwbi5maXJzdERheU9mV2Vlaztcblx0XHR2YXIgd2Vla2RheXMgPSBzZWxmLmwxMG4ud2Vla2RheXMuc2hvcnRoYW5kLnNsaWNlKCk7XG5cblx0XHRpZiAoZmlyc3REYXlPZldlZWsgPiAwICYmIGZpcnN0RGF5T2ZXZWVrIDwgd2Vla2RheXMubGVuZ3RoKSB7XG5cdFx0XHR3ZWVrZGF5cyA9IFtdLmNvbmNhdCh3ZWVrZGF5cy5zcGxpY2UoZmlyc3REYXlPZldlZWssIHdlZWtkYXlzLmxlbmd0aCksIHdlZWtkYXlzLnNwbGljZSgwLCBmaXJzdERheU9mV2VlaykpO1xuXHRcdH1cblxuXHRcdHNlbGYud2Vla2RheUNvbnRhaW5lci5pbm5lckhUTUwgPSBcIlxcblxcdFxcdDxzcGFuIGNsYXNzPWZsYXRwaWNrci13ZWVrZGF5PlxcblxcdFxcdFxcdFwiICsgd2Vla2RheXMuam9pbihcIjwvc3Bhbj48c3BhbiBjbGFzcz1mbGF0cGlja3Itd2Vla2RheT5cIikgKyBcIlxcblxcdFxcdDwvc3Bhbj5cXG5cXHRcXHRcIjtcblxuXHRcdHJldHVybiBzZWxmLndlZWtkYXlDb250YWluZXI7XG5cdH1cblxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRmdW5jdGlvbiBidWlsZFdlZWtzKCkge1xuXHRcdHNlbGYuY2FsZW5kYXJDb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhhc1dlZWtzXCIpO1xuXHRcdHNlbGYud2Vla1dyYXBwZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLXdlZWt3cmFwcGVyXCIpO1xuXHRcdHNlbGYud2Vla1dyYXBwZXIuYXBwZW5kQ2hpbGQoY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJmbGF0cGlja3Itd2Vla2RheVwiLCBzZWxmLmwxMG4ud2Vla0FiYnJldmlhdGlvbikpO1xuXHRcdHNlbGYud2Vla051bWJlcnMgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLXdlZWtzXCIpO1xuXHRcdHNlbGYud2Vla1dyYXBwZXIuYXBwZW5kQ2hpbGQoc2VsZi53ZWVrTnVtYmVycyk7XG5cblx0XHRyZXR1cm4gc2VsZi53ZWVrV3JhcHBlcjtcblx0fVxuXG5cdGZ1bmN0aW9uIGNoYW5nZU1vbnRoKHZhbHVlLCBpc19vZmZzZXQsIGFuaW1hdGUpIHtcblx0XHRpc19vZmZzZXQgPSBpc19vZmZzZXQgPT09IHVuZGVmaW5lZCB8fCBpc19vZmZzZXQ7XG5cdFx0dmFyIGRlbHRhID0gaXNfb2Zmc2V0ID8gdmFsdWUgOiB2YWx1ZSAtIHNlbGYuY3VycmVudE1vbnRoO1xuXHRcdHZhciBza2lwQW5pbWF0aW9ucyA9ICFzZWxmLmNvbmZpZy5hbmltYXRlIHx8IGFuaW1hdGUgPT09IGZhbHNlO1xuXG5cdFx0aWYgKGRlbHRhIDwgMCAmJiBzZWxmLl9oaWRlUHJldk1vbnRoQXJyb3cgfHwgZGVsdGEgPiAwICYmIHNlbGYuX2hpZGVOZXh0TW9udGhBcnJvdykgcmV0dXJuO1xuXG5cdFx0c2VsZi5jdXJyZW50TW9udGggKz0gZGVsdGE7XG5cblx0XHRpZiAoc2VsZi5jdXJyZW50TW9udGggPCAwIHx8IHNlbGYuY3VycmVudE1vbnRoID4gMTEpIHtcblx0XHRcdHNlbGYuY3VycmVudFllYXIgKz0gc2VsZi5jdXJyZW50TW9udGggPiAxMSA/IDEgOiAtMTtcblx0XHRcdHNlbGYuY3VycmVudE1vbnRoID0gKHNlbGYuY3VycmVudE1vbnRoICsgMTIpICUgMTI7XG5cblx0XHRcdHRyaWdnZXJFdmVudChcIlllYXJDaGFuZ2VcIik7XG5cdFx0fVxuXG5cdFx0YnVpbGREYXlzKCFza2lwQW5pbWF0aW9ucyA/IGRlbHRhIDogdW5kZWZpbmVkKTtcblxuXHRcdGlmIChza2lwQW5pbWF0aW9ucykge1xuXHRcdFx0dHJpZ2dlckV2ZW50KFwiTW9udGhDaGFuZ2VcIik7XG5cdFx0XHRyZXR1cm4gdXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpO1xuXHRcdH1cblxuXHRcdC8vIHJlbW92ZSBwb3NzaWJsZSByZW1uYW50cyBmcm9tIGNsaWNraW5nIHRvbyBmYXN0XG5cdFx0dmFyIG5hdiA9IHNlbGYubmF2aWdhdGlvbkN1cnJlbnRNb250aDtcblx0XHRpZiAoZGVsdGEgPCAwKSB7XG5cdFx0XHR3aGlsZSAobmF2Lm5leHRTaWJsaW5nICYmIC9jdXJyLy50ZXN0KG5hdi5uZXh0U2libGluZy5jbGFzc05hbWUpKSB7XG5cdFx0XHRcdHNlbGYubW9udGhOYXYucmVtb3ZlQ2hpbGQobmF2Lm5leHRTaWJsaW5nKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGRlbHRhID4gMCkge1xuXHRcdFx0d2hpbGUgKG5hdi5wcmV2aW91c1NpYmxpbmcgJiYgL2N1cnIvLnRlc3QobmF2LnByZXZpb3VzU2libGluZy5jbGFzc05hbWUpKSB7XG5cdFx0XHRcdHNlbGYubW9udGhOYXYucmVtb3ZlQ2hpbGQobmF2LnByZXZpb3VzU2libGluZyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2VsZi5vbGRDdXJNb250aCA9IHNlbGYubmF2aWdhdGlvbkN1cnJlbnRNb250aDtcblxuXHRcdHNlbGYubmF2aWdhdGlvbkN1cnJlbnRNb250aCA9IHNlbGYubW9udGhOYXYuaW5zZXJ0QmVmb3JlKHNlbGYub2xkQ3VyTW9udGguY2xvbmVOb2RlKHRydWUpLCBkZWx0YSA+IDAgPyBzZWxmLm9sZEN1ck1vbnRoLm5leHRTaWJsaW5nIDogc2VsZi5vbGRDdXJNb250aCk7XG5cblx0XHRpZiAoZGVsdGEgPiAwKSB7XG5cdFx0XHRzZWxmLmRheXNDb250YWluZXIuZmlyc3RDaGlsZC5jbGFzc0xpc3QuYWRkKFwic2xpZGVMZWZ0XCIpO1xuXHRcdFx0c2VsZi5kYXlzQ29udGFpbmVyLmxhc3RDaGlsZC5jbGFzc0xpc3QuYWRkKFwic2xpZGVMZWZ0TmV3XCIpO1xuXG5cdFx0XHRzZWxmLm9sZEN1ck1vbnRoLmNsYXNzTGlzdC5hZGQoXCJzbGlkZUxlZnRcIik7XG5cdFx0XHRzZWxmLm5hdmlnYXRpb25DdXJyZW50TW9udGguY2xhc3NMaXN0LmFkZChcInNsaWRlTGVmdE5ld1wiKTtcblx0XHR9IGVsc2UgaWYgKGRlbHRhIDwgMCkge1xuXHRcdFx0c2VsZi5kYXlzQ29udGFpbmVyLmZpcnN0Q2hpbGQuY2xhc3NMaXN0LmFkZChcInNsaWRlUmlnaHROZXdcIik7XG5cdFx0XHRzZWxmLmRheXNDb250YWluZXIubGFzdENoaWxkLmNsYXNzTGlzdC5hZGQoXCJzbGlkZVJpZ2h0XCIpO1xuXG5cdFx0XHRzZWxmLm9sZEN1ck1vbnRoLmNsYXNzTGlzdC5hZGQoXCJzbGlkZVJpZ2h0XCIpO1xuXHRcdFx0c2VsZi5uYXZpZ2F0aW9uQ3VycmVudE1vbnRoLmNsYXNzTGlzdC5hZGQoXCJzbGlkZVJpZ2h0TmV3XCIpO1xuXHRcdH1cblxuXHRcdHNlbGYuY3VycmVudE1vbnRoRWxlbWVudCA9IHNlbGYubmF2aWdhdGlvbkN1cnJlbnRNb250aC5maXJzdENoaWxkO1xuXHRcdHNlbGYuY3VycmVudFllYXJFbGVtZW50ID0gc2VsZi5uYXZpZ2F0aW9uQ3VycmVudE1vbnRoLmxhc3RDaGlsZC5jaGlsZE5vZGVzWzBdO1xuXG5cdFx0dXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpO1xuXHRcdHNlbGYub2xkQ3VyTW9udGguZmlyc3RDaGlsZC50ZXh0Q29udGVudCA9IHNlbGYudXRpbHMubW9udGhUb1N0cihzZWxmLmN1cnJlbnRNb250aCAtIGRlbHRhKTtcblxuXHRcdHRyaWdnZXJFdmVudChcIk1vbnRoQ2hhbmdlXCIpO1xuXG5cdFx0aWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC4kaSkge1xuXHRcdFx0dmFyIGluZGV4ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudC4kaTtcblx0XHRcdGFmdGVyRGF5QW5pbShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGZvY3VzT25EYXkoaW5kZXgsIDApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gY2xlYXIodHJpZ2dlckNoYW5nZUV2ZW50KSB7XG5cdFx0c2VsZi5pbnB1dC52YWx1ZSA9IFwiXCI7XG5cblx0XHRpZiAoc2VsZi5hbHRJbnB1dCkgc2VsZi5hbHRJbnB1dC52YWx1ZSA9IFwiXCI7XG5cblx0XHRpZiAoc2VsZi5tb2JpbGVJbnB1dCkgc2VsZi5tb2JpbGVJbnB1dC52YWx1ZSA9IFwiXCI7XG5cblx0XHRzZWxmLnNlbGVjdGVkRGF0ZXMgPSBbXTtcblx0XHRzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiA9IHVuZGVmaW5lZDtcblx0XHRzZWxmLnNob3dUaW1lSW5wdXQgPSBmYWxzZTtcblxuXHRcdHNlbGYucmVkcmF3KCk7XG5cblx0XHRpZiAodHJpZ2dlckNoYW5nZUV2ZW50ICE9PSBmYWxzZSlcblx0XHRcdC8vIHRyaWdnZXJDaGFuZ2VFdmVudCBpcyB0cnVlIChkZWZhdWx0KSBvciBhbiBFdmVudFxuXHRcdFx0dHJpZ2dlckV2ZW50KFwiQ2hhbmdlXCIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2xvc2UoKSB7XG5cdFx0c2VsZi5pc09wZW4gPSBmYWxzZTtcblxuXHRcdGlmICghc2VsZi5pc01vYmlsZSkge1xuXHRcdFx0c2VsZi5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwib3BlblwiKTtcblx0XHRcdHNlbGYuX2lucHV0LmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIik7XG5cdFx0fVxuXG5cdFx0dHJpZ2dlckV2ZW50KFwiQ2xvc2VcIik7XG5cdH1cblxuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGZvciAodmFyIGkgPSBzZWxmLl9oYW5kbGVycy5sZW5ndGg7IGktLTspIHtcblx0XHRcdHZhciBoID0gc2VsZi5faGFuZGxlcnNbaV07XG5cdFx0XHRoLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihoLmV2ZW50LCBoLmhhbmRsZXIpO1xuXHRcdH1cblxuXHRcdHNlbGYuX2hhbmRsZXJzID0gW107XG5cblx0XHRpZiAoc2VsZi5tb2JpbGVJbnB1dCkge1xuXHRcdFx0aWYgKHNlbGYubW9iaWxlSW5wdXQucGFyZW50Tm9kZSkgc2VsZi5tb2JpbGVJbnB1dC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlbGYubW9iaWxlSW5wdXQpO1xuXHRcdFx0c2VsZi5tb2JpbGVJbnB1dCA9IG51bGw7XG5cdFx0fSBlbHNlIGlmIChzZWxmLmNhbGVuZGFyQ29udGFpbmVyICYmIHNlbGYuY2FsZW5kYXJDb250YWluZXIucGFyZW50Tm9kZSkgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlbGYuY2FsZW5kYXJDb250YWluZXIpO1xuXG5cdFx0aWYgKHNlbGYuYWx0SW5wdXQpIHtcblx0XHRcdHNlbGYuaW5wdXQudHlwZSA9IFwidGV4dFwiO1xuXHRcdFx0aWYgKHNlbGYuYWx0SW5wdXQucGFyZW50Tm9kZSkgc2VsZi5hbHRJbnB1dC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlbGYuYWx0SW5wdXQpO1xuXHRcdFx0ZGVsZXRlIHNlbGYuYWx0SW5wdXQ7XG5cdFx0fVxuXG5cdFx0aWYgKHNlbGYuaW5wdXQpIHtcblx0XHRcdHNlbGYuaW5wdXQudHlwZSA9IHNlbGYuaW5wdXQuX3R5cGU7XG5cdFx0XHRzZWxmLmlucHV0LmNsYXNzTGlzdC5yZW1vdmUoXCJmbGF0cGlja3ItaW5wdXRcIik7XG5cdFx0XHRzZWxmLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShcInJlYWRvbmx5XCIpO1xuXHRcdFx0c2VsZi5pbnB1dC52YWx1ZSA9IFwiXCI7XG5cdFx0fVxuXG5cdFx0W1wiX3Nob3dUaW1lSW5wdXRcIiwgXCJsYXRlc3RTZWxlY3RlZERhdGVPYmpcIiwgXCJfaGlkZU5leHRNb250aEFycm93XCIsIFwiX2hpZGVQcmV2TW9udGhBcnJvd1wiLCBcIl9faGlkZU5leHRNb250aEFycm93XCIsIFwiX19oaWRlUHJldk1vbnRoQXJyb3dcIiwgXCJpc01vYmlsZVwiLCBcImlzT3BlblwiLCBcInNlbGVjdGVkRGF0ZUVsZW1cIiwgXCJtaW5EYXRlSGFzVGltZVwiLCBcIm1heERhdGVIYXNUaW1lXCIsIFwiZGF5c1wiLCBcImRheXNDb250YWluZXJcIiwgXCJfaW5wdXRcIiwgXCJfcG9zaXRpb25FbGVtZW50XCIsIFwiaW5uZXJDb250YWluZXJcIiwgXCJyQ29udGFpbmVyXCIsIFwibW9udGhOYXZcIiwgXCJ0b2RheURhdGVFbGVtXCIsIFwiY2FsZW5kYXJDb250YWluZXJcIiwgXCJ3ZWVrZGF5Q29udGFpbmVyXCIsIFwicHJldk1vbnRoTmF2XCIsIFwibmV4dE1vbnRoTmF2XCIsIFwiY3VycmVudE1vbnRoRWxlbWVudFwiLCBcImN1cnJlbnRZZWFyRWxlbWVudFwiLCBcIm5hdmlnYXRpb25DdXJyZW50TW9udGhcIiwgXCJzZWxlY3RlZERhdGVFbGVtXCIsIFwiY29uZmlnXCJdLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0XHRcdHJldHVybiBkZWxldGUgc2VsZltrXTtcblx0XHR9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzQ2FsZW5kYXJFbGVtKGVsZW0pIHtcblx0XHRpZiAoc2VsZi5jb25maWcuYXBwZW5kVG8gJiYgc2VsZi5jb25maWcuYXBwZW5kVG8uY29udGFpbnMoZWxlbSkpIHJldHVybiB0cnVlO1xuXG5cdFx0cmV0dXJuIHNlbGYuY2FsZW5kYXJDb250YWluZXIuY29udGFpbnMoZWxlbSk7XG5cdH1cblxuXHRmdW5jdGlvbiBkb2N1bWVudENsaWNrKGUpIHtcblx0XHRpZiAoc2VsZi5pc09wZW4gJiYgIXNlbGYuY29uZmlnLmlubGluZSkge1xuXHRcdFx0dmFyIGlzQ2FsZW5kYXJFbGVtZW50ID0gaXNDYWxlbmRhckVsZW0oZS50YXJnZXQpO1xuXHRcdFx0dmFyIGlzSW5wdXQgPSBlLnRhcmdldCA9PT0gc2VsZi5pbnB1dCB8fCBlLnRhcmdldCA9PT0gc2VsZi5hbHRJbnB1dCB8fCBzZWxmLmVsZW1lbnQuY29udGFpbnMoZS50YXJnZXQpIHx8XG5cdFx0XHQvLyB3ZWIgY29tcG9uZW50c1xuXHRcdFx0ZS5wYXRoICYmIGUucGF0aC5pbmRleE9mICYmICh+ZS5wYXRoLmluZGV4T2Yoc2VsZi5pbnB1dCkgfHwgfmUucGF0aC5pbmRleE9mKHNlbGYuYWx0SW5wdXQpKTtcblxuXHRcdFx0dmFyIGxvc3RGb2N1cyA9IGUudHlwZSA9PT0gXCJibHVyXCIgPyBpc0lucHV0ICYmIGUucmVsYXRlZFRhcmdldCAmJiAhaXNDYWxlbmRhckVsZW0oZS5yZWxhdGVkVGFyZ2V0KSA6ICFpc0lucHV0ICYmICFpc0NhbGVuZGFyRWxlbWVudDtcblxuXHRcdFx0aWYgKGxvc3RGb2N1cykge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdHNlbGYuY2xvc2UoKTtcblxuXHRcdFx0XHRpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiICYmIHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0XHRzZWxmLmNsZWFyKGZhbHNlKTtcblx0XHRcdFx0XHRzZWxmLnJlZHJhdygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gY2hhbmdlWWVhcihuZXdZZWFyKSB7XG5cdFx0aWYgKCFuZXdZZWFyIHx8IHNlbGYuY3VycmVudFllYXJFbGVtZW50Lm1pbiAmJiBuZXdZZWFyIDwgc2VsZi5jdXJyZW50WWVhckVsZW1lbnQubWluIHx8IHNlbGYuY3VycmVudFllYXJFbGVtZW50Lm1heCAmJiBuZXdZZWFyID4gc2VsZi5jdXJyZW50WWVhckVsZW1lbnQubWF4KSByZXR1cm47XG5cblx0XHR2YXIgbmV3WWVhck51bSA9IHBhcnNlSW50KG5ld1llYXIsIDEwKSxcblx0XHQgICAgaXNOZXdZZWFyID0gc2VsZi5jdXJyZW50WWVhciAhPT0gbmV3WWVhck51bTtcblxuXHRcdHNlbGYuY3VycmVudFllYXIgPSBuZXdZZWFyTnVtIHx8IHNlbGYuY3VycmVudFllYXI7XG5cblx0XHRpZiAoc2VsZi5jb25maWcubWF4RGF0ZSAmJiBzZWxmLmN1cnJlbnRZZWFyID09PSBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEZ1bGxZZWFyKCkpIHtcblx0XHRcdHNlbGYuY3VycmVudE1vbnRoID0gTWF0aC5taW4oc2VsZi5jb25maWcubWF4RGF0ZS5nZXRNb250aCgpLCBzZWxmLmN1cnJlbnRNb250aCk7XG5cdFx0fSBlbHNlIGlmIChzZWxmLmNvbmZpZy5taW5EYXRlICYmIHNlbGYuY3VycmVudFllYXIgPT09IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0RnVsbFllYXIoKSkge1xuXHRcdFx0c2VsZi5jdXJyZW50TW9udGggPSBNYXRoLm1heChzZWxmLmNvbmZpZy5taW5EYXRlLmdldE1vbnRoKCksIHNlbGYuY3VycmVudE1vbnRoKTtcblx0XHR9XG5cblx0XHRpZiAoaXNOZXdZZWFyKSB7XG5cdFx0XHRzZWxmLnJlZHJhdygpO1xuXHRcdFx0dHJpZ2dlckV2ZW50KFwiWWVhckNoYW5nZVwiKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBpc0VuYWJsZWQoZGF0ZSwgdGltZWxlc3MpIHtcblx0XHRpZiAoc2VsZi5jb25maWcubWluRGF0ZSAmJiBjb21wYXJlRGF0ZXMoZGF0ZSwgc2VsZi5jb25maWcubWluRGF0ZSwgdGltZWxlc3MgIT09IHVuZGVmaW5lZCA/IHRpbWVsZXNzIDogIXNlbGYubWluRGF0ZUhhc1RpbWUpIDwgMCB8fCBzZWxmLmNvbmZpZy5tYXhEYXRlICYmIGNvbXBhcmVEYXRlcyhkYXRlLCBzZWxmLmNvbmZpZy5tYXhEYXRlLCB0aW1lbGVzcyAhPT0gdW5kZWZpbmVkID8gdGltZWxlc3MgOiAhc2VsZi5tYXhEYXRlSGFzVGltZSkgPiAwKSByZXR1cm4gZmFsc2U7XG5cblx0XHRpZiAoIXNlbGYuY29uZmlnLmVuYWJsZS5sZW5ndGggJiYgIXNlbGYuY29uZmlnLmRpc2FibGUubGVuZ3RoKSByZXR1cm4gdHJ1ZTtcblxuXHRcdHZhciBkYXRlVG9DaGVjayA9IHNlbGYucGFyc2VEYXRlKGRhdGUsIG51bGwsIHRydWUpOyAvLyB0aW1lbGVzc1xuXG5cdFx0dmFyIGJvb2wgPSBzZWxmLmNvbmZpZy5lbmFibGUubGVuZ3RoID4gMCxcblx0XHQgICAgYXJyYXkgPSBib29sID8gc2VsZi5jb25maWcuZW5hYmxlIDogc2VsZi5jb25maWcuZGlzYWJsZTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBkOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcblx0XHRcdGQgPSBhcnJheVtpXTtcblxuXHRcdFx0aWYgKGQgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBkKGRhdGVUb0NoZWNrKSkgLy8gZGlzYWJsZWQgYnkgZnVuY3Rpb25cblx0XHRcdFx0cmV0dXJuIGJvb2w7ZWxzZSBpZiAoZCBpbnN0YW5jZW9mIERhdGUgJiYgZC5nZXRUaW1lKCkgPT09IGRhdGVUb0NoZWNrLmdldFRpbWUoKSlcblx0XHRcdFx0Ly8gZGlzYWJsZWQgYnkgZGF0ZVxuXHRcdFx0XHRyZXR1cm4gYm9vbDtlbHNlIGlmICh0eXBlb2YgZCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLnBhcnNlRGF0ZShkLCBudWxsLCB0cnVlKS5nZXRUaW1lKCkgPT09IGRhdGVUb0NoZWNrLmdldFRpbWUoKSlcblx0XHRcdFx0Ly8gZGlzYWJsZWQgYnkgZGF0ZSBzdHJpbmdcblx0XHRcdFx0cmV0dXJuIGJvb2w7ZWxzZSBpZiAoIC8vIGRpc2FibGVkIGJ5IHJhbmdlXG5cdFx0XHQodHlwZW9mIGQgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihkKSkgPT09IFwib2JqZWN0XCIgJiYgZC5mcm9tICYmIGQudG8gJiYgZGF0ZVRvQ2hlY2sgPj0gZC5mcm9tICYmIGRhdGVUb0NoZWNrIDw9IGQudG8pIHJldHVybiBib29sO1xuXHRcdH1cblxuXHRcdHJldHVybiAhYm9vbDtcblx0fVxuXG5cdGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG5cdFx0dmFyIGlzSW5wdXQgPSBlLnRhcmdldCA9PT0gc2VsZi5faW5wdXQ7XG5cdFx0dmFyIGNhbGVuZGFyRWxlbSA9IGlzQ2FsZW5kYXJFbGVtKGUudGFyZ2V0KTtcblx0XHR2YXIgYWxsb3dJbnB1dCA9IHNlbGYuY29uZmlnLmFsbG93SW5wdXQ7XG5cdFx0dmFyIGFsbG93S2V5ZG93biA9IHNlbGYuaXNPcGVuICYmICghYWxsb3dJbnB1dCB8fCAhaXNJbnB1dCk7XG5cdFx0dmFyIGFsbG93SW5saW5lS2V5ZG93biA9IHNlbGYuY29uZmlnLmlubGluZSAmJiBpc0lucHV0ICYmICFhbGxvd0lucHV0O1xuXG5cdFx0aWYgKGUua2V5ID09PSBcIkVudGVyXCIgJiYgYWxsb3dJbnB1dCAmJiBpc0lucHV0KSB7XG5cdFx0XHRzZWxmLnNldERhdGUoc2VsZi5faW5wdXQudmFsdWUsIHRydWUsIGUudGFyZ2V0ID09PSBzZWxmLmFsdElucHV0ID8gc2VsZi5jb25maWcuYWx0Rm9ybWF0IDogc2VsZi5jb25maWcuZGF0ZUZvcm1hdCk7XG5cdFx0XHRyZXR1cm4gZS50YXJnZXQuYmx1cigpO1xuXHRcdH0gZWxzZSBpZiAoY2FsZW5kYXJFbGVtIHx8IGFsbG93S2V5ZG93biB8fCBhbGxvd0lubGluZUtleWRvd24pIHtcblx0XHRcdHZhciBpc1RpbWVPYmogPSBzZWxmLnRpbWVDb250YWluZXIgJiYgc2VsZi50aW1lQ29udGFpbmVyLmNvbnRhaW5zKGUudGFyZ2V0KTtcblx0XHRcdHN3aXRjaCAoZS5rZXkpIHtcblx0XHRcdFx0Y2FzZSBcIkVudGVyXCI6XG5cdFx0XHRcdFx0aWYgKGlzVGltZU9iaikgdXBkYXRlVmFsdWUoKTtlbHNlIHNlbGVjdERhdGUoZSk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFwiRXNjYXBlXCI6XG5cdFx0XHRcdFx0Ly8gZXNjYXBlXG5cdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdHNlbGYuY2xvc2UoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFwiQXJyb3dMZWZ0XCI6XG5cdFx0XHRcdGNhc2UgXCJBcnJvd1JpZ2h0XCI6XG5cdFx0XHRcdFx0aWYgKCFpc1RpbWVPYmopIHtcblx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0XHRcdFx0aWYgKHNlbGYuZGF5c0NvbnRhaW5lcikge1xuXHRcdFx0XHRcdFx0XHR2YXIgX2RlbHRhID0gZS5rZXkgPT09IFwiQXJyb3dSaWdodFwiID8gMSA6IC0xO1xuXG5cdFx0XHRcdFx0XHRcdGlmICghZS5jdHJsS2V5KSBmb2N1c09uRGF5KGUudGFyZ2V0LiRpLCBfZGVsdGEpO2Vsc2UgY2hhbmdlTW9udGgoX2RlbHRhLCB0cnVlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSAmJiAhaXNUaW1lT2JqKSBzZWxmLmhvdXJFbGVtZW50LmZvY3VzKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBcIkFycm93VXBcIjpcblx0XHRcdFx0Y2FzZSBcIkFycm93RG93blwiOlxuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHR2YXIgZGVsdGEgPSBlLmtleSA9PT0gXCJBcnJvd0Rvd25cIiA/IDEgOiAtMTtcblxuXHRcdFx0XHRcdGlmIChzZWxmLmRheXNDb250YWluZXIpIHtcblx0XHRcdFx0XHRcdGlmIChlLmN0cmxLZXkpIHtcblx0XHRcdFx0XHRcdFx0Y2hhbmdlWWVhcihzZWxmLmN1cnJlbnRZZWFyIC0gZGVsdGEpO1xuXHRcdFx0XHRcdFx0XHRmb2N1c09uRGF5KGUudGFyZ2V0LiRpLCAwKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIWlzVGltZU9iaikgZm9jdXNPbkRheShlLnRhcmdldC4kaSwgZGVsdGEgKiA3KTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHNlbGYuY29uZmlnLmVuYWJsZVRpbWUpIHtcblx0XHRcdFx0XHRcdGlmICghaXNUaW1lT2JqKSBzZWxmLmhvdXJFbGVtZW50LmZvY3VzKCk7XG5cdFx0XHRcdFx0XHR1cGRhdGVUaW1lKGUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgXCJUYWJcIjpcblx0XHRcdFx0XHRpZiAoZS50YXJnZXQgPT09IHNlbGYuaG91ckVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdHNlbGYubWludXRlRWxlbWVudC5zZWxlY3QoKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGUudGFyZ2V0ID09PSBzZWxmLm1pbnV0ZUVsZW1lbnQgJiYgKHNlbGYuc2Vjb25kRWxlbWVudCB8fCBzZWxmLmFtUE0pKSB7XG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHQoc2VsZi5zZWNvbmRFbGVtZW50IHx8IHNlbGYuYW1QTSkuZm9jdXMoKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGUudGFyZ2V0ID09PSBzZWxmLnNlY29uZEVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdHNlbGYuYW1QTS5mb2N1cygpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgXCJhXCI6XG5cdFx0XHRcdFx0aWYgKGUudGFyZ2V0ID09PSBzZWxmLmFtUE0pIHtcblx0XHRcdFx0XHRcdHNlbGYuYW1QTS50ZXh0Q29udGVudCA9IFwiQU1cIjtcblx0XHRcdFx0XHRcdHNldEhvdXJzRnJvbUlucHV0cygpO1xuXHRcdFx0XHRcdFx0dXBkYXRlVmFsdWUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBcInBcIjpcblx0XHRcdFx0XHRpZiAoZS50YXJnZXQgPT09IHNlbGYuYW1QTSkge1xuXHRcdFx0XHRcdFx0c2VsZi5hbVBNLnRleHRDb250ZW50ID0gXCJQTVwiO1xuXHRcdFx0XHRcdFx0c2V0SG91cnNGcm9tSW5wdXRzKCk7XG5cdFx0XHRcdFx0XHR1cGRhdGVWYWx1ZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRyaWdnZXJFdmVudChcIktleURvd25cIiwgZSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gb25Nb3VzZU92ZXIoZWxlbSkge1xuXHRcdGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoICE9PSAxIHx8ICFlbGVtLmNsYXNzTGlzdC5jb250YWlucyhcImZsYXRwaWNrci1kYXlcIikpIHJldHVybjtcblxuXHRcdHZhciBob3ZlckRhdGUgPSBlbGVtLmRhdGVPYmosXG5cdFx0ICAgIGluaXRpYWxEYXRlID0gc2VsZi5wYXJzZURhdGUoc2VsZi5zZWxlY3RlZERhdGVzWzBdLCBudWxsLCB0cnVlKSxcblx0XHQgICAgcmFuZ2VTdGFydERhdGUgPSBNYXRoLm1pbihob3ZlckRhdGUuZ2V0VGltZSgpLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0uZ2V0VGltZSgpKSxcblx0XHQgICAgcmFuZ2VFbmREYXRlID0gTWF0aC5tYXgoaG92ZXJEYXRlLmdldFRpbWUoKSwgc2VsZi5zZWxlY3RlZERhdGVzWzBdLmdldFRpbWUoKSksXG5cdFx0ICAgIGNvbnRhaW5zRGlzYWJsZWQgPSBmYWxzZTtcblxuXHRcdGZvciAodmFyIHQgPSByYW5nZVN0YXJ0RGF0ZTsgdCA8IHJhbmdlRW5kRGF0ZTsgdCArPSBzZWxmLnV0aWxzLmR1cmF0aW9uLkRBWSkge1xuXHRcdFx0aWYgKCFpc0VuYWJsZWQobmV3IERhdGUodCkpKSB7XG5cdFx0XHRcdGNvbnRhaW5zRGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCh0aW1lc3RhbXAsIGkpIHtcblx0XHRcdHZhciBvdXRPZlJhbmdlID0gdGltZXN0YW1wIDwgc2VsZi5taW5SYW5nZURhdGUuZ2V0VGltZSgpIHx8IHRpbWVzdGFtcCA+IHNlbGYubWF4UmFuZ2VEYXRlLmdldFRpbWUoKSxcblx0XHRcdCAgICBkYXlFbGVtID0gc2VsZi5kYXlzLmNoaWxkTm9kZXNbaV07XG5cblx0XHRcdGlmIChvdXRPZlJhbmdlKSB7XG5cdFx0XHRcdHNlbGYuZGF5cy5jaGlsZE5vZGVzW2ldLmNsYXNzTGlzdC5hZGQoXCJub3RBbGxvd2VkXCIpO1xuXHRcdFx0XHRbXCJpblJhbmdlXCIsIFwic3RhcnRSYW5nZVwiLCBcImVuZFJhbmdlXCJdLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0XHRkYXlFbGVtLmNsYXNzTGlzdC5yZW1vdmUoYyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gXCJjb250aW51ZVwiO1xuXHRcdFx0fSBlbHNlIGlmIChjb250YWluc0Rpc2FibGVkICYmICFvdXRPZlJhbmdlKSByZXR1cm4gXCJjb250aW51ZVwiO1xuXG5cdFx0XHRbXCJzdGFydFJhbmdlXCIsIFwiaW5SYW5nZVwiLCBcImVuZFJhbmdlXCIsIFwibm90QWxsb3dlZFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdGRheUVsZW0uY2xhc3NMaXN0LnJlbW92ZShjKTtcblx0XHRcdH0pO1xuXG5cdFx0XHR2YXIgbWluUmFuZ2VEYXRlID0gTWF0aC5tYXgoc2VsZi5taW5SYW5nZURhdGUuZ2V0VGltZSgpLCByYW5nZVN0YXJ0RGF0ZSksXG5cdFx0XHQgICAgbWF4UmFuZ2VEYXRlID0gTWF0aC5taW4oc2VsZi5tYXhSYW5nZURhdGUuZ2V0VGltZSgpLCByYW5nZUVuZERhdGUpO1xuXG5cdFx0XHRlbGVtLmNsYXNzTGlzdC5hZGQoaG92ZXJEYXRlIDwgc2VsZi5zZWxlY3RlZERhdGVzWzBdID8gXCJzdGFydFJhbmdlXCIgOiBcImVuZFJhbmdlXCIpO1xuXG5cdFx0XHRpZiAoaW5pdGlhbERhdGUgPCBob3ZlckRhdGUgJiYgdGltZXN0YW1wID09PSBpbml0aWFsRGF0ZS5nZXRUaW1lKCkpIGRheUVsZW0uY2xhc3NMaXN0LmFkZChcInN0YXJ0UmFuZ2VcIik7ZWxzZSBpZiAoaW5pdGlhbERhdGUgPiBob3ZlckRhdGUgJiYgdGltZXN0YW1wID09PSBpbml0aWFsRGF0ZS5nZXRUaW1lKCkpIGRheUVsZW0uY2xhc3NMaXN0LmFkZChcImVuZFJhbmdlXCIpO1xuXG5cdFx0XHRpZiAodGltZXN0YW1wID49IG1pblJhbmdlRGF0ZSAmJiB0aW1lc3RhbXAgPD0gbWF4UmFuZ2VEYXRlKSBkYXlFbGVtLmNsYXNzTGlzdC5hZGQoXCJpblJhbmdlXCIpO1xuXHRcdH07XG5cblx0XHRmb3IgKHZhciB0aW1lc3RhbXAgPSBzZWxmLmRheXMuY2hpbGROb2Rlc1swXS5kYXRlT2JqLmdldFRpbWUoKSwgaSA9IDA7IGkgPCA0MjsgaSsrLCB0aW1lc3RhbXAgKz0gc2VsZi51dGlscy5kdXJhdGlvbi5EQVkpIHtcblx0XHRcdHZhciBfcmV0ID0gX2xvb3AodGltZXN0YW1wLCBpKTtcblxuXHRcdFx0aWYgKF9yZXQgPT09IFwiY29udGludWVcIikgY29udGludWU7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gb25SZXNpemUoKSB7XG5cdFx0aWYgKHNlbGYuaXNPcGVuICYmICFzZWxmLmNvbmZpZy5zdGF0aWMgJiYgIXNlbGYuY29uZmlnLmlubGluZSkgcG9zaXRpb25DYWxlbmRhcigpO1xuXHR9XG5cblx0ZnVuY3Rpb24gb3BlbihlKSB7XG5cdFx0aWYgKHNlbGYuaXNNb2JpbGUpIHtcblx0XHRcdGlmIChlKSB7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0ZS50YXJnZXQuYmx1cigpO1xuXHRcdFx0fVxuXG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VsZi5tb2JpbGVJbnB1dC5jbGljaygpO1xuXHRcdFx0fSwgMCk7XG5cblx0XHRcdHRyaWdnZXJFdmVudChcIk9wZW5cIik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHNlbGYuaXNPcGVuIHx8IHNlbGYuX2lucHV0LmRpc2FibGVkIHx8IHNlbGYuY29uZmlnLmlubGluZSkgcmV0dXJuO1xuXG5cdFx0c2VsZi5pc09wZW4gPSB0cnVlO1xuXHRcdHNlbGYuY2FsZW5kYXJDb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm9wZW5cIik7XG5cdFx0cG9zaXRpb25DYWxlbmRhcigpO1xuXHRcdHNlbGYuX2lucHV0LmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XG5cblx0XHR0cmlnZ2VyRXZlbnQoXCJPcGVuXCIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gbWluTWF4RGF0ZVNldHRlcih0eXBlKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRlKSB7XG5cdFx0XHR2YXIgZGF0ZU9iaiA9IHNlbGYuY29uZmlnW1wiX1wiICsgdHlwZSArIFwiRGF0ZVwiXSA9IHNlbGYucGFyc2VEYXRlKGRhdGUpO1xuXG5cdFx0XHR2YXIgaW52ZXJzZURhdGVPYmogPSBzZWxmLmNvbmZpZ1tcIl9cIiArICh0eXBlID09PSBcIm1pblwiID8gXCJtYXhcIiA6IFwibWluXCIpICsgXCJEYXRlXCJdO1xuXHRcdFx0dmFyIGlzVmFsaWREYXRlID0gZGF0ZSAmJiBkYXRlT2JqIGluc3RhbmNlb2YgRGF0ZTtcblxuXHRcdFx0aWYgKGlzVmFsaWREYXRlKSB7XG5cdFx0XHRcdHNlbGZbdHlwZSArIFwiRGF0ZUhhc1RpbWVcIl0gPSBkYXRlT2JqLmdldEhvdXJzKCkgfHwgZGF0ZU9iai5nZXRNaW51dGVzKCkgfHwgZGF0ZU9iai5nZXRTZWNvbmRzKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMpIHtcblx0XHRcdFx0c2VsZi5zZWxlY3RlZERhdGVzID0gc2VsZi5zZWxlY3RlZERhdGVzLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuXHRcdFx0XHRcdHJldHVybiBpc0VuYWJsZWQoZCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZiAoIXNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggJiYgdHlwZSA9PT0gXCJtaW5cIikgc2V0SG91cnNGcm9tRGF0ZShkYXRlT2JqKTtcblx0XHRcdFx0dXBkYXRlVmFsdWUoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHNlbGYuZGF5c0NvbnRhaW5lcikge1xuXHRcdFx0XHRyZWRyYXcoKTtcblxuXHRcdFx0XHRpZiAoaXNWYWxpZERhdGUpIHNlbGYuY3VycmVudFllYXJFbGVtZW50W3R5cGVdID0gZGF0ZU9iai5nZXRGdWxsWWVhcigpO2Vsc2Ugc2VsZi5jdXJyZW50WWVhckVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHR5cGUpO1xuXG5cdFx0XHRcdHNlbGYuY3VycmVudFllYXJFbGVtZW50LmRpc2FibGVkID0gaW52ZXJzZURhdGVPYmogJiYgZGF0ZU9iaiAmJiBpbnZlcnNlRGF0ZU9iai5nZXRGdWxsWWVhcigpID09PSBkYXRlT2JqLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlQ29uZmlnKCkge1xuXHRcdHZhciBib29sT3B0cyA9IFtcInV0Y1wiLCBcIndyYXBcIiwgXCJ3ZWVrTnVtYmVyc1wiLCBcImFsbG93SW5wdXRcIiwgXCJjbGlja09wZW5zXCIsIFwidGltZV8yNGhyXCIsIFwiZW5hYmxlVGltZVwiLCBcIm5vQ2FsZW5kYXJcIiwgXCJhbHRJbnB1dFwiLCBcInNob3J0aGFuZEN1cnJlbnRNb250aFwiLCBcImlubGluZVwiLCBcInN0YXRpY1wiLCBcImVuYWJsZVNlY29uZHNcIiwgXCJkaXNhYmxlTW9iaWxlXCJdO1xuXG5cdFx0dmFyIGhvb2tzID0gW1wib25DaGFuZ2VcIiwgXCJvbkNsb3NlXCIsIFwib25EYXlDcmVhdGVcIiwgXCJvbktleURvd25cIiwgXCJvbk1vbnRoQ2hhbmdlXCIsIFwib25PcGVuXCIsIFwib25QYXJzZUNvbmZpZ1wiLCBcIm9uUmVhZHlcIiwgXCJvblZhbHVlVXBkYXRlXCIsIFwib25ZZWFyQ2hhbmdlXCJdO1xuXG5cdFx0c2VsZi5jb25maWcgPSBPYmplY3QuY3JlYXRlKEZsYXRwaWNrci5kZWZhdWx0Q29uZmlnKTtcblxuXHRcdHZhciB1c2VyQ29uZmlnID0gX2V4dGVuZHMoe30sIHNlbGYuaW5zdGFuY2VDb25maWcsIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2VsZi5lbGVtZW50LmRhdGFzZXQgfHwge30pKSk7XG5cblx0XHRzZWxmLmNvbmZpZy5wYXJzZURhdGUgPSB1c2VyQ29uZmlnLnBhcnNlRGF0ZTtcblx0XHRzZWxmLmNvbmZpZy5mb3JtYXREYXRlID0gdXNlckNvbmZpZy5mb3JtYXREYXRlO1xuXG5cdFx0X2V4dGVuZHMoc2VsZi5jb25maWcsIHVzZXJDb25maWcpO1xuXG5cdFx0aWYgKCF1c2VyQ29uZmlnLmRhdGVGb3JtYXQgJiYgdXNlckNvbmZpZy5lbmFibGVUaW1lKSB7XG5cdFx0XHRzZWxmLmNvbmZpZy5kYXRlRm9ybWF0ID0gc2VsZi5jb25maWcubm9DYWxlbmRhciA/IFwiSDppXCIgKyAoc2VsZi5jb25maWcuZW5hYmxlU2Vjb25kcyA/IFwiOlNcIiA6IFwiXCIpIDogRmxhdHBpY2tyLmRlZmF1bHRDb25maWcuZGF0ZUZvcm1hdCArIFwiIEg6aVwiICsgKHNlbGYuY29uZmlnLmVuYWJsZVNlY29uZHMgPyBcIjpTXCIgOiBcIlwiKTtcblx0XHR9XG5cblx0XHRpZiAodXNlckNvbmZpZy5hbHRJbnB1dCAmJiB1c2VyQ29uZmlnLmVuYWJsZVRpbWUgJiYgIXVzZXJDb25maWcuYWx0Rm9ybWF0KSB7XG5cdFx0XHRzZWxmLmNvbmZpZy5hbHRGb3JtYXQgPSBzZWxmLmNvbmZpZy5ub0NhbGVuZGFyID8gXCJoOmlcIiArIChzZWxmLmNvbmZpZy5lbmFibGVTZWNvbmRzID8gXCI6UyBLXCIgOiBcIiBLXCIpIDogRmxhdHBpY2tyLmRlZmF1bHRDb25maWcuYWx0Rm9ybWF0ICsgKFwiIGg6aVwiICsgKHNlbGYuY29uZmlnLmVuYWJsZVNlY29uZHMgPyBcIjpTXCIgOiBcIlwiKSArIFwiIEtcIik7XG5cdFx0fVxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuY29uZmlnLCBcIm1pbkRhdGVcIiwge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9taW5EYXRlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogbWluTWF4RGF0ZVNldHRlcihcIm1pblwiKVxuXHRcdH0pO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuY29uZmlnLCBcIm1heERhdGVcIiwge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9tYXhEYXRlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogbWluTWF4RGF0ZVNldHRlcihcIm1heFwiKVxuXHRcdH0pO1xuXG5cdFx0c2VsZi5jb25maWcubWluRGF0ZSA9IHVzZXJDb25maWcubWluRGF0ZTtcblx0XHRzZWxmLmNvbmZpZy5tYXhEYXRlID0gdXNlckNvbmZpZy5tYXhEYXRlO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBib29sT3B0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c2VsZi5jb25maWdbYm9vbE9wdHNbaV1dID0gc2VsZi5jb25maWdbYm9vbE9wdHNbaV1dID09PSB0cnVlIHx8IHNlbGYuY29uZmlnW2Jvb2xPcHRzW2ldXSA9PT0gXCJ0cnVlXCI7XG5cdFx0fWZvciAodmFyIF9pID0gaG9va3MubGVuZ3RoOyBfaS0tOykge1xuXHRcdFx0aWYgKHNlbGYuY29uZmlnW2hvb2tzW19pXV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRzZWxmLmNvbmZpZ1tob29rc1tfaV1dID0gYXJyYXlpZnkoc2VsZi5jb25maWdbaG9va3NbX2ldXSB8fCBbXSkubWFwKGJpbmRUb0luc3RhbmNlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBzZWxmLmNvbmZpZy5wbHVnaW5zLmxlbmd0aDsgX2kyKyspIHtcblx0XHRcdHZhciBwbHVnaW5Db25mID0gc2VsZi5jb25maWcucGx1Z2luc1tfaTJdKHNlbGYpIHx8IHt9O1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIHBsdWdpbkNvbmYpIHtcblxuXHRcdFx0XHRpZiAoc2VsZi5jb25maWdba2V5XSBpbnN0YW5jZW9mIEFycmF5IHx8IH5ob29rcy5pbmRleE9mKGtleSkpIHtcblx0XHRcdFx0XHRzZWxmLmNvbmZpZ1trZXldID0gYXJyYXlpZnkocGx1Z2luQ29uZltrZXldKS5tYXAoYmluZFRvSW5zdGFuY2UpLmNvbmNhdChzZWxmLmNvbmZpZ1trZXldKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdXNlckNvbmZpZ1trZXldID09PSBcInVuZGVmaW5lZFwiKSBzZWxmLmNvbmZpZ1trZXldID0gcGx1Z2luQ29uZltrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRyaWdnZXJFdmVudChcIlBhcnNlQ29uZmlnXCIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0dXBMb2NhbGUoKSB7XG5cdFx0aWYgKF90eXBlb2Yoc2VsZi5jb25maWcubG9jYWxlKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgRmxhdHBpY2tyLmwxMG5zW3NlbGYuY29uZmlnLmxvY2FsZV0gPT09IFwidW5kZWZpbmVkXCIpIGNvbnNvbGUud2FybihcImZsYXRwaWNrcjogaW52YWxpZCBsb2NhbGUgXCIgKyBzZWxmLmNvbmZpZy5sb2NhbGUpO1xuXG5cdFx0c2VsZi5sMTBuID0gX2V4dGVuZHMoT2JqZWN0LmNyZWF0ZShGbGF0cGlja3IubDEwbnMuZGVmYXVsdCksIF90eXBlb2Yoc2VsZi5jb25maWcubG9jYWxlKSA9PT0gXCJvYmplY3RcIiA/IHNlbGYuY29uZmlnLmxvY2FsZSA6IHNlbGYuY29uZmlnLmxvY2FsZSAhPT0gXCJkZWZhdWx0XCIgPyBGbGF0cGlja3IubDEwbnNbc2VsZi5jb25maWcubG9jYWxlXSB8fCB7fSA6IHt9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHBvc2l0aW9uQ2FsZW5kYXIoKSB7XG5cdFx0aWYgKHNlbGYuY2FsZW5kYXJDb250YWluZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG5cdFx0dmFyIGNhbGVuZGFySGVpZ2h0ID0gc2VsZi5jYWxlbmRhckNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXG5cdFx0ICAgIGNhbGVuZGFyV2lkdGggPSBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLm9mZnNldFdpZHRoLFxuXHRcdCAgICBjb25maWdQb3MgPSBzZWxmLmNvbmZpZy5wb3NpdGlvbixcblx0XHQgICAgaW5wdXRCb3VuZHMgPSBzZWxmLl9wb3NpdGlvbkVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG5cdFx0ICAgIGRpc3RhbmNlRnJvbUJvdHRvbSA9IHdpbmRvdy5pbm5lckhlaWdodCAtIGlucHV0Qm91bmRzLmJvdHRvbSxcblx0XHQgICAgc2hvd09uVG9wID0gY29uZmlnUG9zID09PSBcImFib3ZlXCIgfHwgY29uZmlnUG9zICE9PSBcImJlbG93XCIgJiYgZGlzdGFuY2VGcm9tQm90dG9tIDwgY2FsZW5kYXJIZWlnaHQgJiYgaW5wdXRCb3VuZHMudG9wID4gY2FsZW5kYXJIZWlnaHQ7XG5cblx0XHR2YXIgdG9wID0gd2luZG93LnBhZ2VZT2Zmc2V0ICsgaW5wdXRCb3VuZHMudG9wICsgKCFzaG93T25Ub3AgPyBzZWxmLl9wb3NpdGlvbkVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgMiA6IC1jYWxlbmRhckhlaWdodCAtIDIpO1xuXG5cdFx0dG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJhcnJvd1RvcFwiLCAhc2hvd09uVG9wKTtcblx0XHR0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcImFycm93Qm90dG9tXCIsIHNob3dPblRvcCk7XG5cblx0XHRpZiAoc2VsZi5jb25maWcuaW5saW5lKSByZXR1cm47XG5cblx0XHR2YXIgbGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldCArIGlucHV0Qm91bmRzLmxlZnQ7XG5cdFx0dmFyIHJpZ2h0ID0gd2luZG93LmRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGggLSBpbnB1dEJvdW5kcy5yaWdodDtcblx0XHR2YXIgcmlnaHRNb3N0ID0gbGVmdCArIGNhbGVuZGFyV2lkdGggPiB3aW5kb3cuZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aDtcblxuXHRcdHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwicmlnaHRNb3N0XCIsIHJpZ2h0TW9zdCk7XG5cblx0XHRpZiAoc2VsZi5jb25maWcuc3RhdGljKSByZXR1cm47XG5cblx0XHRzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjtcblxuXHRcdGlmICghcmlnaHRNb3N0KSB7XG5cdFx0XHRzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuXHRcdFx0c2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLmxlZnQgPSBcImF1dG9cIjtcblx0XHRcdHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUucmlnaHQgPSByaWdodCArIFwicHhcIjtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiByZWRyYXcoKSB7XG5cdFx0aWYgKHNlbGYuY29uZmlnLm5vQ2FsZW5kYXIgfHwgc2VsZi5pc01vYmlsZSkgcmV0dXJuO1xuXG5cdFx0YnVpbGRXZWVrZGF5cygpO1xuXHRcdHVwZGF0ZU5hdmlnYXRpb25DdXJyZW50TW9udGgoKTtcblx0XHRidWlsZERheXMoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNlbGVjdERhdGUoZSkge1xuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0aWYgKCFlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXCJmbGF0cGlja3ItZGF5XCIpIHx8IGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImRpc2FibGVkXCIpIHx8IGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcIm5vdEFsbG93ZWRcIikpIHJldHVybjtcblxuXHRcdHZhciBzZWxlY3RlZERhdGUgPSBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiA9IG5ldyBEYXRlKGUudGFyZ2V0LmRhdGVPYmouZ2V0VGltZSgpKTtcblxuXHRcdHZhciBzaG91bGRDaGFuZ2VNb250aCA9IHNlbGVjdGVkRGF0ZS5nZXRNb250aCgpICE9PSBzZWxmLmN1cnJlbnRNb250aCAmJiBzZWxmLmNvbmZpZy5tb2RlICE9PSBcInJhbmdlXCI7XG5cblx0XHRzZWxmLnNlbGVjdGVkRGF0ZUVsZW0gPSBlLnRhcmdldDtcblxuXHRcdGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInNpbmdsZVwiKSBzZWxmLnNlbGVjdGVkRGF0ZXMgPSBbc2VsZWN0ZWREYXRlXTtlbHNlIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcIm11bHRpcGxlXCIpIHtcblx0XHRcdHZhciBzZWxlY3RlZEluZGV4ID0gaXNEYXRlU2VsZWN0ZWQoc2VsZWN0ZWREYXRlKTtcblx0XHRcdGlmIChzZWxlY3RlZEluZGV4KSBzZWxmLnNlbGVjdGVkRGF0ZXMuc3BsaWNlKHNlbGVjdGVkSW5kZXgsIDEpO2Vsc2Ugc2VsZi5zZWxlY3RlZERhdGVzLnB1c2goc2VsZWN0ZWREYXRlKTtcblx0XHR9IGVsc2UgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIikge1xuXHRcdFx0aWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDIpIHNlbGYuY2xlYXIoKTtcblxuXHRcdFx0c2VsZi5zZWxlY3RlZERhdGVzLnB1c2goc2VsZWN0ZWREYXRlKTtcblxuXHRcdFx0Ly8gdW5sZXNzIHNlbGVjdGluZyBzYW1lIGRhdGUgdHdpY2UsIHNvcnQgYXNjZW5kaW5nbHlcblx0XHRcdGlmIChjb21wYXJlRGF0ZXMoc2VsZWN0ZWREYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0sIHRydWUpICE9PSAwKSBzZWxmLnNlbGVjdGVkRGF0ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0XHRyZXR1cm4gYS5nZXRUaW1lKCkgLSBiLmdldFRpbWUoKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHNldEhvdXJzRnJvbUlucHV0cygpO1xuXG5cdFx0aWYgKHNob3VsZENoYW5nZU1vbnRoKSB7XG5cdFx0XHR2YXIgaXNOZXdZZWFyID0gc2VsZi5jdXJyZW50WWVhciAhPT0gc2VsZWN0ZWREYXRlLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHRzZWxmLmN1cnJlbnRZZWFyID0gc2VsZWN0ZWREYXRlLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHRzZWxmLmN1cnJlbnRNb250aCA9IHNlbGVjdGVkRGF0ZS5nZXRNb250aCgpO1xuXG5cdFx0XHRpZiAoaXNOZXdZZWFyKSB0cmlnZ2VyRXZlbnQoXCJZZWFyQ2hhbmdlXCIpO1xuXG5cdFx0XHR0cmlnZ2VyRXZlbnQoXCJNb250aENoYW5nZVwiKTtcblx0XHR9XG5cblx0XHRidWlsZERheXMoKTtcblxuXHRcdGlmIChzZWxmLm1pbkRhdGVIYXNUaW1lICYmIHNlbGYuY29uZmlnLmVuYWJsZVRpbWUgJiYgY29tcGFyZURhdGVzKHNlbGVjdGVkRGF0ZSwgc2VsZi5jb25maWcubWluRGF0ZSkgPT09IDApIHNldEhvdXJzRnJvbURhdGUoc2VsZi5jb25maWcubWluRGF0ZSk7XG5cblx0XHR1cGRhdGVWYWx1ZSgpO1xuXG5cdFx0aWYgKHNlbGYuY29uZmlnLmVuYWJsZVRpbWUpIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHNlbGYuc2hvd1RpbWVJbnB1dCA9IHRydWU7XG5cdFx0fSwgNTApO1xuXG5cdFx0aWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIikge1xuXHRcdFx0aWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0b25Nb3VzZU92ZXIoZS50YXJnZXQpO1xuXG5cdFx0XHRcdHNlbGYuX2hpZGVQcmV2TW9udGhBcnJvdyA9IHNlbGYuX2hpZGVQcmV2TW9udGhBcnJvdyB8fCBzZWxmLm1pblJhbmdlRGF0ZSA+IHNlbGYuZGF5cy5jaGlsZE5vZGVzWzBdLmRhdGVPYmo7XG5cblx0XHRcdFx0c2VsZi5faGlkZU5leHRNb250aEFycm93ID0gc2VsZi5faGlkZU5leHRNb250aEFycm93IHx8IHNlbGYubWF4UmFuZ2VEYXRlIDwgbmV3IERhdGUoc2VsZi5jdXJyZW50WWVhciwgc2VsZi5jdXJyZW50TW9udGggKyAxLCAxKTtcblx0XHRcdH0gZWxzZSB1cGRhdGVOYXZpZ2F0aW9uQ3VycmVudE1vbnRoKCk7XG5cdFx0fVxuXG5cdFx0dHJpZ2dlckV2ZW50KFwiQ2hhbmdlXCIpO1xuXG5cdFx0Ly8gbWFpbnRhaW4gZm9jdXNcblx0XHRpZiAoIXNob3VsZENoYW5nZU1vbnRoKSBmb2N1c09uRGF5KGUudGFyZ2V0LiRpLCAwKTtlbHNlIGFmdGVyRGF5QW5pbShmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gc2VsZi5zZWxlY3RlZERhdGVFbGVtLmZvY3VzKCk7XG5cdFx0fSk7XG5cblx0XHRpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSkgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gc2VsZi5ob3VyRWxlbWVudC5zZWxlY3QoKTtcblx0XHR9LCA0NTEpO1xuXG5cdFx0aWYgKHNlbGYuY29uZmlnLmNsb3NlT25TZWxlY3QpIHtcblx0XHRcdHZhciBzaW5nbGUgPSBzZWxmLmNvbmZpZy5tb2RlID09PSBcInNpbmdsZVwiICYmICFzZWxmLmNvbmZpZy5lbmFibGVUaW1lO1xuXHRcdFx0dmFyIHJhbmdlID0gc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiICYmIHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDIgJiYgIXNlbGYuY29uZmlnLmVuYWJsZVRpbWU7XG5cblx0XHRcdGlmIChzaW5nbGUgfHwgcmFuZ2UpIHNlbGYuY2xvc2UoKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBzZXQob3B0aW9uLCB2YWx1ZSkge1xuXHRcdHNlbGYuY29uZmlnW29wdGlvbl0gPSB2YWx1ZTtcblx0XHRzZWxmLnJlZHJhdygpO1xuXHRcdGp1bXBUb0RhdGUoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldFNlbGVjdGVkRGF0ZShpbnB1dERhdGUsIGZvcm1hdCkge1xuXHRcdGlmIChpbnB1dERhdGUgaW5zdGFuY2VvZiBBcnJheSkgc2VsZi5zZWxlY3RlZERhdGVzID0gaW5wdXREYXRlLm1hcChmdW5jdGlvbiAoZCkge1xuXHRcdFx0cmV0dXJuIHNlbGYucGFyc2VEYXRlKGQsIGZvcm1hdCk7XG5cdFx0fSk7ZWxzZSBpZiAoaW5wdXREYXRlIGluc3RhbmNlb2YgRGF0ZSB8fCAhaXNOYU4oaW5wdXREYXRlKSkgc2VsZi5zZWxlY3RlZERhdGVzID0gW3NlbGYucGFyc2VEYXRlKGlucHV0RGF0ZSwgZm9ybWF0KV07ZWxzZSBpZiAoaW5wdXREYXRlICYmIGlucHV0RGF0ZS5zdWJzdHJpbmcpIHtcblx0XHRcdHN3aXRjaCAoc2VsZi5jb25maWcubW9kZSkge1xuXHRcdFx0XHRjYXNlIFwic2luZ2xlXCI6XG5cdFx0XHRcdFx0c2VsZi5zZWxlY3RlZERhdGVzID0gW3NlbGYucGFyc2VEYXRlKGlucHV0RGF0ZSwgZm9ybWF0KV07XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBcIm11bHRpcGxlXCI6XG5cdFx0XHRcdFx0c2VsZi5zZWxlY3RlZERhdGVzID0gaW5wdXREYXRlLnNwbGl0KFwiOyBcIikubWFwKGZ1bmN0aW9uIChkYXRlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc2VsZi5wYXJzZURhdGUoZGF0ZSwgZm9ybWF0KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFwicmFuZ2VcIjpcblx0XHRcdFx0XHRzZWxmLnNlbGVjdGVkRGF0ZXMgPSBpbnB1dERhdGUuc3BsaXQoc2VsZi5sMTBuLnJhbmdlU2VwYXJhdG9yKS5tYXAoZnVuY3Rpb24gKGRhdGUpIHtcblx0XHRcdFx0XHRcdHJldHVybiBzZWxmLnBhcnNlRGF0ZShkYXRlLCBmb3JtYXQpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzZWxmLnNlbGVjdGVkRGF0ZXMgPSBzZWxmLnNlbGVjdGVkRGF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG5cdFx0XHRyZXR1cm4gZCBpbnN0YW5jZW9mIERhdGUgJiYgaXNFbmFibGVkKGQsIGZhbHNlKTtcblx0XHR9KTtcblxuXHRcdHNlbGYuc2VsZWN0ZWREYXRlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYS5nZXRUaW1lKCkgLSBiLmdldFRpbWUoKTtcblx0XHR9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldERhdGUoZGF0ZSwgdHJpZ2dlckNoYW5nZSwgZm9ybWF0KSB7XG5cdFx0aWYgKCFkYXRlKSByZXR1cm4gc2VsZi5jbGVhcih0cmlnZ2VyQ2hhbmdlKTtcblxuXHRcdHNldFNlbGVjdGVkRGF0ZShkYXRlLCBmb3JtYXQpO1xuXG5cdFx0c2VsZi5zaG93VGltZUlucHV0ID0gc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA+IDA7XG5cdFx0c2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogPSBzZWxmLnNlbGVjdGVkRGF0ZXNbMF07XG5cblx0XHRzZWxmLnJlZHJhdygpO1xuXHRcdGp1bXBUb0RhdGUoKTtcblxuXHRcdHNldEhvdXJzRnJvbURhdGUoKTtcblx0XHR1cGRhdGVWYWx1ZSh0cmlnZ2VyQ2hhbmdlKTtcblxuXHRcdGlmICh0cmlnZ2VyQ2hhbmdlKSB0cmlnZ2VyRXZlbnQoXCJDaGFuZ2VcIik7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXR1cERhdGVzKCkge1xuXHRcdGZ1bmN0aW9uIHBhcnNlRGF0ZVJ1bGVzKGFycikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IGFyci5sZW5ndGg7IGktLTspIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBhcnJbaV0gPT09IFwic3RyaW5nXCIgfHwgK2FycltpXSkgYXJyW2ldID0gc2VsZi5wYXJzZURhdGUoYXJyW2ldLCBudWxsLCB0cnVlKTtlbHNlIGlmIChhcnJbaV0gJiYgYXJyW2ldLmZyb20gJiYgYXJyW2ldLnRvKSB7XG5cdFx0XHRcdFx0YXJyW2ldLmZyb20gPSBzZWxmLnBhcnNlRGF0ZShhcnJbaV0uZnJvbSk7XG5cdFx0XHRcdFx0YXJyW2ldLnRvID0gc2VsZi5wYXJzZURhdGUoYXJyW2ldLnRvKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYXJyLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuXHRcdFx0XHRyZXR1cm4geDtcblx0XHRcdH0pOyAvLyByZW1vdmUgZmFsc3kgdmFsdWVzXG5cdFx0fVxuXG5cdFx0c2VsZi5zZWxlY3RlZERhdGVzID0gW107XG5cdFx0c2VsZi5ub3cgPSBuZXcgRGF0ZSgpO1xuXG5cdFx0aWYgKHNlbGYuY29uZmlnLmRpc2FibGUubGVuZ3RoKSBzZWxmLmNvbmZpZy5kaXNhYmxlID0gcGFyc2VEYXRlUnVsZXMoc2VsZi5jb25maWcuZGlzYWJsZSk7XG5cblx0XHRpZiAoc2VsZi5jb25maWcuZW5hYmxlLmxlbmd0aCkgc2VsZi5jb25maWcuZW5hYmxlID0gcGFyc2VEYXRlUnVsZXMoc2VsZi5jb25maWcuZW5hYmxlKTtcblxuXHRcdHZhciBwcmVsb2FkZWREYXRlID0gc2VsZi5jb25maWcuZGVmYXVsdERhdGUgfHwgc2VsZi5pbnB1dC52YWx1ZTtcblx0XHRpZiAocHJlbG9hZGVkRGF0ZSkgc2V0U2VsZWN0ZWREYXRlKHByZWxvYWRlZERhdGUsIHNlbGYuY29uZmlnLmRhdGVGb3JtYXQpO1xuXG5cdFx0dmFyIGluaXRpYWxEYXRlID0gc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA/IHNlbGYuc2VsZWN0ZWREYXRlc1swXSA6IHNlbGYuY29uZmlnLm1pbkRhdGUgJiYgc2VsZi5jb25maWcubWluRGF0ZS5nZXRUaW1lKCkgPiBzZWxmLm5vdyA/IHNlbGYuY29uZmlnLm1pbkRhdGUgOiBzZWxmLmNvbmZpZy5tYXhEYXRlICYmIHNlbGYuY29uZmlnLm1heERhdGUuZ2V0VGltZSgpIDwgc2VsZi5ub3cgPyBzZWxmLmNvbmZpZy5tYXhEYXRlIDogc2VsZi5ub3c7XG5cblx0XHRzZWxmLmN1cnJlbnRZZWFyID0gaW5pdGlhbERhdGUuZ2V0RnVsbFllYXIoKTtcblx0XHRzZWxmLmN1cnJlbnRNb250aCA9IGluaXRpYWxEYXRlLmdldE1vbnRoKCk7XG5cblx0XHRpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCkgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogPSBzZWxmLnNlbGVjdGVkRGF0ZXNbMF07XG5cblx0XHRzZWxmLm1pbkRhdGVIYXNUaW1lID0gc2VsZi5jb25maWcubWluRGF0ZSAmJiAoc2VsZi5jb25maWcubWluRGF0ZS5nZXRIb3VycygpIHx8IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0TWludXRlcygpIHx8IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0U2Vjb25kcygpKTtcblxuXHRcdHNlbGYubWF4RGF0ZUhhc1RpbWUgPSBzZWxmLmNvbmZpZy5tYXhEYXRlICYmIChzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEhvdXJzKCkgfHwgc2VsZi5jb25maWcubWF4RGF0ZS5nZXRNaW51dGVzKCkgfHwgc2VsZi5jb25maWcubWF4RGF0ZS5nZXRTZWNvbmRzKCkpO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIFwibGF0ZXN0U2VsZWN0ZWREYXRlT2JqXCIsIHtcblx0XHRcdGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHRcdFx0XHRyZXR1cm4gc2VsZi5fc2VsZWN0ZWREYXRlT2JqIHx8IHNlbGYuc2VsZWN0ZWREYXRlc1tzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoIC0gMV07XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiBzZXQoZGF0ZSkge1xuXHRcdFx0XHRzZWxmLl9zZWxlY3RlZERhdGVPYmogPSBkYXRlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKCFzZWxmLmlzTW9iaWxlKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgXCJzaG93VGltZUlucHV0XCIsIHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNlbGYuX3Nob3dUaW1lSW5wdXQ7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldDogZnVuY3Rpb24gc2V0KGJvb2wpIHtcblx0XHRcdFx0XHRzZWxmLl9zaG93VGltZUlucHV0ID0gYm9vbDtcblx0XHRcdFx0XHRpZiAoc2VsZi5jYWxlbmRhckNvbnRhaW5lcikgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJzaG93VGltZUlucHV0XCIsIGJvb2wpO1xuXHRcdFx0XHRcdHBvc2l0aW9uQ2FsZW5kYXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0dXBIZWxwZXJGdW5jdGlvbnMoKSB7XG5cdFx0c2VsZi51dGlscyA9IHtcblx0XHRcdGR1cmF0aW9uOiB7XG5cdFx0XHRcdERBWTogODY0MDAwMDBcblx0XHRcdH0sXG5cdFx0XHRnZXREYXlzaW5Nb250aDogZnVuY3Rpb24gZ2V0RGF5c2luTW9udGgobW9udGgsIHlyKSB7XG5cdFx0XHRcdG1vbnRoID0gdHlwZW9mIG1vbnRoID09PSBcInVuZGVmaW5lZFwiID8gc2VsZi5jdXJyZW50TW9udGggOiBtb250aDtcblxuXHRcdFx0XHR5ciA9IHR5cGVvZiB5ciA9PT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYuY3VycmVudFllYXIgOiB5cjtcblxuXHRcdFx0XHRpZiAobW9udGggPT09IDEgJiYgKHlyICUgNCA9PT0gMCAmJiB5ciAlIDEwMCAhPT0gMCB8fCB5ciAlIDQwMCA9PT0gMCkpIHJldHVybiAyOTtcblxuXHRcdFx0XHRyZXR1cm4gc2VsZi5sMTBuLmRheXNJbk1vbnRoW21vbnRoXTtcblx0XHRcdH0sXG5cdFx0XHRtb250aFRvU3RyOiBmdW5jdGlvbiBtb250aFRvU3RyKG1vbnRoTnVtYmVyLCBzaG9ydGhhbmQpIHtcblx0XHRcdFx0c2hvcnRoYW5kID0gdHlwZW9mIHNob3J0aGFuZCA9PT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYuY29uZmlnLnNob3J0aGFuZEN1cnJlbnRNb250aCA6IHNob3J0aGFuZDtcblxuXHRcdFx0XHRyZXR1cm4gc2VsZi5sMTBuLm1vbnRoc1soc2hvcnRoYW5kID8gXCJzaG9ydFwiIDogXCJsb25nXCIpICsgXCJoYW5kXCJdW21vbnRoTnVtYmVyXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0ZnVuY3Rpb24gc2V0dXBGb3JtYXRzKCkge1xuXHRcdFtcIkRcIiwgXCJGXCIsIFwiSlwiLCBcIk1cIiwgXCJXXCIsIFwibFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG5cdFx0XHRzZWxmLmZvcm1hdHNbZl0gPSBGbGF0cGlja3IucHJvdG90eXBlLmZvcm1hdHNbZl0uYmluZChzZWxmKTtcblx0XHR9KTtcblxuXHRcdHNlbGYucmV2Rm9ybWF0LkYgPSBGbGF0cGlja3IucHJvdG90eXBlLnJldkZvcm1hdC5GLmJpbmQoc2VsZik7XG5cdFx0c2VsZi5yZXZGb3JtYXQuTSA9IEZsYXRwaWNrci5wcm90b3R5cGUucmV2Rm9ybWF0Lk0uYmluZChzZWxmKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldHVwSW5wdXRzKCkge1xuXHRcdHNlbGYuaW5wdXQgPSBzZWxmLmNvbmZpZy53cmFwID8gc2VsZi5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1pbnB1dF1cIikgOiBzZWxmLmVsZW1lbnQ7XG5cblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRcdGlmICghc2VsZi5pbnB1dCkgcmV0dXJuIGNvbnNvbGUud2FybihcIkVycm9yOiBpbnZhbGlkIGlucHV0IGVsZW1lbnQgc3BlY2lmaWVkXCIsIHNlbGYuaW5wdXQpO1xuXG5cdFx0c2VsZi5pbnB1dC5fdHlwZSA9IHNlbGYuaW5wdXQudHlwZTtcblx0XHRzZWxmLmlucHV0LnR5cGUgPSBcInRleHRcIjtcblxuXHRcdHNlbGYuaW5wdXQuY2xhc3NMaXN0LmFkZChcImZsYXRwaWNrci1pbnB1dFwiKTtcblx0XHRzZWxmLl9pbnB1dCA9IHNlbGYuaW5wdXQ7XG5cblx0XHRpZiAoc2VsZi5jb25maWcuYWx0SW5wdXQpIHtcblx0XHRcdC8vIHJlcGxpY2F0ZSBzZWxmLmVsZW1lbnRcblx0XHRcdHNlbGYuYWx0SW5wdXQgPSBjcmVhdGVFbGVtZW50KHNlbGYuaW5wdXQubm9kZU5hbWUsIHNlbGYuaW5wdXQuY2xhc3NOYW1lICsgXCIgXCIgKyBzZWxmLmNvbmZpZy5hbHRJbnB1dENsYXNzKTtcblx0XHRcdHNlbGYuX2lucHV0ID0gc2VsZi5hbHRJbnB1dDtcblx0XHRcdHNlbGYuYWx0SW5wdXQucGxhY2Vob2xkZXIgPSBzZWxmLmlucHV0LnBsYWNlaG9sZGVyO1xuXHRcdFx0c2VsZi5hbHRJbnB1dC5kaXNhYmxlZCA9IHNlbGYuaW5wdXQuZGlzYWJsZWQ7XG5cdFx0XHRzZWxmLmFsdElucHV0LnR5cGUgPSBcInRleHRcIjtcblx0XHRcdHNlbGYuaW5wdXQudHlwZSA9IFwiaGlkZGVuXCI7XG5cblx0XHRcdGlmICghc2VsZi5jb25maWcuc3RhdGljICYmIHNlbGYuaW5wdXQucGFyZW50Tm9kZSkgc2VsZi5pbnB1dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzZWxmLmFsdElucHV0LCBzZWxmLmlucHV0Lm5leHRTaWJsaW5nKTtcblx0XHR9XG5cblx0XHRpZiAoIXNlbGYuY29uZmlnLmFsbG93SW5wdXQpIHNlbGYuX2lucHV0LnNldEF0dHJpYnV0ZShcInJlYWRvbmx5XCIsIFwicmVhZG9ubHlcIik7XG5cblx0XHRzZWxmLl9wb3NpdGlvbkVsZW1lbnQgPSBzZWxmLmNvbmZpZy5wb3NpdGlvbkVsZW1lbnQgfHwgc2VsZi5faW5wdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXR1cE1vYmlsZSgpIHtcblx0XHR2YXIgaW5wdXRUeXBlID0gc2VsZi5jb25maWcuZW5hYmxlVGltZSA/IHNlbGYuY29uZmlnLm5vQ2FsZW5kYXIgPyBcInRpbWVcIiA6IFwiZGF0ZXRpbWUtbG9jYWxcIiA6IFwiZGF0ZVwiO1xuXG5cdFx0c2VsZi5tb2JpbGVJbnB1dCA9IGNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCBzZWxmLmlucHV0LmNsYXNzTmFtZSArIFwiIGZsYXRwaWNrci1tb2JpbGVcIik7XG5cdFx0c2VsZi5tb2JpbGVJbnB1dC5zdGVwID0gXCJhbnlcIjtcblx0XHRzZWxmLm1vYmlsZUlucHV0LnRhYkluZGV4ID0gMTtcblx0XHRzZWxmLm1vYmlsZUlucHV0LnR5cGUgPSBpbnB1dFR5cGU7XG5cdFx0c2VsZi5tb2JpbGVJbnB1dC5kaXNhYmxlZCA9IHNlbGYuaW5wdXQuZGlzYWJsZWQ7XG5cdFx0c2VsZi5tb2JpbGVJbnB1dC5wbGFjZWhvbGRlciA9IHNlbGYuaW5wdXQucGxhY2Vob2xkZXI7XG5cblx0XHRzZWxmLm1vYmlsZUZvcm1hdFN0ciA9IGlucHV0VHlwZSA9PT0gXCJkYXRldGltZS1sb2NhbFwiID8gXCJZLW0tZFxcXFxUSDppOlNcIiA6IGlucHV0VHlwZSA9PT0gXCJkYXRlXCIgPyBcIlktbS1kXCIgOiBcIkg6aTpTXCI7XG5cblx0XHRpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCkge1xuXHRcdFx0c2VsZi5tb2JpbGVJbnB1dC5kZWZhdWx0VmFsdWUgPSBzZWxmLm1vYmlsZUlucHV0LnZhbHVlID0gc2VsZi5mb3JtYXREYXRlKHNlbGYuc2VsZWN0ZWREYXRlc1swXSwgc2VsZi5tb2JpbGVGb3JtYXRTdHIpO1xuXHRcdH1cblxuXHRcdGlmIChzZWxmLmNvbmZpZy5taW5EYXRlKSBzZWxmLm1vYmlsZUlucHV0Lm1pbiA9IHNlbGYuZm9ybWF0RGF0ZShzZWxmLmNvbmZpZy5taW5EYXRlLCBcIlktbS1kXCIpO1xuXG5cdFx0aWYgKHNlbGYuY29uZmlnLm1heERhdGUpIHNlbGYubW9iaWxlSW5wdXQubWF4ID0gc2VsZi5mb3JtYXREYXRlKHNlbGYuY29uZmlnLm1heERhdGUsIFwiWS1tLWRcIik7XG5cblx0XHRzZWxmLmlucHV0LnR5cGUgPSBcImhpZGRlblwiO1xuXHRcdGlmIChzZWxmLmNvbmZpZy5hbHRJbnB1dCkgc2VsZi5hbHRJbnB1dC50eXBlID0gXCJoaWRkZW5cIjtcblxuXHRcdHRyeSB7XG5cdFx0XHRzZWxmLmlucHV0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNlbGYubW9iaWxlSW5wdXQsIHNlbGYuaW5wdXQubmV4dFNpYmxpbmcpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8vXG5cdFx0fVxuXG5cdFx0c2VsZi5tb2JpbGVJbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRzZWxmLnNldERhdGUoZS50YXJnZXQudmFsdWUsIGZhbHNlLCBzZWxmLm1vYmlsZUZvcm1hdFN0cik7XG5cdFx0XHR0cmlnZ2VyRXZlbnQoXCJDaGFuZ2VcIik7XG5cdFx0XHR0cmlnZ2VyRXZlbnQoXCJDbG9zZVwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHRvZ2dsZSgpIHtcblx0XHRpZiAoc2VsZi5pc09wZW4pIHJldHVybiBzZWxmLmNsb3NlKCk7XG5cdFx0c2VsZi5vcGVuKCk7XG5cdH1cblxuXHRmdW5jdGlvbiB0cmlnZ2VyRXZlbnQoZXZlbnQsIGRhdGEpIHtcblx0XHR2YXIgaG9va3MgPSBzZWxmLmNvbmZpZ1tcIm9uXCIgKyBldmVudF07XG5cblx0XHRpZiAoaG9va3MgIT09IHVuZGVmaW5lZCAmJiBob29rcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaG9va3NbaV0gJiYgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGhvb2tzW2ldKHNlbGYuc2VsZWN0ZWREYXRlcywgc2VsZi5pbnB1dC52YWx1ZSwgc2VsZiwgZGF0YSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGV2ZW50ID09PSBcIkNoYW5nZVwiKSB7XG5cdFx0XHRzZWxmLmlucHV0LmRpc3BhdGNoRXZlbnQoY3JlYXRlRXZlbnQoXCJjaGFuZ2VcIikpO1xuXG5cdFx0XHQvLyBtYW55IGZyb250LWVuZCBmcmFtZXdvcmtzIGJpbmQgdG8gdGhlIGlucHV0IGV2ZW50XG5cdFx0XHRzZWxmLmlucHV0LmRpc3BhdGNoRXZlbnQoY3JlYXRlRXZlbnQoXCJpbnB1dFwiKSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG4gICogQ3JlYXRlcyBhbiBFdmVudCwgbm9ybWFsaXplZCBhY3Jvc3MgYnJvd3NlcnNcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgZXZlbnQgbmFtZSwgZS5nLiBcImNsaWNrXCJcbiAgKiBAcmV0dXJuIHtFdmVudH0gdGhlIGNyZWF0ZWQgZXZlbnRcbiAgKi9cblx0ZnVuY3Rpb24gY3JlYXRlRXZlbnQobmFtZSkge1xuXHRcdGlmIChzZWxmLl9zdXBwb3J0c0V2ZW50cykgcmV0dXJuIG5ldyBFdmVudChuYW1lLCB7IGJ1YmJsZXM6IHRydWUgfSk7XG5cblx0XHRzZWxmLl9bbmFtZSArIFwiRXZlbnRcIl0gPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuXHRcdHNlbGYuX1tuYW1lICsgXCJFdmVudFwiXS5pbml0RXZlbnQobmFtZSwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0cmV0dXJuIHNlbGYuX1tuYW1lICsgXCJFdmVudFwiXTtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzRGF0ZVNlbGVjdGVkKGRhdGUpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGNvbXBhcmVEYXRlcyhzZWxmLnNlbGVjdGVkRGF0ZXNbaV0sIGRhdGUpID09PSAwKSByZXR1cm4gXCJcIiArIGk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNEYXRlSW5SYW5nZShkYXRlKSB7XG5cdFx0aWYgKHNlbGYuY29uZmlnLm1vZGUgIT09IFwicmFuZ2VcIiB8fCBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoIDwgMikgcmV0dXJuIGZhbHNlO1xuXHRcdHJldHVybiBjb21wYXJlRGF0ZXMoZGF0ZSwgc2VsZi5zZWxlY3RlZERhdGVzWzBdKSA+PSAwICYmIGNvbXBhcmVEYXRlcyhkYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMV0pIDw9IDA7XG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVOYXZpZ2F0aW9uQ3VycmVudE1vbnRoKCkge1xuXHRcdGlmIChzZWxmLmNvbmZpZy5ub0NhbGVuZGFyIHx8IHNlbGYuaXNNb2JpbGUgfHwgIXNlbGYubW9udGhOYXYpIHJldHVybjtcblxuXHRcdHNlbGYuY3VycmVudE1vbnRoRWxlbWVudC50ZXh0Q29udGVudCA9IHNlbGYudXRpbHMubW9udGhUb1N0cihzZWxmLmN1cnJlbnRNb250aCkgKyBcIiBcIjtcblx0XHRzZWxmLmN1cnJlbnRZZWFyRWxlbWVudC52YWx1ZSA9IHNlbGYuY3VycmVudFllYXI7XG5cblx0XHRzZWxmLl9oaWRlUHJldk1vbnRoQXJyb3cgPSBzZWxmLmNvbmZpZy5taW5EYXRlICYmIChzZWxmLmN1cnJlbnRZZWFyID09PSBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEZ1bGxZZWFyKCkgPyBzZWxmLmN1cnJlbnRNb250aCA8PSBzZWxmLmNvbmZpZy5taW5EYXRlLmdldE1vbnRoKCkgOiBzZWxmLmN1cnJlbnRZZWFyIDwgc2VsZi5jb25maWcubWluRGF0ZS5nZXRGdWxsWWVhcigpKTtcblxuXHRcdHNlbGYuX2hpZGVOZXh0TW9udGhBcnJvdyA9IHNlbGYuY29uZmlnLm1heERhdGUgJiYgKHNlbGYuY3VycmVudFllYXIgPT09IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0RnVsbFllYXIoKSA/IHNlbGYuY3VycmVudE1vbnRoICsgMSA+IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0TW9udGgoKSA6IHNlbGYuY3VycmVudFllYXIgPiBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEZ1bGxZZWFyKCkpO1xuXHR9XG5cblx0LyoqXG4gICogVXBkYXRlcyB0aGUgdmFsdWVzIG9mIGlucHV0cyBhc3NvY2lhdGVkIHdpdGggdGhlIGNhbGVuZGFyXG4gICogQHJldHVybiB7dm9pZH1cbiAgKi9cblx0ZnVuY3Rpb24gdXBkYXRlVmFsdWUodHJpZ2dlckNoYW5nZSkge1xuXHRcdGlmICghc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCkgcmV0dXJuIHNlbGYuY2xlYXIodHJpZ2dlckNoYW5nZSk7XG5cblx0XHRpZiAoc2VsZi5pc01vYmlsZSkge1xuXHRcdFx0c2VsZi5tb2JpbGVJbnB1dC52YWx1ZSA9IHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPyBzZWxmLmZvcm1hdERhdGUoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmosIHNlbGYubW9iaWxlRm9ybWF0U3RyKSA6IFwiXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGpvaW5DaGFyID0gc2VsZi5jb25maWcubW9kZSAhPT0gXCJyYW5nZVwiID8gXCI7IFwiIDogc2VsZi5sMTBuLnJhbmdlU2VwYXJhdG9yO1xuXG5cdFx0c2VsZi5pbnB1dC52YWx1ZSA9IHNlbGYuc2VsZWN0ZWREYXRlcy5tYXAoZnVuY3Rpb24gKGRPYmopIHtcblx0XHRcdHJldHVybiBzZWxmLmZvcm1hdERhdGUoZE9iaiwgc2VsZi5jb25maWcuZGF0ZUZvcm1hdCk7XG5cdFx0fSkuam9pbihqb2luQ2hhcik7XG5cblx0XHRpZiAoc2VsZi5jb25maWcuYWx0SW5wdXQpIHtcblx0XHRcdHNlbGYuYWx0SW5wdXQudmFsdWUgPSBzZWxmLnNlbGVjdGVkRGF0ZXMubWFwKGZ1bmN0aW9uIChkT2JqKSB7XG5cdFx0XHRcdHJldHVybiBzZWxmLmZvcm1hdERhdGUoZE9iaiwgc2VsZi5jb25maWcuYWx0Rm9ybWF0KTtcblx0XHRcdH0pLmpvaW4oam9pbkNoYXIpO1xuXHRcdH1cblx0XHR0cmlnZ2VyRXZlbnQoXCJWYWx1ZVVwZGF0ZVwiKTtcblx0fVxuXG5cdGZ1bmN0aW9uIG1vdXNlRGVsdGEoZSkge1xuXHRcdHJldHVybiBNYXRoLm1heCgtMSwgTWF0aC5taW4oMSwgZS53aGVlbERlbHRhIHx8IC1lLmRlbHRhWSkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gb25Nb250aE5hdlNjcm9sbChlKSB7XG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdHZhciBpc1llYXIgPSBzZWxmLmN1cnJlbnRZZWFyRWxlbWVudC5wYXJlbnROb2RlLmNvbnRhaW5zKGUudGFyZ2V0KTtcblxuXHRcdGlmIChlLnRhcmdldCA9PT0gc2VsZi5jdXJyZW50TW9udGhFbGVtZW50IHx8IGlzWWVhcikge1xuXG5cdFx0XHR2YXIgZGVsdGEgPSBtb3VzZURlbHRhKGUpO1xuXG5cdFx0XHRpZiAoaXNZZWFyKSB7XG5cdFx0XHRcdGNoYW5nZVllYXIoc2VsZi5jdXJyZW50WWVhciArIGRlbHRhKTtcblx0XHRcdFx0ZS50YXJnZXQudmFsdWUgPSBzZWxmLmN1cnJlbnRZZWFyO1xuXHRcdFx0fSBlbHNlIHNlbGYuY2hhbmdlTW9udGgoZGVsdGEsIHRydWUsIGZhbHNlKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBvbk1vbnRoTmF2Q2xpY2soZSkge1xuXHRcdHZhciBpc1ByZXZNb250aCA9IHNlbGYucHJldk1vbnRoTmF2LmNvbnRhaW5zKGUudGFyZ2V0KTtcblx0XHR2YXIgaXNOZXh0TW9udGggPSBzZWxmLm5leHRNb250aE5hdi5jb250YWlucyhlLnRhcmdldCk7XG5cblx0XHRpZiAoaXNQcmV2TW9udGggfHwgaXNOZXh0TW9udGgpIGNoYW5nZU1vbnRoKGlzUHJldk1vbnRoID8gLTEgOiAxKTtlbHNlIGlmIChlLnRhcmdldCA9PT0gc2VsZi5jdXJyZW50WWVhckVsZW1lbnQpIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHNlbGYuY3VycmVudFllYXJFbGVtZW50LnNlbGVjdCgpO1xuXHRcdH0gZWxzZSBpZiAoZS50YXJnZXQuY2xhc3NOYW1lID09PSBcImFycm93VXBcIikgc2VsZi5jaGFuZ2VZZWFyKHNlbGYuY3VycmVudFllYXIgKyAxKTtlbHNlIGlmIChlLnRhcmdldC5jbGFzc05hbWUgPT09IFwiYXJyb3dEb3duXCIpIHNlbGYuY2hhbmdlWWVhcihzZWxmLmN1cnJlbnRZZWFyIC0gMSk7XG5cdH1cblxuXHQvKipcbiAgKiBDcmVhdGVzIGFuIEhUTUxFbGVtZW50IHdpdGggZ2l2ZW4gdGFnLCBjbGFzcywgYW5kIHRleHR1YWwgY29udGVudFxuICAqIEBwYXJhbSB7U3RyaW5nfSB0YWcgdGhlIEhUTUwgdGFnXG4gICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZSB0aGUgbmV3IGVsZW1lbnQncyBjbGFzcyBuYW1lXG4gICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnQgVGhlIG5ldyBlbGVtZW50J3MgdGV4dCBjb250ZW50XG4gICogQHJldHVybiB7SFRNTEVsZW1lbnR9IHRoZSBjcmVhdGVkIEhUTUwgZWxlbWVudFxuICAqL1xuXHRmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZywgY2xhc3NOYW1lLCBjb250ZW50KSB7XG5cdFx0dmFyIGUgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuXHRcdGNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCBcIlwiO1xuXHRcdGNvbnRlbnQgPSBjb250ZW50IHx8IFwiXCI7XG5cblx0XHRlLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcblxuXHRcdGlmIChjb250ZW50ICE9PSB1bmRlZmluZWQpIGUudGV4dENvbnRlbnQgPSBjb250ZW50O1xuXG5cdFx0cmV0dXJuIGU7XG5cdH1cblxuXHRmdW5jdGlvbiBhcnJheWlmeShvYmopIHtcblx0XHRpZiAob2JqIGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBvYmo7XG5cdFx0cmV0dXJuIFtvYmpdO1xuXHR9XG5cblx0ZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxlbSwgY2xhc3NOYW1lLCBib29sKSB7XG5cdFx0aWYgKGJvb2wpIHJldHVybiBlbGVtLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcblx0XHRlbGVtLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcblx0fVxuXG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuXHRcdHZhciB0aW1lb3V0ID0gdm9pZCAwO1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY29udGV4dCA9IHRoaXMsXG5cdFx0XHQgICAgYXJncyA9IGFyZ3VtZW50cztcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHRcdHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGltZW91dCA9IG51bGw7XG5cdFx0XHRcdGlmICghaW1tZWRpYXRlKSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuXHRcdFx0fSwgd2FpdCk7XG5cdFx0XHRpZiAoaW1tZWRpYXRlICYmICF0aW1lb3V0KSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuXHRcdH07XG5cdH1cblxuXHQvKipcbiAgKiBDb21wdXRlIHRoZSBkaWZmZXJlbmNlIGluIGRhdGVzLCBtZWFzdXJlZCBpbiBtc1xuICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZTFcbiAgKiBAcGFyYW0ge0RhdGV9IGRhdGUyXG4gICogQHBhcmFtIHtCb29sZWFufSB0aW1lbGVzcyB3aGV0aGVyIHRvIHJlc2V0IHRpbWVzIG9mIGJvdGggZGF0ZXMgdG8gMDA6MDBcbiAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBkaWZmZXJlbmNlIGluIG1zXG4gICovXG5cdGZ1bmN0aW9uIGNvbXBhcmVEYXRlcyhkYXRlMSwgZGF0ZTIsIHRpbWVsZXNzKSB7XG5cdFx0aWYgKCEoZGF0ZTEgaW5zdGFuY2VvZiBEYXRlKSB8fCAhKGRhdGUyIGluc3RhbmNlb2YgRGF0ZSkpIHJldHVybiBmYWxzZTtcblxuXHRcdGlmICh0aW1lbGVzcyAhPT0gZmFsc2UpIHtcblx0XHRcdHJldHVybiBuZXcgRGF0ZShkYXRlMS5nZXRUaW1lKCkpLnNldEhvdXJzKDAsIDAsIDAsIDApIC0gbmV3IERhdGUoZGF0ZTIuZ2V0VGltZSgpKS5zZXRIb3VycygwLCAwLCAwLCAwKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0ZTEuZ2V0VGltZSgpIC0gZGF0ZTIuZ2V0VGltZSgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gdGltZVdyYXBwZXIoZSkge1xuXHRcdGUucHJldmVudERlZmF1bHQoKTtcblxuXHRcdHZhciBpc0tleURvd24gPSBlLnR5cGUgPT09IFwia2V5ZG93blwiLFxuXHRcdCAgICBpc1doZWVsID0gZS50eXBlID09PSBcIndoZWVsXCIsXG5cdFx0ICAgIGlzSW5jcmVtZW50ID0gZS50eXBlID09PSBcImluY3JlbWVudFwiLFxuXHRcdCAgICBpbnB1dCA9IGUudGFyZ2V0O1xuXG5cdFx0aWYgKHNlbGYuYW1QTSAmJiBlLnRhcmdldCA9PT0gc2VsZi5hbVBNKSByZXR1cm4gZS50YXJnZXQudGV4dENvbnRlbnQgPSBbXCJBTVwiLCBcIlBNXCJdW2UudGFyZ2V0LnRleHRDb250ZW50ID09PSBcIkFNXCIgfCAwXTtcblxuXHRcdHZhciBtaW4gPSBOdW1iZXIoaW5wdXQubWluKSxcblx0XHQgICAgbWF4ID0gTnVtYmVyKGlucHV0Lm1heCksXG5cdFx0ICAgIHN0ZXAgPSBOdW1iZXIoaW5wdXQuc3RlcCksXG5cdFx0ICAgIGN1clZhbHVlID0gcGFyc2VJbnQoaW5wdXQudmFsdWUsIDEwKSxcblx0XHQgICAgZGVsdGEgPSBlLmRlbHRhIHx8ICghaXNLZXlEb3duID8gTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIGUud2hlZWxEZWx0YSB8fCAtZS5kZWx0YVkpKSB8fCAwIDogZS53aGljaCA9PT0gMzggPyAxIDogLTEpO1xuXG5cdFx0dmFyIG5ld1ZhbHVlID0gY3VyVmFsdWUgKyBzdGVwICogZGVsdGE7XG5cblx0XHRpZiAodHlwZW9mIGlucHV0LnZhbHVlICE9PSBcInVuZGVmaW5lZFwiICYmIGlucHV0LnZhbHVlLmxlbmd0aCA9PT0gMikge1xuXHRcdFx0dmFyIGlzSG91ckVsZW0gPSBpbnB1dCA9PT0gc2VsZi5ob3VyRWxlbWVudCxcblx0XHRcdCAgICBpc01pbnV0ZUVsZW0gPSBpbnB1dCA9PT0gc2VsZi5taW51dGVFbGVtZW50O1xuXG5cdFx0XHRpZiAobmV3VmFsdWUgPCBtaW4pIHtcblx0XHRcdFx0bmV3VmFsdWUgPSBtYXggKyBuZXdWYWx1ZSArICFpc0hvdXJFbGVtICsgKGlzSG91ckVsZW0gJiYgIXNlbGYuYW1QTSk7XG5cblx0XHRcdFx0aWYgKGlzTWludXRlRWxlbSkgaW5jcmVtZW50TnVtSW5wdXQobnVsbCwgLTEsIHNlbGYuaG91ckVsZW1lbnQpO1xuXHRcdFx0fSBlbHNlIGlmIChuZXdWYWx1ZSA+IG1heCkge1xuXHRcdFx0XHRuZXdWYWx1ZSA9IGlucHV0ID09PSBzZWxmLmhvdXJFbGVtZW50ID8gbmV3VmFsdWUgLSBtYXggLSAhc2VsZi5hbVBNIDogbWluO1xuXG5cdFx0XHRcdGlmIChpc01pbnV0ZUVsZW0pIGluY3JlbWVudE51bUlucHV0KG51bGwsIDEsIHNlbGYuaG91ckVsZW1lbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc2VsZi5hbVBNICYmIGlzSG91ckVsZW0gJiYgKHN0ZXAgPT09IDEgPyBuZXdWYWx1ZSArIGN1clZhbHVlID09PSAyMyA6IE1hdGguYWJzKG5ld1ZhbHVlIC0gY3VyVmFsdWUpID4gc3RlcCkpIHNlbGYuYW1QTS50ZXh0Q29udGVudCA9IHNlbGYuYW1QTS50ZXh0Q29udGVudCA9PT0gXCJQTVwiID8gXCJBTVwiIDogXCJQTVwiO1xuXG5cdFx0XHRpbnB1dC52YWx1ZSA9IHNlbGYucGFkKG5ld1ZhbHVlKTtcblx0XHR9XG5cdH1cblxuXHRpbml0KCk7XG5cdHJldHVybiBzZWxmO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuRmxhdHBpY2tyLmRlZmF1bHRDb25maWcgPSB7XG5cdG1vZGU6IFwic2luZ2xlXCIsXG5cblx0cG9zaXRpb246IFwiYXV0b1wiLFxuXG5cdGFuaW1hdGU6IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJNU0lFXCIpID09PSAtMSxcblxuXHQvKiBpZiB0cnVlLCBkYXRlcyB3aWxsIGJlIHBhcnNlZCwgZm9ybWF0dGVkLCBhbmQgZGlzcGxheWVkIGluIFVUQy5cbiBwcmVsb2FkaW5nIGRhdGUgc3RyaW5ncyB3LyB0aW1lem9uZXMgaXMgcmVjb21tZW5kZWQgYnV0IG5vdCBuZWNlc3NhcnkgKi9cblx0dXRjOiBmYWxzZSxcblxuXHQvLyB3cmFwOiBzZWUgaHR0cHM6Ly9jaG1sbi5naXRodWIuaW8vZmxhdHBpY2tyL2V4YW1wbGVzLyNmbGF0cGlja3ItZXh0ZXJuYWwtZWxlbWVudHNcblx0d3JhcDogZmFsc2UsXG5cblx0Ly8gZW5hYmxlcyB3ZWVrIG51bWJlcnNcblx0d2Vla051bWJlcnM6IGZhbHNlLFxuXG5cdC8vIGFsbG93IG1hbnVhbCBkYXRldGltZSBpbnB1dFxuXHRhbGxvd0lucHV0OiBmYWxzZSxcblxuXHQvKlxuIFx0Y2xpY2tpbmcgb24gaW5wdXQgb3BlbnMgdGhlIGRhdGUodGltZSlwaWNrZXIuXG4gXHRkaXNhYmxlIGlmIHlvdSB3aXNoIHRvIG9wZW4gdGhlIGNhbGVuZGFyIG1hbnVhbGx5IHdpdGggLm9wZW4oKVxuICovXG5cdGNsaWNrT3BlbnM6IHRydWUsXG5cblx0LypcbiBcdGNsb3NlcyBjYWxlbmRhciBhZnRlciBkYXRlIHNlbGVjdGlvbixcbiBcdHVubGVzcyAnbW9kZScgaXMgJ211bHRpcGxlJyBvciBlbmFibGVUaW1lIGlzIHRydWVcbiAqL1xuXHRjbG9zZU9uU2VsZWN0OiB0cnVlLFxuXG5cdC8vIGRpc3BsYXkgdGltZSBwaWNrZXIgaW4gMjQgaG91ciBtb2RlXG5cdHRpbWVfMjRocjogZmFsc2UsXG5cblx0Ly8gZW5hYmxlcyB0aGUgdGltZSBwaWNrZXIgZnVuY3Rpb25hbGl0eVxuXHRlbmFibGVUaW1lOiBmYWxzZSxcblxuXHQvLyBub0NhbGVuZGFyOiB0cnVlIHdpbGwgaGlkZSB0aGUgY2FsZW5kYXIuIHVzZSBmb3IgYSB0aW1lIHBpY2tlciBhbG9uZyB3LyBlbmFibGVUaW1lXG5cdG5vQ2FsZW5kYXI6IGZhbHNlLFxuXG5cdC8vIG1vcmUgZGF0ZSBmb3JtYXQgY2hhcnMgYXQgaHR0cHM6Ly9jaG1sbi5naXRodWIuaW8vZmxhdHBpY2tyLyNkYXRlZm9ybWF0XG5cdGRhdGVGb3JtYXQ6IFwiWS1tLWRcIixcblxuXHQvLyBkYXRlIGZvcm1hdCB1c2VkIGluIGFyaWEtbGFiZWwgZm9yIGRheXNcblx0YXJpYURhdGVGb3JtYXQ6IFwiRiBqLCBZXCIsXG5cblx0Ly8gYWx0SW5wdXQgLSBzZWUgaHR0cHM6Ly9jaG1sbi5naXRodWIuaW8vZmxhdHBpY2tyLyNhbHRpbnB1dFxuXHRhbHRJbnB1dDogZmFsc2UsXG5cblx0Ly8gdGhlIGNyZWF0ZWQgYWx0SW5wdXQgZWxlbWVudCB3aWxsIGhhdmUgdGhpcyBjbGFzcy5cblx0YWx0SW5wdXRDbGFzczogXCJmb3JtLWNvbnRyb2wgaW5wdXRcIixcblxuXHQvLyBzYW1lIGFzIGRhdGVGb3JtYXQsIGJ1dCBmb3IgYWx0SW5wdXRcblx0YWx0Rm9ybWF0OiBcIkYgaiwgWVwiLCAvLyBkZWZhdWx0cyB0byBlLmcuIEp1bmUgMTAsIDIwMTZcblxuXHQvLyBkZWZhdWx0RGF0ZSAtIGVpdGhlciBhIGRhdGVzdHJpbmcgb3IgYSBkYXRlIG9iamVjdC4gdXNlZCBmb3IgZGF0ZXRpbWVwaWNrZXJcInMgaW5pdGlhbCB2YWx1ZVxuXHRkZWZhdWx0RGF0ZTogbnVsbCxcblxuXHQvLyB0aGUgbWluaW11bSBkYXRlIHRoYXQgdXNlciBjYW4gcGljayAoaW5jbHVzaXZlKVxuXHRtaW5EYXRlOiBudWxsLFxuXG5cdC8vIHRoZSBtYXhpbXVtIGRhdGUgdGhhdCB1c2VyIGNhbiBwaWNrIChpbmNsdXNpdmUpXG5cdG1heERhdGU6IG51bGwsXG5cblx0Ly8gZGF0ZXBhcnNlciB0aGF0IHRyYW5zZm9ybXMgYSBnaXZlbiBzdHJpbmcgdG8gYSBkYXRlIG9iamVjdFxuXHRwYXJzZURhdGU6IG51bGwsXG5cblx0Ly8gZGF0ZWZvcm1hdHRlciB0aGF0IHRyYW5zZm9ybXMgYSBnaXZlbiBkYXRlIG9iamVjdCB0byBhIHN0cmluZywgYWNjb3JkaW5nIHRvIHBhc3NlZCBmb3JtYXRcblx0Zm9ybWF0RGF0ZTogbnVsbCxcblxuXHRnZXRXZWVrOiBmdW5jdGlvbiBnZXRXZWVrKGdpdmVuRGF0ZSkge1xuXHRcdHZhciBkYXRlID0gbmV3IERhdGUoZ2l2ZW5EYXRlLmdldFRpbWUoKSk7XG5cdFx0dmFyIG9uZWphbiA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG5cdFx0cmV0dXJuIE1hdGguY2VpbCgoKGRhdGUgLSBvbmVqYW4pIC8gODY0MDAwMDAgKyBvbmVqYW4uZ2V0RGF5KCkgKyAxKSAvIDcpO1xuXHR9LFxuXG5cblx0Ly8gc2VlIGh0dHBzOi8vY2htbG4uZ2l0aHViLmlvL2ZsYXRwaWNrci8jZGlzYWJsZVxuXHRlbmFibGU6IFtdLFxuXG5cdC8vIHNlZSBodHRwczovL2NobWxuLmdpdGh1Yi5pby9mbGF0cGlja3IvI2Rpc2FibGVcblx0ZGlzYWJsZTogW10sXG5cblx0Ly8gZGlzcGxheSB0aGUgc2hvcnQgdmVyc2lvbiBvZiBtb250aCBuYW1lcyAtIGUuZy4gU2VwIGluc3RlYWQgb2YgU2VwdGVtYmVyXG5cdHNob3J0aGFuZEN1cnJlbnRNb250aDogZmFsc2UsXG5cblx0Ly8gZGlzcGxheXMgY2FsZW5kYXIgaW5saW5lLiBzZWUgaHR0cHM6Ly9jaG1sbi5naXRodWIuaW8vZmxhdHBpY2tyLyNpbmxpbmUtY2FsZW5kYXJcblx0aW5saW5lOiBmYWxzZSxcblxuXHQvLyBwb3NpdGlvbiBjYWxlbmRhciBpbnNpZGUgd3JhcHBlciBhbmQgbmV4dCB0byB0aGUgaW5wdXQgZWxlbWVudFxuXHQvLyBsZWF2ZSBhdCBmYWxzZSB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3VcInJlIGRvaW5nXG5cdFwic3RhdGljXCI6IGZhbHNlLFxuXG5cdC8vIERPTSBub2RlIHRvIGFwcGVuZCB0aGUgY2FsZW5kYXIgdG8gaW4gKnN0YXRpYyogbW9kZVxuXHRhcHBlbmRUbzogbnVsbCxcblxuXHQvLyBjb2RlIGZvciBwcmV2aW91cy9uZXh0IGljb25zLiB0aGlzIGlzIHdoZXJlIHlvdSBwdXQgeW91ciBjdXN0b20gaWNvbiBjb2RlIGUuZy4gZm9udGF3ZXNvbWVcblx0cHJldkFycm93OiBcIjxzdmcgdmVyc2lvbj0nMS4xJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHhtbG5zOnhsaW5rPSdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyB2aWV3Qm94PScwIDAgMTcgMTcnPjxnPjwvZz48cGF0aCBkPSdNNS4yMDcgOC40NzFsNy4xNDYgNy4xNDctMC43MDcgMC43MDctNy44NTMtNy44NTQgNy44NTQtNy44NTMgMC43MDcgMC43MDctNy4xNDcgNy4xNDZ6JyAvPjwvc3ZnPlwiLFxuXHRuZXh0QXJyb3c6IFwiPHN2ZyB2ZXJzaW9uPScxLjEnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgeG1sbnM6eGxpbms9J2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnIHZpZXdCb3g9JzAgMCAxNyAxNyc+PGc+PC9nPjxwYXRoIGQ9J00xMy4yMDcgOC40NzJsLTcuODU0IDcuODU0LTAuNzA3LTAuNzA3IDcuMTQ2LTcuMTQ2LTcuMTQ2LTcuMTQ4IDAuNzA3LTAuNzA3IDcuODU0IDcuODU0eicgLz48L3N2Zz5cIixcblxuXHQvLyBlbmFibGVzIHNlY29uZHMgaW4gdGhlIHRpbWUgcGlja2VyXG5cdGVuYWJsZVNlY29uZHM6IGZhbHNlLFxuXG5cdC8vIHN0ZXAgc2l6ZSB1c2VkIHdoZW4gc2Nyb2xsaW5nL2luY3JlbWVudGluZyB0aGUgaG91ciBlbGVtZW50XG5cdGhvdXJJbmNyZW1lbnQ6IDEsXG5cblx0Ly8gc3RlcCBzaXplIHVzZWQgd2hlbiBzY3JvbGxpbmcvaW5jcmVtZW50aW5nIHRoZSBtaW51dGUgZWxlbWVudFxuXHRtaW51dGVJbmNyZW1lbnQ6IDUsXG5cblx0Ly8gaW5pdGlhbCB2YWx1ZSBpbiB0aGUgaG91ciBlbGVtZW50XG5cdGRlZmF1bHRIb3VyOiAxMixcblxuXHQvLyBpbml0aWFsIHZhbHVlIGluIHRoZSBtaW51dGUgZWxlbWVudFxuXHRkZWZhdWx0TWludXRlOiAwLFxuXG5cdC8vIGRpc2FibGUgbmF0aXZlIG1vYmlsZSBkYXRldGltZSBpbnB1dCBzdXBwb3J0XG5cdGRpc2FibGVNb2JpbGU6IGZhbHNlLFxuXG5cdC8vIGRlZmF1bHQgbG9jYWxlXG5cdGxvY2FsZTogXCJkZWZhdWx0XCIsXG5cblx0cGx1Z2luczogW10sXG5cblx0Ly8gY2FsbGVkIGV2ZXJ5IHRpbWUgY2FsZW5kYXIgaXMgY2xvc2VkXG5cdG9uQ2xvc2U6IHVuZGVmaW5lZCwgLy8gZnVuY3Rpb24gKGRhdGVPYmosIGRhdGVTdHIpIHt9XG5cblx0Ly8gb25DaGFuZ2UgY2FsbGJhY2sgd2hlbiB1c2VyIHNlbGVjdHMgYSBkYXRlIG9yIHRpbWVcblx0b25DaGFuZ2U6IHVuZGVmaW5lZCwgLy8gZnVuY3Rpb24gKGRhdGVPYmosIGRhdGVTdHIpIHt9XG5cblx0Ly8gY2FsbGVkIGZvciBldmVyeSBkYXkgZWxlbWVudFxuXHRvbkRheUNyZWF0ZTogdW5kZWZpbmVkLFxuXG5cdC8vIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBtb250aCBpcyBjaGFuZ2VkXG5cdG9uTW9udGhDaGFuZ2U6IHVuZGVmaW5lZCxcblxuXHQvLyBjYWxsZWQgZXZlcnkgdGltZSBjYWxlbmRhciBpcyBvcGVuZWRcblx0b25PcGVuOiB1bmRlZmluZWQsIC8vIGZ1bmN0aW9uIChkYXRlT2JqLCBkYXRlU3RyKSB7fVxuXG5cdC8vIGNhbGxlZCBhZnRlciB0aGUgY29uZmlndXJhdGlvbiBoYXMgYmVlbiBwYXJzZWRcblx0b25QYXJzZUNvbmZpZzogdW5kZWZpbmVkLFxuXG5cdC8vIGNhbGxlZCBhZnRlciBjYWxlbmRhciBpcyByZWFkeVxuXHRvblJlYWR5OiB1bmRlZmluZWQsIC8vIGZ1bmN0aW9uIChkYXRlT2JqLCBkYXRlU3RyKSB7fVxuXG5cdC8vIGNhbGxlZCBhZnRlciBpbnB1dCB2YWx1ZSB1cGRhdGVkXG5cdG9uVmFsdWVVcGRhdGU6IHVuZGVmaW5lZCxcblxuXHQvLyBjYWxsZWQgZXZlcnkgdGltZSB0aGUgeWVhciBpcyBjaGFuZ2VkXG5cdG9uWWVhckNoYW5nZTogdW5kZWZpbmVkLFxuXG5cdG9uS2V5RG93bjogdW5kZWZpbmVkXG59O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuRmxhdHBpY2tyLmwxMG5zID0ge1xuXHRlbjoge1xuXHRcdHdlZWtkYXlzOiB7XG5cdFx0XHRzaG9ydGhhbmQ6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcblx0XHRcdGxvbmdoYW5kOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXVxuXHRcdH0sXG5cdFx0bW9udGhzOiB7XG5cdFx0XHRzaG9ydGhhbmQ6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXSxcblx0XHRcdGxvbmdoYW5kOiBbXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXVxuXHRcdH0sXG5cdFx0ZGF5c0luTW9udGg6IFszMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXSxcblx0XHRmaXJzdERheU9mV2VlazogMCxcblx0XHRvcmRpbmFsOiBmdW5jdGlvbiBvcmRpbmFsKG50aCkge1xuXHRcdFx0dmFyIHMgPSBudGggJSAxMDA7XG5cdFx0XHRpZiAocyA+IDMgJiYgcyA8IDIxKSByZXR1cm4gXCJ0aFwiO1xuXHRcdFx0c3dpdGNoIChzICUgMTApIHtcblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdHJldHVybiBcInN0XCI7XG5cdFx0XHRcdGNhc2UgMjpcblx0XHRcdFx0XHRyZXR1cm4gXCJuZFwiO1xuXHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0cmV0dXJuIFwicmRcIjtcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRyZXR1cm4gXCJ0aFwiO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0cmFuZ2VTZXBhcmF0b3I6IFwiIHRvIFwiLFxuXHRcdHdlZWtBYmJyZXZpYXRpb246IFwiV2tcIixcblx0XHRzY3JvbGxUaXRsZTogXCJTY3JvbGwgdG8gaW5jcmVtZW50XCIsXG5cdFx0dG9nZ2xlVGl0bGU6IFwiQ2xpY2sgdG8gdG9nZ2xlXCJcblx0fVxufTtcblxuRmxhdHBpY2tyLmwxMG5zLmRlZmF1bHQgPSBPYmplY3QuY3JlYXRlKEZsYXRwaWNrci5sMTBucy5lbik7XG5GbGF0cGlja3IubG9jYWxpemUgPSBmdW5jdGlvbiAobDEwbikge1xuXHRyZXR1cm4gX2V4dGVuZHMoRmxhdHBpY2tyLmwxMG5zLmRlZmF1bHQsIGwxMG4gfHwge30pO1xufTtcbkZsYXRwaWNrci5zZXREZWZhdWx0cyA9IGZ1bmN0aW9uIChjb25maWcpIHtcblx0cmV0dXJuIF9leHRlbmRzKEZsYXRwaWNrci5kZWZhdWx0Q29uZmlnLCBjb25maWcgfHwge30pO1xufTtcblxuRmxhdHBpY2tyLnByb3RvdHlwZSA9IHtcblx0Zm9ybWF0czoge1xuXHRcdC8vIGdldCB0aGUgZGF0ZSBpbiBVVENcblx0XHRaOiBmdW5jdGlvbiBaKGRhdGUpIHtcblx0XHRcdHJldHVybiBkYXRlLnRvSVNPU3RyaW5nKCk7XG5cdFx0fSxcblxuXHRcdC8vIHdlZWtkYXkgbmFtZSwgc2hvcnQsIGUuZy4gVGh1XG5cdFx0RDogZnVuY3Rpb24gRChkYXRlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5sMTBuLndlZWtkYXlzLnNob3J0aGFuZFt0aGlzLmZvcm1hdHMudyhkYXRlKV07XG5cdFx0fSxcblxuXHRcdC8vIGZ1bGwgbW9udGggbmFtZSBlLmcuIEphbnVhcnlcblx0XHRGOiBmdW5jdGlvbiBGKGRhdGUpIHtcblx0XHRcdHJldHVybiB0aGlzLnV0aWxzLm1vbnRoVG9TdHIodGhpcy5mb3JtYXRzLm4oZGF0ZSkgLSAxLCBmYWxzZSk7XG5cdFx0fSxcblxuXHRcdC8vIHBhZGRlZCBob3VyIDEtMTJcblx0XHRHOiBmdW5jdGlvbiBHKGRhdGUpIHtcblx0XHRcdHJldHVybiBGbGF0cGlja3IucHJvdG90eXBlLnBhZChGbGF0cGlja3IucHJvdG90eXBlLmZvcm1hdHMuaChkYXRlKSk7XG5cdFx0fSxcblxuXHRcdC8vIGhvdXJzIHdpdGggbGVhZGluZyB6ZXJvIGUuZy4gMDNcblx0XHRIOiBmdW5jdGlvbiBIKGRhdGUpIHtcblx0XHRcdHJldHVybiBGbGF0cGlja3IucHJvdG90eXBlLnBhZChkYXRlLmdldEhvdXJzKCkpO1xuXHRcdH0sXG5cblx0XHQvLyBkYXkgKDEtMzApIHdpdGggb3JkaW5hbCBzdWZmaXggZS5nLiAxc3QsIDJuZFxuXHRcdEo6IGZ1bmN0aW9uIEooZGF0ZSkge1xuXHRcdFx0cmV0dXJuIGRhdGUuZ2V0RGF0ZSgpICsgdGhpcy5sMTBuLm9yZGluYWwoZGF0ZS5nZXREYXRlKCkpO1xuXHRcdH0sXG5cblx0XHQvLyBBTS9QTVxuXHRcdEs6IGZ1bmN0aW9uIEsoZGF0ZSkge1xuXHRcdFx0cmV0dXJuIGRhdGUuZ2V0SG91cnMoKSA+IDExID8gXCJQTVwiIDogXCJBTVwiO1xuXHRcdH0sXG5cblx0XHQvLyBzaG9ydGhhbmQgbW9udGggZS5nLiBKYW4sIFNlcCwgT2N0LCBldGNcblx0XHRNOiBmdW5jdGlvbiBNKGRhdGUpIHtcblx0XHRcdHJldHVybiB0aGlzLnV0aWxzLm1vbnRoVG9TdHIoZGF0ZS5nZXRNb250aCgpLCB0cnVlKTtcblx0XHR9LFxuXG5cdFx0Ly8gc2Vjb25kcyAwMC01OVxuXHRcdFM6IGZ1bmN0aW9uIFMoZGF0ZSkge1xuXHRcdFx0cmV0dXJuIEZsYXRwaWNrci5wcm90b3R5cGUucGFkKGRhdGUuZ2V0U2Vjb25kcygpKTtcblx0XHR9LFxuXG5cdFx0Ly8gdW5peCB0aW1lc3RhbXBcblx0XHRVOiBmdW5jdGlvbiBVKGRhdGUpIHtcblx0XHRcdHJldHVybiBkYXRlLmdldFRpbWUoKSAvIDEwMDA7XG5cdFx0fSxcblxuXHRcdFc6IGZ1bmN0aW9uIFcoZGF0ZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY29uZmlnLmdldFdlZWsoZGF0ZSk7XG5cdFx0fSxcblxuXHRcdC8vIGZ1bGwgeWVhciBlLmcuIDIwMTZcblx0XHRZOiBmdW5jdGlvbiBZKGRhdGUpIHtcblx0XHRcdHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCk7XG5cdFx0fSxcblxuXHRcdC8vIGRheSBpbiBtb250aCwgcGFkZGVkICgwMS0zMClcblx0XHRkOiBmdW5jdGlvbiBkKGRhdGUpIHtcblx0XHRcdHJldHVybiBGbGF0cGlja3IucHJvdG90eXBlLnBhZChkYXRlLmdldERhdGUoKSk7XG5cdFx0fSxcblxuXHRcdC8vIGhvdXIgZnJvbSAxLTEyIChhbS9wbSlcblx0XHRoOiBmdW5jdGlvbiBoKGRhdGUpIHtcblx0XHRcdHJldHVybiBkYXRlLmdldEhvdXJzKCkgJSAxMiA/IGRhdGUuZ2V0SG91cnMoKSAlIDEyIDogMTI7XG5cdFx0fSxcblxuXHRcdC8vIG1pbnV0ZXMsIHBhZGRlZCB3aXRoIGxlYWRpbmcgemVybyBlLmcuIDA5XG5cdFx0aTogZnVuY3Rpb24gaShkYXRlKSB7XG5cdFx0XHRyZXR1cm4gRmxhdHBpY2tyLnByb3RvdHlwZS5wYWQoZGF0ZS5nZXRNaW51dGVzKCkpO1xuXHRcdH0sXG5cblx0XHQvLyBkYXkgaW4gbW9udGggKDEtMzApXG5cdFx0ajogZnVuY3Rpb24gaihkYXRlKSB7XG5cdFx0XHRyZXR1cm4gZGF0ZS5nZXREYXRlKCk7XG5cdFx0fSxcblxuXHRcdC8vIHdlZWtkYXkgbmFtZSwgZnVsbCwgZS5nLiBUaHVyc2RheVxuXHRcdGw6IGZ1bmN0aW9uIGwoZGF0ZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMubDEwbi53ZWVrZGF5cy5sb25naGFuZFtkYXRlLmdldERheSgpXTtcblx0XHR9LFxuXG5cdFx0Ly8gcGFkZGVkIG1vbnRoIG51bWJlciAoMDEtMTIpXG5cdFx0bTogZnVuY3Rpb24gbShkYXRlKSB7XG5cdFx0XHRyZXR1cm4gRmxhdHBpY2tyLnByb3RvdHlwZS5wYWQoZGF0ZS5nZXRNb250aCgpICsgMSk7XG5cdFx0fSxcblxuXHRcdC8vIHRoZSBtb250aCBudW1iZXIgKDEtMTIpXG5cdFx0bjogZnVuY3Rpb24gbihkYXRlKSB7XG5cdFx0XHRyZXR1cm4gZGF0ZS5nZXRNb250aCgpICsgMTtcblx0XHR9LFxuXG5cdFx0Ly8gc2Vjb25kcyAwLTU5XG5cdFx0czogZnVuY3Rpb24gcyhkYXRlKSB7XG5cdFx0XHRyZXR1cm4gZGF0ZS5nZXRTZWNvbmRzKCk7XG5cdFx0fSxcblxuXHRcdC8vIG51bWJlciBvZiB0aGUgZGF5IG9mIHRoZSB3ZWVrXG5cdFx0dzogZnVuY3Rpb24gdyhkYXRlKSB7XG5cdFx0XHRyZXR1cm4gZGF0ZS5nZXREYXkoKTtcblx0XHR9LFxuXG5cdFx0Ly8gbGFzdCB0d28gZGlnaXRzIG9mIHllYXIgZS5nLiAxNiBmb3IgMjAxNlxuXHRcdHk6IGZ1bmN0aW9uIHkoZGF0ZSkge1xuXHRcdFx0cmV0dXJuIFN0cmluZyhkYXRlLmdldEZ1bGxZZWFyKCkpLnN1YnN0cmluZygyKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG4gICogRm9ybWF0cyBhIGdpdmVuIERhdGUgb2JqZWN0IGludG8gYSBzdHJpbmcgYmFzZWQgb24gc3VwcGxpZWQgZm9ybWF0XG4gICogQHBhcmFtIHtEYXRlfSBkYXRlT2JqIHRoZSBkYXRlIG9iamVjdFxuICAqIEBwYXJhbSB7U3RyaW5nfSBmcm10IGEgc3RyaW5nIGNvbXBvc2VkIG9mIGZvcm1hdHRpbmcgdG9rZW5zIGUuZy4gXCJZLW0tZFwiXG4gICogQHJldHVybiB7U3RyaW5nfSBUaGUgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGF0ZSBlLmcuIDIwMTctMDItMDNcbiAgKi9cblx0Zm9ybWF0RGF0ZTogZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlT2JqLCBmcm10KSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdGlmICh0aGlzLmNvbmZpZyAhPT0gdW5kZWZpbmVkICYmIHRoaXMuY29uZmlnLmZvcm1hdERhdGUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuY29uZmlnLmZvcm1hdERhdGUoZGF0ZU9iaiwgZnJtdCk7XG5cblx0XHRyZXR1cm4gZnJtdC5zcGxpdChcIlwiKS5tYXAoZnVuY3Rpb24gKGMsIGksIGFycikge1xuXHRcdFx0cmV0dXJuIF90aGlzLmZvcm1hdHNbY10gJiYgYXJyW2kgLSAxXSAhPT0gXCJcXFxcXCIgPyBfdGhpcy5mb3JtYXRzW2NdKGRhdGVPYmopIDogYyAhPT0gXCJcXFxcXCIgPyBjIDogXCJcIjtcblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9LFxuXG5cblx0cmV2Rm9ybWF0OiB7XG5cdFx0RDogZnVuY3Rpb24gRCgpIHt9LFxuXHRcdEY6IGZ1bmN0aW9uIEYoZGF0ZU9iaiwgbW9udGhOYW1lKSB7XG5cdFx0XHRkYXRlT2JqLnNldE1vbnRoKHRoaXMubDEwbi5tb250aHMubG9uZ2hhbmQuaW5kZXhPZihtb250aE5hbWUpKTtcblx0XHR9LFxuXHRcdEc6IGZ1bmN0aW9uIEcoZGF0ZU9iaiwgaG91cikge1xuXHRcdFx0ZGF0ZU9iai5zZXRIb3VycyhwYXJzZUZsb2F0KGhvdXIpKTtcblx0XHR9LFxuXHRcdEg6IGZ1bmN0aW9uIEgoZGF0ZU9iaiwgaG91cikge1xuXHRcdFx0ZGF0ZU9iai5zZXRIb3VycyhwYXJzZUZsb2F0KGhvdXIpKTtcblx0XHR9LFxuXHRcdEo6IGZ1bmN0aW9uIEooZGF0ZU9iaiwgZGF5KSB7XG5cdFx0XHRkYXRlT2JqLnNldERhdGUocGFyc2VGbG9hdChkYXkpKTtcblx0XHR9LFxuXHRcdEs6IGZ1bmN0aW9uIEsoZGF0ZU9iaiwgYW1QTSkge1xuXHRcdFx0dmFyIGhvdXJzID0gZGF0ZU9iai5nZXRIb3VycygpO1xuXG5cdFx0XHRpZiAoaG91cnMgIT09IDEyKSBkYXRlT2JqLnNldEhvdXJzKGhvdXJzICUgMTIgKyAxMiAqIC9wbS9pLnRlc3QoYW1QTSkpO1xuXHRcdH0sXG5cdFx0TTogZnVuY3Rpb24gTShkYXRlT2JqLCBzaG9ydE1vbnRoKSB7XG5cdFx0XHRkYXRlT2JqLnNldE1vbnRoKHRoaXMubDEwbi5tb250aHMuc2hvcnRoYW5kLmluZGV4T2Yoc2hvcnRNb250aCkpO1xuXHRcdH0sXG5cdFx0UzogZnVuY3Rpb24gUyhkYXRlT2JqLCBzZWNvbmRzKSB7XG5cdFx0XHRkYXRlT2JqLnNldFNlY29uZHMoc2Vjb25kcyk7XG5cdFx0fSxcblx0XHRVOiBmdW5jdGlvbiBVKGRhdGVPYmosIHVuaXhTZWNvbmRzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IERhdGUocGFyc2VGbG9hdCh1bml4U2Vjb25kcykgKiAxMDAwKTtcblx0XHR9LFxuXG5cdFx0VzogZnVuY3Rpb24gVyhkYXRlT2JqLCB3ZWVrTnVtYmVyKSB7XG5cdFx0XHR3ZWVrTnVtYmVyID0gcGFyc2VJbnQod2Vla051bWJlcik7XG5cdFx0XHRyZXR1cm4gbmV3IERhdGUoZGF0ZU9iai5nZXRGdWxsWWVhcigpLCAwLCAyICsgKHdlZWtOdW1iZXIgLSAxKSAqIDcsIDAsIDAsIDAsIDAsIDApO1xuXHRcdH0sXG5cdFx0WTogZnVuY3Rpb24gWShkYXRlT2JqLCB5ZWFyKSB7XG5cdFx0XHRkYXRlT2JqLnNldEZ1bGxZZWFyKHllYXIpO1xuXHRcdH0sXG5cdFx0WjogZnVuY3Rpb24gWihkYXRlT2JqLCBJU09EYXRlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IERhdGUoSVNPRGF0ZSk7XG5cdFx0fSxcblxuXHRcdGQ6IGZ1bmN0aW9uIGQoZGF0ZU9iaiwgZGF5KSB7XG5cdFx0XHRkYXRlT2JqLnNldERhdGUocGFyc2VGbG9hdChkYXkpKTtcblx0XHR9LFxuXHRcdGg6IGZ1bmN0aW9uIGgoZGF0ZU9iaiwgaG91cikge1xuXHRcdFx0ZGF0ZU9iai5zZXRIb3VycyhwYXJzZUZsb2F0KGhvdXIpKTtcblx0XHR9LFxuXHRcdGk6IGZ1bmN0aW9uIGkoZGF0ZU9iaiwgbWludXRlcykge1xuXHRcdFx0ZGF0ZU9iai5zZXRNaW51dGVzKHBhcnNlRmxvYXQobWludXRlcykpO1xuXHRcdH0sXG5cdFx0ajogZnVuY3Rpb24gaihkYXRlT2JqLCBkYXkpIHtcblx0XHRcdGRhdGVPYmouc2V0RGF0ZShwYXJzZUZsb2F0KGRheSkpO1xuXHRcdH0sXG5cdFx0bDogZnVuY3Rpb24gbCgpIHt9LFxuXHRcdG06IGZ1bmN0aW9uIG0oZGF0ZU9iaiwgbW9udGgpIHtcblx0XHRcdGRhdGVPYmouc2V0TW9udGgocGFyc2VGbG9hdChtb250aCkgLSAxKTtcblx0XHR9LFxuXHRcdG46IGZ1bmN0aW9uIG4oZGF0ZU9iaiwgbW9udGgpIHtcblx0XHRcdGRhdGVPYmouc2V0TW9udGgocGFyc2VGbG9hdChtb250aCkgLSAxKTtcblx0XHR9LFxuXHRcdHM6IGZ1bmN0aW9uIHMoZGF0ZU9iaiwgc2Vjb25kcykge1xuXHRcdFx0ZGF0ZU9iai5zZXRTZWNvbmRzKHBhcnNlRmxvYXQoc2Vjb25kcykpO1xuXHRcdH0sXG5cdFx0dzogZnVuY3Rpb24gdygpIHt9LFxuXHRcdHk6IGZ1bmN0aW9uIHkoZGF0ZU9iaiwgeWVhcikge1xuXHRcdFx0ZGF0ZU9iai5zZXRGdWxsWWVhcigyMDAwICsgcGFyc2VGbG9hdCh5ZWFyKSk7XG5cdFx0fVxuXHR9LFxuXG5cdHRva2VuUmVnZXg6IHtcblx0XHREOiBcIihcXFxcdyspXCIsXG5cdFx0RjogXCIoXFxcXHcrKVwiLFxuXHRcdEc6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG5cdFx0SDogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcblx0XHRKOiBcIihcXFxcZFxcXFxkfFxcXFxkKVxcXFx3K1wiLFxuXHRcdEs6IFwiKFxcXFx3KylcIixcblx0XHRNOiBcIihcXFxcdyspXCIsXG5cdFx0UzogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcblx0XHRVOiBcIiguKylcIixcblx0XHRXOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuXHRcdFk6IFwiKFxcXFxkezR9KVwiLFxuXHRcdFo6IFwiKC4rKVwiLFxuXHRcdGQ6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG5cdFx0aDogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcblx0XHRpOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuXHRcdGo6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG5cdFx0bDogXCIoXFxcXHcrKVwiLFxuXHRcdG06IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG5cdFx0bjogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcblx0XHRzOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuXHRcdHc6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG5cdFx0eTogXCIoXFxcXGR7Mn0pXCJcblx0fSxcblxuXHRwYWQ6IGZ1bmN0aW9uIHBhZChudW1iZXIpIHtcblx0XHRyZXR1cm4gKFwiMFwiICsgbnVtYmVyKS5zbGljZSgtMik7XG5cdH0sXG5cblx0LyoqXG4gICogUGFyc2VzIGEgZGF0ZSgrdGltZSkgc3RyaW5nIGludG8gYSBEYXRlIG9iamVjdFxuICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRlIHRoZSBkYXRlIHN0cmluZywgZS5nLiAyMDE3LTAyLTAzIDE0OjQ1XG4gICogQHBhcmFtIHtTdHJpbmd9IGdpdmVuRm9ybWF0IHRoZSBkYXRlIGZvcm1hdCwgZS5nLiBZLW0tZCBIOmlcbiAgKiBAcGFyYW0ge0Jvb2xlYW59IHRpbWVsZXNzIHdoZXRoZXIgdG8gcmVzZXQgdGhlIHRpbWUgb2YgRGF0ZSBvYmplY3RcbiAgKiBAcmV0dXJuIHtEYXRlfSB0aGUgcGFyc2VkIERhdGUgb2JqZWN0XG4gICovXG5cdHBhcnNlRGF0ZTogZnVuY3Rpb24gcGFyc2VEYXRlKGRhdGUsIGdpdmVuRm9ybWF0LCB0aW1lbGVzcykge1xuXHRcdGlmICghZGF0ZSkgcmV0dXJuIG51bGw7XG5cblx0XHR2YXIgZGF0ZV9vcmlnID0gZGF0ZTtcblxuXHRcdGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xuXHRcdFx0ZGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTsgLy8gY3JlYXRlIGEgY29weVxuXHRcdFx0ZGF0ZS5mcF9pc1VUQyA9IGRhdGVfb3JpZy5mcF9pc1VUQztcblx0XHR9IGVsc2UgaWYgKGRhdGUudG9GaXhlZCAhPT0gdW5kZWZpbmVkKSAvLyB0aW1lc3RhbXBcblx0XHRcdGRhdGUgPSBuZXcgRGF0ZShkYXRlKTtlbHNlIHtcblx0XHRcdC8vIGRhdGUgc3RyaW5nXG5cdFx0XHR2YXIgZm9ybWF0ID0gZ2l2ZW5Gb3JtYXQgfHwgKHRoaXMuY29uZmlnIHx8IEZsYXRwaWNrci5kZWZhdWx0Q29uZmlnKS5kYXRlRm9ybWF0O1xuXHRcdFx0ZGF0ZSA9IFN0cmluZyhkYXRlKS50cmltKCk7XG5cblx0XHRcdGlmIChkYXRlID09PSBcInRvZGF5XCIpIHtcblx0XHRcdFx0ZGF0ZSA9IG5ldyBEYXRlKCk7XG5cdFx0XHRcdHRpbWVsZXNzID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSBpZiAoL1okLy50ZXN0KGRhdGUpIHx8IC9HTVQkLy50ZXN0KGRhdGUpKSAvLyBkYXRlc3RyaW5ncyB3LyB0aW1lem9uZVxuXHRcdFx0XHRkYXRlID0gbmV3IERhdGUoZGF0ZSk7ZWxzZSBpZiAodGhpcy5jb25maWcgJiYgdGhpcy5jb25maWcucGFyc2VEYXRlKSBkYXRlID0gdGhpcy5jb25maWcucGFyc2VEYXRlKGRhdGUsIGZvcm1hdCk7ZWxzZSB7XG5cdFx0XHRcdHZhciBwYXJzZWREYXRlID0gIXRoaXMuY29uZmlnIHx8ICF0aGlzLmNvbmZpZy5ub0NhbGVuZGFyID8gbmV3IERhdGUobmV3IERhdGUoKS5nZXRGdWxsWWVhcigpLCAwLCAxLCAwLCAwLCAwLCAwKSA6IG5ldyBEYXRlKG5ldyBEYXRlKCkuc2V0SG91cnMoMCwgMCwgMCwgMCkpO1xuXG5cdFx0XHRcdHZhciBtYXRjaGVkID0gdm9pZCAwO1xuXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBtYXRjaEluZGV4ID0gMCwgcmVnZXhTdHIgPSBcIlwiOyBpIDwgZm9ybWF0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIHRva2VuID0gZm9ybWF0W2ldO1xuXHRcdFx0XHRcdHZhciBpc0JhY2tTbGFzaCA9IHRva2VuID09PSBcIlxcXFxcIjtcblx0XHRcdFx0XHR2YXIgZXNjYXBlZCA9IGZvcm1hdFtpIC0gMV0gPT09IFwiXFxcXFwiIHx8IGlzQmFja1NsYXNoO1xuXG5cdFx0XHRcdFx0aWYgKHRoaXMudG9rZW5SZWdleFt0b2tlbl0gJiYgIWVzY2FwZWQpIHtcblx0XHRcdFx0XHRcdHJlZ2V4U3RyICs9IHRoaXMudG9rZW5SZWdleFt0b2tlbl07XG5cdFx0XHRcdFx0XHR2YXIgbWF0Y2ggPSBuZXcgUmVnRXhwKHJlZ2V4U3RyKS5leGVjKGRhdGUpO1xuXHRcdFx0XHRcdFx0aWYgKG1hdGNoICYmIChtYXRjaGVkID0gdHJ1ZSkpIHtcblx0XHRcdFx0XHRcdFx0cGFyc2VkRGF0ZSA9IHRoaXMucmV2Rm9ybWF0W3Rva2VuXShwYXJzZWREYXRlLCBtYXRjaFsrK21hdGNoSW5kZXhdKSB8fCBwYXJzZWREYXRlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIWlzQmFja1NsYXNoKSByZWdleFN0ciArPSBcIi5cIjsgLy8gZG9uJ3QgcmVhbGx5IGNhcmVcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRhdGUgPSBtYXRjaGVkID8gcGFyc2VkRGF0ZSA6IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0XHRpZiAoIShkYXRlIGluc3RhbmNlb2YgRGF0ZSkpIHtcblx0XHRcdGNvbnNvbGUud2FybihcImZsYXRwaWNrcjogaW52YWxpZCBkYXRlIFwiICsgZGF0ZV9vcmlnKTtcblx0XHRcdGNvbnNvbGUuaW5mbyh0aGlzLmVsZW1lbnQpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuY29uZmlnICYmIHRoaXMuY29uZmlnLnV0YyAmJiAhZGF0ZS5mcF9pc1VUQykgZGF0ZSA9IGRhdGUuZnBfdG9VVEMoKTtcblxuXHRcdGlmICh0aW1lbGVzcyA9PT0gdHJ1ZSkgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcblxuXHRcdHJldHVybiBkYXRlO1xuXHR9XG59O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gX2ZsYXRwaWNrcihub2RlTGlzdCwgY29uZmlnKSB7XG5cdHZhciBub2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG5vZGVMaXN0KTsgLy8gc3RhdGljIGxpc3Rcblx0dmFyIGluc3RhbmNlcyA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dHJ5IHtcblx0XHRcdG5vZGVzW2ldLl9mbGF0cGlja3IgPSBuZXcgRmxhdHBpY2tyKG5vZGVzW2ldLCBjb25maWcgfHwge30pO1xuXHRcdFx0aW5zdGFuY2VzLnB1c2gobm9kZXNbaV0uX2ZsYXRwaWNrcik7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Y29uc29sZS53YXJuKGUsIGUuc3RhY2spO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBpbnN0YW5jZXMubGVuZ3RoID09PSAxID8gaW5zdGFuY2VzWzBdIDogaW5zdGFuY2VzO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHQvLyBicm93c2VyIGVudlxuXHRIVE1MQ29sbGVjdGlvbi5wcm90b3R5cGUuZmxhdHBpY2tyID0gTm9kZUxpc3QucHJvdG90eXBlLmZsYXRwaWNrciA9IGZ1bmN0aW9uIChjb25maWcpIHtcblx0XHRyZXR1cm4gX2ZsYXRwaWNrcih0aGlzLCBjb25maWcpO1xuXHR9O1xuXG5cdEhUTUxFbGVtZW50LnByb3RvdHlwZS5mbGF0cGlja3IgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG5cdFx0cmV0dXJuIF9mbGF0cGlja3IoW3RoaXNdLCBjb25maWcpO1xuXHR9O1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZmxhdHBpY2tyKHNlbGVjdG9yLCBjb25maWcpIHtcblx0cmV0dXJuIF9mbGF0cGlja3Iod2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpLCBjb25maWcpO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0alF1ZXJ5LmZuLmZsYXRwaWNrciA9IGZ1bmN0aW9uIChjb25maWcpIHtcblx0XHRyZXR1cm4gX2ZsYXRwaWNrcih0aGlzLCBjb25maWcpO1xuXHR9O1xufVxuXG5EYXRlLnByb3RvdHlwZS5mcF9pbmNyID0gZnVuY3Rpb24gKGRheXMpIHtcblx0cmV0dXJuIG5ldyBEYXRlKHRoaXMuZ2V0RnVsbFllYXIoKSwgdGhpcy5nZXRNb250aCgpLCB0aGlzLmdldERhdGUoKSArIHBhcnNlSW50KGRheXMsIDEwKSk7XG59O1xuXG5EYXRlLnByb3RvdHlwZS5mcF9pc1VUQyA9IGZhbHNlO1xuRGF0ZS5wcm90b3R5cGUuZnBfdG9VVEMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBuZXdEYXRlID0gbmV3IERhdGUodGhpcy5nZXRVVENGdWxsWWVhcigpLCB0aGlzLmdldFVUQ01vbnRoKCksIHRoaXMuZ2V0VVRDRGF0ZSgpLCB0aGlzLmdldFVUQ0hvdXJzKCksIHRoaXMuZ2V0VVRDTWludXRlcygpLCB0aGlzLmdldFVUQ1NlY29uZHMoKSk7XG5cblx0bmV3RGF0ZS5mcF9pc1VUQyA9IHRydWU7XG5cdHJldHVybiBuZXdEYXRlO1xufTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIpIG1vZHVsZS5leHBvcnRzID0gRmxhdHBpY2tyOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHMpO1xuXG52YXIgX2xvZ2dlciA9IHJlcXVpcmUoJy4vbG9nZ2VyJyk7XG5cbnZhciBfbG9nZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZ2dlcik7XG5cbnZhciBfRXZlbnRFbWl0dGVyMiA9IHJlcXVpcmUoJy4vRXZlbnRFbWl0dGVyJyk7XG5cbnZhciBfRXZlbnRFbWl0dGVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0V2ZW50RW1pdHRlcjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfZGVmYXVsdHMob2JqLCBkZWZhdWx0cykgeyB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRlZmF1bHRzKTsgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7IHZhciBrZXkgPSBrZXlzW2ldOyB2YXIgdmFsdWUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGRlZmF1bHRzLCBrZXkpOyBpZiAodmFsdWUgJiYgdmFsdWUuY29uZmlndXJhYmxlICYmIG9ialtrZXldID09PSB1bmRlZmluZWQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSk7IH0gfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IF9kZWZhdWx0cyhzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gcmVtb3ZlKGFyciwgd2hhdCkge1xuICB2YXIgZm91bmQgPSBhcnIuaW5kZXhPZih3aGF0KTtcblxuICB3aGlsZSAoZm91bmQgIT09IC0xKSB7XG4gICAgYXJyLnNwbGljZShmb3VuZCwgMSk7XG4gICAgZm91bmQgPSBhcnIuaW5kZXhPZih3aGF0KTtcbiAgfVxufVxuXG52YXIgQ29ubmVjdG9yID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgX2luaGVyaXRzKENvbm5lY3RvciwgX0V2ZW50RW1pdHRlcik7XG5cbiAgZnVuY3Rpb24gQ29ubmVjdG9yKGJhY2tlbmQsIHN0b3JlLCBzZXJ2aWNlcykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25uZWN0b3IpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0V2ZW50RW1pdHRlci5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLmJhY2tlbmQgPSBiYWNrZW5kO1xuICAgIF90aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgX3RoaXMuc2VydmljZXMgPSBzZXJ2aWNlcztcbiAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICBfdGhpcy5sb2dnZXIgPSBfbG9nZ2VyMi5kZWZhdWx0LmNyZWF0ZSgnYmFja2VuZENvbm5lY3RvcicpO1xuXG4gICAgX3RoaXMuc3RhdGUgPSB7fTtcbiAgICBfdGhpcy5xdWV1ZSA9IFtdO1xuXG4gICAgX3RoaXMuYmFja2VuZCAmJiBfdGhpcy5iYWNrZW5kLmluaXQgJiYgX3RoaXMuYmFja2VuZC5pbml0KHNlcnZpY2VzLCBvcHRpb25zLmJhY2tlbmQsIG9wdGlvbnMpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIENvbm5lY3Rvci5wcm90b3R5cGUucXVldWVMb2FkID0gZnVuY3Rpb24gcXVldWVMb2FkKGxhbmd1YWdlcywgbmFtZXNwYWNlcywgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIC8vIGZpbmQgd2hhdCBuZWVkcyB0byBiZSBsb2FkZWRcbiAgICB2YXIgdG9Mb2FkID0gW10sXG4gICAgICAgIHBlbmRpbmcgPSBbXSxcbiAgICAgICAgdG9Mb2FkTGFuZ3VhZ2VzID0gW10sXG4gICAgICAgIHRvTG9hZE5hbWVzcGFjZXMgPSBbXTtcblxuICAgIGxhbmd1YWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChsbmcpIHtcbiAgICAgIHZhciBoYXNBbGxOYW1lc3BhY2VzID0gdHJ1ZTtcblxuICAgICAgbmFtZXNwYWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChucykge1xuICAgICAgICB2YXIgbmFtZSA9IGxuZyArICd8JyArIG5zO1xuXG4gICAgICAgIGlmIChfdGhpczIuc3RvcmUuaGFzUmVzb3VyY2VCdW5kbGUobG5nLCBucykpIHtcbiAgICAgICAgICBfdGhpczIuc3RhdGVbbmFtZV0gPSAyOyAvLyBsb2FkZWRcbiAgICAgICAgfSBlbHNlIGlmIChfdGhpczIuc3RhdGVbbmFtZV0gPCAwKSB7XG4gICAgICAgICAgLy8gbm90aGluZyB0byBkbyBmb3IgZXJyXG4gICAgICAgIH0gZWxzZSBpZiAoX3RoaXMyLnN0YXRlW25hbWVdID09PSAxKSB7XG4gICAgICAgICAgaWYgKHBlbmRpbmcuaW5kZXhPZihuYW1lKSA8IDApIHBlbmRpbmcucHVzaChuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczIuc3RhdGVbbmFtZV0gPSAxOyAvLyBwZW5kaW5nXG5cbiAgICAgICAgICBoYXNBbGxOYW1lc3BhY2VzID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAocGVuZGluZy5pbmRleE9mKG5hbWUpIDwgMCkgcGVuZGluZy5wdXNoKG5hbWUpO1xuICAgICAgICAgIGlmICh0b0xvYWQuaW5kZXhPZihuYW1lKSA8IDApIHRvTG9hZC5wdXNoKG5hbWUpO1xuICAgICAgICAgIGlmICh0b0xvYWROYW1lc3BhY2VzLmluZGV4T2YobnMpIDwgMCkgdG9Mb2FkTmFtZXNwYWNlcy5wdXNoKG5zKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghaGFzQWxsTmFtZXNwYWNlcykgdG9Mb2FkTGFuZ3VhZ2VzLnB1c2gobG5nKTtcbiAgICB9KTtcblxuICAgIGlmICh0b0xvYWQubGVuZ3RoIHx8IHBlbmRpbmcubGVuZ3RoKSB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2goe1xuICAgICAgICBwZW5kaW5nOiBwZW5kaW5nLFxuICAgICAgICBsb2FkZWQ6IHt9LFxuICAgICAgICBlcnJvcnM6IFtdLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0b0xvYWQ6IHRvTG9hZCxcbiAgICAgIHBlbmRpbmc6IHBlbmRpbmcsXG4gICAgICB0b0xvYWRMYW5ndWFnZXM6IHRvTG9hZExhbmd1YWdlcyxcbiAgICAgIHRvTG9hZE5hbWVzcGFjZXM6IHRvTG9hZE5hbWVzcGFjZXNcbiAgICB9O1xuICB9O1xuXG4gIENvbm5lY3Rvci5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gbG9hZGVkKG5hbWUsIGVyciwgZGF0YSkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgdmFyIF9uYW1lJHNwbGl0ID0gbmFtZS5zcGxpdCgnfCcpLFxuICAgICAgICBfbmFtZSRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfbmFtZSRzcGxpdCwgMiksXG4gICAgICAgIGxuZyA9IF9uYW1lJHNwbGl0MlswXSxcbiAgICAgICAgbnMgPSBfbmFtZSRzcGxpdDJbMV07XG5cbiAgICBpZiAoZXJyKSB0aGlzLmVtaXQoJ2ZhaWxlZExvYWRpbmcnLCBsbmcsIG5zLCBlcnIpO1xuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuc3RvcmUuYWRkUmVzb3VyY2VCdW5kbGUobG5nLCBucywgZGF0YSk7XG4gICAgfVxuXG4gICAgLy8gc2V0IGxvYWRlZFxuICAgIHRoaXMuc3RhdGVbbmFtZV0gPSBlcnIgPyAtMSA6IDI7XG4gICAgLy8gY2FsbGJhY2sgaWYgcmVhZHlcbiAgICB0aGlzLnF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKHEpIHtcbiAgICAgIHV0aWxzLnB1c2hQYXRoKHEubG9hZGVkLCBbbG5nXSwgbnMpO1xuICAgICAgcmVtb3ZlKHEucGVuZGluZywgbmFtZSk7XG5cbiAgICAgIGlmIChlcnIpIHEuZXJyb3JzLnB1c2goZXJyKTtcblxuICAgICAgaWYgKHEucGVuZGluZy5sZW5ndGggPT09IDAgJiYgIXEuZG9uZSkge1xuICAgICAgICBfdGhpczMuZW1pdCgnbG9hZGVkJywgcS5sb2FkZWQpO1xuICAgICAgICBxLmVycm9ycy5sZW5ndGggPyBxLmNhbGxiYWNrKHEuZXJyb3JzKSA6IHEuY2FsbGJhY2soKTtcbiAgICAgICAgcS5kb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHJlbW92ZSBkb25lIGxvYWQgcmVxdWVzdHNcbiAgICB0aGlzLnF1ZXVlID0gdGhpcy5xdWV1ZS5maWx0ZXIoZnVuY3Rpb24gKHEpIHtcbiAgICAgIHJldHVybiAhcS5kb25lO1xuICAgIH0pO1xuICB9O1xuXG4gIENvbm5lY3Rvci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIHJlYWQobG5nLCBucywgZmNOYW1lLCB0cmllZCwgd2FpdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIGlmICghdHJpZWQpIHRyaWVkID0gMDtcbiAgICBpZiAoIXdhaXQpIHdhaXQgPSAyNTA7XG5cbiAgICBpZiAoIWxuZy5sZW5ndGgpIHJldHVybiBjYWxsYmFjayhudWxsLCB7fSk7IC8vIG5vdGluZyB0byBsb2FkXG5cbiAgICB0aGlzLmJhY2tlbmRbZmNOYW1lXShsbmcsIG5zLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoZXJyICYmIGRhdGEgLyogPSByZXRyeUZsYWcgKi8gJiYgdHJpZWQgPCA1KSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNC5yZWFkLmNhbGwoX3RoaXM0LCBsbmcsIG5zLCBmY05hbWUsICsrdHJpZWQsIHdhaXQgKiAyLCBjYWxsYmFjayk7XG4gICAgICAgIH0sIHdhaXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhlcnIsIGRhdGEpO1xuICAgIH0pO1xuICB9O1xuXG4gIENvbm5lY3Rvci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIGxvYWQobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCBjYWxsYmFjaykge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgaWYgKCF0aGlzLmJhY2tlbmQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ05vIGJhY2tlbmQgd2FzIGFkZGVkIHZpYSBpMThuZXh0LnVzZS4gV2lsbCBub3QgbG9hZCByZXNvdXJjZXMuJyk7XG4gICAgICByZXR1cm4gY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgdGhpcy5iYWNrZW5kLm9wdGlvbnMsIHRoaXMub3B0aW9ucy5iYWNrZW5kKTtcblxuICAgIGlmICh0eXBlb2YgbGFuZ3VhZ2VzID09PSAnc3RyaW5nJykgbGFuZ3VhZ2VzID0gdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZVV0aWxzLnRvUmVzb2x2ZUhpZXJhcmNoeShsYW5ndWFnZXMpO1xuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycpIG5hbWVzcGFjZXMgPSBbbmFtZXNwYWNlc107XG5cbiAgICB2YXIgdG9Mb2FkID0gdGhpcy5xdWV1ZUxvYWQobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCBjYWxsYmFjayk7XG4gICAgaWYgKCF0b0xvYWQudG9Mb2FkLmxlbmd0aCkge1xuICAgICAgaWYgKCF0b0xvYWQucGVuZGluZy5sZW5ndGgpIGNhbGxiYWNrKCk7IC8vIG5vdGhpbmcgdG8gbG9hZCBhbmQgbm8gcGVuZGluZ3MuLi5jYWxsYmFjayBub3dcbiAgICAgIHJldHVybjsgLy8gcGVuZGluZ3Mgd2lsbCB0cmlnZ2VyIGNhbGxiYWNrXG4gICAgfVxuXG4gICAgLy8gbG9hZCB3aXRoIG11bHRpLWxvYWRcbiAgICBpZiAob3B0aW9ucy5hbGxvd011bHRpTG9hZGluZyAmJiB0aGlzLmJhY2tlbmQucmVhZE11bHRpKSB7XG4gICAgICB0aGlzLnJlYWQodG9Mb2FkLnRvTG9hZExhbmd1YWdlcywgdG9Mb2FkLnRvTG9hZE5hbWVzcGFjZXMsICdyZWFkTXVsdGknLCBudWxsLCBudWxsLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgIGlmIChlcnIpIF90aGlzNS5sb2dnZXIud2FybignbG9hZGluZyBuYW1lc3BhY2VzICcgKyB0b0xvYWQudG9Mb2FkTmFtZXNwYWNlcy5qb2luKCcsICcpICsgJyBmb3IgbGFuZ3VhZ2VzICcgKyB0b0xvYWQudG9Mb2FkTGFuZ3VhZ2VzLmpvaW4oJywgJykgKyAnIHZpYSBtdWx0aWxvYWRpbmcgZmFpbGVkJywgZXJyKTtcbiAgICAgICAgaWYgKCFlcnIgJiYgZGF0YSkgX3RoaXM1LmxvZ2dlci5sb2coJ2xvYWRlZCBuYW1lc3BhY2VzICcgKyB0b0xvYWQudG9Mb2FkTmFtZXNwYWNlcy5qb2luKCcsICcpICsgJyBmb3IgbGFuZ3VhZ2VzICcgKyB0b0xvYWQudG9Mb2FkTGFuZ3VhZ2VzLmpvaW4oJywgJykgKyAnIHZpYSBtdWx0aWxvYWRpbmcnLCBkYXRhKTtcblxuICAgICAgICB0b0xvYWQudG9Mb2FkLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICB2YXIgX25hbWUkc3BsaXQzID0gbmFtZS5zcGxpdCgnfCcpLFxuICAgICAgICAgICAgICBfbmFtZSRzcGxpdDQgPSBfc2xpY2VkVG9BcnJheShfbmFtZSRzcGxpdDMsIDIpLFxuICAgICAgICAgICAgICBsID0gX25hbWUkc3BsaXQ0WzBdLFxuICAgICAgICAgICAgICBuID0gX25hbWUkc3BsaXQ0WzFdO1xuXG4gICAgICAgICAgdmFyIGJ1bmRsZSA9IHV0aWxzLmdldFBhdGgoZGF0YSwgW2wsIG5dKTtcbiAgICAgICAgICBpZiAoYnVuZGxlKSB7XG4gICAgICAgICAgICBfdGhpczUubG9hZGVkKG5hbWUsIGVyciwgYnVuZGxlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIF9lcnIgPSAnbG9hZGluZyBuYW1lc3BhY2UgJyArIG4gKyAnIGZvciBsYW5ndWFnZSAnICsgbCArICcgdmlhIG11bHRpbG9hZGluZyBmYWlsZWQnO1xuICAgICAgICAgICAgX3RoaXM1LmxvYWRlZChuYW1lLCBfZXJyKTtcbiAgICAgICAgICAgIF90aGlzNS5sb2dnZXIuZXJyb3IoX2Vycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGxvYWQgb25lIGJ5IG9uZVxuICAgIGVsc2Uge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciByZWFkT25lID0gZnVuY3Rpb24gcmVhZE9uZShuYW1lKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIF9uYW1lJHNwbGl0NSA9IG5hbWUuc3BsaXQoJ3wnKSxcbiAgICAgICAgICAgICAgICBfbmFtZSRzcGxpdDYgPSBfc2xpY2VkVG9BcnJheShfbmFtZSRzcGxpdDUsIDIpLFxuICAgICAgICAgICAgICAgIGxuZyA9IF9uYW1lJHNwbGl0NlswXSxcbiAgICAgICAgICAgICAgICBucyA9IF9uYW1lJHNwbGl0NlsxXTtcblxuICAgICAgICAgICAgdGhpcy5yZWFkKGxuZywgbnMsICdyZWFkJywgbnVsbCwgbnVsbCwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgICBpZiAoZXJyKSBfdGhpczYubG9nZ2VyLndhcm4oJ2xvYWRpbmcgbmFtZXNwYWNlICcgKyBucyArICcgZm9yIGxhbmd1YWdlICcgKyBsbmcgKyAnIGZhaWxlZCcsIGVycik7XG4gICAgICAgICAgICAgIGlmICghZXJyICYmIGRhdGEpIF90aGlzNi5sb2dnZXIubG9nKCdsb2FkZWQgbmFtZXNwYWNlICcgKyBucyArICcgZm9yIGxhbmd1YWdlICcgKyBsbmcsIGRhdGEpO1xuXG4gICAgICAgICAgICAgIF90aGlzNi5sb2FkZWQobmFtZSwgZXJyLCBkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICA7XG5cbiAgICAgICAgICB0b0xvYWQudG9Mb2FkLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJlYWRPbmUuY2FsbChfdGhpczUsIG5hbWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpO1xuICAgICAgfVxuICB9O1xuXG4gIENvbm5lY3Rvci5wcm90b3R5cGUucmVsb2FkID0gZnVuY3Rpb24gcmVsb2FkKGxhbmd1YWdlcywgbmFtZXNwYWNlcykge1xuICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgaWYgKCF0aGlzLmJhY2tlbmQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ05vIGJhY2tlbmQgd2FzIGFkZGVkIHZpYSBpMThuZXh0LnVzZS4gV2lsbCBub3QgbG9hZCByZXNvdXJjZXMuJyk7XG4gICAgfVxuICAgIHZhciBvcHRpb25zID0gX2V4dGVuZHMoe30sIHRoaXMuYmFja2VuZC5vcHRpb25zLCB0aGlzLm9wdGlvbnMuYmFja2VuZCk7XG5cbiAgICBpZiAodHlwZW9mIGxhbmd1YWdlcyA9PT0gJ3N0cmluZycpIGxhbmd1YWdlcyA9IHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscy50b1Jlc29sdmVIaWVyYXJjaHkobGFuZ3VhZ2VzKTtcbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnKSBuYW1lc3BhY2VzID0gW25hbWVzcGFjZXNdO1xuXG4gICAgLy8gbG9hZCB3aXRoIG11bHRpLWxvYWRcbiAgICBpZiAob3B0aW9ucy5hbGxvd011bHRpTG9hZGluZyAmJiB0aGlzLmJhY2tlbmQucmVhZE11bHRpKSB7XG4gICAgICB0aGlzLnJlYWQobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCAncmVhZE11bHRpJywgbnVsbCwgbnVsbCwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICBpZiAoZXJyKSBfdGhpczcubG9nZ2VyLndhcm4oJ3JlbG9hZGluZyBuYW1lc3BhY2VzICcgKyBuYW1lc3BhY2VzLmpvaW4oJywgJykgKyAnIGZvciBsYW5ndWFnZXMgJyArIGxhbmd1YWdlcy5qb2luKCcsICcpICsgJyB2aWEgbXVsdGlsb2FkaW5nIGZhaWxlZCcsIGVycik7XG4gICAgICAgIGlmICghZXJyICYmIGRhdGEpIF90aGlzNy5sb2dnZXIubG9nKCdyZWxvYWRlZCBuYW1lc3BhY2VzICcgKyBuYW1lc3BhY2VzLmpvaW4oJywgJykgKyAnIGZvciBsYW5ndWFnZXMgJyArIGxhbmd1YWdlcy5qb2luKCcsICcpICsgJyB2aWEgbXVsdGlsb2FkaW5nJywgZGF0YSk7XG5cbiAgICAgICAgbGFuZ3VhZ2VzLmZvckVhY2goZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICBuYW1lc3BhY2VzLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHZhciBidW5kbGUgPSB1dGlscy5nZXRQYXRoKGRhdGEsIFtsLCBuXSk7XG4gICAgICAgICAgICBpZiAoYnVuZGxlKSB7XG4gICAgICAgICAgICAgIF90aGlzNy5sb2FkZWQobCArICd8JyArIG4sIGVyciwgYnVuZGxlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBfZXJyMiA9ICdyZWxvYWRpbmcgbmFtZXNwYWNlICcgKyBuICsgJyBmb3IgbGFuZ3VhZ2UgJyArIGwgKyAnIHZpYSBtdWx0aWxvYWRpbmcgZmFpbGVkJztcbiAgICAgICAgICAgICAgX3RoaXM3LmxvYWRlZChsICsgJ3wnICsgbiwgX2VycjIpO1xuICAgICAgICAgICAgICBfdGhpczcubG9nZ2VyLmVycm9yKF9lcnIyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBsb2FkIG9uZSBieSBvbmVcbiAgICBlbHNlIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcmVhZE9uZSA9IGZ1bmN0aW9uIHJlYWRPbmUobmFtZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBfbmFtZSRzcGxpdDcgPSBuYW1lLnNwbGl0KCd8JyksXG4gICAgICAgICAgICAgICAgX25hbWUkc3BsaXQ4ID0gX3NsaWNlZFRvQXJyYXkoX25hbWUkc3BsaXQ3LCAyKSxcbiAgICAgICAgICAgICAgICBsbmcgPSBfbmFtZSRzcGxpdDhbMF0sXG4gICAgICAgICAgICAgICAgbnMgPSBfbmFtZSRzcGxpdDhbMV07XG5cbiAgICAgICAgICAgIHRoaXMucmVhZChsbmcsIG5zLCAncmVhZCcsIG51bGwsIG51bGwsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgICAgaWYgKGVycikgX3RoaXM4LmxvZ2dlci53YXJuKCdyZWxvYWRpbmcgbmFtZXNwYWNlICcgKyBucyArICcgZm9yIGxhbmd1YWdlICcgKyBsbmcgKyAnIGZhaWxlZCcsIGVycik7XG4gICAgICAgICAgICAgIGlmICghZXJyICYmIGRhdGEpIF90aGlzOC5sb2dnZXIubG9nKCdyZWxvYWRlZCBuYW1lc3BhY2UgJyArIG5zICsgJyBmb3IgbGFuZ3VhZ2UgJyArIGxuZywgZGF0YSk7XG5cbiAgICAgICAgICAgICAgX3RoaXM4LmxvYWRlZChuYW1lLCBlcnIsIGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIDtcblxuICAgICAgICAgIGxhbmd1YWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICBuYW1lc3BhY2VzLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgcmVhZE9uZS5jYWxsKF90aGlzNywgbCArICd8JyArIG4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG4gIH07XG5cbiAgQ29ubmVjdG9yLnByb3RvdHlwZS5zYXZlTWlzc2luZyA9IGZ1bmN0aW9uIHNhdmVNaXNzaW5nKGxhbmd1YWdlcywgbmFtZXNwYWNlLCBrZXksIGZhbGxiYWNrVmFsdWUpIHtcbiAgICBpZiAodGhpcy5iYWNrZW5kICYmIHRoaXMuYmFja2VuZC5jcmVhdGUpIHRoaXMuYmFja2VuZC5jcmVhdGUobGFuZ3VhZ2VzLCBuYW1lc3BhY2UsIGtleSwgZmFsbGJhY2tWYWx1ZSk7XG5cbiAgICAvLyB3cml0ZSB0byBzdG9yZSB0byBhdm9pZCByZXNlbmRpbmdcbiAgICBpZiAoIWxhbmd1YWdlcyB8fCAhbGFuZ3VhZ2VzWzBdKSByZXR1cm47XG4gICAgdGhpcy5zdG9yZS5hZGRSZXNvdXJjZShsYW5ndWFnZXNbMF0sIG5hbWVzcGFjZSwga2V5LCBmYWxsYmFja1ZhbHVlKTtcbiAgfTtcblxuICByZXR1cm4gQ29ubmVjdG9yO1xufShfRXZlbnRFbWl0dGVyMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ29ubmVjdG9yOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIHV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzKTtcblxudmFyIF9sb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xuXG52YXIgX2xvZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2dnZXIpO1xuXG52YXIgX0V2ZW50RW1pdHRlcjIgPSByZXF1aXJlKCcuL0V2ZW50RW1pdHRlcicpO1xuXG52YXIgX0V2ZW50RW1pdHRlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FdmVudEVtaXR0ZXIyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2RlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHsgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkZWZhdWx0cyk7IGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykgeyB2YXIga2V5ID0ga2V5c1tpXTsgdmFyIHZhbHVlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkZWZhdWx0cywga2V5KTsgaWYgKHZhbHVlICYmIHZhbHVlLmNvbmZpZ3VyYWJsZSAmJiBvYmpba2V5XSA9PT0gdW5kZWZpbmVkKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpOyB9IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBfZGVmYXVsdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbnZhciBDb25uZWN0b3IgPSBmdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICBfaW5oZXJpdHMoQ29ubmVjdG9yLCBfRXZlbnRFbWl0dGVyKTtcblxuICBmdW5jdGlvbiBDb25uZWN0b3IoY2FjaGUsIHN0b3JlLCBzZXJ2aWNlcykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25uZWN0b3IpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0V2ZW50RW1pdHRlci5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLmNhY2hlID0gY2FjaGU7XG4gICAgX3RoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICBfdGhpcy5zZXJ2aWNlcyA9IHNlcnZpY2VzO1xuICAgIF90aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIF90aGlzLmxvZ2dlciA9IF9sb2dnZXIyLmRlZmF1bHQuY3JlYXRlKCdjYWNoZUNvbm5lY3RvcicpO1xuXG4gICAgX3RoaXMuY2FjaGUgJiYgX3RoaXMuY2FjaGUuaW5pdCAmJiBfdGhpcy5jYWNoZS5pbml0KHNlcnZpY2VzLCBvcHRpb25zLmNhY2hlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBDb25uZWN0b3IucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiBsb2FkKGxhbmd1YWdlcywgbmFtZXNwYWNlcywgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGlmICghdGhpcy5jYWNoZSkgcmV0dXJuIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgdmFyIG9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgdGhpcy5jYWNoZS5vcHRpb25zLCB0aGlzLm9wdGlvbnMuY2FjaGUpO1xuXG4gICAgaWYgKHR5cGVvZiBsYW5ndWFnZXMgPT09ICdzdHJpbmcnKSBsYW5ndWFnZXMgPSB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMudG9SZXNvbHZlSGllcmFyY2h5KGxhbmd1YWdlcyk7XG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJykgbmFtZXNwYWNlcyA9IFtuYW1lc3BhY2VzXTtcblxuICAgIGlmIChvcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuY2FjaGUubG9hZChsYW5ndWFnZXMsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgaWYgKGVycikgX3RoaXMyLmxvZ2dlci5lcnJvcignbG9hZGluZyBsYW5ndWFnZXMgJyArIGxhbmd1YWdlcy5qb2luKCcsICcpICsgJyBmcm9tIGNhY2hlIGZhaWxlZCcsIGVycik7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgZm9yICh2YXIgbCBpbiBkYXRhKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuIGluIGRhdGFbbF0pIHtcbiAgICAgICAgICAgICAgaWYgKG4gPT09ICdpMThuU3RhbXAnKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgdmFyIGJ1bmRsZSA9IGRhdGFbbF1bbl07XG4gICAgICAgICAgICAgIGlmIChidW5kbGUpIF90aGlzMi5zdG9yZS5hZGRSZXNvdXJjZUJ1bmRsZShsLCBuLCBidW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgIH1cbiAgfTtcblxuICBDb25uZWN0b3IucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiBzYXZlKCkge1xuICAgIGlmICh0aGlzLmNhY2hlICYmIHRoaXMub3B0aW9ucy5jYWNoZSAmJiB0aGlzLm9wdGlvbnMuY2FjaGUuZW5hYmxlZCkgdGhpcy5jYWNoZS5zYXZlKHRoaXMuc3RvcmUuZGF0YSk7XG4gIH07XG5cbiAgcmV0dXJuIENvbm5lY3Rvcjtcbn0oX0V2ZW50RW1pdHRlcjMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENvbm5lY3RvcjsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBFdmVudEVtaXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXZlbnRFbWl0dGVyKTtcblxuXHRcdHRoaXMub2JzZXJ2ZXJzID0ge307XG5cdH1cblxuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnRzLCBsaXN0ZW5lcikge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cblx0XHRldmVudHMuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuXHRcdFx0X3RoaXMub2JzZXJ2ZXJzW2V2ZW50XSA9IF90aGlzLm9ic2VydmVyc1tldmVudF0gfHwgW107XG5cdFx0XHRfdGhpcy5vYnNlcnZlcnNbZXZlbnRdLnB1c2gobGlzdGVuZXIpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuXHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdFx0aWYgKCF0aGlzLm9ic2VydmVyc1tldmVudF0pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLm9ic2VydmVyc1tldmVudF0uZm9yRWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoIWxpc3RlbmVyKSB7XG5cdFx0XHRcdGRlbGV0ZSBfdGhpczIub2JzZXJ2ZXJzW2V2ZW50XTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IF90aGlzMi5vYnNlcnZlcnNbZXZlbnRdLmluZGV4T2YobGlzdGVuZXIpO1xuXHRcdFx0XHRpZiAoaW5kZXggPiAtMSkge1xuXHRcdFx0XHRcdF90aGlzMi5vYnNlcnZlcnNbZXZlbnRdLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fTtcblxuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG5cdFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG5cdFx0XHRhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vYnNlcnZlcnNbZXZlbnRdKSB7XG5cdFx0XHR2YXIgY2xvbmVkID0gW10uY29uY2F0KHRoaXMub2JzZXJ2ZXJzW2V2ZW50XSk7XG5cdFx0XHRjbG9uZWQuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcblx0XHRcdFx0b2JzZXJ2ZXIuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9ic2VydmVyc1snKiddKSB7XG5cdFx0XHR2YXIgX2Nsb25lZCA9IFtdLmNvbmNhdCh0aGlzLm9ic2VydmVyc1snKiddKTtcblx0XHRcdF9jbG9uZWQuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcblx0XHRcdFx0dmFyIF9yZWY7XG5cblx0XHRcdFx0b2JzZXJ2ZXIuYXBwbHkob2JzZXJ2ZXIsIChfcmVmID0gW2V2ZW50XSkuY29uY2F0LmFwcGx5KF9yZWYsIGFyZ3MpKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gRXZlbnRFbWl0dGVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudEVtaXR0ZXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHMpO1xuXG52YXIgX2xvZ2dlciA9IHJlcXVpcmUoJy4vbG9nZ2VyJyk7XG5cbnZhciBfbG9nZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZ2dlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBJbnRlcnBvbGF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEludGVycG9sYXRvcigpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW50ZXJwb2xhdG9yKTtcblxuICAgIHRoaXMubG9nZ2VyID0gX2xvZ2dlcjIuZGVmYXVsdC5jcmVhdGUoJ2ludGVycG9sYXRvcicpO1xuXG4gICAgdGhpcy5pbml0KG9wdGlvbnMsIHRydWUpO1xuICB9XG5cbiAgSW50ZXJwb2xhdG9yLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIHJlc2V0ID0gYXJndW1lbnRzWzFdO1xuXG4gICAgaWYgKHJlc2V0KSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgdGhpcy5mb3JtYXQgPSBvcHRpb25zLmludGVycG9sYXRpb24gJiYgb3B0aW9ucy5pbnRlcnBvbGF0aW9uLmZvcm1hdCB8fCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICAgIHRoaXMuZXNjYXBlID0gb3B0aW9ucy5pbnRlcnBvbGF0aW9uICYmIG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5lc2NhcGUgfHwgdXRpbHMuZXNjYXBlO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuaW50ZXJwb2xhdGlvbikgb3B0aW9ucy5pbnRlcnBvbGF0aW9uID0geyBlc2NhcGVWYWx1ZTogdHJ1ZSB9O1xuXG4gICAgdmFyIGlPcHRzID0gb3B0aW9ucy5pbnRlcnBvbGF0aW9uO1xuXG4gICAgdGhpcy5lc2NhcGVWYWx1ZSA9IGlPcHRzLmVzY2FwZVZhbHVlICE9PSB1bmRlZmluZWQgPyBpT3B0cy5lc2NhcGVWYWx1ZSA6IHRydWU7XG5cbiAgICB0aGlzLnByZWZpeCA9IGlPcHRzLnByZWZpeCA/IHV0aWxzLnJlZ2V4RXNjYXBlKGlPcHRzLnByZWZpeCkgOiBpT3B0cy5wcmVmaXhFc2NhcGVkIHx8ICd7eyc7XG4gICAgdGhpcy5zdWZmaXggPSBpT3B0cy5zdWZmaXggPyB1dGlscy5yZWdleEVzY2FwZShpT3B0cy5zdWZmaXgpIDogaU9wdHMuc3VmZml4RXNjYXBlZCB8fCAnfX0nO1xuICAgIHRoaXMuZm9ybWF0U2VwYXJhdG9yID0gaU9wdHMuZm9ybWF0U2VwYXJhdG9yID8gdXRpbHMucmVnZXhFc2NhcGUoaU9wdHMuZm9ybWF0U2VwYXJhdG9yKSA6IGlPcHRzLmZvcm1hdFNlcGFyYXRvciB8fCAnLCc7XG5cbiAgICB0aGlzLnVuZXNjYXBlUHJlZml4ID0gaU9wdHMudW5lc2NhcGVTdWZmaXggPyAnJyA6IGlPcHRzLnVuZXNjYXBlUHJlZml4IHx8ICctJztcbiAgICB0aGlzLnVuZXNjYXBlU3VmZml4ID0gdGhpcy51bmVzY2FwZVByZWZpeCA/ICcnIDogaU9wdHMudW5lc2NhcGVTdWZmaXggfHwgJyc7XG5cbiAgICB0aGlzLm5lc3RpbmdQcmVmaXggPSBpT3B0cy5uZXN0aW5nUHJlZml4ID8gdXRpbHMucmVnZXhFc2NhcGUoaU9wdHMubmVzdGluZ1ByZWZpeCkgOiBpT3B0cy5uZXN0aW5nUHJlZml4RXNjYXBlZCB8fCB1dGlscy5yZWdleEVzY2FwZSgnJHQoJyk7XG4gICAgdGhpcy5uZXN0aW5nU3VmZml4ID0gaU9wdHMubmVzdGluZ1N1ZmZpeCA/IHV0aWxzLnJlZ2V4RXNjYXBlKGlPcHRzLm5lc3RpbmdTdWZmaXgpIDogaU9wdHMubmVzdGluZ1N1ZmZpeEVzY2FwZWQgfHwgdXRpbHMucmVnZXhFc2NhcGUoJyknKTtcblxuICAgIC8vIHRoZSByZWdleHBcbiAgICB0aGlzLnJlc2V0UmVnRXhwKCk7XG4gIH07XG5cbiAgSW50ZXJwb2xhdG9yLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMpIHRoaXMuaW5pdCh0aGlzLm9wdGlvbnMpO1xuICB9O1xuXG4gIEludGVycG9sYXRvci5wcm90b3R5cGUucmVzZXRSZWdFeHAgPSBmdW5jdGlvbiByZXNldFJlZ0V4cCgpIHtcbiAgICAvLyB0aGUgcmVnZXhwXG4gICAgdmFyIHJlZ2V4cFN0ciA9IHRoaXMucHJlZml4ICsgJyguKz8pJyArIHRoaXMuc3VmZml4O1xuICAgIHRoaXMucmVnZXhwID0gbmV3IFJlZ0V4cChyZWdleHBTdHIsICdnJyk7XG5cbiAgICB2YXIgcmVnZXhwVW5lc2NhcGVTdHIgPSB0aGlzLnByZWZpeCArIHRoaXMudW5lc2NhcGVQcmVmaXggKyAnKC4rPyknICsgdGhpcy51bmVzY2FwZVN1ZmZpeCArIHRoaXMuc3VmZml4O1xuICAgIHRoaXMucmVnZXhwVW5lc2NhcGUgPSBuZXcgUmVnRXhwKHJlZ2V4cFVuZXNjYXBlU3RyLCAnZycpO1xuXG4gICAgdmFyIG5lc3RpbmdSZWdleHBTdHIgPSB0aGlzLm5lc3RpbmdQcmVmaXggKyAnKC4rPyknICsgdGhpcy5uZXN0aW5nU3VmZml4O1xuICAgIHRoaXMubmVzdGluZ1JlZ2V4cCA9IG5ldyBSZWdFeHAobmVzdGluZ1JlZ2V4cFN0ciwgJ2cnKTtcbiAgfTtcblxuICBJbnRlcnBvbGF0b3IucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24gaW50ZXJwb2xhdGUoc3RyLCBkYXRhLCBsbmcpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG1hdGNoID0gdm9pZCAwLFxuICAgICAgICB2YWx1ZSA9IHZvaWQgMDtcblxuICAgIGZ1bmN0aW9uIHJlZ2V4U2FmZSh2YWwpIHtcbiAgICAgIHJldHVybiB2YWwucmVwbGFjZSgvXFwkL2csICckJCQkJyk7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZUZvcm1hdCA9IGZ1bmN0aW9uIGhhbmRsZUZvcm1hdChrZXkpIHtcbiAgICAgIGlmIChrZXkuaW5kZXhPZihfdGhpcy5mb3JtYXRTZXBhcmF0b3IpIDwgMCkgcmV0dXJuIHV0aWxzLmdldFBhdGgoZGF0YSwga2V5KTtcblxuICAgICAgdmFyIHAgPSBrZXkuc3BsaXQoX3RoaXMuZm9ybWF0U2VwYXJhdG9yKTtcbiAgICAgIHZhciBrID0gcC5zaGlmdCgpLnRyaW0oKTtcbiAgICAgIHZhciBmID0gcC5qb2luKF90aGlzLmZvcm1hdFNlcGFyYXRvcikudHJpbSgpO1xuXG4gICAgICByZXR1cm4gX3RoaXMuZm9ybWF0KHV0aWxzLmdldFBhdGgoZGF0YSwgayksIGYsIGxuZyk7XG4gICAgfTtcblxuICAgIHRoaXMucmVzZXRSZWdFeHAoKTtcblxuICAgIC8vIHVuZXNjYXBlIGlmIGhhcyB1bmVzY2FwZVByZWZpeC9TdWZmaXhcbiAgICB3aGlsZSAobWF0Y2ggPSB0aGlzLnJlZ2V4cFVuZXNjYXBlLmV4ZWMoc3RyKSkge1xuICAgICAgdmFyIF92YWx1ZSA9IGhhbmRsZUZvcm1hdChtYXRjaFsxXS50cmltKCkpO1xuICAgICAgc3RyID0gc3RyLnJlcGxhY2UobWF0Y2hbMF0sIF92YWx1ZSk7XG4gICAgICB0aGlzLnJlZ2V4cFVuZXNjYXBlLmxhc3RJbmRleCA9IDA7XG4gICAgfVxuXG4gICAgLy8gcmVndWxhciBlc2NhcGUgb24gZGVtYW5kXG4gICAgd2hpbGUgKG1hdGNoID0gdGhpcy5yZWdleHAuZXhlYyhzdHIpKSB7XG4gICAgICB2YWx1ZSA9IGhhbmRsZUZvcm1hdChtYXRjaFsxXS50cmltKCkpO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHZhbHVlID0gdXRpbHMubWFrZVN0cmluZyh2YWx1ZSk7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ21pc3NlZCB0byBwYXNzIGluIHZhcmlhYmxlICcgKyBtYXRjaFsxXSArICcgZm9yIGludGVycG9sYXRpbmcgJyArIHN0cik7XG4gICAgICAgIHZhbHVlID0gJyc7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHRoaXMuZXNjYXBlVmFsdWUgPyByZWdleFNhZmUodGhpcy5lc2NhcGUodmFsdWUpKSA6IHJlZ2V4U2FmZSh2YWx1ZSk7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZShtYXRjaFswXSwgdmFsdWUpO1xuICAgICAgdGhpcy5yZWdleHAubGFzdEluZGV4ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICBJbnRlcnBvbGF0b3IucHJvdG90eXBlLm5lc3QgPSBmdW5jdGlvbiBuZXN0KHN0ciwgZmMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICB2YXIgbWF0Y2ggPSB2b2lkIDAsXG4gICAgICAgIHZhbHVlID0gdm9pZCAwO1xuXG4gICAgdmFyIGNsb25lZE9wdGlvbnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpKTtcbiAgICBjbG9uZWRPcHRpb25zLmFwcGx5UG9zdFByb2Nlc3NvciA9IGZhbHNlOyAvLyBhdm9pZCBwb3N0IHByb2Nlc3Npbmcgb24gbmVzdGVkIGxvb2t1cFxuXG4gICAgZnVuY3Rpb24gcmVnZXhTYWZlKHZhbCkge1xuICAgICAgcmV0dXJuIHZhbC5yZXBsYWNlKC9cXCQvZywgJyQkJCQnKTtcbiAgICB9XG5cbiAgICAvLyBpZiB2YWx1ZSBpcyBzb21ldGhpbmcgbGlrZSBcIm15S2V5XCI6IFwibG9yZW0gJChhbm90aGVyS2V5LCB7IFwiY291bnRcIjoge3thVmFsdWVJbk9wdGlvbnN9fSB9KVwiXG4gICAgZnVuY3Rpb24gaGFuZGxlSGFzT3B0aW9ucyhrZXkpIHtcbiAgICAgIGlmIChrZXkuaW5kZXhPZignLCcpIDwgMCkgcmV0dXJuIGtleTtcblxuICAgICAgdmFyIHAgPSBrZXkuc3BsaXQoJywnKTtcbiAgICAgIGtleSA9IHAuc2hpZnQoKTtcbiAgICAgIHZhciBvcHRpb25zU3RyaW5nID0gcC5qb2luKCcsJyk7XG4gICAgICBvcHRpb25zU3RyaW5nID0gdGhpcy5pbnRlcnBvbGF0ZShvcHRpb25zU3RyaW5nLCBjbG9uZWRPcHRpb25zKTtcbiAgICAgIG9wdGlvbnNTdHJpbmcgPSBvcHRpb25zU3RyaW5nLnJlcGxhY2UoLycvZywgJ1wiJyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNsb25lZE9wdGlvbnMgPSBKU09OLnBhcnNlKG9wdGlvbnNTdHJpbmcpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignZmFpbGVkIHBhcnNpbmcgb3B0aW9ucyBzdHJpbmcgaW4gbmVzdGluZyBmb3Iga2V5ICcgKyBrZXksIGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cblxuICAgIC8vIHJlZ3VsYXIgZXNjYXBlIG9uIGRlbWFuZFxuICAgIHdoaWxlIChtYXRjaCA9IHRoaXMubmVzdGluZ1JlZ2V4cC5leGVjKHN0cikpIHtcbiAgICAgIHZhbHVlID0gZmMoaGFuZGxlSGFzT3B0aW9ucy5jYWxsKHRoaXMsIG1hdGNoWzFdLnRyaW0oKSksIGNsb25lZE9wdGlvbnMpO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHZhbHVlID0gdXRpbHMubWFrZVN0cmluZyh2YWx1ZSk7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ21pc3NlZCB0byBwYXNzIGluIHZhcmlhYmxlICcgKyBtYXRjaFsxXSArICcgZm9yIGludGVycG9sYXRpbmcgJyArIHN0cik7XG4gICAgICAgIHZhbHVlID0gJyc7XG4gICAgICB9XG4gICAgICAvLyBOZXN0ZWQga2V5cyBzaG91bGQgbm90IGJlIGVzY2FwZWQgYnkgZGVmYXVsdCAjODU0XG4gICAgICAvLyB2YWx1ZSA9IHRoaXMuZXNjYXBlVmFsdWUgPyByZWdleFNhZmUodXRpbHMuZXNjYXBlKHZhbHVlKSkgOiByZWdleFNhZmUodmFsdWUpO1xuICAgICAgc3RyID0gc3RyLnJlcGxhY2UobWF0Y2hbMF0sIHZhbHVlKTtcbiAgICAgIHRoaXMucmVnZXhwLmxhc3RJbmRleCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgcmV0dXJuIEludGVycG9sYXRvcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSW50ZXJwb2xhdG9yOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9sb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xuXG52YXIgX2xvZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2dnZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xufVxuXG52YXIgTGFuZ3VhZ2VVdGlsID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMYW5ndWFnZVV0aWwob3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYW5ndWFnZVV0aWwpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHRoaXMud2hpdGVsaXN0ID0gdGhpcy5vcHRpb25zLndoaXRlbGlzdCB8fCBmYWxzZTtcbiAgICB0aGlzLmxvZ2dlciA9IF9sb2dnZXIyLmRlZmF1bHQuY3JlYXRlKCdsYW5ndWFnZVV0aWxzJyk7XG4gIH1cblxuICBMYW5ndWFnZVV0aWwucHJvdG90eXBlLmdldExhbmd1YWdlUGFydEZyb21Db2RlID0gZnVuY3Rpb24gZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSkge1xuICAgIGlmIChjb2RlLmluZGV4T2YoJy0nKSA8IDApIHJldHVybiBjb2RlO1xuXG4gICAgdmFyIHNwZWNpYWxDYXNlcyA9IFsnTkItTk8nLCAnTk4tTk8nLCAnbmItTk8nLCAnbm4tTk8nLCAnbmItbm8nLCAnbm4tbm8nXTtcbiAgICB2YXIgcCA9IGNvZGUuc3BsaXQoJy0nKTtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUoc3BlY2lhbENhc2VzLmluZGV4T2YoY29kZSkgPiAtMSA/IHBbMV0udG9Mb3dlckNhc2UoKSA6IHBbMF0pO1xuICB9O1xuXG4gIExhbmd1YWdlVXRpbC5wcm90b3R5cGUuZ2V0U2NyaXB0UGFydEZyb21Db2RlID0gZnVuY3Rpb24gZ2V0U2NyaXB0UGFydEZyb21Db2RlKGNvZGUpIHtcbiAgICBpZiAoY29kZS5pbmRleE9mKCctJykgPCAwKSByZXR1cm4gbnVsbDtcblxuICAgIHZhciBwID0gY29kZS5zcGxpdCgnLScpO1xuICAgIGlmIChwLmxlbmd0aCA9PT0gMikgcmV0dXJuIG51bGw7XG4gICAgcC5wb3AoKTtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUocC5qb2luKCctJykpO1xuICB9O1xuXG4gIExhbmd1YWdlVXRpbC5wcm90b3R5cGUuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUgPSBmdW5jdGlvbiBnZXRMYW5ndWFnZVBhcnRGcm9tQ29kZShjb2RlKSB7XG4gICAgaWYgKGNvZGUuaW5kZXhPZignLScpIDwgMCkgcmV0dXJuIGNvZGU7XG5cbiAgICB2YXIgc3BlY2lhbENhc2VzID0gWydOQi1OTycsICdOTi1OTycsICduYi1OTycsICdubi1OTycsICduYi1ubycsICdubi1ubyddO1xuICAgIHZhciBwID0gY29kZS5zcGxpdCgnLScpO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShzcGVjaWFsQ2FzZXMuaW5kZXhPZihjb2RlKSA+IC0xID8gcFsxXS50b0xvd2VyQ2FzZSgpIDogcFswXSk7XG4gIH07XG5cbiAgTGFuZ3VhZ2VVdGlsLnByb3RvdHlwZS5mb3JtYXRMYW5ndWFnZUNvZGUgPSBmdW5jdGlvbiBmb3JtYXRMYW5ndWFnZUNvZGUoY29kZSkge1xuICAgIC8vIGh0dHA6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvbGFuZ3VhZ2UtdGFncy9sYW5ndWFnZS10YWdzLnhodG1sXG4gICAgaWYgKHR5cGVvZiBjb2RlID09PSAnc3RyaW5nJyAmJiBjb2RlLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICB2YXIgc3BlY2lhbENhc2VzID0gWydoYW5zJywgJ2hhbnQnLCAnbGF0bicsICdjeXJsJywgJ2NhbnMnLCAnbW9uZycsICdhcmFiJ107XG4gICAgICB2YXIgcCA9IGNvZGUuc3BsaXQoJy0nKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb3dlckNhc2VMbmcpIHtcbiAgICAgICAgcCA9IHAubWFwKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHAubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHBbMF0gPSBwWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHBbMV0gPSBwWzFdLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKHNwZWNpYWxDYXNlcy5pbmRleE9mKHBbMV0udG9Mb3dlckNhc2UoKSkgPiAtMSkgcFsxXSA9IGNhcGl0YWxpemUocFsxXS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH0gZWxzZSBpZiAocC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcFswXSA9IHBbMF0udG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAvLyBpZiBsZW5naHQgMiBndWVzcyBpdCdzIGEgY291bnRyeVxuICAgICAgICBpZiAocFsxXS5sZW5ndGggPT09IDIpIHBbMV0gPSBwWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChwWzBdICE9PSAnc2duJyAmJiBwWzJdLmxlbmd0aCA9PT0gMikgcFsyXSA9IHBbMl0udG9VcHBlckNhc2UoKTtcblxuICAgICAgICBpZiAoc3BlY2lhbENhc2VzLmluZGV4T2YocFsxXS50b0xvd2VyQ2FzZSgpKSA+IC0xKSBwWzFdID0gY2FwaXRhbGl6ZShwWzFdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBpZiAoc3BlY2lhbENhc2VzLmluZGV4T2YocFsyXS50b0xvd2VyQ2FzZSgpKSA+IC0xKSBwWzJdID0gY2FwaXRhbGl6ZShwWzJdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcC5qb2luKCctJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY2xlYW5Db2RlIHx8IHRoaXMub3B0aW9ucy5sb3dlckNhc2VMbmcgPyBjb2RlLnRvTG93ZXJDYXNlKCkgOiBjb2RlO1xuICAgIH1cbiAgfTtcblxuICBMYW5ndWFnZVV0aWwucHJvdG90eXBlLmlzV2hpdGVsaXN0ZWQgPSBmdW5jdGlvbiBpc1doaXRlbGlzdGVkKGNvZGUsIGV4YWN0TWF0Y2gpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvYWQgPT09ICdsYW5ndWFnZU9ubHknIHx8IHRoaXMub3B0aW9ucy5ub25FeHBsaWNpdFdoaXRlbGlzdCAmJiAhZXhhY3RNYXRjaCkge1xuICAgICAgY29kZSA9IHRoaXMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSk7XG4gICAgfVxuICAgIHJldHVybiAhdGhpcy53aGl0ZWxpc3QgfHwgIXRoaXMud2hpdGVsaXN0Lmxlbmd0aCB8fCB0aGlzLndoaXRlbGlzdC5pbmRleE9mKGNvZGUpID4gLTEgPyB0cnVlIDogZmFsc2U7XG4gIH07XG5cbiAgTGFuZ3VhZ2VVdGlsLnByb3RvdHlwZS5nZXRGYWxsYmFja0NvZGVzID0gZnVuY3Rpb24gZ2V0RmFsbGJhY2tDb2RlcyhmYWxsYmFja3MsIGNvZGUpIHtcbiAgICBpZiAoIWZhbGxiYWNrcykgcmV0dXJuIFtdO1xuICAgIGlmICh0eXBlb2YgZmFsbGJhY2tzID09PSAnc3RyaW5nJykgZmFsbGJhY2tzID0gW2ZhbGxiYWNrc107XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkoZmFsbGJhY2tzKSA9PT0gJ1tvYmplY3QgQXJyYXldJykgcmV0dXJuIGZhbGxiYWNrcztcblxuICAgIC8vIGFzdW1lIHdlIGhhdmUgYW4gb2JqZWN0IGRlZmluaW5nIGZhbGxiYWNrc1xuICAgIHZhciBmb3VuZCA9IGZhbGxiYWNrc1tjb2RlXTtcbiAgICBpZiAoIWZvdW5kKSBmb3VuZCA9IGZhbGxiYWNrc1t0aGlzLmdldFNjcmlwdFBhcnRGcm9tQ29kZShjb2RlKV07XG4gICAgaWYgKCFmb3VuZCkgZm91bmQgPSBmYWxsYmFja3NbdGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUoY29kZSldO1xuICAgIGlmICghZm91bmQpIGZvdW5kID0gZmFsbGJhY2tzLmRlZmF1bHQ7XG5cbiAgICByZXR1cm4gZm91bmQgfHwgW107XG4gIH07XG5cbiAgTGFuZ3VhZ2VVdGlsLnByb3RvdHlwZS50b1Jlc29sdmVIaWVyYXJjaHkgPSBmdW5jdGlvbiB0b1Jlc29sdmVIaWVyYXJjaHkoY29kZSwgZmFsbGJhY2tDb2RlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBmYWxsYmFja0NvZGVzID0gdGhpcy5nZXRGYWxsYmFja0NvZGVzKGZhbGxiYWNrQ29kZSB8fCB0aGlzLm9wdGlvbnMuZmFsbGJhY2tMbmcgfHwgW10sIGNvZGUpO1xuXG4gICAgdmFyIGNvZGVzID0gW107XG4gICAgdmFyIGFkZENvZGUgPSBmdW5jdGlvbiBhZGRDb2RlKGNvZGUpIHtcbiAgICAgIHZhciBleGFjdE1hdGNoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgaWYgKCFjb2RlKSByZXR1cm47XG4gICAgICBpZiAoX3RoaXMuaXNXaGl0ZWxpc3RlZChjb2RlLCBleGFjdE1hdGNoKSkge1xuICAgICAgICBjb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oJ3JlamVjdGluZyBub24td2hpdGVsaXN0ZWQgbGFuZ3VhZ2UgY29kZTogJyArIGNvZGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIGNvZGUgPT09ICdzdHJpbmcnICYmIGNvZGUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9hZCAhPT0gJ2xhbmd1YWdlT25seScpIGFkZENvZGUodGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUoY29kZSksIHRydWUpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2FkICE9PSAnbGFuZ3VhZ2VPbmx5JyAmJiB0aGlzLm9wdGlvbnMubG9hZCAhPT0gJ2N1cnJlbnRPbmx5JykgYWRkQ29kZSh0aGlzLmdldFNjcmlwdFBhcnRGcm9tQ29kZShjb2RlKSwgdHJ1ZSk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvYWQgIT09ICdjdXJyZW50T25seScpIGFkZENvZGUodGhpcy5nZXRMYW5ndWFnZVBhcnRGcm9tQ29kZShjb2RlKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGFkZENvZGUodGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUoY29kZSkpO1xuICAgIH1cblxuICAgIGZhbGxiYWNrQ29kZXMuZm9yRWFjaChmdW5jdGlvbiAoZmMpIHtcbiAgICAgIGlmIChjb2Rlcy5pbmRleE9mKGZjKSA8IDApIGFkZENvZGUoX3RoaXMuZm9ybWF0TGFuZ3VhZ2VDb2RlKGZjKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29kZXM7XG4gIH07XG5cbiAgcmV0dXJuIExhbmd1YWdlVXRpbDtcbn0oKTtcblxuO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBMYW5ndWFnZVV0aWw7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfbG9nZ2VyID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcblxudmFyIF9sb2dnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9nZ2VyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLy8gZGVmaW5pdGlvbiBodHRwOi8vdHJhbnNsYXRlLnNvdXJjZWZvcmdlLm5ldC93aWtpL2wxMG4vcGx1cmFsZm9ybXNcbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgc2V0cyA9IFt7IGxuZ3M6IFsnYWNoJywgJ2FrJywgJ2FtJywgJ2FybicsICdicicsICdmaWwnLCAnZ3VuJywgJ2xuJywgJ21mZScsICdtZycsICdtaScsICdvYycsICd0ZycsICd0aScsICd0cicsICd1eicsICd3YSddLCBucjogWzEsIDJdLCBmYzogMSB9LCB7IGxuZ3M6IFsnYWYnLCAnYW4nLCAnYXN0JywgJ2F6JywgJ2JnJywgJ2JuJywgJ2NhJywgJ2RhJywgJ2RlJywgJ2RldicsICdlbCcsICdlbicsICdlbycsICdlcycsICdlc19hcicsICdldCcsICdldScsICdmaScsICdmbycsICdmdXInLCAnZnknLCAnZ2wnLCAnZ3UnLCAnaGEnLCAnaGUnLCAnaGknLCAnaHUnLCAnaHknLCAnaWEnLCAnaXQnLCAna24nLCAna3UnLCAnbGInLCAnbWFpJywgJ21sJywgJ21uJywgJ21yJywgJ25haCcsICduYXAnLCAnbmInLCAnbmUnLCAnbmwnLCAnbm4nLCAnbm8nLCAnbnNvJywgJ3BhJywgJ3BhcCcsICdwbXMnLCAncHMnLCAncHQnLCAncHRfYnInLCAncm0nLCAnc2NvJywgJ3NlJywgJ3NpJywgJ3NvJywgJ3NvbicsICdzcScsICdzdicsICdzdycsICd0YScsICd0ZScsICd0aycsICd1cicsICd5byddLCBucjogWzEsIDJdLCBmYzogMiB9LCB7IGxuZ3M6IFsnYXknLCAnYm8nLCAnY2dnJywgJ2ZhJywgJ2lkJywgJ2phJywgJ2pibycsICdrYScsICdraycsICdrbScsICdrbycsICdreScsICdsbycsICdtcycsICdzYWgnLCAnc3UnLCAndGgnLCAndHQnLCAndWcnLCAndmknLCAnd28nLCAnemgnXSwgbnI6IFsxXSwgZmM6IDMgfSwgeyBsbmdzOiBbJ2JlJywgJ2JzJywgJ2R6JywgJ2hyJywgJ3J1JywgJ3NyJywgJ3VrJ10sIG5yOiBbMSwgMiwgNV0sIGZjOiA0IH0sIHsgbG5nczogWydhciddLCBucjogWzAsIDEsIDIsIDMsIDExLCAxMDBdLCBmYzogNSB9LCB7IGxuZ3M6IFsnY3MnLCAnc2snXSwgbnI6IFsxLCAyLCA1XSwgZmM6IDYgfSwgeyBsbmdzOiBbJ2NzYicsICdwbCddLCBucjogWzEsIDIsIDVdLCBmYzogNyB9LCB7IGxuZ3M6IFsnY3knXSwgbnI6IFsxLCAyLCAzLCA4XSwgZmM6IDggfSwgeyBsbmdzOiBbJ2ZyJ10sIG5yOiBbMSwgMl0sIGZjOiA5IH0sIHsgbG5nczogWydnYSddLCBucjogWzEsIDIsIDMsIDcsIDExXSwgZmM6IDEwIH0sIHsgbG5nczogWydnZCddLCBucjogWzEsIDIsIDMsIDIwXSwgZmM6IDExIH0sIHsgbG5nczogWydpcyddLCBucjogWzEsIDJdLCBmYzogMTIgfSwgeyBsbmdzOiBbJ2p2J10sIG5yOiBbMCwgMV0sIGZjOiAxMyB9LCB7IGxuZ3M6IFsna3cnXSwgbnI6IFsxLCAyLCAzLCA0XSwgZmM6IDE0IH0sIHsgbG5nczogWydsdCddLCBucjogWzEsIDIsIDEwXSwgZmM6IDE1IH0sIHsgbG5nczogWydsdiddLCBucjogWzEsIDIsIDBdLCBmYzogMTYgfSwgeyBsbmdzOiBbJ21rJ10sIG5yOiBbMSwgMl0sIGZjOiAxNyB9LCB7IGxuZ3M6IFsnbW5rJ10sIG5yOiBbMCwgMSwgMl0sIGZjOiAxOCB9LCB7IGxuZ3M6IFsnbXQnXSwgbnI6IFsxLCAyLCAxMSwgMjBdLCBmYzogMTkgfSwgeyBsbmdzOiBbJ29yJ10sIG5yOiBbMiwgMV0sIGZjOiAyIH0sIHsgbG5nczogWydybyddLCBucjogWzEsIDIsIDIwXSwgZmM6IDIwIH0sIHsgbG5nczogWydzbCddLCBucjogWzUsIDEsIDIsIDNdLCBmYzogMjEgfV07XG5cbnZhciBfcnVsZXNQbHVyYWxzVHlwZXMgPSB7XG4gIDE6IGZ1bmN0aW9uIF8obikge1xuICAgIHJldHVybiBOdW1iZXIobiA+IDEpO1xuICB9LFxuICAyOiBmdW5jdGlvbiBfKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gIT0gMSk7XG4gIH0sXG4gIDM6IGZ1bmN0aW9uIF8obikge1xuICAgIHJldHVybiAwO1xuICB9LFxuICA0OiBmdW5jdGlvbiBfKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gJSAxMCA9PSAxICYmIG4gJSAxMDAgIT0gMTEgPyAwIDogbiAlIDEwID49IDIgJiYgbiAlIDEwIDw9IDQgJiYgKG4gJSAxMDAgPCAxMCB8fCBuICUgMTAwID49IDIwKSA/IDEgOiAyKTtcbiAgfSxcbiAgNTogZnVuY3Rpb24gXyhuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID09PSAwID8gMCA6IG4gPT0gMSA/IDEgOiBuID09IDIgPyAyIDogbiAlIDEwMCA+PSAzICYmIG4gJSAxMDAgPD0gMTAgPyAzIDogbiAlIDEwMCA+PSAxMSA/IDQgOiA1KTtcbiAgfSxcbiAgNjogZnVuY3Rpb24gXyhuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID09IDEgPyAwIDogbiA+PSAyICYmIG4gPD0gNCA/IDEgOiAyKTtcbiAgfSxcbiAgNzogZnVuY3Rpb24gXyhuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID09IDEgPyAwIDogbiAlIDEwID49IDIgJiYgbiAlIDEwIDw9IDQgJiYgKG4gJSAxMDAgPCAxMCB8fCBuICUgMTAwID49IDIwKSA/IDEgOiAyKTtcbiAgfSxcbiAgODogZnVuY3Rpb24gXyhuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID09IDEgPyAwIDogbiA9PSAyID8gMSA6IG4gIT0gOCAmJiBuICE9IDExID8gMiA6IDMpO1xuICB9LFxuICA5OiBmdW5jdGlvbiBfKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gPj0gMik7XG4gIH0sXG4gIDEwOiBmdW5jdGlvbiBfKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gPT0gMSA/IDAgOiBuID09IDIgPyAxIDogbiA8IDcgPyAyIDogbiA8IDExID8gMyA6IDQpO1xuICB9LFxuICAxMTogZnVuY3Rpb24gXyhuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID09IDEgfHwgbiA9PSAxMSA/IDAgOiBuID09IDIgfHwgbiA9PSAxMiA/IDEgOiBuID4gMiAmJiBuIDwgMjAgPyAyIDogMyk7XG4gIH0sXG4gIDEyOiBmdW5jdGlvbiBfKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gJSAxMCAhPSAxIHx8IG4gJSAxMDAgPT0gMTEpO1xuICB9LFxuICAxMzogZnVuY3Rpb24gXyhuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuICE9PSAwKTtcbiAgfSxcbiAgMTQ6IGZ1bmN0aW9uIF8obikge1xuICAgIHJldHVybiBOdW1iZXIobiA9PSAxID8gMCA6IG4gPT0gMiA/IDEgOiBuID09IDMgPyAyIDogMyk7XG4gIH0sXG4gIDE1OiBmdW5jdGlvbiBfKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gJSAxMCA9PSAxICYmIG4gJSAxMDAgIT0gMTEgPyAwIDogbiAlIDEwID49IDIgJiYgKG4gJSAxMDAgPCAxMCB8fCBuICUgMTAwID49IDIwKSA/IDEgOiAyKTtcbiAgfSxcbiAgMTY6IGZ1bmN0aW9uIF8obikge1xuICAgIHJldHVybiBOdW1iZXIobiAlIDEwID09IDEgJiYgbiAlIDEwMCAhPSAxMSA/IDAgOiBuICE9PSAwID8gMSA6IDIpO1xuICB9LFxuICAxNzogZnVuY3Rpb24gXyhuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID09IDEgfHwgbiAlIDEwID09IDEgPyAwIDogMSk7XG4gIH0sXG4gIDE4OiBmdW5jdGlvbiBfKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gPT0gMCA/IDAgOiBuID09IDEgPyAxIDogMik7XG4gIH0sXG4gIDE5OiBmdW5jdGlvbiBfKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gPT0gMSA/IDAgOiBuID09PSAwIHx8IG4gJSAxMDAgPiAxICYmIG4gJSAxMDAgPCAxMSA/IDEgOiBuICUgMTAwID4gMTAgJiYgbiAlIDEwMCA8IDIwID8gMiA6IDMpO1xuICB9LFxuICAyMDogZnVuY3Rpb24gXyhuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID09IDEgPyAwIDogbiA9PT0gMCB8fCBuICUgMTAwID4gMCAmJiBuICUgMTAwIDwgMjAgPyAxIDogMik7XG4gIH0sXG4gIDIxOiBmdW5jdGlvbiBfKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gJSAxMDAgPT0gMSA/IDEgOiBuICUgMTAwID09IDIgPyAyIDogbiAlIDEwMCA9PSAzIHx8IG4gJSAxMDAgPT0gNCA/IDMgOiAwKTtcbiAgfVxufTtcbi8qIGVzbGludC1lbmFibGUgKi9cblxuZnVuY3Rpb24gY3JlYXRlUnVsZXMoKSB7XG4gIHZhciBsLFxuICAgICAgcnVsZXMgPSB7fTtcbiAgc2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChzZXQpIHtcbiAgICBzZXQubG5ncy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XG4gICAgICByZXR1cm4gcnVsZXNbbF0gPSB7XG4gICAgICAgIG51bWJlcnM6IHNldC5ucixcbiAgICAgICAgcGx1cmFsczogX3J1bGVzUGx1cmFsc1R5cGVzW3NldC5mY11cbiAgICAgIH07XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gcnVsZXM7XG59XG5cbnZhciBQbHVyYWxSZXNvbHZlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGx1cmFsUmVzb2x2ZXIobGFuZ3VhZ2VVdGlscykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQbHVyYWxSZXNvbHZlcik7XG5cbiAgICB0aGlzLmxhbmd1YWdlVXRpbHMgPSBsYW5ndWFnZVV0aWxzO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICB0aGlzLmxvZ2dlciA9IF9sb2dnZXIyLmRlZmF1bHQuY3JlYXRlKCdwbHVyYWxSZXNvbHZlcicpO1xuXG4gICAgdGhpcy5ydWxlcyA9IGNyZWF0ZVJ1bGVzKCk7XG4gIH1cblxuICBQbHVyYWxSZXNvbHZlci5wcm90b3R5cGUuYWRkUnVsZSA9IGZ1bmN0aW9uIGFkZFJ1bGUobG5nLCBvYmopIHtcbiAgICB0aGlzLnJ1bGVzW2xuZ10gPSBvYmo7XG4gIH07XG5cbiAgUGx1cmFsUmVzb2x2ZXIucHJvdG90eXBlLmdldFJ1bGUgPSBmdW5jdGlvbiBnZXRSdWxlKGNvZGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlc1t0aGlzLmxhbmd1YWdlVXRpbHMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSldO1xuICB9O1xuXG4gIFBsdXJhbFJlc29sdmVyLnByb3RvdHlwZS5uZWVkc1BsdXJhbCA9IGZ1bmN0aW9uIG5lZWRzUGx1cmFsKGNvZGUpIHtcbiAgICB2YXIgcnVsZSA9IHRoaXMuZ2V0UnVsZShjb2RlKTtcblxuICAgIHJldHVybiBydWxlICYmIHJ1bGUubnVtYmVycy5sZW5ndGggPD0gMSA/IGZhbHNlIDogdHJ1ZTtcbiAgfTtcblxuICBQbHVyYWxSZXNvbHZlci5wcm90b3R5cGUuZ2V0U3VmZml4ID0gZnVuY3Rpb24gZ2V0U3VmZml4KGNvZGUsIGNvdW50KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBydWxlID0gdGhpcy5nZXRSdWxlKGNvZGUpO1xuXG4gICAgaWYgKHJ1bGUpIHtcbiAgICAgIHZhciBfcmV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocnVsZS5udW1iZXJzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHtcbiAgICAgICAgICAgIHY6ICcnXG4gICAgICAgICAgfTsgLy8gb25seSBzaW5ndWxhclxuXG4gICAgICAgIHZhciBpZHggPSBydWxlLm5vQWJzID8gcnVsZS5wbHVyYWxzKGNvdW50KSA6IHJ1bGUucGx1cmFscyhNYXRoLmFicyhjb3VudCkpO1xuICAgICAgICB2YXIgc3VmZml4ID0gcnVsZS5udW1iZXJzW2lkeF07XG5cbiAgICAgICAgLy8gc3BlY2lhbCB0cmVhdG1lbnQgZm9yIGxuZ3Mgb25seSBoYXZpbmcgc2luZ3VsYXIgYW5kIHBsdXJhbFxuICAgICAgICBpZiAocnVsZS5udW1iZXJzLmxlbmd0aCA9PT0gMiAmJiBydWxlLm51bWJlcnNbMF0gPT09IDEpIHtcbiAgICAgICAgICBpZiAoc3VmZml4ID09PSAyKSB7XG4gICAgICAgICAgICBzdWZmaXggPSAncGx1cmFsJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHN1ZmZpeCA9PT0gMSkge1xuICAgICAgICAgICAgc3VmZml4ID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJldHVyblN1ZmZpeCA9IGZ1bmN0aW9uIHJldHVyblN1ZmZpeCgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMub3B0aW9ucy5wcmVwZW5kICYmIHN1ZmZpeC50b1N0cmluZygpID8gX3RoaXMub3B0aW9ucy5wcmVwZW5kICsgc3VmZml4LnRvU3RyaW5nKCkgOiBzdWZmaXgudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDT01QQVRJQklMSVRZIEpTT05cbiAgICAgICAgLy8gdjFcbiAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUpTT04gPT09ICd2MScpIHtcbiAgICAgICAgICBpZiAoc3VmZml4ID09PSAxKSByZXR1cm4ge1xuICAgICAgICAgICAgICB2OiAnJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICBpZiAodHlwZW9mIHN1ZmZpeCA9PT0gJ251bWJlcicpIHJldHVybiB7XG4gICAgICAgICAgICAgIHY6ICdfcGx1cmFsXycgKyBzdWZmaXgudG9TdHJpbmcoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdjogcmV0dXJuU3VmZml4KClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIHYyXG4gICAgICAgIGVsc2UgaWYgKF90aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUpTT04gPT09ICd2MicgfHwgcnVsZS5udW1iZXJzLmxlbmd0aCA9PT0gMiAmJiBydWxlLm51bWJlcnNbMF0gPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHY6IHJldHVyblN1ZmZpeCgpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB2MyAtIGdldHRleHQgaW5kZXhcbiAgICAgICAgICBlbHNlIGlmIChydWxlLm51bWJlcnMubGVuZ3RoID09PSAyICYmIHJ1bGUubnVtYmVyc1swXSA9PT0gMSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHY6IHJldHVyblN1ZmZpeCgpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdjogX3RoaXMub3B0aW9ucy5wcmVwZW5kICYmIGlkeC50b1N0cmluZygpID8gX3RoaXMub3B0aW9ucy5wcmVwZW5kICsgaWR4LnRvU3RyaW5nKCkgOiBpZHgudG9TdHJpbmcoKVxuICAgICAgICB9O1xuICAgICAgfSgpO1xuXG4gICAgICBpZiAoKHR5cGVvZiBfcmV0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihfcmV0KSkgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0LnY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ25vIHBsdXJhbCBydWxlIGZvdW5kIGZvcjogJyArIGNvZGUpO1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUGx1cmFsUmVzb2x2ZXI7XG59KCk7XG5cbjtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUGx1cmFsUmVzb2x2ZXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX0V2ZW50RW1pdHRlcjIgPSByZXF1aXJlKCcuL0V2ZW50RW1pdHRlcicpO1xuXG52YXIgX0V2ZW50RW1pdHRlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FdmVudEVtaXR0ZXIyKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIHV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHsgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkZWZhdWx0cyk7IGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykgeyB2YXIga2V5ID0ga2V5c1tpXTsgdmFyIHZhbHVlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkZWZhdWx0cywga2V5KTsgaWYgKHZhbHVlICYmIHZhbHVlLmNvbmZpZ3VyYWJsZSAmJiBvYmpba2V5XSA9PT0gdW5kZWZpbmVkKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpOyB9IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBfZGVmYXVsdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbnZhciBSZXNvdXJjZVN0b3JlID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgX2luaGVyaXRzKFJlc291cmNlU3RvcmUsIF9FdmVudEVtaXR0ZXIpO1xuXG4gIGZ1bmN0aW9uIFJlc291cmNlU3RvcmUoKSB7XG4gICAgdmFyIGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7IG5zOiBbJ3RyYW5zbGF0aW9uJ10sIGRlZmF1bHROUzogJ3RyYW5zbGF0aW9uJyB9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlc291cmNlU3RvcmUpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0V2ZW50RW1pdHRlci5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLmRhdGEgPSBkYXRhO1xuICAgIF90aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFJlc291cmNlU3RvcmUucHJvdG90eXBlLmFkZE5hbWVzcGFjZXMgPSBmdW5jdGlvbiBhZGROYW1lc3BhY2VzKG5zKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ucy5pbmRleE9mKG5zKSA8IDApIHtcbiAgICAgIHRoaXMub3B0aW9ucy5ucy5wdXNoKG5zKTtcbiAgICB9XG4gIH07XG5cbiAgUmVzb3VyY2VTdG9yZS5wcm90b3R5cGUucmVtb3ZlTmFtZXNwYWNlcyA9IGZ1bmN0aW9uIHJlbW92ZU5hbWVzcGFjZXMobnMpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLm9wdGlvbnMubnMuaW5kZXhPZihucyk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfTtcblxuICBSZXNvdXJjZVN0b3JlLnByb3RvdHlwZS5nZXRSZXNvdXJjZSA9IGZ1bmN0aW9uIGdldFJlc291cmNlKGxuZywgbnMsIGtleSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICAgIHZhciBrZXlTZXBhcmF0b3IgPSBvcHRpb25zLmtleVNlcGFyYXRvciB8fCB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yO1xuICAgIGlmIChrZXlTZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkga2V5U2VwYXJhdG9yID0gJy4nO1xuXG4gICAgdmFyIHBhdGggPSBbbG5nLCBuc107XG4gICAgaWYgKGtleSAmJiB0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGguY29uY2F0KGtleSk7XG4gICAgaWYgKGtleSAmJiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykgcGF0aCA9IHBhdGguY29uY2F0KGtleVNlcGFyYXRvciA/IGtleS5zcGxpdChrZXlTZXBhcmF0b3IpIDoga2V5KTtcblxuICAgIGlmIChsbmcuaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgIHBhdGggPSBsbmcuc3BsaXQoJy4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbHMuZ2V0UGF0aCh0aGlzLmRhdGEsIHBhdGgpO1xuICB9O1xuXG4gIFJlc291cmNlU3RvcmUucHJvdG90eXBlLmFkZFJlc291cmNlID0gZnVuY3Rpb24gYWRkUmVzb3VyY2UobG5nLCBucywga2V5LCB2YWx1ZSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB7IHNpbGVudDogZmFsc2UgfTtcblxuICAgIHZhciBrZXlTZXBhcmF0b3IgPSB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yO1xuICAgIGlmIChrZXlTZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkga2V5U2VwYXJhdG9yID0gJy4nO1xuXG4gICAgdmFyIHBhdGggPSBbbG5nLCBuc107XG4gICAgaWYgKGtleSkgcGF0aCA9IHBhdGguY29uY2F0KGtleVNlcGFyYXRvciA/IGtleS5zcGxpdChrZXlTZXBhcmF0b3IpIDoga2V5KTtcblxuICAgIGlmIChsbmcuaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgIHBhdGggPSBsbmcuc3BsaXQoJy4nKTtcbiAgICAgIHZhbHVlID0gbnM7XG4gICAgICBucyA9IHBhdGhbMV07XG4gICAgfVxuXG4gICAgdGhpcy5hZGROYW1lc3BhY2VzKG5zKTtcblxuICAgIHV0aWxzLnNldFBhdGgodGhpcy5kYXRhLCBwYXRoLCB2YWx1ZSk7XG5cbiAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLmVtaXQoJ2FkZGVkJywgbG5nLCBucywga2V5LCB2YWx1ZSk7XG4gIH07XG5cbiAgUmVzb3VyY2VTdG9yZS5wcm90b3R5cGUuYWRkUmVzb3VyY2VzID0gZnVuY3Rpb24gYWRkUmVzb3VyY2VzKGxuZywgbnMsIHJlc291cmNlcykge1xuICAgIGZvciAodmFyIG0gaW4gcmVzb3VyY2VzKSB7XG4gICAgICBpZiAodHlwZW9mIHJlc291cmNlc1ttXSA9PT0gJ3N0cmluZycpIHRoaXMuYWRkUmVzb3VyY2UobG5nLCBucywgbSwgcmVzb3VyY2VzW21dLCB7IHNpbGVudDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KCdhZGRlZCcsIGxuZywgbnMsIHJlc291cmNlcyk7XG4gIH07XG5cbiAgUmVzb3VyY2VTdG9yZS5wcm90b3R5cGUuYWRkUmVzb3VyY2VCdW5kbGUgPSBmdW5jdGlvbiBhZGRSZXNvdXJjZUJ1bmRsZShsbmcsIG5zLCByZXNvdXJjZXMsIGRlZXAsIG92ZXJ3cml0ZSkge1xuICAgIHZhciBwYXRoID0gW2xuZywgbnNdO1xuICAgIGlmIChsbmcuaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgIHBhdGggPSBsbmcuc3BsaXQoJy4nKTtcbiAgICAgIGRlZXAgPSByZXNvdXJjZXM7XG4gICAgICByZXNvdXJjZXMgPSBucztcbiAgICAgIG5zID0gcGF0aFsxXTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZE5hbWVzcGFjZXMobnMpO1xuXG4gICAgdmFyIHBhY2sgPSB1dGlscy5nZXRQYXRoKHRoaXMuZGF0YSwgcGF0aCkgfHwge307XG5cbiAgICBpZiAoZGVlcCkge1xuICAgICAgdXRpbHMuZGVlcEV4dGVuZChwYWNrLCByZXNvdXJjZXMsIG92ZXJ3cml0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2sgPSBfZXh0ZW5kcyh7fSwgcGFjaywgcmVzb3VyY2VzKTtcbiAgICB9XG5cbiAgICB1dGlscy5zZXRQYXRoKHRoaXMuZGF0YSwgcGF0aCwgcGFjayk7XG5cbiAgICB0aGlzLmVtaXQoJ2FkZGVkJywgbG5nLCBucywgcmVzb3VyY2VzKTtcbiAgfTtcblxuICBSZXNvdXJjZVN0b3JlLnByb3RvdHlwZS5yZW1vdmVSZXNvdXJjZUJ1bmRsZSA9IGZ1bmN0aW9uIHJlbW92ZVJlc291cmNlQnVuZGxlKGxuZywgbnMpIHtcbiAgICBpZiAodGhpcy5oYXNSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSkge1xuICAgICAgZGVsZXRlIHRoaXMuZGF0YVtsbmddW25zXTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVOYW1lc3BhY2VzKG5zKTtcblxuICAgIHRoaXMuZW1pdCgncmVtb3ZlZCcsIGxuZywgbnMpO1xuICB9O1xuXG4gIFJlc291cmNlU3RvcmUucHJvdG90eXBlLmhhc1Jlc291cmNlQnVuZGxlID0gZnVuY3Rpb24gaGFzUmVzb3VyY2VCdW5kbGUobG5nLCBucykge1xuICAgIHJldHVybiB0aGlzLmdldFJlc291cmNlKGxuZywgbnMpICE9PSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgUmVzb3VyY2VTdG9yZS5wcm90b3R5cGUuZ2V0UmVzb3VyY2VCdW5kbGUgPSBmdW5jdGlvbiBnZXRSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSB7XG4gICAgaWYgKCFucykgbnMgPSB0aGlzLm9wdGlvbnMuZGVmYXVsdE5TO1xuXG4gICAgLy8gVE9ETzogQ09NUEFUSUJJTElUWSByZW1vdmUgZXh0ZW5kIGluIHYyLjEuMFxuICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUFQSSA9PT0gJ3YxJykgcmV0dXJuIF9leHRlbmRzKHt9LCB0aGlzLmdldFJlc291cmNlKGxuZywgbnMpKTtcblxuICAgIHJldHVybiB0aGlzLmdldFJlc291cmNlKGxuZywgbnMpO1xuICB9O1xuXG4gIFJlc291cmNlU3RvcmUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9O1xuXG4gIHJldHVybiBSZXNvdXJjZVN0b3JlO1xufShfRXZlbnRFbWl0dGVyMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUmVzb3VyY2VTdG9yZTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9sb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xuXG52YXIgX2xvZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2dnZXIpO1xuXG52YXIgX0V2ZW50RW1pdHRlcjIgPSByZXF1aXJlKCcuL0V2ZW50RW1pdHRlcicpO1xuXG52YXIgX0V2ZW50RW1pdHRlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FdmVudEVtaXR0ZXIyKTtcblxudmFyIF9wb3N0UHJvY2Vzc29yID0gcmVxdWlyZSgnLi9wb3N0UHJvY2Vzc29yJyk7XG5cbnZhciBfcG9zdFByb2Nlc3NvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3N0UHJvY2Vzc29yKTtcblxudmFyIF92ID0gcmVxdWlyZSgnLi9jb21wYXRpYmlsaXR5L3YxJyk7XG5cbnZhciBjb21wYXQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdik7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciB1dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlscyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZhdWx0cyhvYmosIGRlZmF1bHRzKSB7IHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGVmYXVsdHMpOyBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHsgdmFyIGtleSA9IGtleXNbaV07IHZhciB2YWx1ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZGVmYXVsdHMsIGtleSk7IGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25maWd1cmFibGUgJiYgb2JqW2tleV0gPT09IHVuZGVmaW5lZCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKTsgfSB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogX2RlZmF1bHRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG52YXIgVHJhbnNsYXRvciA9IGZ1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gIF9pbmhlcml0cyhUcmFuc2xhdG9yLCBfRXZlbnRFbWl0dGVyKTtcblxuICBmdW5jdGlvbiBUcmFuc2xhdG9yKHNlcnZpY2VzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zbGF0b3IpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0V2ZW50RW1pdHRlci5jYWxsKHRoaXMpKTtcblxuICAgIHV0aWxzLmNvcHkoWydyZXNvdXJjZVN0b3JlJywgJ2xhbmd1YWdlVXRpbHMnLCAncGx1cmFsUmVzb2x2ZXInLCAnaW50ZXJwb2xhdG9yJywgJ2JhY2tlbmRDb25uZWN0b3InXSwgc2VydmljZXMsIF90aGlzKTtcblxuICAgIF90aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIF90aGlzLmxvZ2dlciA9IF9sb2dnZXIyLmRlZmF1bHQuY3JlYXRlKCd0cmFuc2xhdG9yJyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgVHJhbnNsYXRvci5wcm90b3R5cGUuY2hhbmdlTGFuZ3VhZ2UgPSBmdW5jdGlvbiBjaGFuZ2VMYW5ndWFnZShsbmcpIHtcbiAgICBpZiAobG5nKSB0aGlzLmxhbmd1YWdlID0gbG5nO1xuICB9O1xuXG4gIFRyYW5zbGF0b3IucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uIGV4aXN0cyhrZXkpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogeyBpbnRlcnBvbGF0aW9uOiB7fSB9O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5QVBJID09PSAndjEnKSB7XG4gICAgICBvcHRpb25zID0gY29tcGF0LmNvbnZlcnRUT3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlKGtleSwgb3B0aW9ucykgIT09IHVuZGVmaW5lZDtcbiAgfTtcblxuICBUcmFuc2xhdG9yLnByb3RvdHlwZS5leHRyYWN0RnJvbUtleSA9IGZ1bmN0aW9uIGV4dHJhY3RGcm9tS2V5KGtleSwgb3B0aW9ucykge1xuICAgIHZhciBuc1NlcGFyYXRvciA9IG9wdGlvbnMubnNTZXBhcmF0b3IgfHwgdGhpcy5vcHRpb25zLm5zU2VwYXJhdG9yO1xuICAgIGlmIChuc1NlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSBuc1NlcGFyYXRvciA9ICc6JztcbiAgICB2YXIga2V5U2VwYXJhdG9yID0gb3B0aW9ucy5rZXlTZXBhcmF0b3IgfHwgdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvciB8fCAnLic7XG5cbiAgICB2YXIgbmFtZXNwYWNlcyA9IG9wdGlvbnMubnMgfHwgdGhpcy5vcHRpb25zLmRlZmF1bHROUztcbiAgICBpZiAobnNTZXBhcmF0b3IgJiYga2V5LmluZGV4T2YobnNTZXBhcmF0b3IpID4gLTEpIHtcbiAgICAgIHZhciBwYXJ0cyA9IGtleS5zcGxpdChuc1NlcGFyYXRvcik7XG4gICAgICBpZiAobnNTZXBhcmF0b3IgIT09IGtleVNlcGFyYXRvciB8fCBuc1NlcGFyYXRvciA9PT0ga2V5U2VwYXJhdG9yICYmIHRoaXMub3B0aW9ucy5ucy5pbmRleE9mKHBhcnRzWzBdKSA+IC0xKSBuYW1lc3BhY2VzID0gcGFydHMuc2hpZnQoKTtcbiAgICAgIGtleSA9IHBhcnRzLmpvaW4oa2V5U2VwYXJhdG9yKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJykgbmFtZXNwYWNlcyA9IFtuYW1lc3BhY2VzXTtcblxuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIG5hbWVzcGFjZXM6IG5hbWVzcGFjZXNcbiAgICB9O1xuICB9O1xuXG4gIFRyYW5zbGF0b3IucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIHRyYW5zbGF0ZShrZXlzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgaWYgKCh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob3B0aW9ucykpICE9PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5vdmVybG9hZFRyYW5zbGF0aW9uT3B0aW9uSGFuZGxlcihhcmd1bWVudHMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlBUEkgPT09ICd2MScpIHtcbiAgICAgIG9wdGlvbnMgPSBjb21wYXQuY29udmVydFRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIG5vbiB2YWxpZCBrZXlzIGhhbmRsaW5nXG4gICAgaWYgKGtleXMgPT09IHVuZGVmaW5lZCB8fCBrZXlzID09PSBudWxsIHx8IGtleXMgPT09ICcnKSByZXR1cm4gJyc7XG4gICAgaWYgKHR5cGVvZiBrZXlzID09PSAnbnVtYmVyJykga2V5cyA9IFN0cmluZyhrZXlzKTtcbiAgICBpZiAodHlwZW9mIGtleXMgPT09ICdzdHJpbmcnKSBrZXlzID0gW2tleXNdO1xuXG4gICAgLy8gc2VwYXJhdG9yc1xuICAgIHZhciBrZXlTZXBhcmF0b3IgPSBvcHRpb25zLmtleVNlcGFyYXRvciB8fCB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yIHx8ICcuJztcblxuICAgIC8vIGdldCBuYW1lc3BhY2UocylcblxuICAgIHZhciBfZXh0cmFjdEZyb21LZXkgPSB0aGlzLmV4dHJhY3RGcm9tS2V5KGtleXNba2V5cy5sZW5ndGggLSAxXSwgb3B0aW9ucyksXG4gICAgICAgIGtleSA9IF9leHRyYWN0RnJvbUtleS5rZXksXG4gICAgICAgIG5hbWVzcGFjZXMgPSBfZXh0cmFjdEZyb21LZXkubmFtZXNwYWNlcztcblxuICAgIHZhciBuYW1lc3BhY2UgPSBuYW1lc3BhY2VzW25hbWVzcGFjZXMubGVuZ3RoIC0gMV07XG5cbiAgICAvLyByZXR1cm4ga2V5IG9uIENJTW9kZVxuICAgIHZhciBsbmcgPSBvcHRpb25zLmxuZyB8fCB0aGlzLmxhbmd1YWdlO1xuICAgIHZhciBhcHBlbmROYW1lc3BhY2VUb0NJTW9kZSA9IG9wdGlvbnMuYXBwZW5kTmFtZXNwYWNlVG9DSU1vZGUgfHwgdGhpcy5vcHRpb25zLmFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlO1xuICAgIGlmIChsbmcgJiYgbG5nLnRvTG93ZXJDYXNlKCkgPT09ICdjaW1vZGUnKSB7XG4gICAgICBpZiAoYXBwZW5kTmFtZXNwYWNlVG9DSU1vZGUpIHtcbiAgICAgICAgdmFyIG5zU2VwYXJhdG9yID0gb3B0aW9ucy5uc1NlcGFyYXRvciB8fCB0aGlzLm9wdGlvbnMubnNTZXBhcmF0b3I7XG4gICAgICAgIHJldHVybiBuYW1lc3BhY2UgKyBuc1NlcGFyYXRvciArIGtleTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG5cbiAgICAvLyByZXNvbHZlIGZyb20gc3RvcmVcbiAgICB2YXIgcmVzID0gdGhpcy5yZXNvbHZlKGtleXMsIG9wdGlvbnMpO1xuXG4gICAgdmFyIHJlc1R5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHJlcyk7XG4gICAgdmFyIG5vT2JqZWN0ID0gWydbb2JqZWN0IE51bWJlcl0nLCAnW29iamVjdCBGdW5jdGlvbl0nLCAnW29iamVjdCBSZWdFeHBdJ107XG4gICAgdmFyIGpvaW5BcnJheXMgPSBvcHRpb25zLmpvaW5BcnJheXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuam9pbkFycmF5cyA6IHRoaXMub3B0aW9ucy5qb2luQXJyYXlzO1xuXG4gICAgLy8gb2JqZWN0XG4gICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzICE9PSAnc3RyaW5nJyAmJiBub09iamVjdC5pbmRleE9mKHJlc1R5cGUpIDwgMCAmJiAhKGpvaW5BcnJheXMgJiYgcmVzVHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykpIHtcbiAgICAgIGlmICghb3B0aW9ucy5yZXR1cm5PYmplY3RzICYmICF0aGlzLm9wdGlvbnMucmV0dXJuT2JqZWN0cykge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdhY2Nlc3NpbmcgYW4gb2JqZWN0IC0gYnV0IHJldHVybk9iamVjdHMgb3B0aW9ucyBpcyBub3QgZW5hYmxlZCEnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yZXR1cm5lZE9iamVjdEhhbmRsZXIgPyB0aGlzLm9wdGlvbnMucmV0dXJuZWRPYmplY3RIYW5kbGVyKGtleSwgcmVzLCBvcHRpb25zKSA6ICdrZXkgXFwnJyArIGtleSArICcgKCcgKyB0aGlzLmxhbmd1YWdlICsgJylcXCcgcmV0dXJuZWQgYW4gb2JqZWN0IGluc3RlYWQgb2Ygc3RyaW5nLic7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHdlIGdvdCBhIHNlcGFyYXRvciB3ZSBsb29wIG92ZXIgY2hpbGRyZW4gLSBlbHNlIHdlIGp1c3QgcmV0dXJuIG9iamVjdCBhcyBpc1xuICAgICAgLy8gYXMgaGF2aW5nIGl0IHNldCB0byBmYWxzZSBtZWFucyBubyBoaWVyYXJjaHkgc28gbm8gbG9va3VwIGZvciBuZXN0ZWQgdmFsdWVzXG4gICAgICBpZiAob3B0aW9ucy5rZXlTZXBhcmF0b3IgfHwgdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvcikge1xuICAgICAgICB2YXIgY29weSA9IHJlc1R5cGUgPT09ICdbb2JqZWN0IEFycmF5XScgPyBbXSA6IHt9OyAvLyBhcHBseSBjaGlsZCB0cmFuc2xhdGlvbiBvbiBhIGNvcHlcblxuICAgICAgICBmb3IgKHZhciBtIGluIHJlcykge1xuICAgICAgICAgIGNvcHlbbV0gPSB0aGlzLnRyYW5zbGF0ZSgnJyArIGtleSArIGtleVNlcGFyYXRvciArIG0sIF9leHRlbmRzKHsgam9pbkFycmF5czogZmFsc2UsIG5zOiBuYW1lc3BhY2VzIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBjb3B5O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBhcnJheSBzcGVjaWFsIHRyZWF0bWVudFxuICAgIGVsc2UgaWYgKGpvaW5BcnJheXMgJiYgcmVzVHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICByZXMgPSByZXMuam9pbihqb2luQXJyYXlzKTtcbiAgICAgICAgaWYgKHJlcykgcmVzID0gdGhpcy5leHRlbmRUcmFuc2xhdGlvbihyZXMsIGtleSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICAvLyBzdHJpbmcsIGVtcHR5IG9yIG51bGxcbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciB1c2VkRGVmYXVsdCA9IGZhbHNlLFxuICAgICAgICAgICAgICB1c2VkS2V5ID0gZmFsc2U7XG5cbiAgICAgICAgICAvLyBmYWxsYmFjayB2YWx1ZVxuICAgICAgICAgIGlmICghdGhpcy5pc1ZhbGlkTG9va3VwKHJlcykgJiYgb3B0aW9ucy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdXNlZERlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgcmVzID0gb3B0aW9ucy5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5pc1ZhbGlkTG9va3VwKHJlcykpIHtcbiAgICAgICAgICAgIHVzZWRLZXkgPSB0cnVlO1xuICAgICAgICAgICAgcmVzID0ga2V5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHNhdmUgbWlzc2luZ1xuICAgICAgICAgIGlmICh1c2VkS2V5IHx8IHVzZWREZWZhdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ21pc3NpbmdLZXknLCBsbmcsIG5hbWVzcGFjZSwga2V5LCByZXMpO1xuXG4gICAgICAgICAgICB2YXIgbG5ncyA9IFtdO1xuICAgICAgICAgICAgdmFyIGZhbGxiYWNrTG5ncyA9IHRoaXMubGFuZ3VhZ2VVdGlscy5nZXRGYWxsYmFja0NvZGVzKHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZywgb3B0aW9ucy5sbmcgfHwgdGhpcy5sYW5ndWFnZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNhdmVNaXNzaW5nVG8gPT09ICdmYWxsYmFjaycgJiYgZmFsbGJhY2tMbmdzICYmIGZhbGxiYWNrTG5nc1swXSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZhbGxiYWNrTG5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxuZ3MucHVzaChmYWxsYmFja0xuZ3NbaV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zYXZlTWlzc2luZ1RvID09PSAnYWxsJykge1xuICAgICAgICAgICAgICBsbmdzID0gdGhpcy5sYW5ndWFnZVV0aWxzLnRvUmVzb2x2ZUhpZXJhcmNoeShvcHRpb25zLmxuZyB8fCB0aGlzLmxhbmd1YWdlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vKHRoaXMub3B0aW9ucy5zYXZlTWlzc2luZ1RvID09PSAnY3VycmVudCcgfHwgKHRoaXMub3B0aW9ucy5zYXZlTWlzc2luZ1RvID09PSAnZmFsbGJhY2snICYmIHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZ1swXSA9PT0gZmFsc2UpICkge1xuICAgICAgICAgICAgICBsbmdzLnB1c2gob3B0aW9ucy5sbmcgfHwgdGhpcy5sYW5ndWFnZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2F2ZU1pc3NpbmcpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5taXNzaW5nS2V5SGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5taXNzaW5nS2V5SGFuZGxlcihsbmdzLCBuYW1lc3BhY2UsIGtleSwgcmVzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmJhY2tlbmRDb25uZWN0b3IgJiYgdGhpcy5iYWNrZW5kQ29ubmVjdG9yLnNhdmVNaXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iYWNrZW5kQ29ubmVjdG9yLnNhdmVNaXNzaW5nKGxuZ3MsIG5hbWVzcGFjZSwga2V5LCByZXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZW1pdCgnbWlzc2luZ0tleScsIGxuZ3MsIG5hbWVzcGFjZSwga2V5LCByZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGV4dGVuZFxuICAgICAgICAgIHJlcyA9IHRoaXMuZXh0ZW5kVHJhbnNsYXRpb24ocmVzLCBrZXksIG9wdGlvbnMpO1xuXG4gICAgICAgICAgLy8gYXBwZW5kIG5hbWVzcGFjZSBpZiBzdGlsbCBrZXlcbiAgICAgICAgICBpZiAodXNlZEtleSAmJiByZXMgPT09IGtleSAmJiB0aGlzLm9wdGlvbnMuYXBwZW5kTmFtZXNwYWNlVG9NaXNzaW5nS2V5KSByZXMgPSBuYW1lc3BhY2UgKyAnOicgKyBrZXk7XG5cbiAgICAgICAgICAvLyBwYXJzZU1pc3NpbmdLZXlIYW5kbGVyXG4gICAgICAgICAgaWYgKHVzZWRLZXkgJiYgdGhpcy5vcHRpb25zLnBhcnNlTWlzc2luZ0tleUhhbmRsZXIpIHJlcyA9IHRoaXMub3B0aW9ucy5wYXJzZU1pc3NpbmdLZXlIYW5kbGVyKHJlcyk7XG4gICAgICAgIH1cblxuICAgIC8vIHJldHVyblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgVHJhbnNsYXRvci5wcm90b3R5cGUuZXh0ZW5kVHJhbnNsYXRpb24gPSBmdW5jdGlvbiBleHRlbmRUcmFuc2xhdGlvbihyZXMsIGtleSwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgaWYgKG9wdGlvbnMuaW50ZXJwb2xhdGlvbikgdGhpcy5pbnRlcnBvbGF0b3IuaW5pdChfZXh0ZW5kcyh7fSwgb3B0aW9ucywgeyBpbnRlcnBvbGF0aW9uOiBfZXh0ZW5kcyh7fSwgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24sIG9wdGlvbnMuaW50ZXJwb2xhdGlvbikgfSkpO1xuXG4gICAgLy8gaW50ZXJwb2xhdGVcbiAgICB2YXIgZGF0YSA9IG9wdGlvbnMucmVwbGFjZSAmJiB0eXBlb2Ygb3B0aW9ucy5yZXBsYWNlICE9PSAnc3RyaW5nJyA/IG9wdGlvbnMucmVwbGFjZSA6IG9wdGlvbnM7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMpIGRhdGEgPSBfZXh0ZW5kcyh7fSwgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZGVmYXVsdFZhcmlhYmxlcywgZGF0YSk7XG4gICAgcmVzID0gdGhpcy5pbnRlcnBvbGF0b3IuaW50ZXJwb2xhdGUocmVzLCBkYXRhLCB0aGlzLmxhbmd1YWdlKTtcblxuICAgIC8vIG5lc3RpbmdcbiAgICByZXMgPSB0aGlzLmludGVycG9sYXRvci5uZXN0KHJlcywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzMi50cmFuc2xhdGUuYXBwbHkoX3RoaXMyLCBhcmdzKTtcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIGlmIChvcHRpb25zLmludGVycG9sYXRpb24pIHRoaXMuaW50ZXJwb2xhdG9yLnJlc2V0KCk7XG5cbiAgICAvLyBwb3N0IHByb2Nlc3NcbiAgICB2YXIgcG9zdFByb2Nlc3MgPSBvcHRpb25zLnBvc3RQcm9jZXNzIHx8IHRoaXMub3B0aW9ucy5wb3N0UHJvY2VzcztcbiAgICB2YXIgcG9zdFByb2Nlc3Nvck5hbWVzID0gdHlwZW9mIHBvc3RQcm9jZXNzID09PSAnc3RyaW5nJyA/IFtwb3N0UHJvY2Vzc10gOiBwb3N0UHJvY2VzcztcblxuICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZCAmJiBwb3N0UHJvY2Vzc29yTmFtZXMgJiYgcG9zdFByb2Nlc3Nvck5hbWVzLmxlbmd0aCAmJiBvcHRpb25zLmFwcGx5UG9zdFByb2Nlc3NvciAhPT0gZmFsc2UpIHtcbiAgICAgIHJlcyA9IF9wb3N0UHJvY2Vzc29yMi5kZWZhdWx0LmhhbmRsZShwb3N0UHJvY2Vzc29yTmFtZXMsIHJlcywga2V5LCBvcHRpb25zLCB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFRyYW5zbGF0b3IucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKGtleXMpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHZhciBmb3VuZCA9IHZvaWQgMDtcblxuICAgIGlmICh0eXBlb2Yga2V5cyA9PT0gJ3N0cmluZycpIGtleXMgPSBba2V5c107XG5cbiAgICAvLyBmb3JFYWNoIHBvc3NpYmxlIGtleVxuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgaWYgKF90aGlzMy5pc1ZhbGlkTG9va3VwKGZvdW5kKSkgcmV0dXJuO1xuXG4gICAgICB2YXIgX2V4dHJhY3RGcm9tS2V5MiA9IF90aGlzMy5leHRyYWN0RnJvbUtleShrLCBvcHRpb25zKSxcbiAgICAgICAgICBrZXkgPSBfZXh0cmFjdEZyb21LZXkyLmtleSxcbiAgICAgICAgICBuYW1lc3BhY2VzID0gX2V4dHJhY3RGcm9tS2V5Mi5uYW1lc3BhY2VzO1xuXG4gICAgICBpZiAoX3RoaXMzLm9wdGlvbnMuZmFsbGJhY2tOUykgbmFtZXNwYWNlcyA9IG5hbWVzcGFjZXMuY29uY2F0KF90aGlzMy5vcHRpb25zLmZhbGxiYWNrTlMpO1xuXG4gICAgICB2YXIgbmVlZHNQbHVyYWxIYW5kbGluZyA9IG9wdGlvbnMuY291bnQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5jb3VudCAhPT0gJ3N0cmluZyc7XG4gICAgICB2YXIgbmVlZHNDb250ZXh0SGFuZGxpbmcgPSBvcHRpb25zLmNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5jb250ZXh0ID09PSAnc3RyaW5nJyAmJiBvcHRpb25zLmNvbnRleHQgIT09ICcnO1xuXG4gICAgICB2YXIgY29kZXMgPSBvcHRpb25zLmxuZ3MgPyBvcHRpb25zLmxuZ3MgOiBfdGhpczMubGFuZ3VhZ2VVdGlscy50b1Jlc29sdmVIaWVyYXJjaHkob3B0aW9ucy5sbmcgfHwgX3RoaXMzLmxhbmd1YWdlKTtcblxuICAgICAgbmFtZXNwYWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChucykge1xuICAgICAgICBpZiAoX3RoaXMzLmlzVmFsaWRMb29rdXAoZm91bmQpKSByZXR1cm47XG5cbiAgICAgICAgY29kZXMuZm9yRWFjaChmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAgIGlmIChfdGhpczMuaXNWYWxpZExvb2t1cChmb3VuZCkpIHJldHVybjtcblxuICAgICAgICAgIHZhciBmaW5hbEtleSA9IGtleTtcbiAgICAgICAgICB2YXIgZmluYWxLZXlzID0gW2ZpbmFsS2V5XTtcblxuICAgICAgICAgIHZhciBwbHVyYWxTdWZmaXggPSB2b2lkIDA7XG4gICAgICAgICAgaWYgKG5lZWRzUGx1cmFsSGFuZGxpbmcpIHBsdXJhbFN1ZmZpeCA9IF90aGlzMy5wbHVyYWxSZXNvbHZlci5nZXRTdWZmaXgoY29kZSwgb3B0aW9ucy5jb3VudCk7XG5cbiAgICAgICAgICAvLyBmYWxsYmFjayBmb3IgcGx1cmFsIGlmIGNvbnRleHQgbm90IGZvdW5kXG4gICAgICAgICAgaWYgKG5lZWRzUGx1cmFsSGFuZGxpbmcgJiYgbmVlZHNDb250ZXh0SGFuZGxpbmcpIGZpbmFsS2V5cy5wdXNoKGZpbmFsS2V5ICsgcGx1cmFsU3VmZml4KTtcblxuICAgICAgICAgIC8vIGdldCBrZXkgZm9yIGNvbnRleHQgaWYgbmVlZGVkXG4gICAgICAgICAgaWYgKG5lZWRzQ29udGV4dEhhbmRsaW5nKSBmaW5hbEtleXMucHVzaChmaW5hbEtleSArPSAnJyArIF90aGlzMy5vcHRpb25zLmNvbnRleHRTZXBhcmF0b3IgKyBvcHRpb25zLmNvbnRleHQpO1xuXG4gICAgICAgICAgLy8gZ2V0IGtleSBmb3IgcGx1cmFsIGlmIG5lZWRlZFxuICAgICAgICAgIGlmIChuZWVkc1BsdXJhbEhhbmRsaW5nKSBmaW5hbEtleXMucHVzaChmaW5hbEtleSArPSBwbHVyYWxTdWZmaXgpO1xuXG4gICAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIGZpbmFsS2V5cyBzdGFydGluZyB3aXRoIG1vc3Qgc3BlY2lmaWMgcGx1cmFsa2V5ICgtPiBjb250ZXh0a2V5IG9ubHkpIC0+IHNpbmd1bGFya2V5IG9ubHlcbiAgICAgICAgICB2YXIgcG9zc2libGVLZXkgPSB2b2lkIDA7XG4gICAgICAgICAgd2hpbGUgKHBvc3NpYmxlS2V5ID0gZmluYWxLZXlzLnBvcCgpKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMzLmlzVmFsaWRMb29rdXAoZm91bmQpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGZvdW5kID0gX3RoaXMzLmdldFJlc291cmNlKGNvZGUsIG5zLCBwb3NzaWJsZUtleSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZvdW5kO1xuICB9O1xuXG4gIFRyYW5zbGF0b3IucHJvdG90eXBlLmlzVmFsaWRMb29rdXAgPSBmdW5jdGlvbiBpc1ZhbGlkTG9va3VwKHJlcykge1xuICAgIHJldHVybiByZXMgIT09IHVuZGVmaW5lZCAmJiAhKCF0aGlzLm9wdGlvbnMucmV0dXJuTnVsbCAmJiByZXMgPT09IG51bGwpICYmICEoIXRoaXMub3B0aW9ucy5yZXR1cm5FbXB0eVN0cmluZyAmJiByZXMgPT09ICcnKTtcbiAgfTtcblxuICBUcmFuc2xhdG9yLnByb3RvdHlwZS5nZXRSZXNvdXJjZSA9IGZ1bmN0aW9uIGdldFJlc291cmNlKGNvZGUsIG5zLCBrZXkpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG5cbiAgICByZXR1cm4gdGhpcy5yZXNvdXJjZVN0b3JlLmdldFJlc291cmNlKGNvZGUsIG5zLCBrZXksIG9wdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBUcmFuc2xhdG9yO1xufShfRXZlbnRFbWl0dGVyMy5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVHJhbnNsYXRvcjsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNvbnZlcnRBUElPcHRpb25zID0gY29udmVydEFQSU9wdGlvbnM7XG5leHBvcnRzLmNvbnZlcnRKU09OT3B0aW9ucyA9IGNvbnZlcnRKU09OT3B0aW9ucztcbmV4cG9ydHMuY29udmVydFRPcHRpb25zID0gY29udmVydFRPcHRpb25zO1xuZXhwb3J0cy5hcHBlbmRCYWNrd2FyZHNBUEkgPSBhcHBlbmRCYWNrd2FyZHNBUEk7XG5cbnZhciBfbG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5cbnZhciBfbG9nZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZ2dlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNvbnZlcnRJbnRlcnBvbGF0aW9uKG9wdGlvbnMpIHtcblxuICBvcHRpb25zLmludGVycG9sYXRpb24gPSB7XG4gICAgdW5lc2NhcGVTdWZmaXg6ICdIVE1MJ1xuICB9O1xuXG4gIG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5wcmVmaXggPSBvcHRpb25zLmludGVycG9sYXRpb25QcmVmaXggfHwgJ19fJztcbiAgb3B0aW9ucy5pbnRlcnBvbGF0aW9uLnN1ZmZpeCA9IG9wdGlvbnMuaW50ZXJwb2xhdGlvblN1ZmZpeCB8fCAnX18nO1xuICBvcHRpb25zLmludGVycG9sYXRpb24uZXNjYXBlVmFsdWUgPSBvcHRpb25zLmVzY2FwZUludGVycG9sYXRpb24gfHwgZmFsc2U7XG5cbiAgb3B0aW9ucy5pbnRlcnBvbGF0aW9uLm5lc3RpbmdQcmVmaXggPSBvcHRpb25zLnJldXNlUHJlZml4IHx8ICckdCgnO1xuICBvcHRpb25zLmludGVycG9sYXRpb24ubmVzdGluZ1N1ZmZpeCA9IG9wdGlvbnMucmV1c2VTdWZmaXggfHwgJyknO1xuXG4gIHJldHVybiBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0QVBJT3B0aW9ucyhvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnJlc1N0b3JlKSBvcHRpb25zLnJlc291cmNlcyA9IG9wdGlvbnMucmVzU3RvcmU7XG5cbiAgaWYgKG9wdGlvbnMubnMgJiYgb3B0aW9ucy5ucy5kZWZhdWx0TnMpIHtcbiAgICBvcHRpb25zLmRlZmF1bHROUyA9IG9wdGlvbnMubnMuZGVmYXVsdE5zO1xuICAgIG9wdGlvbnMubnMgPSBvcHRpb25zLm5zLm5hbWVzcGFjZXM7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy5kZWZhdWx0TlMgPSBvcHRpb25zLm5zIHx8ICd0cmFuc2xhdGlvbic7XG4gIH1cblxuICBpZiAob3B0aW9ucy5mYWxsYmFja1RvRGVmYXVsdE5TICYmIG9wdGlvbnMuZGVmYXVsdE5TKSBvcHRpb25zLmZhbGxiYWNrTlMgPSBvcHRpb25zLmRlZmF1bHROUztcblxuICBvcHRpb25zLnNhdmVNaXNzaW5nID0gb3B0aW9ucy5zZW5kTWlzc2luZztcbiAgb3B0aW9ucy5zYXZlTWlzc2luZ1RvID0gb3B0aW9ucy5zZW5kTWlzc2luZ1RvIHx8ICdjdXJyZW50JztcbiAgb3B0aW9ucy5yZXR1cm5OdWxsID0gb3B0aW9ucy5mYWxsYmFja09uTnVsbCA/IGZhbHNlIDogdHJ1ZTtcbiAgb3B0aW9ucy5yZXR1cm5FbXB0eVN0cmluZyA9IG9wdGlvbnMuZmFsbGJhY2tPbkVtcHR5ID8gZmFsc2UgOiB0cnVlO1xuICBvcHRpb25zLnJldHVybk9iamVjdHMgPSBvcHRpb25zLnJldHVybk9iamVjdFRyZWVzO1xuICBvcHRpb25zLmpvaW5BcnJheXMgPSAnXFxuJztcblxuICBvcHRpb25zLnJldHVybmVkT2JqZWN0SGFuZGxlciA9IG9wdGlvbnMub2JqZWN0VHJlZUtleUhhbmRsZXI7XG4gIG9wdGlvbnMucGFyc2VNaXNzaW5nS2V5SGFuZGxlciA9IG9wdGlvbnMucGFyc2VNaXNzaW5nS2V5O1xuICBvcHRpb25zLmFwcGVuZE5hbWVzcGFjZVRvTWlzc2luZ0tleSA9IHRydWU7XG5cbiAgb3B0aW9ucy5uc1NlcGFyYXRvciA9IG9wdGlvbnMubnNzZXBhcmF0b3IgfHwgJzonO1xuICBvcHRpb25zLmtleVNlcGFyYXRvciA9IG9wdGlvbnMua2V5c2VwYXJhdG9yIHx8ICcuJztcblxuICBpZiAob3B0aW9ucy5zaG9ydGN1dEZ1bmN0aW9uID09PSAnc3ByaW50ZicpIHtcbiAgICBvcHRpb25zLm92ZXJsb2FkVHJhbnNsYXRpb25PcHRpb25IYW5kbGVyID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKGFyZ3NbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3N0UHJvY2VzczogJ3NwcmludGYnLFxuICAgICAgICBzcHJpbnRmOiB2YWx1ZXNcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIG9wdGlvbnMud2hpdGVsaXN0ID0gb3B0aW9ucy5sbmdXaGl0ZWxpc3Q7XG4gIG9wdGlvbnMucHJlbG9hZCA9IG9wdGlvbnMucHJlbG9hZDtcbiAgaWYgKG9wdGlvbnMubG9hZCA9PT0gJ2N1cnJlbnQnKSBvcHRpb25zLmxvYWQgPSAnY3VycmVudE9ubHknO1xuICBpZiAob3B0aW9ucy5sb2FkID09PSAndW5zcGVjaWZpYycpIG9wdGlvbnMubG9hZCA9ICdsYW5ndWFnZU9ubHknO1xuXG4gIC8vIGJhY2tlbmRcbiAgb3B0aW9ucy5iYWNrZW5kID0gb3B0aW9ucy5iYWNrZW5kIHx8IHt9O1xuICBvcHRpb25zLmJhY2tlbmQubG9hZFBhdGggPSBvcHRpb25zLnJlc0dldFBhdGggfHwgJ2xvY2FsZXMvX19sbmdfXy9fX25zX18uanNvbic7XG4gIG9wdGlvbnMuYmFja2VuZC5hZGRQYXRoID0gb3B0aW9ucy5yZXNQb3N0UGF0aCB8fCAnbG9jYWxlcy9hZGQvX19sbmdfXy9fX25zX18nO1xuICBvcHRpb25zLmJhY2tlbmQuYWxsb3dNdWx0aUxvYWRpbmcgPSBvcHRpb25zLmR5bmFtaWNMb2FkO1xuXG4gIC8vIGNhY2hlXG4gIG9wdGlvbnMuY2FjaGUgPSBvcHRpb25zLmNhY2hlIHx8IHt9O1xuICBvcHRpb25zLmNhY2hlLnByZWZpeCA9ICdyZXNfJztcbiAgb3B0aW9ucy5jYWNoZS5leHBpcmF0aW9uVGltZSA9IDcgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xuICBvcHRpb25zLmNhY2hlLmVuYWJsZWQgPSBvcHRpb25zLnVzZUxvY2FsU3RvcmFnZSA/IHRydWUgOiBmYWxzZTtcblxuICBvcHRpb25zID0gY29udmVydEludGVycG9sYXRpb24ob3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLmRlZmF1bHRWYXJpYWJsZXMpIG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5kZWZhdWx0VmFyaWFibGVzID0gb3B0aW9ucy5kZWZhdWx0VmFyaWFibGVzO1xuXG4gIC8vIFRPRE86IGRlcHJlY2F0aW9uXG4gIC8vIGlmIChvcHRpb25zLmdldEFzeW5jID09PSBmYWxzZSkgdGhyb3cgZGVwcmVjYXRpb24gZXJyb3JcblxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuZnVuY3Rpb24gY29udmVydEpTT05PcHRpb25zKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IGNvbnZlcnRJbnRlcnBvbGF0aW9uKG9wdGlvbnMpO1xuICBvcHRpb25zLmpvaW5BcnJheXMgPSAnXFxuJztcblxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuZnVuY3Rpb24gY29udmVydFRPcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuaW50ZXJwb2xhdGlvblByZWZpeCB8fCBvcHRpb25zLmludGVycG9sYXRpb25TdWZmaXggfHwgb3B0aW9ucy5lc2NhcGVJbnRlcnBvbGF0aW9uKSB7XG4gICAgb3B0aW9ucyA9IGNvbnZlcnRJbnRlcnBvbGF0aW9uKG9wdGlvbnMpO1xuICB9XG5cbiAgb3B0aW9ucy5uc1NlcGFyYXRvciA9IG9wdGlvbnMubnNzZXBhcmF0b3I7XG4gIG9wdGlvbnMua2V5U2VwYXJhdG9yID0gb3B0aW9ucy5rZXlzZXBhcmF0b3I7XG5cbiAgb3B0aW9ucy5yZXR1cm5PYmplY3RzID0gb3B0aW9ucy5yZXR1cm5PYmplY3RUcmVlcztcblxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuZnVuY3Rpb24gYXBwZW5kQmFja3dhcmRzQVBJKGkxOG4pIHtcbiAgaTE4bi5sbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgX2xvZ2dlcjIuZGVmYXVsdC5kZXByZWNhdGUoJ2kxOG5leHQubG5nKCkgY2FuIGJlIHJlcGxhY2VkIGJ5IGkxOG5leHQubGFuZ3VhZ2UgZm9yIGRldGVjdGVkIGxhbmd1YWdlIG9yIGkxOG5leHQubGFuZ3VhZ2VzIGZvciBsYW5ndWFnZXMgb3JkZXJlZCBieSB0cmFuc2xhdGlvbiBsb29rdXAuJyk7XG4gICAgcmV0dXJuIGkxOG4uc2VydmljZXMubGFuZ3VhZ2VVdGlscy50b1Jlc29sdmVIaWVyYXJjaHkoaTE4bi5sYW5ndWFnZSlbMF07XG4gIH07XG5cbiAgaTE4bi5wcmVsb2FkID0gZnVuY3Rpb24gKGxuZ3MsIGNiKSB7XG4gICAgX2xvZ2dlcjIuZGVmYXVsdC5kZXByZWNhdGUoJ2kxOG5leHQucHJlbG9hZCgpIGNhbiBiZSByZXBsYWNlZCB3aXRoIGkxOG5leHQubG9hZExhbmd1YWdlcygpJyk7XG4gICAgaTE4bi5sb2FkTGFuZ3VhZ2VzKGxuZ3MsIGNiKTtcbiAgfTtcblxuICBpMThuLnNldExuZyA9IGZ1bmN0aW9uIChsbmcsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgX2xvZ2dlcjIuZGVmYXVsdC5kZXByZWNhdGUoJ2kxOG5leHQuc2V0TG5nKCkgY2FuIGJlIHJlcGxhY2VkIHdpdGggaTE4bmV4dC5jaGFuZ2VMYW5ndWFnZSgpIG9yIGkxOG5leHQuZ2V0Rml4ZWRUKCkgdG8gZ2V0IGEgdHJhbnNsYXRpb24gZnVuY3Rpb24gd2l0aCBmaXhlZCBsYW5ndWFnZSBvciBuYW1lc3BhY2UuJyk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuXG4gICAgaWYgKG9wdGlvbnMuZml4TG5nID09PSB0cnVlKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHJldHVybiBjYWxsYmFjayhudWxsLCBpMThuLmdldEZpeGVkVChsbmcpKTtcbiAgICB9XG5cbiAgICBpMThuLmNoYW5nZUxhbmd1YWdlKGxuZywgY2FsbGJhY2spO1xuICB9O1xuXG4gIGkxOG4uYWRkUG9zdFByb2Nlc3NvciA9IGZ1bmN0aW9uIChuYW1lLCBmYykge1xuICAgIF9sb2dnZXIyLmRlZmF1bHQuZGVwcmVjYXRlKCdpMThuZXh0LmFkZFBvc3RQcm9jZXNzb3IoKSBjYW4gYmUgcmVwbGFjZWQgYnkgaTE4bmV4dC51c2UoeyB0eXBlOiBcXCdwb3N0UHJvY2Vzc29yXFwnLCBuYW1lOiBcXCduYW1lXFwnLCBwcm9jZXNzOiBmYyB9KScpO1xuICAgIGkxOG4udXNlKHtcbiAgICAgIHR5cGU6ICdwb3N0UHJvY2Vzc29yJyxcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBwcm9jZXNzOiBmY1xuICAgIH0pO1xuICB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0ID0gZ2V0O1xuZXhwb3J0cy50cmFuc2Zvcm1PcHRpb25zID0gdHJhbnNmb3JtT3B0aW9ucztcbmZ1bmN0aW9uIGdldCgpIHtcbiAgcmV0dXJuIHtcbiAgICBkZWJ1ZzogZmFsc2UsXG4gICAgaW5pdEltbWVkaWF0ZTogdHJ1ZSxcblxuICAgIG5zOiBbJ3RyYW5zbGF0aW9uJ10sXG4gICAgZGVmYXVsdE5TOiBbJ3RyYW5zbGF0aW9uJ10sXG4gICAgZmFsbGJhY2tMbmc6IFsnZGV2J10sXG4gICAgZmFsbGJhY2tOUzogZmFsc2UsIC8vIHN0cmluZyBvciBhcnJheSBvZiBuYW1lc3BhY2VzXG5cbiAgICB3aGl0ZWxpc3Q6IGZhbHNlLCAvLyBhcnJheSB3aXRoIHdoaXRlbGlzdGVkIGxhbmd1YWdlc1xuICAgIG5vbkV4cGxpY2l0V2hpdGVsaXN0OiBmYWxzZSxcbiAgICBsb2FkOiAnYWxsJywgLy8gfCBjdXJyZW50T25seSB8IGxhbmd1YWdlT25seVxuICAgIHByZWxvYWQ6IGZhbHNlLCAvLyBhcnJheSB3aXRoIHByZWxvYWQgbGFuZ3VhZ2VzXG5cbiAgICBrZXlTZXBhcmF0b3I6ICcuJyxcbiAgICBuc1NlcGFyYXRvcjogJzonLFxuICAgIHBsdXJhbFNlcGFyYXRvcjogJ18nLFxuICAgIGNvbnRleHRTZXBhcmF0b3I6ICdfJyxcblxuICAgIHNhdmVNaXNzaW5nOiBmYWxzZSwgLy8gZW5hYmxlIHRvIHNlbmQgbWlzc2luZyB2YWx1ZXNcbiAgICBzYXZlTWlzc2luZ1RvOiAnZmFsbGJhY2snLCAvLyAnY3VycmVudCcgfHwgJ2FsbCdcbiAgICBtaXNzaW5nS2V5SGFuZGxlcjogZmFsc2UsIC8vIGZ1bmN0aW9uKGxuZywgbnMsIGtleSwgZmFsbGJhY2tWYWx1ZSkgLT4gb3ZlcnJpZGUgaWYgcHJlZmVyIG9uIGhhbmRsaW5nXG5cbiAgICBwb3N0UHJvY2VzczogZmFsc2UsIC8vIHN0cmluZyBvciBhcnJheSBvZiBwb3N0UHJvY2Vzc29yIG5hbWVzXG4gICAgcmV0dXJuTnVsbDogdHJ1ZSwgLy8gYWxsb3dzIG51bGwgdmFsdWUgYXMgdmFsaWQgdHJhbnNsYXRpb25cbiAgICByZXR1cm5FbXB0eVN0cmluZzogdHJ1ZSwgLy8gYWxsb3dzIGVtcHR5IHN0cmluZyB2YWx1ZSBhcyB2YWxpZCB0cmFuc2xhdGlvblxuICAgIHJldHVybk9iamVjdHM6IGZhbHNlLFxuICAgIGpvaW5BcnJheXM6IGZhbHNlLCAvLyBvciBzdHJpbmcgdG8gam9pbiBhcnJheVxuICAgIHJldHVybmVkT2JqZWN0SGFuZGxlcjogZnVuY3Rpb24gcmV0dXJuZWRPYmplY3RIYW5kbGVyKCkge30sIC8vIGZ1bmN0aW9uKGtleSwgdmFsdWUsIG9wdGlvbnMpIHRyaWdnZXJlZCBpZiBrZXkgcmV0dXJucyBvYmplY3QgYnV0IHJldHVybk9iamVjdHMgaXMgc2V0IHRvIGZhbHNlXG4gICAgcGFyc2VNaXNzaW5nS2V5SGFuZGxlcjogZmFsc2UsIC8vIGZ1bmN0aW9uKGtleSkgcGFyc2VkIGEga2V5IHRoYXQgd2FzIG5vdCBmb3VuZCBpbiB0KCkgYmVmb3JlIHJldHVybmluZ1xuICAgIGFwcGVuZE5hbWVzcGFjZVRvTWlzc2luZ0tleTogZmFsc2UsXG4gICAgYXBwZW5kTmFtZXNwYWNlVG9DSU1vZGU6IGZhbHNlLFxuICAgIG92ZXJsb2FkVHJhbnNsYXRpb25PcHRpb25IYW5kbGVyOiBmdW5jdGlvbiBvdmVybG9hZFRyYW5zbGF0aW9uT3B0aW9uSGFuZGxlcihhcmdzKSB7XG4gICAgICByZXR1cm4geyBkZWZhdWx0VmFsdWU6IGFyZ3NbMV0gfTtcbiAgICB9LFxuXG4gICAgaW50ZXJwb2xhdGlvbjoge1xuICAgICAgZXNjYXBlVmFsdWU6IHRydWUsXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSwgX2Zvcm1hdCwgbG5nKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBwcmVmaXg6ICd7eycsXG4gICAgICBzdWZmaXg6ICd9fScsXG4gICAgICBmb3JtYXRTZXBhcmF0b3I6ICcsJyxcbiAgICAgIC8vIHByZWZpeEVzY2FwZWQ6ICd7eycsXG4gICAgICAvLyBzdWZmaXhFc2NhcGVkOiAnfX0nLFxuICAgICAgLy8gdW5lc2NhcGVTdWZmaXg6ICcnLFxuICAgICAgdW5lc2NhcGVQcmVmaXg6ICctJyxcblxuICAgICAgbmVzdGluZ1ByZWZpeDogJyR0KCcsXG4gICAgICBuZXN0aW5nU3VmZml4OiAnKScsXG4gICAgICAvLyBuZXN0aW5nUHJlZml4RXNjYXBlZDogJyR0KCcsXG4gICAgICAvLyBuZXN0aW5nU3VmZml4RXNjYXBlZDogJyknLFxuICAgICAgZGVmYXVsdFZhcmlhYmxlczogdW5kZWZpbmVkIC8vIG9iamVjdCB0aGF0IGNhbiBoYXZlIHZhbHVlcyB0byBpbnRlcnBvbGF0ZSBvbiAtIGV4dGVuZHMgcGFzc2VkIGluIGludGVycG9sYXRpb24gZGF0YVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtT3B0aW9ucyhvcHRpb25zKSB7XG4gIC8vIGNyZWF0ZSBuYW1lc3BhY2Ugb2JqZWN0IGlmIG5hbWVzcGFjZSBpcyBwYXNzZWQgaW4gYXMgc3RyaW5nXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5ucyA9PT0gJ3N0cmluZycpIG9wdGlvbnMubnMgPSBbb3B0aW9ucy5uc107XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5mYWxsYmFja0xuZyA9PT0gJ3N0cmluZycpIG9wdGlvbnMuZmFsbGJhY2tMbmcgPSBbb3B0aW9ucy5mYWxsYmFja0xuZ107XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5mYWxsYmFja05TID09PSAnc3RyaW5nJykgb3B0aW9ucy5mYWxsYmFja05TID0gW29wdGlvbnMuZmFsbGJhY2tOU107XG5cbiAgLy8gZXh0ZW5kIHdoaXRlbGlzdCB3aXRoIGNpbW9kZVxuICBpZiAob3B0aW9ucy53aGl0ZWxpc3QgJiYgb3B0aW9ucy53aGl0ZWxpc3QuaW5kZXhPZignY2ltb2RlJykgPCAwKSBvcHRpb25zLndoaXRlbGlzdC5wdXNoKCdjaW1vZGUnKTtcblxuICByZXR1cm4gb3B0aW9ucztcbn0iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9sb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xuXG52YXIgX2xvZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2dnZXIpO1xuXG52YXIgX0V2ZW50RW1pdHRlcjIgPSByZXF1aXJlKCcuL0V2ZW50RW1pdHRlcicpO1xuXG52YXIgX0V2ZW50RW1pdHRlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FdmVudEVtaXR0ZXIyKTtcblxudmFyIF9SZXNvdXJjZVN0b3JlID0gcmVxdWlyZSgnLi9SZXNvdXJjZVN0b3JlJyk7XG5cbnZhciBfUmVzb3VyY2VTdG9yZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZXNvdXJjZVN0b3JlKTtcblxudmFyIF9UcmFuc2xhdG9yID0gcmVxdWlyZSgnLi9UcmFuc2xhdG9yJyk7XG5cbnZhciBfVHJhbnNsYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UcmFuc2xhdG9yKTtcblxudmFyIF9MYW5ndWFnZVV0aWxzID0gcmVxdWlyZSgnLi9MYW5ndWFnZVV0aWxzJyk7XG5cbnZhciBfTGFuZ3VhZ2VVdGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MYW5ndWFnZVV0aWxzKTtcblxudmFyIF9QbHVyYWxSZXNvbHZlciA9IHJlcXVpcmUoJy4vUGx1cmFsUmVzb2x2ZXInKTtcblxudmFyIF9QbHVyYWxSZXNvbHZlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9QbHVyYWxSZXNvbHZlcik7XG5cbnZhciBfSW50ZXJwb2xhdG9yID0gcmVxdWlyZSgnLi9JbnRlcnBvbGF0b3InKTtcblxudmFyIF9JbnRlcnBvbGF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSW50ZXJwb2xhdG9yKTtcblxudmFyIF9CYWNrZW5kQ29ubmVjdG9yID0gcmVxdWlyZSgnLi9CYWNrZW5kQ29ubmVjdG9yJyk7XG5cbnZhciBfQmFja2VuZENvbm5lY3RvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYWNrZW5kQ29ubmVjdG9yKTtcblxudmFyIF9DYWNoZUNvbm5lY3RvciA9IHJlcXVpcmUoJy4vQ2FjaGVDb25uZWN0b3InKTtcblxudmFyIF9DYWNoZUNvbm5lY3RvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DYWNoZUNvbm5lY3Rvcik7XG5cbnZhciBfZGVmYXVsdHMyID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG52YXIgX3Bvc3RQcm9jZXNzb3IgPSByZXF1aXJlKCcuL3Bvc3RQcm9jZXNzb3InKTtcblxudmFyIF9wb3N0UHJvY2Vzc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3RQcm9jZXNzb3IpO1xuXG52YXIgX3YgPSByZXF1aXJlKCcuL2NvbXBhdGliaWxpdHkvdjEnKTtcblxudmFyIGNvbXBhdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF92KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHsgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkZWZhdWx0cyk7IGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykgeyB2YXIga2V5ID0ga2V5c1tpXTsgdmFyIHZhbHVlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkZWZhdWx0cywga2V5KTsgaWYgKHZhbHVlICYmIHZhbHVlLmNvbmZpZ3VyYWJsZSAmJiBvYmpba2V5XSA9PT0gdW5kZWZpbmVkKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpOyB9IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBfZGVmYXVsdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fTtcblxudmFyIEkxOG4gPSBmdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICBfaW5oZXJpdHMoSTE4biwgX0V2ZW50RW1pdHRlcik7XG5cbiAgZnVuY3Rpb24gSTE4bigpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEkxOG4pO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0V2ZW50RW1pdHRlci5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLm9wdGlvbnMgPSAoMCwgX2RlZmF1bHRzMi50cmFuc2Zvcm1PcHRpb25zKShvcHRpb25zKTtcbiAgICBfdGhpcy5zZXJ2aWNlcyA9IHt9O1xuICAgIF90aGlzLmxvZ2dlciA9IF9sb2dnZXIyLmRlZmF1bHQ7XG4gICAgX3RoaXMubW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGNhbGxiYWNrICYmICFfdGhpcy5pc0luaXRpYWxpemVkICYmICFvcHRpb25zLmlzQ2xvbmUpIF90aGlzLmluaXQob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIEkxOG4ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0KG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG5cbiAgICBpZiAob3B0aW9ucy5jb21wYXRpYmlsaXR5QVBJID09PSAndjEnKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgKDAsIF9kZWZhdWx0czIuZ2V0KSgpLCAoMCwgX2RlZmF1bHRzMi50cmFuc2Zvcm1PcHRpb25zKShjb21wYXQuY29udmVydEFQSU9wdGlvbnMob3B0aW9ucykpLCB7fSk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmNvbXBhdGliaWxpdHlKU09OID09PSAndjEnKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgKDAsIF9kZWZhdWx0czIuZ2V0KSgpLCAoMCwgX2RlZmF1bHRzMi50cmFuc2Zvcm1PcHRpb25zKShjb21wYXQuY29udmVydEpTT05PcHRpb25zKG9wdGlvbnMpKSwge30pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgKDAsIF9kZWZhdWx0czIuZ2V0KSgpLCB0aGlzLm9wdGlvbnMsICgwLCBfZGVmYXVsdHMyLnRyYW5zZm9ybU9wdGlvbnMpKG9wdGlvbnMpKTtcbiAgICB9XG4gICAgaWYgKCFjYWxsYmFjaykgY2FsbGJhY2sgPSBub29wO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2xhc3NPbkRlbWFuZChDbGFzc09yT2JqZWN0KSB7XG4gICAgICBpZiAoIUNsYXNzT3JPYmplY3QpIHJldHVybjtcbiAgICAgIGlmICh0eXBlb2YgQ2xhc3NPck9iamVjdCA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG5ldyBDbGFzc09yT2JqZWN0KCk7XG4gICAgICByZXR1cm4gQ2xhc3NPck9iamVjdDtcbiAgICB9XG5cbiAgICAvLyBpbml0IHNlcnZpY2VzXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNDbG9uZSkge1xuICAgICAgaWYgKHRoaXMubW9kdWxlcy5sb2dnZXIpIHtcbiAgICAgICAgX2xvZ2dlcjIuZGVmYXVsdC5pbml0KGNyZWF0ZUNsYXNzT25EZW1hbmQodGhpcy5tb2R1bGVzLmxvZ2dlciksIHRoaXMub3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfbG9nZ2VyMi5kZWZhdWx0LmluaXQobnVsbCwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGx1ID0gbmV3IF9MYW5ndWFnZVV0aWxzMi5kZWZhdWx0KHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLnN0b3JlID0gbmV3IF9SZXNvdXJjZVN0b3JlMi5kZWZhdWx0KHRoaXMub3B0aW9ucy5yZXNvdXJjZXMsIHRoaXMub3B0aW9ucyk7XG5cbiAgICAgIHZhciBzID0gdGhpcy5zZXJ2aWNlcztcbiAgICAgIHMubG9nZ2VyID0gX2xvZ2dlcjIuZGVmYXVsdDtcbiAgICAgIHMucmVzb3VyY2VTdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgICBzLnJlc291cmNlU3RvcmUub24oJ2FkZGVkIHJlbW92ZWQnLCBmdW5jdGlvbiAobG5nLCBucykge1xuICAgICAgICBzLmNhY2hlQ29ubmVjdG9yLnNhdmUoKTtcbiAgICAgIH0pO1xuICAgICAgcy5sYW5ndWFnZVV0aWxzID0gbHU7XG4gICAgICBzLnBsdXJhbFJlc29sdmVyID0gbmV3IF9QbHVyYWxSZXNvbHZlcjIuZGVmYXVsdChsdSwgeyBwcmVwZW5kOiB0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yLCBjb21wYXRpYmlsaXR5SlNPTjogdGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlKU09OIH0pO1xuICAgICAgcy5pbnRlcnBvbGF0b3IgPSBuZXcgX0ludGVycG9sYXRvcjIuZGVmYXVsdCh0aGlzLm9wdGlvbnMpO1xuXG4gICAgICBzLmJhY2tlbmRDb25uZWN0b3IgPSBuZXcgX0JhY2tlbmRDb25uZWN0b3IyLmRlZmF1bHQoY3JlYXRlQ2xhc3NPbkRlbWFuZCh0aGlzLm1vZHVsZXMuYmFja2VuZCksIHMucmVzb3VyY2VTdG9yZSwgcywgdGhpcy5vcHRpb25zKTtcbiAgICAgIC8vIHBpcGUgZXZlbnRzIGZyb20gYmFja2VuZENvbm5lY3RvclxuICAgICAgcy5iYWNrZW5kQ29ubmVjdG9yLm9uKCcqJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMyLmVtaXQuYXBwbHkoX3RoaXMyLCBbZXZlbnRdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9KTtcblxuICAgICAgcy5iYWNrZW5kQ29ubmVjdG9yLm9uKCdsb2FkZWQnLCBmdW5jdGlvbiAobG9hZGVkKSB7XG4gICAgICAgIHMuY2FjaGVDb25uZWN0b3Iuc2F2ZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIHMuY2FjaGVDb25uZWN0b3IgPSBuZXcgX0NhY2hlQ29ubmVjdG9yMi5kZWZhdWx0KGNyZWF0ZUNsYXNzT25EZW1hbmQodGhpcy5tb2R1bGVzLmNhY2hlKSwgcy5yZXNvdXJjZVN0b3JlLCBzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgLy8gcGlwZSBldmVudHMgZnJvbSBiYWNrZW5kQ29ubmVjdG9yXG4gICAgICBzLmNhY2hlQ29ubmVjdG9yLm9uKCcqJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMyLmVtaXQuYXBwbHkoX3RoaXMyLCBbZXZlbnRdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMubW9kdWxlcy5sYW5ndWFnZURldGVjdG9yKSB7XG4gICAgICAgIHMubGFuZ3VhZ2VEZXRlY3RvciA9IGNyZWF0ZUNsYXNzT25EZW1hbmQodGhpcy5tb2R1bGVzLmxhbmd1YWdlRGV0ZWN0b3IpO1xuICAgICAgICBzLmxhbmd1YWdlRGV0ZWN0b3IuaW5pdChzLCB0aGlzLm9wdGlvbnMuZGV0ZWN0aW9uLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRyYW5zbGF0b3IgPSBuZXcgX1RyYW5zbGF0b3IyLmRlZmF1bHQodGhpcy5zZXJ2aWNlcywgdGhpcy5vcHRpb25zKTtcbiAgICAgIC8vIHBpcGUgZXZlbnRzIGZyb20gdHJhbnNsYXRvclxuICAgICAgdGhpcy50cmFuc2xhdG9yLm9uKCcqJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgICBhcmdzW19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMyLmVtaXQuYXBwbHkoX3RoaXMyLCBbZXZlbnRdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBhcHBlbmQgYXBpXG4gICAgdmFyIHN0b3JlQXBpID0gWydnZXRSZXNvdXJjZScsICdhZGRSZXNvdXJjZScsICdhZGRSZXNvdXJjZXMnLCAnYWRkUmVzb3VyY2VCdW5kbGUnLCAncmVtb3ZlUmVzb3VyY2VCdW5kbGUnLCAnaGFzUmVzb3VyY2VCdW5kbGUnLCAnZ2V0UmVzb3VyY2VCdW5kbGUnXTtcbiAgICBzdG9yZUFwaS5mb3JFYWNoKGZ1bmN0aW9uIChmY05hbWUpIHtcbiAgICAgIF90aGlzMltmY05hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZVtmY05hbWVdLmFwcGx5KHRoaXMuc3RvcmUsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gVE9ETzogQ09NUEFUSUJJTElUWSByZW1vdmUgdGhpc1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUFQSSA9PT0gJ3YxJykgY29tcGF0LmFwcGVuZEJhY2t3YXJkc0FQSSh0aGlzKTtcblxuICAgIHZhciBsb2FkID0gZnVuY3Rpb24gbG9hZCgpIHtcbiAgICAgIF90aGlzMi5jaGFuZ2VMYW5ndWFnZShfdGhpczIub3B0aW9ucy5sbmcsIGZ1bmN0aW9uIChlcnIsIHQpIHtcbiAgICAgICAgX3RoaXMyLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICBfdGhpczIubG9nZ2VyLmxvZygnaW5pdGlhbGl6ZWQnLCBfdGhpczIub3B0aW9ucyk7XG4gICAgICAgIF90aGlzMi5lbWl0KCdpbml0aWFsaXplZCcsIF90aGlzMi5vcHRpb25zKTtcblxuICAgICAgICBjYWxsYmFjayhlcnIsIHQpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzb3VyY2VzIHx8ICF0aGlzLm9wdGlvbnMuaW5pdEltbWVkaWF0ZSkge1xuICAgICAgbG9hZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRUaW1lb3V0KGxvYWQsIDApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEkxOG4ucHJvdG90eXBlLmxvYWRSZXNvdXJjZXMgPSBmdW5jdGlvbiBsb2FkUmVzb3VyY2VzKCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBub29wO1xuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMucmVzb3VyY2VzKSB7XG4gICAgICB2YXIgX3JldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzMy5sYW5ndWFnZSAmJiBfdGhpczMubGFuZ3VhZ2UudG9Mb3dlckNhc2UoKSA9PT0gJ2NpbW9kZScpIHJldHVybiB7XG4gICAgICAgICAgICB2OiBjYWxsYmFjaygpXG4gICAgICAgICAgfTsgLy8gYXZvaWQgbG9hZGluZyByZXNvdXJjZXMgZm9yIGNpbW9kZVxuXG4gICAgICAgIHZhciB0b0xvYWQgPSBbXTtcblxuICAgICAgICB2YXIgYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKGxuZykge1xuICAgICAgICAgIHZhciBsbmdzID0gX3RoaXMzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMudG9SZXNvbHZlSGllcmFyY2h5KGxuZyk7XG4gICAgICAgICAgbG5ncy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICBpZiAodG9Mb2FkLmluZGV4T2YobCkgPCAwKSB0b0xvYWQucHVzaChsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBhcHBlbmQoX3RoaXMzLmxhbmd1YWdlKTtcblxuICAgICAgICBpZiAoX3RoaXMzLm9wdGlvbnMucHJlbG9hZCkge1xuICAgICAgICAgIF90aGlzMy5vcHRpb25zLnByZWxvYWQuZm9yRWFjaChmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgYXBwZW5kKGwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMzLnNlcnZpY2VzLmNhY2hlQ29ubmVjdG9yLmxvYWQodG9Mb2FkLCBfdGhpczMub3B0aW9ucy5ucywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMy5zZXJ2aWNlcy5iYWNrZW5kQ29ubmVjdG9yLmxvYWQodG9Mb2FkLCBfdGhpczMub3B0aW9ucy5ucywgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgIH0oKTtcblxuICAgICAgaWYgKCh0eXBlb2YgX3JldCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoX3JldCkpID09PSBcIm9iamVjdFwiKSByZXR1cm4gX3JldC52O1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9XG4gIH07XG5cbiAgSTE4bi5wcm90b3R5cGUucmVsb2FkUmVzb3VyY2VzID0gZnVuY3Rpb24gcmVsb2FkUmVzb3VyY2VzKGxuZ3MsIG5zKSB7XG4gICAgaWYgKCFsbmdzKSBsbmdzID0gdGhpcy5sYW5ndWFnZXM7XG4gICAgaWYgKCFucykgbnMgPSB0aGlzLm9wdGlvbnMubnM7XG4gICAgdGhpcy5zZXJ2aWNlcy5iYWNrZW5kQ29ubmVjdG9yLnJlbG9hZChsbmdzLCBucyk7XG4gIH07XG5cbiAgSTE4bi5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKG1vZHVsZSkge1xuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ2JhY2tlbmQnKSB7XG4gICAgICB0aGlzLm1vZHVsZXMuYmFja2VuZCA9IG1vZHVsZTtcbiAgICB9XG5cbiAgICBpZiAobW9kdWxlLnR5cGUgPT09ICdjYWNoZScpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5jYWNoZSA9IG1vZHVsZTtcbiAgICB9XG5cbiAgICBpZiAobW9kdWxlLnR5cGUgPT09ICdsb2dnZXInIHx8IG1vZHVsZS5sb2cgJiYgbW9kdWxlLndhcm4gJiYgbW9kdWxlLndhcm4pIHtcbiAgICAgIHRoaXMubW9kdWxlcy5sb2dnZXIgPSBtb2R1bGU7XG4gICAgfVxuXG4gICAgaWYgKG1vZHVsZS50eXBlID09PSAnbGFuZ3VhZ2VEZXRlY3RvcicpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5sYW5ndWFnZURldGVjdG9yID0gbW9kdWxlO1xuICAgIH1cblxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ3Bvc3RQcm9jZXNzb3InKSB7XG4gICAgICBfcG9zdFByb2Nlc3NvcjIuZGVmYXVsdC5hZGRQb3N0UHJvY2Vzc29yKG1vZHVsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgSTE4bi5wcm90b3R5cGUuY2hhbmdlTGFuZ3VhZ2UgPSBmdW5jdGlvbiBjaGFuZ2VMYW5ndWFnZShsbmcsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uIGRvbmUoZXJyKSB7XG4gICAgICBpZiAobG5nKSB7XG4gICAgICAgIF90aGlzNC5lbWl0KCdsYW5ndWFnZUNoYW5nZWQnLCBsbmcpO1xuICAgICAgICBfdGhpczQubG9nZ2VyLmxvZygnbGFuZ3VhZ2VDaGFuZ2VkJywgbG5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3RoaXM0LnQuYXBwbHkoX3RoaXM0LCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAoIWxuZyAmJiB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IpIGxuZyA9IHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5kZXRlY3QoKTtcblxuICAgIGlmIChsbmcpIHtcbiAgICAgIHRoaXMubGFuZ3VhZ2UgPSBsbmc7XG4gICAgICB0aGlzLmxhbmd1YWdlcyA9IHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscy50b1Jlc29sdmVIaWVyYXJjaHkobG5nKTtcblxuICAgICAgdGhpcy50cmFuc2xhdG9yLmNoYW5nZUxhbmd1YWdlKGxuZyk7XG5cbiAgICAgIGlmICh0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IpIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5jYWNoZVVzZXJMYW5ndWFnZShsbmcpO1xuICAgIH1cblxuICAgIHRoaXMubG9hZFJlc291cmNlcyhmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBkb25lKGVycik7XG4gICAgfSk7XG4gIH07XG5cbiAgSTE4bi5wcm90b3R5cGUuZ2V0Rml4ZWRUID0gZnVuY3Rpb24gZ2V0Rml4ZWRUKGxuZywgbnMpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIHZhciBmaXhlZFQgPSBmdW5jdGlvbiBmaXhlZFQoa2V5KSB7XG4gICAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIHZhciBvcHRpb25zID0gX2V4dGVuZHMoe30sIG9wdHMpO1xuICAgICAgb3B0aW9ucy5sbmcgPSBvcHRpb25zLmxuZyB8fCBmaXhlZFQubG5nO1xuICAgICAgb3B0aW9ucy5ucyA9IG9wdGlvbnMubnMgfHwgZml4ZWRULm5zO1xuICAgICAgcmV0dXJuIF90aGlzNS50KGtleSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBmaXhlZFQubG5nID0gbG5nO1xuICAgIGZpeGVkVC5ucyA9IG5zO1xuICAgIHJldHVybiBmaXhlZFQ7XG4gIH07XG5cbiAgSTE4bi5wcm90b3R5cGUudCA9IGZ1bmN0aW9uIHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNsYXRvciAmJiB0aGlzLnRyYW5zbGF0b3IudHJhbnNsYXRlLmFwcGx5KHRoaXMudHJhbnNsYXRvciwgYXJndW1lbnRzKTtcbiAgfTtcblxuICBJMThuLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbiBleGlzdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNsYXRvciAmJiB0aGlzLnRyYW5zbGF0b3IuZXhpc3RzLmFwcGx5KHRoaXMudHJhbnNsYXRvciwgYXJndW1lbnRzKTtcbiAgfTtcblxuICBJMThuLnByb3RvdHlwZS5zZXREZWZhdWx0TmFtZXNwYWNlID0gZnVuY3Rpb24gc2V0RGVmYXVsdE5hbWVzcGFjZShucykge1xuICAgIHRoaXMub3B0aW9ucy5kZWZhdWx0TlMgPSBucztcbiAgfTtcblxuICBJMThuLnByb3RvdHlwZS5sb2FkTmFtZXNwYWNlcyA9IGZ1bmN0aW9uIGxvYWROYW1lc3BhY2VzKG5zLCBjYWxsYmFjaykge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMubnMpIHJldHVybiBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgIGlmICh0eXBlb2YgbnMgPT09ICdzdHJpbmcnKSBucyA9IFtuc107XG5cbiAgICBucy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICBpZiAoX3RoaXM2Lm9wdGlvbnMubnMuaW5kZXhPZihuKSA8IDApIF90aGlzNi5vcHRpb25zLm5zLnB1c2gobik7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxvYWRSZXNvdXJjZXMoY2FsbGJhY2spO1xuICB9O1xuXG4gIEkxOG4ucHJvdG90eXBlLmxvYWRMYW5ndWFnZXMgPSBmdW5jdGlvbiBsb2FkTGFuZ3VhZ2VzKGxuZ3MsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBsbmdzID09PSAnc3RyaW5nJykgbG5ncyA9IFtsbmdzXTtcbiAgICB2YXIgcHJlbG9hZGVkID0gdGhpcy5vcHRpb25zLnByZWxvYWQgfHwgW107XG5cbiAgICB2YXIgbmV3TG5ncyA9IGxuZ3MuZmlsdGVyKGZ1bmN0aW9uIChsbmcpIHtcbiAgICAgIHJldHVybiBwcmVsb2FkZWQuaW5kZXhPZihsbmcpIDwgMDtcbiAgICB9KTtcbiAgICAvLyBFeGl0IGVhcmx5IGlmIGFsbCBnaXZlbiBsYW5ndWFnZXMgYXJlIGFscmVhZHkgcHJlbG9hZGVkXG4gICAgaWYgKCFuZXdMbmdzLmxlbmd0aCkgcmV0dXJuIGNhbGxiYWNrKCk7XG5cbiAgICB0aGlzLm9wdGlvbnMucHJlbG9hZCA9IHByZWxvYWRlZC5jb25jYXQobmV3TG5ncyk7XG4gICAgdGhpcy5sb2FkUmVzb3VyY2VzKGNhbGxiYWNrKTtcbiAgfTtcblxuICBJMThuLnByb3RvdHlwZS5kaXIgPSBmdW5jdGlvbiBkaXIobG5nKSB7XG4gICAgaWYgKCFsbmcpIGxuZyA9IHRoaXMubGFuZ3VhZ2U7XG4gICAgaWYgKCFsbmcpIHJldHVybiAncnRsJztcblxuICAgIHZhciBydGxMbmdzID0gWydhcicsICdzaHUnLCAnc3FyJywgJ3NzaCcsICd4YWEnLCAneWhkJywgJ3l1ZCcsICdhYW8nLCAnYWJoJywgJ2FidicsICdhY20nLCAnYWNxJywgJ2FjdycsICdhY3gnLCAnYWN5JywgJ2FkZicsICdhZHMnLCAnYWViJywgJ2FlYycsICdhZmInLCAnYWpwJywgJ2FwYycsICdhcGQnLCAnYXJiJywgJ2FycScsICdhcnMnLCAnYXJ5JywgJ2FyeicsICdhdXonLCAnYXZsJywgJ2F5aCcsICdheWwnLCAnYXluJywgJ2F5cCcsICdiYnonLCAncGdhJywgJ2hlJywgJ2l3JywgJ3BzJywgJ3BidCcsICdwYnUnLCAncHN0JywgJ3BycCcsICdwcmQnLCAndXInLCAneWRkJywgJ3lkcycsICd5aWgnLCAnamknLCAneWknLCAnaGJvJywgJ21lbicsICd4bW4nLCAnZmEnLCAnanByJywgJ3BlbycsICdwZXMnLCAncHJzJywgJ2R2JywgJ3NhbSddO1xuXG4gICAgcmV0dXJuIHJ0bExuZ3MuaW5kZXhPZih0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUobG5nKSkgPj0gMCA/ICdydGwnIDogJ2x0cic7XG4gIH07XG5cbiAgSTE4bi5wcm90b3R5cGUuY3JlYXRlSW5zdGFuY2UgPSBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZSgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzFdO1xuXG4gICAgcmV0dXJuIG5ldyBJMThuKG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfTtcblxuICBJMThuLnByb3RvdHlwZS5jbG9uZUluc3RhbmNlID0gZnVuY3Rpb24gY2xvbmVJbnN0YW5jZSgpIHtcbiAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG5vb3A7XG5cbiAgICB2YXIgbWVyZ2VkT3B0aW9ucyA9IF9leHRlbmRzKHt9LCBvcHRpb25zLCB0aGlzLm9wdGlvbnMsIHsgaXNDbG9uZTogdHJ1ZSB9KTtcbiAgICB2YXIgY2xvbmUgPSBuZXcgSTE4bihtZXJnZWRPcHRpb25zLCBjYWxsYmFjayk7XG4gICAgdmFyIG1lbWJlcnNUb0NvcHkgPSBbJ3N0b3JlJywgJ3NlcnZpY2VzJywgJ2xhbmd1YWdlJ107XG4gICAgbWVtYmVyc1RvQ29weS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICBjbG9uZVttXSA9IF90aGlzN1ttXTtcbiAgICB9KTtcbiAgICBjbG9uZS50cmFuc2xhdG9yID0gbmV3IF9UcmFuc2xhdG9yMi5kZWZhdWx0KGNsb25lLnNlcnZpY2VzLCBjbG9uZS5vcHRpb25zKTtcbiAgICBjbG9uZS50cmFuc2xhdG9yLm9uKCcqJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuNSA+IDEgPyBfbGVuNSAtIDEgOiAwKSwgX2tleTUgPSAxOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTUgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gICAgICB9XG5cbiAgICAgIGNsb25lLmVtaXQuYXBwbHkoY2xvbmUsIFtldmVudF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9KTtcbiAgICBjbG9uZS5pbml0KG1lcmdlZE9wdGlvbnMsIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiBjbG9uZTtcbiAgfTtcblxuICByZXR1cm4gSTE4bjtcbn0oX0V2ZW50RW1pdHRlcjMuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBJMThuKCk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2kxOG5leHQgPSByZXF1aXJlKCcuL2kxOG5leHQnKTtcblxudmFyIF9pMThuZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2kxOG5leHQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBfaTE4bmV4dDIuZGVmYXVsdDsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBjb25zb2xlTG9nZ2VyID0ge1xuICB0eXBlOiAnbG9nZ2VyJyxcblxuICBsb2c6IGZ1bmN0aW9uIGxvZyhhcmdzKSB7XG4gICAgdGhpcy5fb3V0cHV0KCdsb2cnLCBhcmdzKTtcbiAgfSxcbiAgd2FybjogZnVuY3Rpb24gd2FybihhcmdzKSB7XG4gICAgdGhpcy5fb3V0cHV0KCd3YXJuJywgYXJncyk7XG4gIH0sXG4gIGVycm9yOiBmdW5jdGlvbiBlcnJvcihhcmdzKSB7XG4gICAgdGhpcy5fb3V0cHV0KCdlcnJvcicsIGFyZ3MpO1xuICB9LFxuICBfb3V0cHV0OiBmdW5jdGlvbiBfb3V0cHV0KHR5cGUsIGFyZ3MpIHtcbiAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlW3R5cGVdKSBjb25zb2xlW3R5cGVdLmFwcGx5KGNvbnNvbGUsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpKTtcbiAgfVxufTtcblxudmFyIExvZ2dlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTG9nZ2VyKGNvbmNyZXRlTG9nZ2VyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExvZ2dlcik7XG5cbiAgICB0aGlzLmluaXQoY29uY3JldGVMb2dnZXIsIG9wdGlvbnMpO1xuICB9XG5cbiAgTG9nZ2VyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdChjb25jcmV0ZUxvZ2dlcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHRoaXMucHJlZml4ID0gb3B0aW9ucy5wcmVmaXggfHwgJ2kxOG5leHQ6JztcbiAgICB0aGlzLmxvZ2dlciA9IGNvbmNyZXRlTG9nZ2VyIHx8IGNvbnNvbGVMb2dnZXI7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmRlYnVnID0gb3B0aW9ucy5kZWJ1ZyA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWU7XG4gIH07XG5cbiAgTG9nZ2VyLnByb3RvdHlwZS5zZXREZWJ1ZyA9IGZ1bmN0aW9uIHNldERlYnVnKGJvb2wpIHtcbiAgICB0aGlzLmRlYnVnID0gYm9vbDtcbiAgfTtcblxuICBMb2dnZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIGxvZygpIHtcbiAgICB0aGlzLmZvcndhcmQoYXJndW1lbnRzLCAnbG9nJywgJycsIHRydWUpO1xuICB9O1xuXG4gIExvZ2dlci5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uIHdhcm4oKSB7XG4gICAgdGhpcy5mb3J3YXJkKGFyZ3VtZW50cywgJ3dhcm4nLCAnJywgdHJ1ZSk7XG4gIH07XG5cbiAgTG9nZ2VyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKCkge1xuICAgIHRoaXMuZm9yd2FyZChhcmd1bWVudHMsICdlcnJvcicsICcnKTtcbiAgfTtcblxuICBMb2dnZXIucHJvdG90eXBlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uIGRlcHJlY2F0ZSgpIHtcbiAgICB0aGlzLmZvcndhcmQoYXJndW1lbnRzLCAnd2FybicsICdXQVJOSU5HIERFUFJFQ0FURUQ6ICcsIHRydWUpO1xuICB9O1xuXG4gIExvZ2dlci5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uIGZvcndhcmQoYXJncywgbHZsLCBwcmVmaXgsIGRlYnVnT25seSkge1xuICAgIGlmIChkZWJ1Z09ubHkgJiYgIXRoaXMuZGVidWcpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnKSBhcmdzWzBdID0gcHJlZml4ICsgdGhpcy5wcmVmaXggKyAnICcgKyBhcmdzWzBdO1xuICAgIHRoaXMubG9nZ2VyW2x2bF0oYXJncyk7XG4gIH07XG5cbiAgTG9nZ2VyLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUobW9kdWxlTmFtZSkge1xuICAgIHZhciBzdWIgPSBuZXcgTG9nZ2VyKHRoaXMubG9nZ2VyLCBfZXh0ZW5kcyh7IHByZWZpeDogdGhpcy5wcmVmaXggKyAnOicgKyBtb2R1bGVOYW1lICsgJzonIH0sIHRoaXMub3B0aW9ucykpO1xuXG4gICAgcmV0dXJuIHN1YjtcbiAgfTtcblxuICAvLyBjcmVhdGVJbnN0YW5jZShvcHRpb25zID0ge30pIHtcbiAgLy8gICByZXR1cm4gbmV3IExvZ2dlcihvcHRpb25zLCBjYWxsYmFjayk7XG4gIC8vIH1cblxuICByZXR1cm4gTG9nZ2VyO1xufSgpO1xuXG47XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBMb2dnZXIoKTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcblxuICBwcm9jZXNzb3JzOiB7fSxcblxuICBhZGRQb3N0UHJvY2Vzc29yOiBmdW5jdGlvbiBhZGRQb3N0UHJvY2Vzc29yKG1vZHVsZSkge1xuICAgIHRoaXMucHJvY2Vzc29yc1ttb2R1bGUubmFtZV0gPSBtb2R1bGU7XG4gIH0sXG4gIGhhbmRsZTogZnVuY3Rpb24gaGFuZGxlKHByb2Nlc3NvcnMsIHZhbHVlLCBrZXksIG9wdGlvbnMsIHRyYW5zbGF0b3IpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgcHJvY2Vzc29ycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9jZXNzb3IpIHtcbiAgICAgIGlmIChfdGhpcy5wcm9jZXNzb3JzW3Byb2Nlc3Nvcl0pIHZhbHVlID0gX3RoaXMucHJvY2Vzc29yc1twcm9jZXNzb3JdLnByb2Nlc3ModmFsdWUsIGtleSwgb3B0aW9ucywgdHJhbnNsYXRvcik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tYWtlU3RyaW5nID0gbWFrZVN0cmluZztcbmV4cG9ydHMuY29weSA9IGNvcHk7XG5leHBvcnRzLnNldFBhdGggPSBzZXRQYXRoO1xuZXhwb3J0cy5wdXNoUGF0aCA9IHB1c2hQYXRoO1xuZXhwb3J0cy5nZXRQYXRoID0gZ2V0UGF0aDtcbmV4cG9ydHMuZGVlcEV4dGVuZCA9IGRlZXBFeHRlbmQ7XG5leHBvcnRzLnJlZ2V4RXNjYXBlID0gcmVnZXhFc2NhcGU7XG5leHBvcnRzLmVzY2FwZSA9IGVzY2FwZTtcbmZ1bmN0aW9uIG1ha2VTdHJpbmcob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkgcmV0dXJuICcnO1xuICByZXR1cm4gJycgKyBvYmplY3Q7XG59XG5cbmZ1bmN0aW9uIGNvcHkoYSwgcywgdCkge1xuICBhLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICBpZiAoc1ttXSkgdFttXSA9IHNbbV07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRMYXN0T2ZQYXRoKG9iamVjdCwgcGF0aCwgRW1wdHkpIHtcbiAgZnVuY3Rpb24gY2xlYW5LZXkoa2V5KSB7XG4gICAgcmV0dXJuIGtleSAmJiBrZXkuaW5kZXhPZignIyMjJykgPiAtMSA/IGtleS5yZXBsYWNlKC8jIyMvZywgJy4nKSA6IGtleTtcbiAgfVxuXG4gIHZhciBzdGFjayA9IHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJyA/IFtdLmNvbmNhdChwYXRoKSA6IHBhdGguc3BsaXQoJy4nKTtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoIW9iamVjdCkgcmV0dXJuIHt9O1xuXG4gICAgdmFyIGtleSA9IGNsZWFuS2V5KHN0YWNrLnNoaWZ0KCkpO1xuICAgIGlmICghb2JqZWN0W2tleV0gJiYgRW1wdHkpIG9iamVjdFtrZXldID0gbmV3IEVtcHR5KCk7XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cblxuICBpZiAoIW9iamVjdCkgcmV0dXJuIHt9O1xuICByZXR1cm4ge1xuICAgIG9iajogb2JqZWN0LFxuICAgIGs6IGNsZWFuS2V5KHN0YWNrLnNoaWZ0KCkpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHNldFBhdGgob2JqZWN0LCBwYXRoLCBuZXdWYWx1ZSkge1xuICB2YXIgX2dldExhc3RPZlBhdGggPSBnZXRMYXN0T2ZQYXRoKG9iamVjdCwgcGF0aCwgT2JqZWN0KSxcbiAgICAgIG9iaiA9IF9nZXRMYXN0T2ZQYXRoLm9iaixcbiAgICAgIGsgPSBfZ2V0TGFzdE9mUGF0aC5rO1xuXG4gIG9ialtrXSA9IG5ld1ZhbHVlO1xufVxuXG5mdW5jdGlvbiBwdXNoUGF0aChvYmplY3QsIHBhdGgsIG5ld1ZhbHVlLCBjb25jYXQpIHtcbiAgdmFyIF9nZXRMYXN0T2ZQYXRoMiA9IGdldExhc3RPZlBhdGgob2JqZWN0LCBwYXRoLCBPYmplY3QpLFxuICAgICAgb2JqID0gX2dldExhc3RPZlBhdGgyLm9iaixcbiAgICAgIGsgPSBfZ2V0TGFzdE9mUGF0aDIuaztcblxuICBvYmpba10gPSBvYmpba10gfHwgW107XG4gIGlmIChjb25jYXQpIG9ialtrXSA9IG9ialtrXS5jb25jYXQobmV3VmFsdWUpO1xuICBpZiAoIWNvbmNhdCkgb2JqW2tdLnB1c2gobmV3VmFsdWUpO1xufVxuXG5mdW5jdGlvbiBnZXRQYXRoKG9iamVjdCwgcGF0aCkge1xuICB2YXIgX2dldExhc3RPZlBhdGgzID0gZ2V0TGFzdE9mUGF0aChvYmplY3QsIHBhdGgpLFxuICAgICAgb2JqID0gX2dldExhc3RPZlBhdGgzLm9iaixcbiAgICAgIGsgPSBfZ2V0TGFzdE9mUGF0aDMuaztcblxuICBpZiAoIW9iaikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgcmV0dXJuIG9ialtrXTtcbn1cblxuZnVuY3Rpb24gZGVlcEV4dGVuZCh0YXJnZXQsIHNvdXJjZSwgb3ZlcndyaXRlKSB7XG4gIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgaWYgKHByb3AgaW4gdGFyZ2V0KSB7XG4gICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgbGVhZiBzdHJpbmcgaW4gdGFyZ2V0IG9yIHNvdXJjZSB0aGVuIHJlcGxhY2Ugd2l0aCBzb3VyY2Ugb3Igc2tpcCBkZXBlbmRpbmcgb24gdGhlICdvdmVyd3JpdGUnIHN3aXRjaFxuICAgICAgaWYgKHR5cGVvZiB0YXJnZXRbcHJvcF0gPT09ICdzdHJpbmcnIHx8IHRhcmdldFtwcm9wXSBpbnN0YW5jZW9mIFN0cmluZyB8fCB0eXBlb2Ygc291cmNlW3Byb3BdID09PSAnc3RyaW5nJyB8fCBzb3VyY2VbcHJvcF0gaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgaWYgKG92ZXJ3cml0ZSkgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVlcEV4dGVuZCh0YXJnZXRbcHJvcF0sIHNvdXJjZVtwcm9wXSwgb3ZlcndyaXRlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgIH1cbiAgfXJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXC1cXFtcXF1cXC9cXHtcXH1cXChcXClcXCpcXCtcXD9cXC5cXFxcXFxeXFwkXFx8XS9nLCAnXFxcXCQmJyk7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgX2VudGl0eU1hcCA9IHtcbiAgXCImXCI6IFwiJmFtcDtcIixcbiAgXCI8XCI6IFwiJmx0O1wiLFxuICBcIj5cIjogXCImZ3Q7XCIsXG4gICdcIic6ICcmcXVvdDsnLFxuICBcIidcIjogJyYjMzk7JyxcbiAgXCIvXCI6ICcmI3gyRjsnXG59O1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG5mdW5jdGlvbiBlc2NhcGUoZGF0YSkge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRhdGEucmVwbGFjZSgvWyY8PlwiJ1xcL10vZywgZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiBfZW50aXR5TWFwW3NdO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvY29tbW9uanMvaW5kZXguanMnKS5kZWZhdWx0O1xuIiwiLyogZ2xvYmFscyBkZWZpbmUsbW9kdWxlICovXG4vKlxuVXNpbmcgYSBVbml2ZXJzYWwgTW9kdWxlIExvYWRlciB0aGF0IHNob3VsZCBiZSBicm93c2VyLCByZXF1aXJlLCBhbmQgQU1EIGZyaWVuZGx5XG5odHRwOi8vcmljb3N0YWNydXouY29tL2NoZWF0c2hlZXRzL3VtZGpzLmh0bWxcbiovXG47KGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5qc29uTG9naWMgPSBmYWN0b3J5KCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICAvKiBnbG9iYWxzIGNvbnNvbGU6ZmFsc2UgKi9cblxuICBpZiAoICEgQXJyYXkuaXNBcnJheSkge1xuICAgIEFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IHRoYXQgY29udGFpbnMgbm8gZHVwbGljYXRlcyAob3JpZ2luYWwgbm90IG1vZGlmaWVkKVxuICAgKiBAcGFyYW0gIHthcnJheX0gYXJyYXkgICBPcmlnaW5hbCByZWZlcmVuY2UgYXJyYXlcbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgTmV3IGFycmF5IHdpdGggbm8gZHVwbGljYXRlc1xuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlVbmlxdWUoYXJyYXkpIHtcbiAgICB2YXIgYSA9IFtdO1xuICAgIGZvciAodmFyIGk9MCwgbD1hcnJheS5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICBpZiAoYS5pbmRleE9mKGFycmF5W2ldKSA9PT0gLTEpIHtcbiAgICAgICAgYS5wdXNoKGFycmF5W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICB2YXIganNvbkxvZ2ljID0ge307XG4gIHZhciBvcGVyYXRpb25zID0ge1xuICAgIFwiPT1cIjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEgPT0gYjtcbiAgICB9LFxuICAgIFwiPT09XCI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhID09PSBiO1xuICAgIH0sXG4gICAgXCIhPVwiOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYSAhPSBiO1xuICAgIH0sXG4gICAgXCIhPT1cIjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEgIT09IGI7XG4gICAgfSxcbiAgICBcIj5cIjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEgPiBiO1xuICAgIH0sXG4gICAgXCI+PVwiOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYSA+PSBiO1xuICAgIH0sXG4gICAgXCI8XCI6IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiAoYyA9PT0gdW5kZWZpbmVkKSA/IGEgPCBiIDogKGEgPCBiKSAmJiAoYiA8IGMpO1xuICAgIH0sXG4gICAgXCI8PVwiOiBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gKGMgPT09IHVuZGVmaW5lZCkgPyBhIDw9IGIgOiAoYSA8PSBiKSAmJiAoYiA8PSBjKTtcbiAgICB9LFxuICAgIFwiISFcIjogZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIGpzb25Mb2dpYy50cnV0aHkoYSk7XG4gICAgfSxcbiAgICBcIiFcIjogZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuICFqc29uTG9naWMudHJ1dGh5KGEpO1xuICAgIH0sXG4gICAgXCIlXCI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhICUgYjtcbiAgICB9LFxuICAgIFwibG9nXCI6IGZ1bmN0aW9uKGEpIHtcbiAgICAgIGNvbnNvbGUubG9nKGEpOyByZXR1cm4gYTtcbiAgICB9LFxuICAgIFwiaW5cIjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgaWYodHlwZW9mIGIuaW5kZXhPZiA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIChiLmluZGV4T2YoYSkgIT09IC0xKTtcbiAgICB9LFxuICAgIFwiY2F0XCI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5qb2luLmNhbGwoYXJndW1lbnRzLCBcIlwiKTtcbiAgICB9LFxuICAgIFwiK1wiOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUucmVkdWNlLmNhbGwoYXJndW1lbnRzLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGEsIDEwKSArIHBhcnNlRmxvYXQoYiwgMTApO1xuICAgICAgfSwgMCk7XG4gICAgfSxcbiAgICBcIipcIjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnJlZHVjZS5jYWxsKGFyZ3VtZW50cywgZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChhLCAxMCkgKiBwYXJzZUZsb2F0KGIsIDEwKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgXCItXCI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIGlmKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gLWE7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCIvXCI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhIC8gYjtcbiAgICB9LFxuICAgIFwibWluXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGgubWluLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBcIm1heFwiOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgXCJtZXJnZVwiOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUucmVkdWNlLmNhbGwoYXJndW1lbnRzLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICAgIH0sIFtdKTtcbiAgICB9LFxuICAgIFwidmFyXCI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHZhciBub3RfZm91bmQgPSAoYiA9PT0gdW5kZWZpbmVkKSA/IG51bGwgOiBiO1xuICAgICAgdmFyIHN1Yl9wcm9wcyA9IFN0cmluZyhhKS5zcGxpdChcIi5cIik7XG4gICAgICB2YXIgZGF0YSA9IHRoaXM7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc3ViX3Byb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbm90X2ZvdW5kO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlc2NlbmRpbmcgaW50byBkYXRhXG4gICAgICAgIGRhdGEgPSBkYXRhW3N1Yl9wcm9wc1tpXV07XG4gICAgICAgIGlmKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBub3RfZm91bmQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG4gICAgXCJtaXNzaW5nXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgLypcbiAgICAgIE1pc3NpbmcgY2FuIHJlY2VpdmUgbWFueSBrZXlzIGFzIG1hbnkgYXJndW1lbnRzLCBsaWtlIHtcIm1pc3Npbmc6WzEsMl19XG4gICAgICBNaXNzaW5nIGNhbiBhbHNvIHJlY2VpdmUgKm9uZSogYXJndW1lbnQgdGhhdCBpcyBhbiBhcnJheSBvZiBrZXlzLFxuICAgICAgd2hpY2ggdHlwaWNhbGx5IGhhcHBlbnMgaWYgaXQncyBhY3R1YWxseSBhY3Rpbmcgb24gdGhlIG91dHB1dCBvZiBhbm90aGVyIGNvbW1hbmRcbiAgICAgIChsaWtlICdpZicgb3IgJ21lcmdlJylcbiAgICAgICovXG5cbiAgICAgIHZhciBtaXNzaW5nID0gW107XG4gICAgICB2YXIga2V5cyA9IEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSA/IGFyZ3VtZW50c1swXSA6IGFyZ3VtZW50cztcblxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IGpzb25Mb2dpYy5hcHBseSh7XCJ2YXJcIjoga2V5fSwgdGhpcyk7XG4gICAgICAgIGlmKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgbWlzc2luZy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1pc3Npbmc7XG4gICAgfSxcbiAgICBcIm1pc3Npbmdfc29tZVwiOiBmdW5jdGlvbihuZWVkX2NvdW50LCBvcHRpb25zKSB7XG4gICAgICAvLyBtaXNzaW5nX3NvbWUgdGFrZXMgdHdvIGFyZ3VtZW50cywgaG93IG1hbnkgKG1pbmltdW0pIGl0ZW1zIG11c3QgYmUgcHJlc2VudCwgYW5kIGFuIGFycmF5IG9mIGtleXMgKGp1c3QgbGlrZSAnbWlzc2luZycpIHRvIGNoZWNrIGZvciBwcmVzZW5jZS5cbiAgICAgIHZhciBhcmVfbWlzc2luZyA9IGpzb25Mb2dpYy5hcHBseSh7XCJtaXNzaW5nXCI6IG9wdGlvbnN9LCB0aGlzKTtcblxuICAgICAgaWYob3B0aW9ucy5sZW5ndGggLSBhcmVfbWlzc2luZy5sZW5ndGggPj0gbmVlZF9jb3VudCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9ZWxzZXtcbiAgICAgICAgcmV0dXJuIGFyZV9taXNzaW5nO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJtZXRob2RcIjogZnVuY3Rpb24ob2JqLCBtZXRob2QsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBvYmpbbWV0aG9kXS5hcHBseShvYmosIGFyZ3MpO1xuICAgIH0sXG5cbiAgfTtcblxuICBqc29uTG9naWMuaXNfbG9naWMgPSBmdW5jdGlvbihsb2dpYykge1xuICAgIHJldHVybiAoXG4gICAgICBsb2dpYyAhPT0gbnVsbCAmJiB0eXBlb2YgbG9naWMgPT09IFwib2JqZWN0XCIgJiYgISBBcnJheS5pc0FycmF5KGxvZ2ljKVxuICAgICk7XG4gIH07XG5cbiAgLypcbiAgVGhpcyBoZWxwZXIgd2lsbCBkZWZlciB0byB0aGUgSnNvbkxvZ2ljIHNwZWMgYXMgYSB0aWUtYnJlYWtlciB3aGVuIGRpZmZlcmVudCBsYW5ndWFnZSBpbnRlcnByZXRlcnMgZGVmaW5lIGRpZmZlcmVudCBiZWhhdmlvciBmb3IgdGhlIHRydXRoaW5lc3Mgb2YgcHJpbWl0aXZlcy4gIEUuZy4sIFBIUCBjb25zaWRlcnMgZW1wdHkgYXJyYXlzIHRvIGJlIGZhbHN5LCBidXQgSmF2YXNjcmlwdCBjb25zaWRlcnMgdGhlbSB0byBiZSB0cnV0aHkuIEpzb25Mb2dpYywgYXMgYW4gZWNvc3lzdGVtLCBuZWVkcyBvbmUgY29uc2lzdGVudCBhbnN3ZXIuXG5cbiAgTGl0ZXJhbCB8IEpTICAgIHwgIFBIUCAgfCAgSnNvbkxvZ2ljXG4gIC0tLS0tLS0tKy0tLS0tLS0rLS0tLS0tLSstLS0tLS0tLS0tLS0tLS1cbiAgW10gICAgICB8IHRydWUgIHwgZmFsc2UgfCBmYWxzZVxuICBcIjBcIiAgICAgfCB0cnVlICB8IGZhbHNlIHwgdHJ1ZVxuICAqL1xuICBqc29uTG9naWMudHJ1dGh5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZihBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICEhIHZhbHVlO1xuICB9O1xuXG5cbiAganNvbkxvZ2ljLmdldF9vcGVyYXRvciA9IGZ1bmN0aW9uKGxvZ2ljKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGxvZ2ljKVswXTtcbiAgfTtcblxuICBqc29uTG9naWMuZ2V0X3ZhbHVlcyA9IGZ1bmN0aW9uKGxvZ2ljKSB7XG4gICAgcmV0dXJuIGxvZ2ljW2pzb25Mb2dpYy5nZXRfb3BlcmF0b3IobG9naWMpXTtcbiAgfTtcblxuICBqc29uTG9naWMuYXBwbHkgPSBmdW5jdGlvbihsb2dpYywgZGF0YSkge1xuICAgIC8vIERvZXMgdGhpcyBhcnJheSBjb250YWluIGxvZ2ljPyBPbmx5IG9uZSB3YXkgdG8gZmluZCBvdXQuXG4gICAgaWYoQXJyYXkuaXNBcnJheShsb2dpYykpIHtcbiAgICAgIHJldHVybiBsb2dpYy5tYXAoZnVuY3Rpb24obCkge1xuICAgICAgICByZXR1cm4ganNvbkxvZ2ljLmFwcGx5KGwsIGRhdGEpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFlvdSd2ZSByZWN1cnNlZCB0byBhIHByaW1pdGl2ZSwgc3RvcCFcbiAgICBpZiggISBqc29uTG9naWMuaXNfbG9naWMobG9naWMpICkge1xuICAgICAgcmV0dXJuIGxvZ2ljO1xuICAgIH1cblxuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gICAgdmFyIG9wID0ganNvbkxvZ2ljLmdldF9vcGVyYXRvcihsb2dpYyk7XG4gICAgdmFyIHZhbHVlcyA9IGxvZ2ljW29wXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgY3VycmVudDtcblxuICAgIC8vIGVhc3kgc3ludGF4IGZvciB1bmFyeSBvcGVyYXRvcnMsIGxpa2Uge1widmFyXCIgOiBcInhcIn0gaW5zdGVhZCBvZiBzdHJpY3Qge1widmFyXCIgOiBbXCJ4XCJdfVxuICAgIGlmKCAhIEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgdmFsdWVzID0gW3ZhbHVlc107XG4gICAgfVxuXG4gICAgLy8gJ2lmJywgJ2FuZCcsIGFuZCAnb3InIHZpb2xhdGUgdGhlIG5vcm1hbCBydWxlIG9mIGRlcHRoLWZpcnN0IGNhbGN1bGF0aW5nIGNvbnNlcXVlbnRzLCBsZXQgZWFjaCBtYW5hZ2UgcmVjdXJzaW9uIGFzIG5lZWRlZC5cbiAgICBpZihvcCA9PT0gXCJpZlwiIHx8IG9wID09IFwiPzpcIikge1xuICAgICAgLyogJ2lmJyBzaG91bGQgYmUgY2FsbGVkIHdpdGggYSBvZGQgbnVtYmVyIG9mIHBhcmFtZXRlcnMsIDMgb3IgZ3JlYXRlclxuICAgICAgVGhpcyB3b3JrcyBvbiB0aGUgcGF0dGVybjpcbiAgICAgIGlmKCAwICl7IDEgfWVsc2V7IDIgfTtcbiAgICAgIGlmKCAwICl7IDEgfWVsc2UgaWYoIDIgKXsgMyB9ZWxzZXsgNCB9O1xuICAgICAgaWYoIDAgKXsgMSB9ZWxzZSBpZiggMiApeyAzIH1lbHNlIGlmKCA0ICl7IDUgfWVsc2V7IDYgfTtcblxuICAgICAgVGhlIGltcGxlbWVudGF0aW9uIGlzOlxuICAgICAgRm9yIHBhaXJzIG9mIHZhbHVlcyAoMCwxIHRoZW4gMiwzIHRoZW4gNCw1IGV0YylcbiAgICAgIElmIHRoZSBmaXJzdCBldmFsdWF0ZXMgdHJ1dGh5LCBldmFsdWF0ZSBhbmQgcmV0dXJuIHRoZSBzZWNvbmRcbiAgICAgIElmIHRoZSBmaXJzdCBldmFsdWF0ZXMgZmFsc3ksIGp1bXAgdG8gdGhlIG5leHQgcGFpciAoZS5nLCAwLDEgdG8gMiwzKVxuICAgICAgZ2l2ZW4gb25lIHBhcmFtZXRlciwgZXZhbHVhdGUgYW5kIHJldHVybiBpdC4gKGl0J3MgYW4gRWxzZSBhbmQgYWxsIHRoZSBJZi9FbHNlSWYgd2VyZSBmYWxzZSlcbiAgICAgIGdpdmVuIDAgcGFyYW1ldGVycywgcmV0dXJuIE5VTEwgKG5vdCBncmVhdCBwcmFjdGljZSwgYnV0IHRoZXJlIHdhcyBubyBFbHNlKVxuICAgICAgKi9cbiAgICAgIGZvcihpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICAgICAgaWYoIGpzb25Mb2dpYy50cnV0aHkoIGpzb25Mb2dpYy5hcHBseSh2YWx1ZXNbaV0sIGRhdGEpICkgKSB7XG4gICAgICAgICAgcmV0dXJuIGpzb25Mb2dpYy5hcHBseSh2YWx1ZXNbaSsxXSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKHZhbHVlcy5sZW5ndGggPT09IGkrMSkgcmV0dXJuIGpzb25Mb2dpYy5hcHBseSh2YWx1ZXNbaV0sIGRhdGEpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfWVsc2UgaWYob3AgPT09IFwiYW5kXCIpIHsgLy8gUmV0dXJuIGZpcnN0IGZhbHN5LCBvciBsYXN0XG4gICAgICBmb3IoaT0wOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSs9MSkge1xuICAgICAgICBjdXJyZW50ID0ganNvbkxvZ2ljLmFwcGx5KHZhbHVlc1tpXSwgZGF0YSk7XG4gICAgICAgIGlmKCAhIGpzb25Mb2dpYy50cnV0aHkoY3VycmVudCkpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJlbnQ7IC8vIExhc3RcbiAgICB9ZWxzZSBpZihvcCA9PT0gXCJvclwiKSB7Ly8gUmV0dXJuIGZpcnN0IHRydXRoeSwgb3IgbGFzdFxuICAgICAgZm9yKGk9MDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrPTEpIHtcbiAgICAgICAgY3VycmVudCA9IGpzb25Mb2dpYy5hcHBseSh2YWx1ZXNbaV0sIGRhdGEpO1xuICAgICAgICBpZigganNvbkxvZ2ljLnRydXRoeShjdXJyZW50KSApIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJlbnQ7IC8vIExhc3RcbiAgICB9XG5cblxuICAgIC8vIEV2ZXJ5b25lIGVsc2UgZ2V0cyBpbW1lZGlhdGUgZGVwdGgtZmlyc3QgcmVjdXJzaW9uXG4gICAgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiBqc29uTG9naWMuYXBwbHkodmFsLCBkYXRhKTtcbiAgICB9KTtcblxuXG4gICAgLy8gVGhlIG9wZXJhdGlvbiBpcyBjYWxsZWQgd2l0aCBcImRhdGFcIiBib3VuZCB0byBpdHMgXCJ0aGlzXCIgYW5kIFwidmFsdWVzXCIgcGFzc2VkIGFzIGFyZ3VtZW50cy5cbiAgICAvLyBTdHJ1Y3R1cmVkIGNvbW1hbmRzIGxpa2UgJSBvciA+IGNhbiBuYW1lIGZvcm1hbCBhcmd1bWVudHMgd2hpbGUgZmxleGlibGUgY29tbWFuZHMgKGxpa2UgbWlzc2luZyBvciBtZXJnZSkgY2FuIG9wZXJhdGUgb24gdGhlIHBzZXVkby1hcnJheSBhcmd1bWVudHNcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9GdW5jdGlvbnMvYXJndW1lbnRzXG4gICAgaWYodHlwZW9mIG9wZXJhdGlvbnNbb3BdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBvcGVyYXRpb25zW29wXS5hcHBseShkYXRhLCB2YWx1ZXMpO1xuICAgIH1lbHNlIGlmKG9wLmluZGV4T2YoXCIuXCIpID4gMCkgeyAvLyBDb250YWlucyBhIGRvdCwgYW5kIG5vdCBpbiB0aGUgMHRoIHBvc2l0aW9uXG4gICAgICB2YXIgc3ViX29wcyA9IFN0cmluZyhvcCkuc3BsaXQoXCIuXCIpO1xuICAgICAgdmFyIG9wZXJhdGlvbiA9IG9wZXJhdGlvbnM7XG4gICAgICBmb3IoaSA9IDA7IGkgPCBzdWJfb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIERlc2NlbmRpbmcgaW50byBvcGVyYXRpb25zXG4gICAgICAgIG9wZXJhdGlvbiA9IG9wZXJhdGlvbltzdWJfb3BzW2ldXTtcbiAgICAgICAgaWYob3BlcmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgb3BlcmF0aW9uIFwiICsgb3AgK1xuICAgICAgICAgIFwiIChmYWlsZWQgYXQgXCIgKyBzdWJfb3BzLnNsaWNlKDAsIGkrMSkuam9pbihcIi5cIikgKyBcIilcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wZXJhdGlvbi5hcHBseShkYXRhLCB2YWx1ZXMpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBvcGVyYXRpb24gXCIgKyBvcCApO1xuICB9O1xuXG4gIGpzb25Mb2dpYy51c2VzX2RhdGEgPSBmdW5jdGlvbihsb2dpYykge1xuICAgIHZhciBjb2xsZWN0aW9uID0gW107XG5cbiAgICBpZigganNvbkxvZ2ljLmlzX2xvZ2ljKGxvZ2ljKSApIHtcbiAgICAgIHZhciBvcCA9IGpzb25Mb2dpYy5nZXRfb3BlcmF0b3IobG9naWMpO1xuICAgICAgdmFyIHZhbHVlcyA9IGxvZ2ljW29wXTtcblxuICAgICAgaWYoICEgQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgIHZhbHVlcyA9IFt2YWx1ZXNdO1xuICAgICAgfVxuXG4gICAgICBpZihvcCA9PT0gXCJ2YXJcIikge1xuICAgICAgICAvLyBUaGlzIGRvZXNuJ3QgY292ZXIgdGhlIGNhc2Ugd2hlcmUgdGhlIGFyZyB0byB2YXIgaXMgaXRzZWxmIGEgcnVsZS5cbiAgICAgICAgY29sbGVjdGlvbi5wdXNoKHZhbHVlc1swXSk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgLy8gUmVjdXJzaW9uIVxuICAgICAgICB2YWx1ZXMubWFwKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgIGNvbGxlY3Rpb24ucHVzaC5hcHBseShjb2xsZWN0aW9uLCBqc29uTG9naWMudXNlc19kYXRhKHZhbCkgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5VW5pcXVlKGNvbGxlY3Rpb24pO1xuICB9O1xuXG4gIGpzb25Mb2dpYy5hZGRfb3BlcmF0aW9uID0gZnVuY3Rpb24obmFtZSwgY29kZSkge1xuICAgIG9wZXJhdGlvbnNbbmFtZV0gPSBjb2RlO1xuICB9O1xuXG4gIGpzb25Mb2dpYy5ybV9vcGVyYXRpb24gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIG9wZXJhdGlvbnNbbmFtZV07XG4gIH07XG5cbiAganNvbkxvZ2ljLnJ1bGVfbGlrZSA9IGZ1bmN0aW9uKHJ1bGUsIHBhdHRlcm4pIHtcbiAgICAvLyBjb25zb2xlLmxvZyhcIklzIFwiLiBKU09OLnN0cmluZ2lmeShydWxlKSAuIFwiIGxpa2UgXCIgLiBKU09OLnN0cmluZ2lmeShwYXR0ZXJuKSAuIFwiP1wiKTtcbiAgICBpZihwYXR0ZXJuID09PSBydWxlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIFRPRE8gOiBEZWVwIG9iamVjdCBlcXVpdmFsZW5jeT9cbiAgICBpZihwYXR0ZXJuID09PSBcIkBcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBXaWxkY2FyZCFcbiAgICBpZihwYXR0ZXJuID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gKHR5cGVvZiBydWxlID09PSBcIm51bWJlclwiKTtcbiAgICB9XG4gICAgaWYocGF0dGVybiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuICh0eXBlb2YgcnVsZSA9PT0gXCJzdHJpbmdcIik7XG4gICAgfVxuICAgIGlmKHBhdHRlcm4gPT09IFwiYXJyYXlcIikge1xuICAgICAgLy8gIWxvZ2ljIHRlc3QgbWlnaHQgYmUgc3VwZXJmbHVvdXMgaW4gSmF2YVNjcmlwdFxuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocnVsZSkgJiYgISBqc29uTG9naWMuaXNfbG9naWMocnVsZSk7XG4gICAgfVxuXG4gICAgaWYoanNvbkxvZ2ljLmlzX2xvZ2ljKHBhdHRlcm4pKSB7XG4gICAgICBpZihqc29uTG9naWMuaXNfbG9naWMocnVsZSkpIHtcbiAgICAgICAgdmFyIHBhdHRlcm5fb3AgPSBqc29uTG9naWMuZ2V0X29wZXJhdG9yKHBhdHRlcm4pO1xuICAgICAgICB2YXIgcnVsZV9vcCA9IGpzb25Mb2dpYy5nZXRfb3BlcmF0b3IocnVsZSk7XG5cbiAgICAgICAgaWYocGF0dGVybl9vcCA9PT0gXCJAXCIgfHwgcGF0dGVybl9vcCA9PT0gcnVsZV9vcCkge1xuICAgICAgICAvLyBlY2hvIFwiXFxuT3BlcmF0b3JzIG1hdGNoLCBnbyBkZWVwZXJcXG5cIjtcbiAgICAgICAgICByZXR1cm4ganNvbkxvZ2ljLnJ1bGVfbGlrZShcbiAgICAgICAgICAgIGpzb25Mb2dpYy5nZXRfdmFsdWVzKHJ1bGUsIGZhbHNlKSxcbiAgICAgICAgICAgIGpzb25Mb2dpYy5nZXRfdmFsdWVzKHBhdHRlcm4sIGZhbHNlKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTsgLy8gcGF0dGVybiBpcyBsb2dpYywgcnVsZSBpc24ndCwgY2FuJ3QgYmUgZXFcbiAgICB9XG5cbiAgICBpZihBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgICBpZihBcnJheS5pc0FycmF5KHJ1bGUpKSB7XG4gICAgICAgIGlmKHBhdHRlcm4ubGVuZ3RoICE9PSBydWxlLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgIE5vdGUsIGFycmF5IG9yZGVyIE1BVFRFUlMsIGJlY2F1c2Ugd2UncmUgdXNpbmcgdGhpcyBhcnJheSB0ZXN0IGxvZ2ljIHRvIGNvbnNpZGVyIGFyZ3VtZW50cywgd2hlcmUgb3JkZXIgY2FuIG1hdHRlci4gKGUuZy4sICsgaXMgY29tbXV0YXRpdmUsIGJ1dCAnLScgb3IgJ2lmJyBvciAndmFyJyBhcmUgTk9UKVxuICAgICAgICAqL1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIC8vIElmIGFueSBmYWlsLCB3ZSBmYWlsXG4gICAgICAgICAgaWYoICEganNvbkxvZ2ljLnJ1bGVfbGlrZShydWxlW2ldLCBwYXR0ZXJuW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gSWYgdGhleSAqYWxsKiBwYXNzZWQsIHdlIHBhc3NcbiAgICAgIH1lbHNle1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFBhdHRlcm4gaXMgYXJyYXksIHJ1bGUgaXNuJ3RcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOb3QgbG9naWMsIG5vdCBhcnJheSwgbm90IGEgPT09IG1hdGNoIGZvciBydWxlLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICByZXR1cm4ganNvbkxvZ2ljO1xufSkpO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVmlldztcbiIsInZhciBoYXNoQ2xlYXIgPSByZXF1aXJlKCcuL19oYXNoQ2xlYXInKSxcbiAgICBoYXNoRGVsZXRlID0gcmVxdWlyZSgnLi9faGFzaERlbGV0ZScpLFxuICAgIGhhc2hHZXQgPSByZXF1aXJlKCcuL19oYXNoR2V0JyksXG4gICAgaGFzaEhhcyA9IHJlcXVpcmUoJy4vX2hhc2hIYXMnKSxcbiAgICBoYXNoU2V0ID0gcmVxdWlyZSgnLi9faGFzaFNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XG4iLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XG4iLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpLFxuICAgIHNldENhY2hlQWRkID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVBZGQnKSxcbiAgICBzZXRDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX3NldENhY2hlSGFzJyk7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxubW9kdWxlLmV4cG9ydHMgPSBTZXRDYWNoZTtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBzdGFja0NsZWFyID0gcmVxdWlyZSgnLi9fc3RhY2tDbGVhcicpLFxuICAgIHN0YWNrRGVsZXRlID0gcmVxdWlyZSgnLi9fc3RhY2tEZWxldGUnKSxcbiAgICBzdGFja0dldCA9IHJlcXVpcmUoJy4vX3N0YWNrR2V0JyksXG4gICAgc3RhY2tIYXMgPSByZXF1aXJlKCcuL19zdGFja0hhcycpLFxuICAgIHN0YWNrU2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVpbnQ4QXJyYXk7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWFrTWFwO1xuIiwiLyoqXG4gKiBBZGRzIHRoZSBrZXktdmFsdWUgYHBhaXJgIHRvIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gcGFpciBUaGUga2V5LXZhbHVlIHBhaXIgdG8gYWRkLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgbWFwYC5cbiAqL1xuZnVuY3Rpb24gYWRkTWFwRW50cnkobWFwLCBwYWlyKSB7XG4gIC8vIERvbid0IHJldHVybiBgbWFwLnNldGAgYmVjYXVzZSBpdCdzIG5vdCBjaGFpbmFibGUgaW4gSUUgMTEuXG4gIG1hcC5zZXQocGFpclswXSwgcGFpclsxXSk7XG4gIHJldHVybiBtYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRkTWFwRW50cnk7XG4iLCIvKipcbiAqIEFkZHMgYHZhbHVlYCB0byBgc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFkZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYHNldGAuXG4gKi9cbmZ1bmN0aW9uIGFkZFNldEVudHJ5KHNldCwgdmFsdWUpIHtcbiAgLy8gRG9uJ3QgcmV0dXJuIGBzZXQuYWRkYCBiZWNhdXNlIGl0J3Mgbm90IGNoYWluYWJsZSBpbiBJRSAxMS5cbiAgc2V0LmFkZCh2YWx1ZSk7XG4gIHJldHVybiBzZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRkU2V0RW50cnk7XG4iLCIvKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlFYWNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RmlsdGVyO1xuIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheU1hcDtcbiIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVB1c2g7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlSZWR1Y2U7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5U29tZTtcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25NZXJnZVZhbHVlO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblZhbHVlO1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc29jSW5kZXhPZjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ247XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbkluO1xuIiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduVmFsdWU7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGFycmF5RWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5RWFjaCcpLFxuICAgIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbicpLFxuICAgIGJhc2VBc3NpZ25JbiA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25JbicpLFxuICAgIGNsb25lQnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVCdWZmZXInKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBjb3B5U3ltYm9scyA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzJyksXG4gICAgY29weVN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzSW4nKSxcbiAgICBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpLFxuICAgIGdldEFsbEtleXNJbiA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXNJbicpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGluaXRDbG9uZUFycmF5ID0gcmVxdWlyZSgnLi9faW5pdENsb25lQXJyYXknKSxcbiAgICBpbml0Q2xvbmVCeVRhZyA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZUJ5VGFnJyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9faW5pdENsb25lT2JqZWN0JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xudmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbmNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG5jbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbmNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbmNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG5jbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbmNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbmNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIERlZXAgY2xvbmVcbiAqICAyIC0gRmxhdHRlbiBpbmhlcml0ZWQgcHJvcGVydGllc1xuICogIDQgLSBDbG9uZSBzeW1ib2xzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICB2YXIgcmVzdWx0LFxuICAgICAgaXNEZWVwID0gYml0bWFzayAmIENMT05FX0RFRVBfRkxBRyxcbiAgICAgIGlzRmxhdCA9IGJpdG1hc2sgJiBDTE9ORV9GTEFUX0ZMQUcsXG4gICAgICBpc0Z1bGwgPSBiaXRtYXNrICYgQ0xPTkVfU1lNQk9MU19GTEFHO1xuXG4gIGlmIChjdXN0b21pemVyKSB7XG4gICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICB9XG4gIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpc0Fycikge1xuICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG5cbiAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgfVxuICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBpc0ZsYXRcbiAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcbiAgICAgICAgICA6IGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBiYXNlQ2xvbmUsIGlzRGVlcCk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICA6IChpc0ZsYXQgPyBrZXlzSW4gOiBrZXlzKTtcblxuICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ2xvbmU7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNyZWF0ZTtcbiIsIi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZGVsYXlgIGFuZCBgXy5kZWZlcmAgd2hpY2ggYWNjZXB0cyBgYXJnc2BcbiAqIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gKiBAcmV0dXJucyB7bnVtYmVyfE9iamVjdH0gUmV0dXJucyB0aGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VEZWxheShmdW5jLCB3YWl0LCBhcmdzKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0sIHdhaXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VEZWxheTtcbiIsInZhciBiYXNlRm9yT3duID0gcmVxdWlyZSgnLi9fYmFzZUZvck93bicpLFxuICAgIGNyZWF0ZUJhc2VFYWNoID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUVhY2gnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUVhY2g7XG4iLCJ2YXIgY3JlYXRlQmFzZUZvciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUJhc2VGb3InKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3I7XG4iLCJ2YXIgYmFzZUZvciA9IHJlcXVpcmUoJy4vX2Jhc2VGb3InKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yT3duO1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldDtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0QWxsS2V5cztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc2Agd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhcyhvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhcztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VIYXNJbjtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGJhc2VJc0VxdWFsRGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsRGVlcCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgZXF1YWxCeVRhZyA9IHJlcXVpcmUoJy4vX2VxdWFsQnlUYWcnKSxcbiAgICBlcXVhbE9iamVjdHMgPSByZXF1aXJlKCcuL19lcXVhbE9iamVjdHMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWxEZWVwO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc01hdGNoO1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc01hc2tlZCA9IHJlcXVpcmUoJy4vX2lzTWFza2VkJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hdGl2ZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwidmFyIGJhc2VNYXRjaGVzID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXMnKSxcbiAgICBiYXNlTWF0Y2hlc1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXNQcm9wZXJ0eScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBwcm9wZXJ0eSA9IHJlcXVpcmUoJy4vcHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXRlcmF0ZWU7XG4iLCJ2YXIgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXMgPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5cztcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5c0luID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5c0luJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXNJbjtcbiIsInZhciBiYXNlSXNNYXRjaCA9IHJlcXVpcmUoJy4vX2Jhc2VJc01hdGNoJyksXG4gICAgZ2V0TWF0Y2hEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWF0Y2hEYXRhJyksXG4gICAgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlcztcbiIsInZhciBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsJyksXG4gICAgZ2V0ID0gcmVxdWlyZSgnLi9nZXQnKSxcbiAgICBoYXNJbiA9IHJlcXVpcmUoJy4vaGFzSW4nKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9faXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzUHJvcGVydHk7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGFzc2lnbk1lcmdlVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25NZXJnZVZhbHVlJyksXG4gICAgYmFzZUZvciA9IHJlcXVpcmUoJy4vX2Jhc2VGb3InKSxcbiAgICBiYXNlTWVyZ2VEZWVwID0gcmVxdWlyZSgnLi9fYmFzZU1lcmdlRGVlcCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCBrZXlzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZTtcbiIsInZhciBhc3NpZ25NZXJnZVZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduTWVyZ2VWYWx1ZScpLFxuICAgIGNsb25lQnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVCdWZmZXInKSxcbiAgICBjbG9uZVR5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19jbG9uZVR5cGVkQXJyYXknKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlT2JqZWN0JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2lzUGxhaW5PYmplY3QnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpLFxuICAgIHRvUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL3RvUGxhaW5PYmplY3QnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgc3JjVmFsdWUgPSBzb3VyY2Vba2V5XSxcbiAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gIGlmIChzdGFja2VkKSB7XG4gICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICBpZiAoaXNDb21tb24pIHtcbiAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHNyY1ZhbHVlKSxcbiAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcbiAgICAgICAgaXNUeXBlZCA9ICFpc0FyciAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheShzcmNWYWx1ZSk7XG5cbiAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IHRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCAoc3JjSW5kZXggJiYgaXNGdW5jdGlvbihvYmpWYWx1ZSkpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNDb21tb24pIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gIH1cbiAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZURlZXA7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eTtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHlEZWVwO1xuIiwidmFyIGJhc2VVbnNldCA9IHJlcXVpcmUoJy4vX2Jhc2VVbnNldCcpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wdWxsQXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICogaW5kZXhlcyBvciBjYXB0dXJpbmcgdGhlIHJlbW92ZWQgZWxlbWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge251bWJlcltdfSBpbmRleGVzIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA/IGluZGV4ZXMubGVuZ3RoIDogMCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgIGlmIChsZW5ndGggPT0gbGFzdEluZGV4IHx8IGluZGV4ICE9PSBwcmV2aW91cykge1xuICAgICAgdmFyIHByZXZpb3VzID0gaW5kZXg7XG4gICAgICBpZiAoaXNJbmRleChpbmRleCkpIHtcbiAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGluZGV4LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VVbnNldChhcnJheSwgaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVB1bGxBdDtcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcbiIsInZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQnKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2xpY2U7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGxhc3QgPSByZXF1aXJlKCcuL2xhc3QnKSxcbiAgICBwYXJlbnQgPSByZXF1aXJlKCcuL19wYXJlbnQnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5zZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHByb3BlcnR5IHBhdGggdG8gdW5zZXQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuc2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBkZWxldGUgb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5zZXQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYWNoZUhhcztcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGBpZGVudGl0eWAgaWYgaXQncyBub3QgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0RnVuY3Rpb247XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBzdHJpbmdUb1BhdGggPSByZXF1aXJlKCcuL19zdHJpbmdUb1BhdGgnKSxcbiAgICB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0UGF0aDtcbiIsInZhciBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVBcnJheUJ1ZmZlcjtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQnVmZmVyO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVEYXRhVmlldztcbiIsInZhciBhZGRNYXBFbnRyeSA9IHJlcXVpcmUoJy4vX2FkZE1hcEVudHJ5JyksXG4gICAgYXJyYXlSZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheVJlZHVjZScpLFxuICAgIG1hcFRvQXJyYXkgPSByZXF1aXJlKCcuL19tYXBUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBtYXAuXG4gKi9cbmZ1bmN0aW9uIGNsb25lTWFwKG1hcCwgaXNEZWVwLCBjbG9uZUZ1bmMpIHtcbiAgdmFyIGFycmF5ID0gaXNEZWVwID8gY2xvbmVGdW5jKG1hcFRvQXJyYXkobWFwKSwgQ0xPTkVfREVFUF9GTEFHKSA6IG1hcFRvQXJyYXkobWFwKTtcbiAgcmV0dXJuIGFycmF5UmVkdWNlKGFycmF5LCBhZGRNYXBFbnRyeSwgbmV3IG1hcC5jb25zdHJ1Y3Rvcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVNYXA7XG4iLCIvKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUZsYWdzID0gL1xcdyokLztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lUmVnRXhwO1xuIiwidmFyIGFkZFNldEVudHJ5ID0gcmVxdWlyZSgnLi9fYWRkU2V0RW50cnknKSxcbiAgICBhcnJheVJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5UmVkdWNlJyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNsb25lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvbmVGdW5jIFRoZSBmdW5jdGlvbiB0byBjbG9uZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHNldC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVTZXQoc2V0LCBpc0RlZXAsIGNsb25lRnVuYykge1xuICB2YXIgYXJyYXkgPSBpc0RlZXAgPyBjbG9uZUZ1bmMoc2V0VG9BcnJheShzZXQpLCBDTE9ORV9ERUVQX0ZMQUcpIDogc2V0VG9BcnJheShzZXQpO1xuICByZXR1cm4gYXJyYXlSZWR1Y2UoYXJyYXksIGFkZFNldEVudHJ5LCBuZXcgc2V0LmNvbnN0cnVjdG9yKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVNldDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc3ltYm9sIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gIHJldHVybiBzeW1ib2xWYWx1ZU9mID8gT2JqZWN0KHN5bWJvbFZhbHVlT2YuY2FsbChzeW1ib2wpKSA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lU3ltYm9sO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weUFycmF5O1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKTtcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weU9iamVjdDtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyk7XG5cbi8qKlxuICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9scztcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGdldFN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHNJbicpO1xuXG4vKipcbiAqIENvcGllcyBvd24gYW5kIGluaGVyaXRlZCBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9sc0luKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9sc0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHNJbjtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG4iLCJ2YXIgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBc3NpZ25lcjtcbiIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRWFjaDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VGb3I7XG4iLCJ2YXIgYmFzZU1lcmdlID0gcmVxdWlyZSgnLi9fYmFzZU1lcmdlJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogVXNlZCBieSBgXy5kZWZhdWx0c0RlZXBgIHRvIGN1c3RvbWl6ZSBpdHMgYF8ubWVyZ2VgIHVzZSB0byBtZXJnZSBzb3VyY2VcbiAqIG9iamVjdHMgaW50byBkZXN0aW5hdGlvbiBvYmplY3RzIHRoYXQgYXJlIHBhc3NlZCB0aHJ1LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gbWVyZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBzcmNWYWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykge1xuICBpZiAoaXNPYmplY3Qob2JqVmFsdWUpICYmIGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgb2JqVmFsdWUpO1xuICAgIGJhc2VNZXJnZShvYmpWYWx1ZSwgc3JjVmFsdWUsIHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSwgc3RhY2spO1xuICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIG9ialZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGN1c3RvbURlZmF1bHRzTWVyZ2U7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheVNvbWUgPSByZXF1aXJlKCcuL19hcnJheVNvbWUnKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxBcnJheXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgbWFwVG9BcnJheSA9IHJlcXVpcmUoJy4vX21hcFRvQXJyYXknKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQnlUYWc7XG4iLCJ2YXIgZ2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxPYmplY3RzO1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXNJbjtcbiIsInZhciBpc0tleWFibGUgPSByZXF1aXJlKCcuL19pc0tleWFibGUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG4iLCJ2YXIgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9faXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXRjaERhdGE7XG4iLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzO1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAob2JqZWN0KSB7XG4gICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzSW47XG4iLCJ2YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuL19EYXRhVmlldycpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL19Qcm9taXNlJyksXG4gICAgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgV2Vha01hcCA9IHJlcXVpcmUoJy4vX1dlYWtNYXAnKSxcbiAgICBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUYWc7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNQYXRoO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVBcnJheTtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpLFxuICAgIGNsb25lRGF0YVZpZXcgPSByZXF1aXJlKCcuL19jbG9uZURhdGFWaWV3JyksXG4gICAgY2xvbmVNYXAgPSByZXF1aXJlKCcuL19jbG9uZU1hcCcpLFxuICAgIGNsb25lUmVnRXhwID0gcmVxdWlyZSgnLi9fY2xvbmVSZWdFeHAnKSxcbiAgICBjbG9uZVNldCA9IHJlcXVpcmUoJy4vX2Nsb25lU2V0JyksXG4gICAgY2xvbmVTeW1ib2wgPSByZXF1aXJlKCcuL19jbG9uZVN5bWJvbCcpLFxuICAgIGNsb25lVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Nsb25lVHlwZWRBcnJheScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGNsb25lRnVuYywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVNYXAob2JqZWN0LCBpc0RlZXAsIGNsb25lRnVuYyk7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIGNsb25lU2V0KG9iamVjdCwgaXNEZWVwLCBjbG9uZUZ1bmMpO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUJ5VGFnO1xuIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lT2JqZWN0O1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiZcbiAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJdGVyYXRlZUNhbGw7XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXk7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXlhYmxlO1xuIiwidmFyIGNvcmVKc0RhdGEgPSByZXF1aXJlKCcuL19jb3JlSnNEYXRhJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXNrZWQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm90b3R5cGU7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmljdENvbXBhcmFibGU7XG4iLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlQ2xlYXI7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG4iLCJ2YXIgSGFzaCA9IHJlcXVpcmUoJy4vX0hhc2gnKSxcbiAgICBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVEZWxldGU7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlR2V0O1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVIYXM7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlU2V0O1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBUb0FycmF5O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlO1xuIiwidmFyIG1lbW9pemUgPSByZXF1aXJlKCcuL21lbW9pemUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemVDYXBwZWQ7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ3JlYXRlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5c0luO1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlclJlc3Q7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKSxcbiAgICBiYXNlU2xpY2UgPSByZXF1aXJlKCcuL19iYXNlU2xpY2UnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwYXJlbnQgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIGdldCB0aGUgcGFyZW50IHZhbHVlIG9mLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBhcmVudCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gcGFyZW50KG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gcGF0aC5sZW5ndGggPCAyID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsIi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlQWRkO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlSGFzO1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb0FycmF5O1xuIiwidmFyIGJhc2VTZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VTZXRUb1N0cmluZycpLFxuICAgIHNob3J0T3V0ID0gcmVxdWlyZSgnLi9fc2hvcnRPdXQnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb1N0cmluZztcbiIsIi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG9ydE91dDtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0NsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrRGVsZXRlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrU2V0O1xuIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUxlYWRpbmdEb3QgPSAvXlxcLi8sXG4gICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHJlTGVhZGluZ0RvdC50ZXN0KHN0cmluZykpIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQXNzaWduZXInKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAqIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YCBhbmQgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BPYmplY3QuYXNzaWduYF0oaHR0cHM6Ly9tZG4uaW8vT2JqZWN0L2Fzc2lnbikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEwLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5hc3NpZ25JblxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogZnVuY3Rpb24gQmFyKCkge1xuICogICB0aGlzLmMgPSAzO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYiA9IDI7XG4gKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAwIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gKi9cbnZhciBhc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICBpZiAoaXNQcm90b3R5cGUoc291cmNlKSB8fCBpc0FycmF5TGlrZShzb3VyY2UpKSB7XG4gICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbjtcbiIsInZhciBiYXNlQ2xvbmUgPSByZXF1aXJlKCcuL19iYXNlQ2xvbmUnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGB2YWx1ZWAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHBzOi8vbWRuLmlvL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtKVxuICogYW5kIHN1cHBvcnRzIGNsb25pbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucywgZGF0ZSBvYmplY3RzLCBtYXBzLFxuICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkXG4gKiBhcnJheXMuIFRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYXJlIGNsb25lZFxuICogYXMgcGxhaW4gb2JqZWN0cy4gQW4gZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaFxuICogYXMgZXJyb3Igb2JqZWN0cywgZnVuY3Rpb25zLCBET00gbm9kZXMsIGFuZCBXZWFrTWFwcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lRGVlcFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAqXG4gKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhzaGFsbG93WzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZTtcbiIsInZhciBiYXNlQ2xvbmUgPSByZXF1aXJlKCcuL19iYXNlQ2xvbmUnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICpcbiAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhkZWVwWzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGVlcDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIG5vdyA9IHJlcXVpcmUoJy4vbm93JyksXG4gICAgdG9OdW1iZXIgPSByZXF1aXJlKCcuL3RvTnVtYmVyJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gKiBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxuICogfSkpO1xuICpcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxhc3RBcmdzLFxuICAgICAgbGFzdFRoaXMsXG4gICAgICBtYXhXYWl0LFxuICAgICAgcmVzdWx0LFxuICAgICAgdGltZXJJZCxcbiAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICByZXN1bHQgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICByZXR1cm4gbWF4aW5nID8gbmF0aXZlTWluKHJlc3VsdCwgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgfVxuICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICB9XG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICB9XG4gICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG4iLCJ2YXIgYXBwbHkgPSByZXF1aXJlKCcuL19hcHBseScpLFxuICAgIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBjdXN0b21EZWZhdWx0c01lcmdlID0gcmVxdWlyZSgnLi9fY3VzdG9tRGVmYXVsdHNNZXJnZScpLFxuICAgIG1lcmdlV2l0aCA9IHJlcXVpcmUoJy4vbWVyZ2VXaXRoJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kZWZhdWx0c2AgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgYXNzaWduc1xuICogZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4xMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uZGVmYXVsdHNcbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZhdWx0c0RlZXAoeyAnYSc6IHsgJ2InOiAyIH0gfSwgeyAnYSc6IHsgJ2InOiAxLCAnYyc6IDMgfSB9KTtcbiAqIC8vID0+IHsgJ2EnOiB7ICdiJzogMiwgJ2MnOiAzIH0gfVxuICovXG52YXIgZGVmYXVsdHNEZWVwID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICBhcmdzLnB1c2godW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c01lcmdlKTtcbiAgcmV0dXJuIGFwcGx5KG1lcmdlV2l0aCwgdW5kZWZpbmVkLCBhcmdzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzRGVlcDtcbiIsInZhciBiYXNlRGVsYXkgPSByZXF1aXJlKCcuL19iYXNlRGVsYXknKSxcbiAgICBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgdG9OdW1iZXIgPSByZXF1aXJlKCcuL3RvTnVtYmVyJyk7XG5cbi8qKlxuICogSW52b2tlcyBgZnVuY2AgYWZ0ZXIgYHdhaXRgIG1pbGxpc2Vjb25kcy4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZVxuICogcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWxheShmdW5jdGlvbih0ZXh0KSB7XG4gKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICogfSwgMTAwMCwgJ2xhdGVyJyk7XG4gKiAvLyA9PiBMb2dzICdsYXRlcicgYWZ0ZXIgb25lIHNlY29uZC5cbiAqL1xudmFyIGRlbGF5ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgd2FpdCwgYXJncykge1xuICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIHRvTnVtYmVyKHdhaXQpIHx8IDAsIGFyZ3MpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVsYXk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZm9yRWFjaCcpO1xuIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG4iLCJ2YXIgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpLFxuICAgIGNhc3RGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2Nhc3RGdW5jdGlvbicpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiXG4gKiBwcm9wZXJ0eSBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgdXNlIGBfLmZvckluYFxuICogb3IgYF8uZm9yT3duYCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAYWxpYXMgZWFjaFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKiBAc2VlIF8uZm9yRWFjaFJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZm9yRWFjaChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyBgMWAgdGhlbiBgMmAuXG4gKlxuICogXy5mb3JFYWNoKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICogICBjb25zb2xlLmxvZyhrZXkpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2ggOiBiYXNlRWFjaDtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgY2FzdEZ1bmN0aW9uKGl0ZXJhdGVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaDtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0O1xuIiwidmFyIGJhc2VIYXMgPSByZXF1aXJlKCcuL19iYXNlSGFzJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiB7ICdiJzogMiB9IH07XG4gKiB2YXIgb3RoZXIgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXMob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXMob3RoZXIsICdhJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXMob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzO1xuIiwidmFyIGJhc2VIYXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VIYXNJbicpLFxuICAgIGhhc1BhdGggPSByZXF1aXJlKCcuL19oYXNQYXRoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNJbjtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG4iLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG4iLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuIiwidmFyIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBlbXB0eSBvYmplY3QsIGNvbGxlY3Rpb24sIG1hcCwgb3Igc2V0LlxuICpcbiAqIE9iamVjdHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIG5vIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZFxuICogcHJvcGVydGllcy5cbiAqXG4gKiBBcnJheS1saWtlIHZhbHVlcyBzdWNoIGFzIGBhcmd1bWVudHNgIG9iamVjdHMsIGFycmF5cywgYnVmZmVycywgc3RyaW5ncywgb3JcbiAqIGpRdWVyeS1saWtlIGNvbGxlY3Rpb25zIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBsZW5ndGhgIG9mIGAwYC5cbiAqIFNpbWlsYXJseSwgbWFwcyBhbmQgc2V0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgc2l6ZWAgb2YgYDBgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNFbXB0eShudWxsKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkodHJ1ZSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KDEpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzRW1wdHkoeyAnYSc6IDEgfSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuICAgICAgKGlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUuc3BsaWNlID09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgaXNCdWZmZXIodmFsdWUpIHx8IGlzVHlwZWRBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICB9XG4gIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpO1xuICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgcmV0dXJuICF2YWx1ZS5zaXplO1xuICB9XG4gIGlmIChpc1Byb3RvdHlwZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFbXB0eTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3ltYm9sO1xuIiwidmFyIGJhc2VJc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19iYXNlSXNUeXBlZEFycmF5JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5c0luID0gcmVxdWlyZSgnLi9fYmFzZUtleXNJbicpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzSW47XG4iLCIvKipcbiAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmxhc3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gbGFzdChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsYXN0O1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemU7XG4iLCJ2YXIgYmFzZU1lcmdlID0gcmVxdWlyZSgnLi9fYmFzZU1lcmdlJyksXG4gICAgY3JlYXRlQXNzaWduZXIgPSByZXF1aXJlKCcuL19jcmVhdGVBc3NpZ25lcicpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBtZXJnZXMgb3duIGFuZFxuICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICogc2tpcHBlZCBpZiBhIGRlc3RpbmF0aW9uIHZhbHVlIGV4aXN0cy4gQXJyYXkgYW5kIHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzXG4gKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gKiBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC41LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHtcbiAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAqIH07XG4gKlxuICogdmFyIG90aGVyID0ge1xuICogICAnYSc6IFt7ICdjJzogMyB9LCB7ICdlJzogNSB9XVxuICogfTtcbiAqXG4gKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICovXG52YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZTtcbiIsInZhciBiYXNlTWVyZ2UgPSByZXF1aXJlKCcuL19iYXNlTWVyZ2UnKSxcbiAgICBjcmVhdGVBc3NpZ25lciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUFzc2lnbmVyJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tZXJnZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAqIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgbWVyZ2VkIHZhbHVlcyBvZiB0aGUgZGVzdGluYXRpb24gYW5kIHNvdXJjZVxuICogcHJvcGVydGllcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIG1lcmdpbmcgaXMgaGFuZGxlZCBieSB0aGVcbiAqIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCBzaXggYXJndW1lbnRzOlxuICogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICogICBpZiAoXy5pc0FycmF5KG9ialZhbHVlKSkge1xuICogICAgIHJldHVybiBvYmpWYWx1ZS5jb25jYXQoc3JjVmFsdWUpO1xuICogICB9XG4gKiB9XG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbMV0sICdiJzogWzJdIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogWzNdLCAnYic6IFs0XSB9O1xuICpcbiAqIF8ubWVyZ2VXaXRoKG9iamVjdCwgb3RoZXIsIGN1c3RvbWl6ZXIpO1xuICogLy8gPT4geyAnYSc6IFsxLCAzXSwgJ2InOiBbMiwgNF0gfVxuICovXG52YXIgbWVyZ2VXaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2VXaXRoO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbm93O1xuIiwidmFyIGJhc2VQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eScpLFxuICAgIGJhc2VQcm9wZXJ0eURlZXAgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHlEZWVwJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb3BlcnR5O1xuIiwidmFyIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VQdWxsQXQgPSByZXF1aXJlKCcuL19iYXNlUHVsbEF0Jyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSBgYXJyYXlgIHRoYXQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yXG4gKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVtb3ZlZCBlbGVtZW50cy4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkXG4gKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICpcbiAqICoqTm90ZToqKiBVbmxpa2UgYF8uZmlsdGVyYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLiBVc2UgYF8ucHVsbGBcbiAqIHRvIHB1bGwgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBieSB2YWx1ZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgNF07XG4gKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obikge1xuICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAqIH0pO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAqIC8vID0+IFsxLCAzXVxuICpcbiAqIGNvbnNvbGUubG9nKGV2ZW5zKTtcbiAqIC8vID0+IFsyLCA0XVxuICovXG5mdW5jdGlvbiByZW1vdmUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgaW5kZXhlcyA9IFtdLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSA9IGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICBpbmRleGVzLnB1c2goaW5kZXgpO1xuICAgIH1cbiAgfVxuICBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZW1vdmU7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJBcnJheTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlcjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xuICoga2V5ZWQgcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICovXG5mdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1BsYWluT2JqZWN0O1xuIiwidmFyIGJhc2VUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VUb1N0cmluZycpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9TdHJpbmc7XG4iLCIvLyEgbW9tZW50LmpzXG4vLyEgdmVyc2lvbiA6IDIuMTguMVxuLy8hIGF1dGhvcnMgOiBUaW0gV29vZCwgSXNrcmVuIENoZXJuZXYsIE1vbWVudC5qcyBjb250cmlidXRvcnNcbi8vISBsaWNlbnNlIDogTUlUXG4vLyEgbW9tZW50anMuY29tXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgaG9va0NhbGxiYWNrO1xuXG5mdW5jdGlvbiBob29rcyAoKSB7XG4gICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG4vLyBUaGlzIGlzIGRvbmUgdG8gcmVnaXN0ZXIgdGhlIG1ldGhvZCBjYWxsZWQgd2l0aCBtb21lbnQoKVxuLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG5mdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2sgKGNhbGxiYWNrKSB7XG4gICAgaG9va0NhbGxiYWNrID0gY2FsbGJhY2s7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBBcnJheSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgIC8vIElFOCB3aWxsIHRyZWF0IHVuZGVmaW5lZCBhbmQgbnVsbCBhcyBvYmplY3QgaWYgaXQgd2Fzbid0IGZvclxuICAgIC8vIGlucHV0ICE9IG51bGxcbiAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcbiAgICB2YXIgaztcbiAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgIC8vIGV2ZW4gaWYgaXRzIG5vdCBvd24gcHJvcGVydHkgSSdkIHN0aWxsIGNhbGwgaXQgbm9uLWVtcHR5XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGlucHV0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG59XG5cbmZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIERhdGUgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG5mdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgIHZhciByZXMgPSBbXSwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJlcy5wdXNoKGZuKGFycltpXSwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBoYXNPd25Qcm9wKGEsIGIpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xufVxuXG5mdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCBpKSkge1xuICAgICAgICAgICAgYVtpXSA9IGJbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xuICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICB9XG5cbiAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XG4gICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCB0cnVlKS51dGMoKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW1wdHkgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIHVudXNlZFRva2VucyAgICA6IFtdLFxuICAgICAgICB1bnVzZWRJbnB1dCAgICAgOiBbXSxcbiAgICAgICAgb3ZlcmZsb3cgICAgICAgIDogLTIsXG4gICAgICAgIGNoYXJzTGVmdE92ZXIgICA6IDAsXG4gICAgICAgIG51bGxJbnB1dCAgICAgICA6IGZhbHNlLFxuICAgICAgICBpbnZhbGlkTW9udGggICAgOiBudWxsLFxuICAgICAgICBpbnZhbGlkRm9ybWF0ICAgOiBmYWxzZSxcbiAgICAgICAgdXNlckludmFsaWRhdGVkIDogZmFsc2UsXG4gICAgICAgIGlzbyAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICBwYXJzZWREYXRlUGFydHMgOiBbXSxcbiAgICAgICAgbWVyaWRpZW0gICAgICAgIDogbnVsbCxcbiAgICAgICAgcmZjMjgyMiAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIHdlZWtkYXlNaXNtYXRjaCA6IGZhbHNlXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xuICAgICAgICBtLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcbiAgICB9XG4gICAgcmV0dXJuIG0uX3BmO1xufVxuXG52YXIgc29tZTtcbmlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgIHNvbWUgPSBBcnJheS5wcm90b3R5cGUuc29tZTtcbn0gZWxzZSB7XG4gICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XG4gICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiB0ICYmIGZ1bi5jYWxsKHRoaXMsIHRbaV0sIGksIHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cblxudmFyIHNvbWUkMSA9IHNvbWU7XG5cbmZ1bmN0aW9uIGlzVmFsaWQobSkge1xuICAgIGlmIChtLl9pc1ZhbGlkID09IG51bGwpIHtcbiAgICAgICAgdmFyIGZsYWdzID0gZ2V0UGFyc2luZ0ZsYWdzKG0pO1xuICAgICAgICB2YXIgcGFyc2VkUGFydHMgPSBzb21lJDEuY2FsbChmbGFncy5wYXJzZWREYXRlUGFydHMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGlzTm93VmFsaWQgPSAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICFmbGFncy5lbXB0eSAmJlxuICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgIWZsYWdzLnVzZXJJbnZhbGlkYXRlZCAmJlxuICAgICAgICAgICAgKCFmbGFncy5tZXJpZGllbSB8fCAoZmxhZ3MubWVyaWRpZW0gJiYgcGFyc2VkUGFydHMpKTtcblxuICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICBpc05vd1ZhbGlkID0gaXNOb3dWYWxpZCAmJlxuICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbiA9PSBudWxsIHx8ICFPYmplY3QuaXNGcm96ZW4obSkpIHtcbiAgICAgICAgICAgIG0uX2lzVmFsaWQgPSBpc05vd1ZhbGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTm93VmFsaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG0uX2lzVmFsaWQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWQgKGZsYWdzKSB7XG4gICAgdmFyIG0gPSBjcmVhdGVVVEMoTmFOKTtcbiAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICBleHRlbmQoZ2V0UGFyc2luZ0ZsYWdzKG0pLCBmbGFncyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbTtcbn1cblxuLy8gUGx1Z2lucyB0aGF0IGFkZCBwcm9wZXJ0aWVzIHNob3VsZCBhbHNvIGFkZCB0aGUga2V5IGhlcmUgKG51bGwgdmFsdWUpLFxuLy8gc28gd2UgY2FuIHByb3Blcmx5IGNsb25lIG91cnNlbHZlcy5cbnZhciBtb21lbnRQcm9wZXJ0aWVzID0gaG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdO1xuXG5mdW5jdGlvbiBjb3B5Q29uZmlnKHRvLCBmcm9tKSB7XG4gICAgdmFyIGksIHByb3AsIHZhbDtcblxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgIHRvLl9pID0gZnJvbS5faTtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICB0by5fZiA9IGZyb20uX2Y7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcbiAgICB9XG5cbiAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwcm9wID0gbW9tZW50UHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgICAgICAgICB0b1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0bztcbn1cblxudmFyIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbmZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICBjb3B5Q29uZmlnKHRoaXMsIGNvbmZpZyk7XG4gICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICB9XG4gICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgIC8vIG9iamVjdHMuXG4gICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgTW9tZW50IHx8IChvYmogIT0gbnVsbCAmJiBvYmouX2lzQU1vbWVudE9iamVjdCAhPSBudWxsKTtcbn1cblxuZnVuY3Rpb24gYWJzRmxvb3IgKG51bWJlcikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgIC8vIC0wIC0+IDBcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpIHx8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICB2YXIgY29lcmNlZE51bWJlciA9ICthcmd1bWVudEZvckNvZXJjaW9uLFxuICAgICAgICB2YWx1ZSA9IDA7XG5cbiAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICB2YWx1ZSA9IGFic0Zsb29yKGNvZXJjZWROdW1iZXIpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gY29tcGFyZSB0d28gYXJyYXlzLCByZXR1cm4gdGhlIG51bWJlciBvZiBkaWZmZXJlbmNlc1xuZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgIGxlbmd0aERpZmYgPSBNYXRoLmFicyhhcnJheTEubGVuZ3RoIC0gYXJyYXkyLmxlbmd0aCksXG4gICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSkpIHtcbiAgICAgICAgICAgIGRpZmZzKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZmZzICsgbGVuZ3RoRGlmZjtcbn1cblxuZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICBpZiAoaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgKHR5cGVvZiBjb25zb2xlICE9PSAgJ3VuZGVmaW5lZCcpICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcblxuICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihudWxsLCBtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICB2YXIgYXJnO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcmcgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnICs9ICdcXG5bJyArIGkgKyAnXSAnO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgKz0ga2V5ICsgJzogJyArIGFyZ3VtZW50c1swXVtrZXldICsgJywgJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMCwgLTIpOyAvLyBSZW1vdmUgdHJhaWxpbmcgY29tbWEgYW5kIHNwYWNlXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdhcm4obXNnICsgJ1xcbkFyZ3VtZW50czogJyArIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpLmpvaW4oJycpICsgJ1xcbicgKyAobmV3IEVycm9yKCkpLnN0YWNrKTtcbiAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sIGZuKTtcbn1cblxudmFyIGRlcHJlY2F0aW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihuYW1lLCBtc2cpO1xuICAgIH1cbiAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xuICAgICAgICB3YXJuKG1zZyk7XG4gICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgfVxufVxuXG5ob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcbmhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciA9IG51bGw7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG5mdW5jdGlvbiBzZXQgKGNvbmZpZykge1xuICAgIHZhciBwcm9wLCBpO1xuICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgcHJvcCA9IGNvbmZpZ1tpXTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvcCkpIHtcbiAgICAgICAgICAgIHRoaXNbaV0gPSBwcm9wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgIC8vIExlbmllbnQgb3JkaW5hbCBwYXJzaW5nIGFjY2VwdHMganVzdCBhIG51bWJlciBpbiBhZGRpdGlvbiB0b1xuICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX2RheU9mTW9udGhPcmRpbmFsUGFyc2UuXG4gICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgIHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgKHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2Uuc291cmNlIHx8IHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UpICtcbiAgICAgICAgICAgICd8JyArICgvXFxkezEsMn0vKS5zb3VyY2UpO1xufVxuXG5mdW5jdGlvbiBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjaGlsZENvbmZpZykge1xuICAgIHZhciByZXMgPSBleHRlbmQoe30sIHBhcmVudENvbmZpZyksIHByb3A7XG4gICAgZm9yIChwcm9wIGluIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSkge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkgJiYgaXNPYmplY3QoY2hpbGRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0ge307XG4gICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgcGFyZW50Q29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBjaGlsZENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQ29uZmlnW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBjaGlsZENvbmZpZ1twcm9wXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlc1twcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHByb3AgaW4gcGFyZW50Q29uZmlnKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wKHBhcmVudENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICBpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgY2hhbmdlcyB0byBwcm9wZXJ0aWVzIGRvbid0IG1vZGlmeSBwYXJlbnQgY29uZmlnXG4gICAgICAgICAgICByZXNbcHJvcF0gPSBleHRlbmQoe30sIHJlc1twcm9wXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gTG9jYWxlKGNvbmZpZykge1xuICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnNldChjb25maWcpO1xuICAgIH1cbn1cblxudmFyIGtleXM7XG5cbmlmIChPYmplY3Qua2V5cykge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cztcbn0gZWxzZSB7XG4gICAga2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIGksIHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChvYmosIGkpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xufVxuXG52YXIga2V5cyQxID0ga2V5cztcblxudmFyIGRlZmF1bHRDYWxlbmRhciA9IHtcbiAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgbmV4dFdlZWsgOiAnZGRkZCBbYXRdIExUJyxcbiAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICBzYW1lRWxzZSA6ICdMJ1xufTtcblxuZnVuY3Rpb24gY2FsZW5kYXIgKGtleSwgbW9tLCBub3cpIHtcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XSB8fCB0aGlzLl9jYWxlbmRhclsnc2FtZUVsc2UnXTtcbiAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xufVxuXG52YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgIExUUyAgOiAnaDptbTpzcyBBJyxcbiAgICBMVCAgIDogJ2g6bW0gQScsXG4gICAgTCAgICA6ICdNTS9ERC9ZWVlZJyxcbiAgICBMTCAgIDogJ01NTU0gRCwgWVlZWScsXG4gICAgTExMICA6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnXG59O1xuXG5mdW5jdGlvbiBsb25nRGF0ZUZvcm1hdCAoa2V5KSB7XG4gICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgIGZvcm1hdFVwcGVyID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldO1xuXG4gICAgaWYgKGZvcm1hdCB8fCAhZm9ybWF0VXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gZm9ybWF0VXBwZXIucmVwbGFjZSgvTU1NTXxNTXxERHxkZGRkL2csIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldO1xufVxuXG52YXIgZGVmYXVsdEludmFsaWREYXRlID0gJ0ludmFsaWQgZGF0ZSc7XG5cbmZ1bmN0aW9uIGludmFsaWREYXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG59XG5cbnZhciBkZWZhdWx0T3JkaW5hbCA9ICclZCc7XG52YXIgZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UgPSAvXFxkezEsMn0vO1xuXG5mdW5jdGlvbiBvcmRpbmFsIChudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JkaW5hbC5yZXBsYWNlKCclZCcsIG51bWJlcik7XG59XG5cbnZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgIGZ1dHVyZSA6ICdpbiAlcycsXG4gICAgcGFzdCAgIDogJyVzIGFnbycsXG4gICAgcyAgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgc3MgOiAnJWQgc2Vjb25kcycsXG4gICAgbSAgOiAnYSBtaW51dGUnLFxuICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgIGggIDogJ2FuIGhvdXInLFxuICAgIGhoIDogJyVkIGhvdXJzJyxcbiAgICBkICA6ICdhIGRheScsXG4gICAgZGQgOiAnJWQgZGF5cycsXG4gICAgTSAgOiAnYSBtb250aCcsXG4gICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICB5ICA6ICdhIHllYXInLFxuICAgIHl5IDogJyVkIHllYXJzJ1xufTtcblxuZnVuY3Rpb24gcmVsYXRpdmVUaW1lIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW3N0cmluZ107XG4gICAgcmV0dXJuIChpc0Z1bmN0aW9uKG91dHB1dCkpID9cbiAgICAgICAgb3V0cHV0KG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkgOlxuICAgICAgICBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbn1cblxuZnVuY3Rpb24gcGFzdEZ1dHVyZSAoZGlmZiwgb3V0cHV0KSB7XG4gICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcbiAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbn1cblxudmFyIGFsaWFzZXMgPSB7fTtcblxuZnVuY3Rpb24gYWRkVW5pdEFsaWFzICh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICB2YXIgbG93ZXJDYXNlID0gdW5pdC50b0xvd2VyQ2FzZSgpO1xuICAgIGFsaWFzZXNbbG93ZXJDYXNlXSA9IGFsaWFzZXNbbG93ZXJDYXNlICsgJ3MnXSA9IGFsaWFzZXNbc2hvcnRoYW5kXSA9IHVuaXQ7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZycgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVPYmplY3RVbml0cyhpbnB1dE9iamVjdCkge1xuICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgIHByb3A7XG5cbiAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkUHJvcCA9IG5vcm1hbGl6ZVVuaXRzKHByb3ApO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRJbnB1dDtcbn1cblxudmFyIHByaW9yaXRpZXMgPSB7fTtcblxuZnVuY3Rpb24gYWRkVW5pdFByaW9yaXR5KHVuaXQsIHByaW9yaXR5KSB7XG4gICAgcHJpb3JpdGllc1t1bml0XSA9IHByaW9yaXR5O1xufVxuXG5mdW5jdGlvbiBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzT2JqKSB7XG4gICAgdmFyIHVuaXRzID0gW107XG4gICAgZm9yICh2YXIgdSBpbiB1bml0c09iaikge1xuICAgICAgICB1bml0cy5wdXNoKHt1bml0OiB1LCBwcmlvcml0eTogcHJpb3JpdGllc1t1XX0pO1xuICAgIH1cbiAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eTtcbiAgICB9KTtcbiAgICByZXR1cm4gdW5pdHM7XG59XG5cbmZ1bmN0aW9uIG1ha2VHZXRTZXQgKHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0JDEodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCB1bml0KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldCAobW9tLCB1bml0KSB7XG4gICAgcmV0dXJuIG1vbS5pc1ZhbGlkKCkgP1xuICAgICAgICBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKSA6IE5hTjtcbn1cblxuZnVuY3Rpb24gc2V0JDEgKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICBpZiAobW9tLmlzVmFsaWQoKSkge1xuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgIH1cbn1cblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBzdHJpbmdHZXQgKHVuaXRzKSB7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxuXG5mdW5jdGlvbiBzdHJpbmdTZXQgKHVuaXRzLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdW5pdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplT2JqZWN0VW5pdHModW5pdHMpO1xuICAgICAgICB2YXIgcHJpb3JpdGl6ZWQgPSBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmlvcml0aXplZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpc1twcmlvcml0aXplZFtpXS51bml0XSh1bml0c1twcmlvcml0aXplZFtpXS51bml0XSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10odmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB6ZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCwgZm9yY2VTaWduKSB7XG4gICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICBzaWduID0gbnVtYmVyID49IDA7XG4gICAgcmV0dXJuIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgK1xuICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArIGFic051bWJlcjtcbn1cblxudmFyIGZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oW0hoXW1tKHNzKT98TW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UW8/fFlZWVlZWXxZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fGtrP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nO1xuXG52YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcblxudmFyIGZvcm1hdEZ1bmN0aW9ucyA9IHt9O1xuXG52YXIgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuLy8gdG9rZW46ICAgICdNJ1xuLy8gcGFkZGVkOiAgIFsnTU0nLCAyXVxuLy8gb3JkaW5hbDogICdNbydcbi8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuZnVuY3Rpb24gYWRkRm9ybWF0VG9rZW4gKHRva2VuLCBwYWRkZWQsIG9yZGluYWwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZ1bmMgPSBjYWxsYmFjaztcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICBmdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbY2FsbGJhY2tdKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0b2tlbikge1xuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgIH1cbiAgICBpZiAocGFkZGVkKSB7XG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gemVyb0ZpbGwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBwYWRkZWRbMV0sIHBhZGRlZFsyXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChvcmRpbmFsKSB7XG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW29yZGluYWxdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGlucHV0KSB7XG4gICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG59XG5cbmZ1bmN0aW9uIG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpIHtcbiAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksIGksIGxlbmd0aDtcblxuICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV0pIHtcbiAgICAgICAgICAgIGFycmF5W2ldID0gZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlbaV0gPSByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGFycmF5W2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAobW9tKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSAnJywgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gaXNGdW5jdGlvbihhcnJheVtpXSkgPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KSA6IGFycmF5W2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbn1cblxuLy8gZm9ybWF0IGRhdGUgdXNpbmcgbmF0aXZlIGRhdGUgb2JqZWN0XG5mdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG4gICAgaWYgKCFtLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gbS5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICB9XG5cbiAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxvY2FsZURhdGEoKSk7XG4gICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPSBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgIHJldHVybiBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XShtKTtcbn1cblxuZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgdmFyIGkgPSA1O1xuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgIH1cblxuICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShsb2NhbEZvcm1hdHRpbmdUb2tlbnMsIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vucyk7XG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICBpIC09IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdDtcbn1cblxudmFyIG1hdGNoMSAgICAgICAgID0gL1xcZC87ICAgICAgICAgICAgLy8gICAgICAgMCAtIDlcbnZhciBtYXRjaDIgICAgICAgICA9IC9cXGRcXGQvOyAgICAgICAgICAvLyAgICAgIDAwIC0gOTlcbnZhciBtYXRjaDMgICAgICAgICA9IC9cXGR7M30vOyAgICAgICAgIC8vICAgICAwMDAgLSA5OTlcbnZhciBtYXRjaDQgICAgICAgICA9IC9cXGR7NH0vOyAgICAgICAgIC8vICAgIDAwMDAgLSA5OTk5XG52YXIgbWF0Y2g2ICAgICAgICAgPSAvWystXT9cXGR7Nn0vOyAgICAvLyAtOTk5OTk5IC0gOTk5OTk5XG52YXIgbWF0Y2gxdG8yICAgICAgPSAvXFxkXFxkPy87ICAgICAgICAgLy8gICAgICAgMCAtIDk5XG52YXIgbWF0Y2gzdG80ICAgICAgPSAvXFxkXFxkXFxkXFxkPy87ICAgICAvLyAgICAgOTk5IC0gOTk5OVxudmFyIG1hdGNoNXRvNiAgICAgID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vOyAvLyAgIDk5OTk5IC0gOTk5OTk5XG52YXIgbWF0Y2gxdG8zICAgICAgPSAvXFxkezEsM30vOyAgICAgICAvLyAgICAgICAwIC0gOTk5XG52YXIgbWF0Y2gxdG80ICAgICAgPSAvXFxkezEsNH0vOyAgICAgICAvLyAgICAgICAwIC0gOTk5OVxudmFyIG1hdGNoMXRvNiAgICAgID0gL1srLV0/XFxkezEsNn0vOyAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuXG52YXIgbWF0Y2hVbnNpZ25lZCAgPSAvXFxkKy87ICAgICAgICAgICAvLyAgICAgICAwIC0gaW5mXG52YXIgbWF0Y2hTaWduZWQgICAgPSAvWystXT9cXGQrLzsgICAgICAvLyAgICAtaW5mIC0gaW5mXG5cbnZhciBtYXRjaE9mZnNldCAgICA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naTsgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG52YXIgbWF0Y2hTaG9ydE9mZnNldCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/L2dpOyAvLyArMDAgLTAwICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuXG52YXIgbWF0Y2hUaW1lc3RhbXAgPSAvWystXT9cXGQrKFxcLlxcZHsxLDN9KT8vOyAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xuXG4vLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbi8vIGluY2x1ZGVzIHNjb3R0aXNoIGdhZWxpYyB0d28gd29yZCBhbmQgaHlwaGVuYXRlZCBtb250aHNcbnZhciBtYXRjaFdvcmQgPSAvWzAtOV0qWydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdK3xbXFx1MDYwMC1cXHUwNkZGXFwvXSsoXFxzKj9bXFx1MDYwMC1cXHUwNkZGXSspezEsMn0vaTtcblxuXG52YXIgcmVnZXhlcyA9IHt9O1xuXG5mdW5jdGlvbiBhZGRSZWdleFRva2VuICh0b2tlbiwgcmVnZXgsIHN0cmljdFJlZ2V4KSB7XG4gICAgcmVnZXhlc1t0b2tlbl0gPSBpc0Z1bmN0aW9uKHJlZ2V4KSA/IHJlZ2V4IDogZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGVEYXRhKSB7XG4gICAgICAgIHJldHVybiAoaXNTdHJpY3QgJiYgc3RyaWN0UmVnZXgpID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4gKHRva2VuLCBjb25maWcpIHtcbiAgICBpZiAoIWhhc093blByb3AocmVnZXhlcywgdG9rZW4pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVuZXNjYXBlRm9ybWF0KHRva2VuKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZ2V4ZXNbdG9rZW5dKGNvbmZpZy5fc3RyaWN0LCBjb25maWcuX2xvY2FsZSk7XG59XG5cbi8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbmZ1bmN0aW9uIHVuZXNjYXBlRm9ybWF0KHMpIHtcbiAgICByZXR1cm4gcmVnZXhFc2NhcGUocy5yZXBsYWNlKCdcXFxcJywgJycpLnJlcGxhY2UoL1xcXFwoXFxbKXxcXFxcKFxcXSl8XFxbKFteXFxdXFxbXSopXFxdfFxcXFwoLikvZywgZnVuY3Rpb24gKG1hdGNoZWQsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICB9KSk7XG59XG5cbmZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbn1cblxudmFyIHRva2VucyA9IHt9O1xuXG5mdW5jdGlvbiBhZGRQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICB2YXIgaSwgZnVuYyA9IGNhbGxiYWNrO1xuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRva2VuID0gW3Rva2VuXTtcbiAgICB9XG4gICAgaWYgKGlzTnVtYmVyKGNhbGxiYWNrKSkge1xuICAgICAgICBmdW5jID0gZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICAgICAgYXJyYXlbY2FsbGJhY2tdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XG4gICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgIGlmIChpbnB1dCAhPSBudWxsICYmIGhhc093blByb3AodG9rZW5zLCB0b2tlbikpIHtcbiAgICAgICAgdG9rZW5zW3Rva2VuXShpbnB1dCwgY29uZmlnLl9hLCBjb25maWcsIHRva2VuKTtcbiAgICB9XG59XG5cbnZhciBZRUFSID0gMDtcbnZhciBNT05USCA9IDE7XG52YXIgREFURSA9IDI7XG52YXIgSE9VUiA9IDM7XG52YXIgTUlOVVRFID0gNDtcbnZhciBTRUNPTkQgPSA1O1xudmFyIE1JTExJU0VDT05EID0gNjtcbnZhciBXRUVLID0gNztcbnZhciBXRUVLREFZID0gODtcblxudmFyIGluZGV4T2Y7XG5cbmlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgIGluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcbn0gZWxzZSB7XG4gICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIC8vIEkga25vd1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSBvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG59XG5cbnZhciBpbmRleE9mJDEgPSBpbmRleE9mO1xuXG5mdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCArIDEsIDApKS5nZXRVVENEYXRlKCk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ00nLCBbJ01NJywgMl0sICdNbycsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHNTaG9ydCh0aGlzLCBmb3JtYXQpO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdNTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcbn0pO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnbW9udGgnLCAnTScpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ21vbnRoJywgOCk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignTScsICAgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdNTScsICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignTU1NJywgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbn0pO1xuYWRkUmVnZXhUb2tlbignTU1NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XG59KTtcblxuYWRkUGFyc2VUb2tlbihbJ00nLCAnTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG59KTtcblxuYWRkUGFyc2VUb2tlbihbJ01NTScsICdNTU1NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAvLyBpZiB3ZSBkaWRuJ3QgZmluZCBhIG1vbnRoIG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZC5cbiAgICBpZiAobW9udGggIT0gbnVsbCkge1xuICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkTW9udGggPSBpbnB1dDtcbiAgICB9XG59KTtcblxuLy8gTE9DQUxFU1xuXG52YXIgTU9OVEhTX0lOX0ZPUk1BVCA9IC9EW29EXT8oXFxbW15cXFtcXF1dKlxcXXxcXHMpK01NTU0/LztcbnZhciBkZWZhdWx0TG9jYWxlTW9udGhzID0gJ0phbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXInLnNwbGl0KCdfJyk7XG5mdW5jdGlvbiBsb2NhbGVNb250aHMgKG0sIGZvcm1hdCkge1xuICAgIGlmICghbSkge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpID8gdGhpcy5fbW9udGhzIDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1snc3RhbmRhbG9uZSddO1xuICAgIH1cbiAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpID8gdGhpcy5fbW9udGhzW20ubW9udGgoKV0gOlxuICAgICAgICB0aGlzLl9tb250aHNbKHRoaXMuX21vbnRocy5pc0Zvcm1hdCB8fCBNT05USFNfSU5fRk9STUFUKS50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCA9ICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKTtcbmZ1bmN0aW9uIGxvY2FsZU1vbnRoc1Nob3J0IChtLCBmb3JtYXQpIHtcbiAgICBpZiAoIW0pIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpID8gdGhpcy5fbW9udGhzU2hvcnQgOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbJ3N0YW5kYWxvbmUnXTtcbiAgICB9XG4gICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpID8gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXSA6XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0W01PTlRIU19JTl9GT1JNQVQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20ubW9udGgoKV07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVN0cmljdFBhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gbW9udGhOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAvLyB0aGlzIGlzIG5vdCB1c2VkXG4gICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgKytpKSB7XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRocyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mJDEuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mJDEuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mJDEuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mJDEuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbG9jYWxlTW9udGhzUGFyc2UgKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBhZGQgc29ydGluZ1xuICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXJcbiAgICAvLyBzZWUgc29ydGluZyBpbiBjb21wdXRlTW9udGhzUGFyc2VcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyaWN0ICYmICF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKSArICd8XicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU1NJyAmJiB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NJyAmJiB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIHNldE1vbnRoIChtb20sIHZhbHVlKSB7XG4gICAgdmFyIGRheU9mTW9udGg7XG5cbiAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgcmV0dXJuIG1vbTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoL15cXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBtb20ubG9jYWxlRGF0YSgpLm1vbnRoc1BhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XG4gICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkYXlPZk1vbnRoID0gTWF0aC5taW4obW9tLmRhdGUoKSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcbiAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgIHJldHVybiBtb207XG59XG5cbmZ1bmN0aW9uIGdldFNldE1vbnRoICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0KHRoaXMsICdNb250aCcpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGF5c0luTW9udGggKCkge1xuICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpKTtcbn1cblxudmFyIGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuZnVuY3Rpb24gbW9udGhzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSBkZWZhdWx0TW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICB9XG59XG5cbnZhciBkZWZhdWx0TW9udGhzUmVnZXggPSBtYXRjaFdvcmQ7XG5mdW5jdGlvbiBtb250aHNSZWdleCAoaXNTdHJpY3QpIHtcbiAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gZGVmYXVsdE1vbnRoc1JlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZU1vbnRoc1BhcnNlICgpIHtcbiAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICBpLCBtb207XG4gICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICBsb25nUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICB9XG4gICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG4gICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSB0aGlzLl9tb250aHNSZWdleDtcbiAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ1knLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHkgPSB0aGlzLnllYXIoKTtcbiAgICByZXR1cm4geSA8PSA5OTk5ID8gJycgKyB5IDogJysnICsgeTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ1lZJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy55ZWFyKCkgJSAxMDA7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZJywgICA0XSwgICAgICAgMCwgJ3llYXInKTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVknLCAgNV0sICAgICAgIDAsICd5ZWFyJyk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZWScsIDYsIHRydWVdLCAwLCAneWVhcicpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygneWVhcicsICd5Jyk7XG5cbi8vIFBSSU9SSVRJRVNcblxuYWRkVW5pdFByaW9yaXR5KCd5ZWFyJywgMSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignWScsICAgICAgbWF0Y2hTaWduZWQpO1xuYWRkUmVnZXhUb2tlbignWVknLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignWVlZWScsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuYWRkUmVnZXhUb2tlbignWVlZWVknLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuYWRkUmVnZXhUb2tlbignWVlZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG5hZGRQYXJzZVRva2VuKFsnWVlZWVknLCAnWVlZWVlZJ10sIFlFQVIpO1xuYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtZRUFSXSA9IGlucHV0Lmxlbmd0aCA9PT0gMiA/IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbn0pO1xuYWRkUGFyc2VUb2tlbignWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbWUVBUl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ1knLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG59XG5cbmZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbn1cblxuLy8gSE9PS1NcblxuaG9va3MucGFyc2VUd29EaWdpdFllYXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xufTtcblxuLy8gTU9NRU5UU1xuXG52YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgdHJ1ZSk7XG5cbmZ1bmN0aW9uIGdldElzTGVhcFllYXIgKCkge1xuICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGF0ZSAoeSwgbSwgZCwgaCwgTSwgcywgbXMpIHtcbiAgICAvLyBjYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTgxMzQ4XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcyk7XG5cbiAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSAoeSkge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG5cbiAgICAvLyB0aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwICYmIGlzRmluaXRlKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSkpIHtcbiAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5KTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGU7XG59XG5cbi8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG5mdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICB2YXIgLy8gZmlyc3Qtd2VlayBkYXkgLS0gd2hpY2ggamFudWFyeSBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgKDQgZm9yIGlzbywgMSBmb3Igb3RoZXIpXG4gICAgICAgIGZ3ZCA9IDcgKyBkb3cgLSBkb3ksXG4gICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgICAgICAgZndkbHcgPSAoNyArIGNyZWF0ZVVUQ0RhdGUoeWVhciwgMCwgZndkKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xuXG4gICAgcmV0dXJuIC1md2RsdyArIGZ3ZCAtIDE7XG59XG5cbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG5mdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla3MoeWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICB2YXIgbG9jYWxXZWVrZGF5ID0gKDcgKyB3ZWVrZGF5IC0gZG93KSAlIDcsXG4gICAgICAgIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICBkYXlPZlllYXIgPSAxICsgNyAqICh3ZWVrIC0gMSkgKyBsb2NhbFdlZWtkYXkgKyB3ZWVrT2Zmc2V0LFxuICAgICAgICByZXNZZWFyLCByZXNEYXlPZlllYXI7XG5cbiAgICBpZiAoZGF5T2ZZZWFyIDw9IDApIHtcbiAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xuICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlzSW5ZZWFyKHJlc1llYXIpICsgZGF5T2ZZZWFyO1xuICAgIH0gZWxzZSBpZiAoZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyKSkge1xuICAgICAgICByZXNZZWFyID0geWVhciArIDE7XG4gICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhciAtIGRheXNJblllYXIoeWVhcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzWWVhciA9IHllYXI7XG4gICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhcjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyOiByZXNZZWFyLFxuICAgICAgICBkYXlPZlllYXI6IHJlc0RheU9mWWVhclxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KG1vbS55ZWFyKCksIGRvdywgZG95KSxcbiAgICAgICAgd2VlayA9IE1hdGguZmxvb3IoKG1vbS5kYXlPZlllYXIoKSAtIHdlZWtPZmZzZXQgLSAxKSAvIDcpICsgMSxcbiAgICAgICAgcmVzV2VlaywgcmVzWWVhcjtcblxuICAgIGlmICh3ZWVrIDwgMSkge1xuICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSAtIDE7XG4gICAgICAgIHJlc1dlZWsgPSB3ZWVrICsgd2Vla3NJblllYXIocmVzWWVhciwgZG93LCBkb3kpO1xuICAgIH0gZWxzZSBpZiAod2VlayA+IHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KSkge1xuICAgICAgICByZXNXZWVrID0gd2VlayAtIHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KTtcbiAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpO1xuICAgICAgICByZXNXZWVrID0gd2VlaztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB3ZWVrOiByZXNXZWVrLFxuICAgICAgICB5ZWFyOiByZXNZZWFyXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgIHdlZWtPZmZzZXROZXh0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIgKyAxLCBkb3csIGRveSk7XG4gICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG5hZGRGb3JtYXRUb2tlbignVycsIFsnV1cnLCAyXSwgJ1dvJywgJ2lzb1dlZWsnKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuYWRkVW5pdEFsaWFzKCdpc29XZWVrJywgJ1cnKTtcblxuLy8gUFJJT1JJVElFU1xuXG5hZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcbmFkZFVuaXRQcmlvcml0eSgnaXNvV2VlaycsIDUpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ3cnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ3d3JywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignVycsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsndycsICd3dycsICdXJywgJ1dXJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcbn0pO1xuXG4vLyBIRUxQRVJTXG5cbi8vIExPQ0FMRVNcblxuZnVuY3Rpb24gbG9jYWxlV2VlayAobW9tKSB7XG4gICAgcmV0dXJuIHdlZWtPZlllYXIobW9tLCB0aGlzLl93ZWVrLmRvdywgdGhpcy5fd2Vlay5kb3kpLndlZWs7XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG59O1xuXG5mdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mV2VlayAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xufVxuXG5mdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mWWVhciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xufVxuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFNldFdlZWsgKGlucHV0KSB7XG4gICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayAoaW5wdXQpIHtcbiAgICB2YXIgd2VlayA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkud2VlaztcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbmFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzKHRoaXMsIGZvcm1hdCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuYWRkRm9ybWF0VG9rZW4oJ0UnLCAwLCAwLCAnaXNvV2Vla2RheScpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbmFkZFVuaXRBbGlhcygnd2Vla2RheScsICdlJyk7XG5hZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4vLyBQUklPUklUWVxuYWRkVW5pdFByaW9yaXR5KCdkYXknLCAxMSk7XG5hZGRVbml0UHJpb3JpdHkoJ3dlZWtkYXknLCAxMSk7XG5hZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtkYXknLCAxMSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignZCcsICAgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdlJywgICAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ0UnLCAgICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KTtcbn0pO1xuYWRkUmVnZXhUb2tlbignZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbn0pO1xuYWRkUmVnZXhUb2tlbignZGRkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUmVnZXgoaXNTdHJpY3QpO1xufSk7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYSB3ZWVrZGF5IG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZFxuICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgIH1cbn0pO1xuXG5hZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgaWYgKCFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgfVxuXG4gICAgaW5wdXQgPSBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCkgJSA3IHx8IDc7XG4gICAgfVxuICAgIHJldHVybiBpc05hTihpbnB1dCkgPyBudWxsIDogaW5wdXQ7XG59XG5cbi8vIExPQ0FMRVNcblxudmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKTtcbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzIChtLCBmb3JtYXQpIHtcbiAgICBpZiAoIW0pIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXMgOlxuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNbJ3N0YW5kYWxvbmUnXTtcbiAgICB9XG4gICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXNbbS5kYXkoKV0gOlxuICAgICAgICB0aGlzLl93ZWVrZGF5c1t0aGlzLl93ZWVrZGF5cy5pc0Zvcm1hdC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5kYXkoKV07XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyk7XG5mdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1Nob3J0IChtKSB7XG4gICAgcmV0dXJuIChtKSA/IHRoaXMuX3dlZWtkYXlzU2hvcnRbbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c1Nob3J0O1xufVxuXG52YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpO1xuZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNNaW4gKG0pIHtcbiAgICByZXR1cm4gKG0pID8gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c01pbjtcbn1cblxuZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UkMSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gd2Vla2RheU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIHtcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mJDEuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mJDEuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mJDEuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mJDEuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mJDEuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlICh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlJDEuY2FsbCh0aGlzLCB3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlID0gW107XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcblxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGRkJyAmJiB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZCcgJiYgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGQnICYmIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrIChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cbiAgICB2YXIgZGF5ID0gdGhpcy5faXNVVEMgPyB0aGlzLl9kLmdldFVUQ0RheSgpIDogdGhpcy5fZC5nZXREYXkoKTtcbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoaW5wdXQgLSBkYXksICdkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRheTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayAoaW5wdXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICB9XG4gICAgdmFyIHdlZWtkYXkgPSAodGhpcy5kYXkoKSArIDcgLSB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3cpICUgNztcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChpbnB1dCAtIHdlZWtkYXksICdkJyk7XG59XG5cbmZ1bmN0aW9uIGdldFNldElTT0RheU9mV2VlayAoaW5wdXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICB9XG5cbiAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgLy8gYXMgYSBnZXR0ZXIsIHJldHVybnMgNyBpbnN0ZWFkIG9mIDAgKDEtNyByYW5nZSBpbnN0ZWFkIG9mIDAtNilcbiAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG5cbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgd2Vla2RheSA9IHBhcnNlSXNvV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyB3ZWVrZGF5IDogd2Vla2RheSAtIDcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRheSgpIHx8IDc7XG4gICAgfVxufVxuXG52YXIgZGVmYXVsdFdlZWtkYXlzUmVnZXggPSBtYXRjaFdvcmQ7XG5mdW5jdGlvbiB3ZWVrZGF5c1JlZ2V4IChpc1N0cmljdCkge1xuICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgIH1cbn1cblxudmFyIGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XG5mdW5jdGlvbiB3ZWVrZGF5c1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgIH1cbn1cblxudmFyIGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4ID0gbWF0Y2hXb3JkO1xuZnVuY3Rpb24gd2Vla2RheXNNaW5SZWdleCAoaXNTdHJpY3QpIHtcbiAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c01pblJlZ2V4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSBkZWZhdWx0V2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gY29tcHV0ZVdlZWtkYXlzUGFyc2UgKCkge1xuICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciBtaW5QaWVjZXMgPSBbXSwgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICBpLCBtb20sIG1pbnAsIHNob3J0cCwgbG9uZ3A7XG4gICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICBtaW5wID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgc2hvcnRwID0gdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpO1xuICAgICAgICBsb25ncCA9IHRoaXMud2Vla2RheXMobW9tLCAnJyk7XG4gICAgICAgIG1pblBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgIG1peGVkUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgIG1peGVkUGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XG4gICAgfVxuICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgd2Vla2RheSAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICBtaW5QaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG5cbiAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaW5QaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmZ1bmN0aW9uIGhGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xufVxuXG5mdW5jdGlvbiBrRm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLmhvdXJzKCkgfHwgMjQ7XG59XG5cbmFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xuYWRkRm9ybWF0VG9rZW4oJ2gnLCBbJ2hoJywgMl0sIDAsIGhGb3JtYXQpO1xuYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xuXG5hZGRGb3JtYXRUb2tlbignaG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ2htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMik7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbn0pO1xuXG5mdW5jdGlvbiBtZXJpZGllbSAodG9rZW4sIGxvd2VyY2FzZSkge1xuICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCBsb3dlcmNhc2UpO1xuICAgIH0pO1xufVxuXG5tZXJpZGllbSgnYScsIHRydWUpO1xubWVyaWRpZW0oJ0EnLCBmYWxzZSk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuLy8gUFJJT1JJVFlcbmFkZFVuaXRQcmlvcml0eSgnaG91cicsIDEzKTtcblxuLy8gUEFSU0lOR1xuXG5mdW5jdGlvbiBtYXRjaE1lcmlkaWVtIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbn1cblxuYWRkUmVnZXhUb2tlbignYScsICBtYXRjaE1lcmlkaWVtKTtcbmFkZFJlZ2V4VG9rZW4oJ0EnLCAgbWF0Y2hNZXJpZGllbSk7XG5hZGRSZWdleFRva2VuKCdIJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdoJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdrJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ2hoJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbigna2snLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbmFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG5hZGRSZWdleFRva2VuKCdobW1zcycsIG1hdGNoNXRvNik7XG5hZGRSZWdleFRva2VuKCdIbW0nLCBtYXRjaDN0bzQpO1xuYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG5hZGRQYXJzZVRva2VuKFsnSCcsICdISCddLCBIT1VSKTtcbmFkZFBhcnNlVG9rZW4oWydrJywgJ2trJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBrSW5wdXQgPSB0b0ludChpbnB1dCk7XG4gICAgYXJyYXlbSE9VUl0gPSBrSW5wdXQgPT09IDI0ID8gMCA6IGtJbnB1dDtcbn0pO1xuYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX2lzUG0gPSBjb25maWcuX2xvY2FsZS5pc1BNKGlucHV0KTtcbiAgICBjb25maWcuX21lcmlkaWVtID0gaW5wdXQ7XG59KTtcbmFkZFBhcnNlVG9rZW4oWydoJywgJ2hoJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQpO1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xufSk7XG5hZGRQYXJzZVRva2VuKCdobW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xufSk7XG5hZGRQYXJzZVRva2VuKCdobW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xufSk7XG5hZGRQYXJzZVRva2VuKCdIbW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xufSk7XG5hZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xufSk7XG5cbi8vIExPQ0FMRVNcblxuZnVuY3Rpb24gbG9jYWxlSXNQTSAoaW5wdXQpIHtcbiAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgLy8gVXNpbmcgY2hhckF0IHNob3VsZCBiZSBtb3JlIGNvbXBhdGlibGUuXG4gICAgcmV0dXJuICgoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJyk7XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSA9IC9bYXBdXFwuP20/XFwuPy9pO1xuZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAncG0nIDogJ1BNJztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgIH1cbn1cblxuXG4vLyBNT01FTlRTXG5cbi8vIFNldHRpbmcgdGhlIGhvdXIgc2hvdWxkIGtlZXAgdGhlIHRpbWUsIGJlY2F1c2UgdGhlIHVzZXIgZXhwbGljaXRseVxuLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgaGUgd2FudHMuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuLy8gYSBuZXcgdGltZXpvbmUpIG1ha2VzIHNlbnNlLiBBZGRpbmcvc3VidHJhY3RpbmcgaG91cnMgZG9lcyBub3QgZm9sbG93XG4vLyB0aGlzIHJ1bGUuXG52YXIgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbi8vIG1vbnRoc1xuLy8gd2Vla1xuLy8gd2Vla2RheXNcbi8vIG1lcmlkaWVtXG52YXIgYmFzZUNvbmZpZyA9IHtcbiAgICBjYWxlbmRhcjogZGVmYXVsdENhbGVuZGFyLFxuICAgIGxvbmdEYXRlRm9ybWF0OiBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQsXG4gICAgaW52YWxpZERhdGU6IGRlZmF1bHRJbnZhbGlkRGF0ZSxcbiAgICBvcmRpbmFsOiBkZWZhdWx0T3JkaW5hbCxcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSxcbiAgICByZWxhdGl2ZVRpbWU6IGRlZmF1bHRSZWxhdGl2ZVRpbWUsXG5cbiAgICBtb250aHM6IGRlZmF1bHRMb2NhbGVNb250aHMsXG4gICAgbW9udGhzU2hvcnQ6IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCxcblxuICAgIHdlZWs6IGRlZmF1bHRMb2NhbGVXZWVrLFxuXG4gICAgd2Vla2RheXM6IGRlZmF1bHRMb2NhbGVXZWVrZGF5cyxcbiAgICB3ZWVrZGF5c01pbjogZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxuICAgIHdlZWtkYXlzU2hvcnQ6IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LFxuXG4gICAgbWVyaWRpZW1QYXJzZTogZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2Vcbn07XG5cbi8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxvY2FsZSBjb25maWcgZmlsZXNcbnZhciBsb2NhbGVzID0ge307XG52YXIgbG9jYWxlRmFtaWxpZXMgPSB7fTtcbnZhciBnbG9iYWxMb2NhbGU7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZShrZXkpIHtcbiAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG59XG5cbi8vIHBpY2sgdGhlIGxvY2FsZSBmcm9tIHRoZSBhcnJheVxuLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbi8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbmZ1bmN0aW9uIGNob29zZUxvY2FsZShuYW1lcykge1xuICAgIHZhciBpID0gMCwgaiwgbmV4dCwgbG9jYWxlLCBzcGxpdDtcblxuICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xuICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XG4gICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQubGVuZ3RoID49IGogJiYgY29tcGFyZUFycmF5cyhzcGxpdCwgbmV4dCwgdHJ1ZSkgPj0gaiAtIDEpIHtcbiAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqLS07XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgdmFyIG9sZExvY2FsZSA9IG51bGw7XG4gICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICBpZiAoIWxvY2FsZXNbbmFtZV0gJiYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvbGRMb2NhbGUgPSBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgICAgICAgICByZXF1aXJlKCcuL2xvY2FsZS8nICsgbmFtZSk7XG4gICAgICAgICAgICAvLyBiZWNhdXNlIGRlZmluZUxvY2FsZSBjdXJyZW50bHkgYWxzbyBzZXRzIHRoZSBnbG9iYWwgbG9jYWxlLCB3ZVxuICAgICAgICAgICAgLy8gd2FudCB0byB1bmRvIHRoYXQgZm9yIGxhenkgbG9hZGVkIGxvY2FsZXNcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShvbGRMb2NhbGUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7IH1cbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxvY2FsZSBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsb2NhbGUuICBJZlxuLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbi8vIGxvY2FsZSBrZXkuXG5mdW5jdGlvbiBnZXRTZXRHbG9iYWxMb2NhbGUgKGtleSwgdmFsdWVzKSB7XG4gICAgdmFyIGRhdGE7XG4gICAgaWYgKGtleSkge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWVzKSkge1xuICAgICAgICAgICAgZGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICBnbG9iYWxMb2NhbGUgPSBkYXRhO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdsb2JhbExvY2FsZS5fYWJicjtcbn1cblxuZnVuY3Rpb24gZGVmaW5lTG9jYWxlIChuYW1lLCBjb25maWcpIHtcbiAgICBpZiAoY29uZmlnICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZSgnZGVmaW5lTG9jYWxlT3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICdhbiBleGlzdGluZyBsb2NhbGUuIG1vbWVudC5kZWZpbmVMb2NhbGUobG9jYWxlTmFtZSwgJyArXG4gICAgICAgICAgICAgICAgICAgICdjb25maWcpIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIGNyZWF0aW5nIGEgbmV3IGxvY2FsZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW25hbWVdLl9jb25maWc7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXS5fY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxvY2FsZXNbbmFtZV0gPSBuZXcgTG9jYWxlKG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZykpO1xuXG4gICAgICAgIGlmIChsb2NhbGVGYW1pbGllc1tuYW1lXSkge1xuICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbbmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIGRlZmluZUxvY2FsZSh4Lm5hbWUsIHguY29uZmlnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGxvY2FsZSBBRlRFUiBhbGwgY2hpbGQgbG9jYWxlcyBoYXZlIGJlZW5cbiAgICAgICAgLy8gY3JlYXRlZCwgc28gd2Ugd29uJ3QgZW5kIHVwIHdpdGggdGhlIGNoaWxkIGxvY2FsZSBzZXQuXG4gICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcblxuXG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMb2NhbGUobmFtZSwgY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHZhciBsb2NhbGUsIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgIC8vIE1FUkdFXG4gICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbbmFtZV0uX2NvbmZpZztcbiAgICAgICAgfVxuICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpO1xuICAgICAgICBsb2NhbGUgPSBuZXcgTG9jYWxlKGNvbmZpZyk7XG4gICAgICAgIGxvY2FsZS5wYXJlbnRMb2NhbGUgPSBsb2NhbGVzW25hbWVdO1xuICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuXG4gICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcGFzcyBudWxsIGZvciBjb25maWcgdG8gdW51cGRhdGUsIHVzZWZ1bCBmb3IgdGVzdHNcbiAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xufVxuXG4vLyByZXR1cm5zIGxvY2FsZSBkYXRhXG5mdW5jdGlvbiBnZXRMb2NhbGUgKGtleSkge1xuICAgIHZhciBsb2NhbGU7XG5cbiAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XG4gICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGlmICgha2V5KSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgfVxuXG4gICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGtleSk7XG4gICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gW2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGNob29zZUxvY2FsZShrZXkpO1xufVxuXG5mdW5jdGlvbiBsaXN0TG9jYWxlcygpIHtcbiAgICByZXR1cm4ga2V5cyQxKGxvY2FsZXMpO1xufVxuXG5mdW5jdGlvbiBjaGVja092ZXJmbG93IChtKSB7XG4gICAgdmFyIG92ZXJmbG93O1xuICAgIHZhciBhID0gbS5fYTtcblxuICAgIGlmIChhICYmIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgYVtNT05USF0gICAgICAgPCAwIHx8IGFbTU9OVEhdICAgICAgID4gMTEgID8gTU9OVEggOlxuICAgICAgICAgICAgYVtEQVRFXSAgICAgICAgPCAxIHx8IGFbREFURV0gICAgICAgID4gZGF5c0luTW9udGgoYVtZRUFSXSwgYVtNT05USF0pID8gREFURSA6XG4gICAgICAgICAgICBhW0hPVVJdICAgICAgICA8IDAgfHwgYVtIT1VSXSAgICAgICAgPiAyNCB8fCAoYVtIT1VSXSA9PT0gMjQgJiYgKGFbTUlOVVRFXSAhPT0gMCB8fCBhW1NFQ09ORF0gIT09IDAgfHwgYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxuICAgICAgICAgICAgYVtNSU5VVEVdICAgICAgPCAwIHx8IGFbTUlOVVRFXSAgICAgID4gNTkgID8gTUlOVVRFIDpcbiAgICAgICAgICAgIGFbU0VDT05EXSAgICAgIDwgMCB8fCBhW1NFQ09ORF0gICAgICA+IDU5ICA/IFNFQ09ORCA6XG4gICAgICAgICAgICBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTkgPyBNSUxMSVNFQ09ORCA6XG4gICAgICAgICAgICAtMTtcblxuICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJiAob3ZlcmZsb3cgPCBZRUFSIHx8IG92ZXJmbG93ID4gREFURSkpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtzICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla2RheSAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFS0RBWTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgIH1cblxuICAgIHJldHVybiBtO1xufVxuXG4vLyBpc28gODYwMSByZWdleFxuLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG52YXIgZXh0ZW5kZWRJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSktKD86XFxkXFxkLVxcZFxcZHxXXFxkXFxkLVxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OjpcXGRcXGQoPzo6XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcbnZhciBiYXNpY0lzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KSg/OlxcZFxcZFxcZFxcZHxXXFxkXFxkXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86XFxkXFxkKD86XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcblxudmFyIHR6UmVnZXggPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy87XG5cbnZhciBpc29EYXRlcyA9IFtcbiAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcbiAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGRcXGQvLCBmYWxzZV0sXG4gICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L10sXG4gICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXG4gICAgWydZWVlZWVlNTUREJywgL1srLV1cXGR7MTB9L10sXG4gICAgWydZWVlZTU1ERCcsIC9cXGR7OH0vXSxcbiAgICAvLyBZWVlZTU0gaXMgTk9UIGFsbG93ZWQgYnkgdGhlIHN0YW5kYXJkXG4gICAgWydHR0dHW1ddV1dFJywgL1xcZHs0fVdcXGR7M30vXSxcbiAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxuICAgIFsnWVlZWURERCcsIC9cXGR7N30vXVxuXTtcblxuLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xudmFyIGlzb1RpbWVzID0gW1xuICAgIFsnSEg6bW06c3MuU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcbiAgICBbJ0hIOm1tOnNzLFNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQsXFxkKy9dLFxuICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICBbJ0hIOm1tJywgL1xcZFxcZDpcXGRcXGQvXSxcbiAgICBbJ0hIbW1zcy5TU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZFxcLlxcZCsvXSxcbiAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgWydISG1tc3MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkL10sXG4gICAgWydISG1tJywgL1xcZFxcZFxcZFxcZC9dLFxuICAgIFsnSEgnLCAvXFxkXFxkL11cbl07XG5cbnZhciBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4vLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuZnVuY3Rpb24gY29uZmlnRnJvbUlTTyhjb25maWcpIHtcbiAgICB2YXIgaSwgbCxcbiAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxuICAgICAgICBtYXRjaCA9IGV4dGVuZGVkSXNvUmVnZXguZXhlYyhzdHJpbmcpIHx8IGJhc2ljSXNvUmVnZXguZXhlYyhzdHJpbmcpLFxuICAgICAgICBhbGxvd1RpbWUsIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIHR6Rm9ybWF0O1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgZGF0ZUZvcm1hdCA9IGlzb0RhdGVzW2ldWzBdO1xuICAgICAgICAgICAgICAgIGFsbG93VGltZSA9IGlzb0RhdGVzW2ldWzJdICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29UaW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvVGltZXNbaV1bMV0uZXhlYyhtYXRjaFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbMl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICB0aW1lRm9ybWF0ID0gKG1hdGNoWzJdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFsbG93VGltZSAmJiB0aW1lRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgaWYgKHR6UmVnZXguZXhlYyhtYXRjaFs0XSkpIHtcbiAgICAgICAgICAgICAgICB0ekZvcm1hdCA9ICdaJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5fZiA9IGRhdGVGb3JtYXQgKyAodGltZUZvcm1hdCB8fCAnJykgKyAodHpGb3JtYXQgfHwgJycpO1xuICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgfVxufVxuXG4vLyBSRkMgMjgyMiByZWdleDogRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI3NlY3Rpb24tMy4zXG52YXIgYmFzaWNSZmNSZWdleCA9IC9eKCg/Ok1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksP1xccyk/KFxcZD9cXGRcXHMoPzpKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYylcXHMoPzpcXGRcXGQpP1xcZFxcZFxccykoXFxkXFxkOlxcZFxcZCkoXFw6XFxkXFxkKT8oXFxzKD86VVR8R01UfFtFQ01QXVtTRF1UfFtBLUlLLVphLWlrLXpdfFsrLV1cXGR7NH0pKSQvO1xuXG4vLyBkYXRlIGFuZCB0aW1lIGZyb20gcmVmIDI4MjIgZm9ybWF0XG5mdW5jdGlvbiBjb25maWdGcm9tUkZDMjgyMihjb25maWcpIHtcbiAgICB2YXIgc3RyaW5nLCBtYXRjaCwgZGF5Rm9ybWF0LFxuICAgICAgICBkYXRlRm9ybWF0LCB0aW1lRm9ybWF0LCB0ekZvcm1hdDtcbiAgICB2YXIgdGltZXpvbmVzID0ge1xuICAgICAgICAnIEdNVCc6ICcgKzAwMDAnLFxuICAgICAgICAnIEVEVCc6ICcgLTA0MDAnLFxuICAgICAgICAnIEVTVCc6ICcgLTA1MDAnLFxuICAgICAgICAnIENEVCc6ICcgLTA1MDAnLFxuICAgICAgICAnIENTVCc6ICcgLTA2MDAnLFxuICAgICAgICAnIE1EVCc6ICcgLTA2MDAnLFxuICAgICAgICAnIE1TVCc6ICcgLTA3MDAnLFxuICAgICAgICAnIFBEVCc6ICcgLTA3MDAnLFxuICAgICAgICAnIFBTVCc6ICcgLTA4MDAnXG4gICAgfTtcbiAgICB2YXIgbWlsaXRhcnkgPSAnWVhXVlVUU1JRUE9OWkFCQ0RFRkdISUtMTSc7XG4gICAgdmFyIHRpbWV6b25lLCB0aW1lem9uZUluZGV4O1xuXG4gICAgc3RyaW5nID0gY29uZmlnLl9pXG4gICAgICAgIC5yZXBsYWNlKC9cXChbXlxcKV0qXFwpfFtcXG5cXHRdL2csICcgJykgLy8gUmVtb3ZlIGNvbW1lbnRzIGFuZCBmb2xkaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCAnICcpIC8vIFJlcGxhY2UgbXVsdGlwbGUtc3BhY2VzIHdpdGggYSBzaW5nbGUgc3BhY2VcbiAgICAgICAgLnJlcGxhY2UoL15cXHN8XFxzJC9nLCAnJyk7IC8vIFJlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZXNcbiAgICBtYXRjaCA9IGJhc2ljUmZjUmVnZXguZXhlYyhzdHJpbmcpO1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGRheUZvcm1hdCA9IG1hdGNoWzFdID8gJ2RkZCcgKyAoKG1hdGNoWzFdLmxlbmd0aCA9PT0gNSkgPyAnLCAnIDogJyAnKSA6ICcnO1xuICAgICAgICBkYXRlRm9ybWF0ID0gJ0QgTU1NICcgKyAoKG1hdGNoWzJdLmxlbmd0aCA+IDEwKSA/ICdZWVlZICcgOiAnWVkgJyk7XG4gICAgICAgIHRpbWVGb3JtYXQgPSAnSEg6bW0nICsgKG1hdGNoWzRdID8gJzpzcycgOiAnJyk7XG5cbiAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB0aGUgdmFuaWxsYSBKUyBEYXRlIG9iamVjdCB3aXRoIGFuIGluZGVwZW50ZW50IGRheS1vZi13ZWVrIGNoZWNrLlxuICAgICAgICBpZiAobWF0Y2hbMV0pIHsgLy8gZGF5IG9mIHdlZWsgZ2l2ZW5cbiAgICAgICAgICAgIHZhciBtb21lbnREYXRlID0gbmV3IERhdGUobWF0Y2hbMl0pO1xuICAgICAgICAgICAgdmFyIG1vbWVudERheSA9IFsnU3VuJywnTW9uJywnVHVlJywnV2VkJywnVGh1JywnRnJpJywnU2F0J11bbW9tZW50RGF0ZS5nZXREYXkoKV07XG5cbiAgICAgICAgICAgIGlmIChtYXRjaFsxXS5zdWJzdHIoMCwzKSAhPT0gbW9tZW50RGF5KSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKG1hdGNoWzVdLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAyOiAvLyBtaWxpdGFyeVxuICAgICAgICAgICAgICAgIGlmICh0aW1lem9uZUluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWV6b25lID0gJyArMDAwMCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZXpvbmVJbmRleCA9IG1pbGl0YXJ5LmluZGV4T2YobWF0Y2hbNV1bMV0udG9VcHBlckNhc2UoKSkgLSAxMjtcbiAgICAgICAgICAgICAgICAgICAgdGltZXpvbmUgPSAoKHRpbWV6b25lSW5kZXggPCAwKSA/ICcgLScgOiAnICsnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoKCcnICsgdGltZXpvbmVJbmRleCkucmVwbGFjZSgvXi0/LywgJzAnKSkubWF0Y2goLy4uJC8pWzBdICsgJzAwJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6IC8vIFpvbmVcbiAgICAgICAgICAgICAgICB0aW1lem9uZSA9IHRpbWV6b25lc1ttYXRjaFs1XV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OiAvLyBVVCBvciArLy05OTk5XG4gICAgICAgICAgICAgICAgdGltZXpvbmUgPSB0aW1lem9uZXNbJyBHTVQnXTtcbiAgICAgICAgfVxuICAgICAgICBtYXRjaFs1XSA9IHRpbWV6b25lO1xuICAgICAgICBjb25maWcuX2kgPSBtYXRjaC5zcGxpY2UoMSkuam9pbignJyk7XG4gICAgICAgIHR6Rm9ybWF0ID0gJyBaWic7XG4gICAgICAgIGNvbmZpZy5fZiA9IGRheUZvcm1hdCArIGRhdGVGb3JtYXQgKyB0aW1lRm9ybWF0ICsgdHpGb3JtYXQ7XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucmZjMjgyMiA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgfVxufVxuXG4vLyBkYXRlIGZyb20gaXNvIGZvcm1hdCBvciBmYWxsYmFja1xuZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG5cbiAgICBpZiAobWF0Y2hlZCAhPT0gbnVsbCkge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGaW5hbCBhdHRlbXB0LCB1c2UgSW5wdXQgRmFsbGJhY2tcbiAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xufVxuXG5ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAndmFsdWUgcHJvdmlkZWQgaXMgbm90IGluIGEgcmVjb2duaXplZCBSRkMyODIyIG9yIElTTyBmb3JtYXQuIG1vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlKCksICcgK1xuICAgICd3aGljaCBpcyBub3QgcmVsaWFibGUgYWNyb3NzIGFsbCBicm93c2VycyBhbmQgdmVyc2lvbnMuIE5vbiBSRkMyODIyL0lTTyBkYXRlIGZvcm1hdHMgYXJlICcgK1xuICAgICdkaXNjb3VyYWdlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGFuIHVwY29taW5nIG1ham9yIHJlbGVhc2UuIFBsZWFzZSByZWZlciB0byAnICtcbiAgICAnaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9qcy1kYXRlLyBmb3IgbW9yZSBpbmZvLicsXG4gICAgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgIH1cbik7XG5cbi8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cbmZ1bmN0aW9uIGRlZmF1bHRzKGEsIGIsIGMpIHtcbiAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgIHZhciBub3dWYWx1ZSA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xuICAgIH1cbiAgICByZXR1cm4gW25vd1ZhbHVlLmdldEZ1bGxZZWFyKCksIG5vd1ZhbHVlLmdldE1vbnRoKCksIG5vd1ZhbHVlLmdldERhdGUoKV07XG59XG5cbi8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuLy8gdGhlIGFycmF5IHNob3VsZCBtaXJyb3IgdGhlIHBhcmFtZXRlcnMgYmVsb3dcbi8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG5mdW5jdGlvbiBjb25maWdGcm9tQXJyYXkgKGNvbmZpZykge1xuICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgeWVhclRvVXNlO1xuXG4gICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAvL2NvbXB1dGUgZGF5IG9mIHRoZSB5ZWFyIGZyb20gd2Vla3MgYW5kIHdlZWtkYXlzXG4gICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcbiAgICAgICAgeWVhclRvVXNlID0gZGVmYXVsdHMoY29uZmlnLl9hW1lFQVJdLCBjdXJyZW50RGF0ZVtZRUFSXSk7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpIHx8IGNvbmZpZy5fZGF5T2ZZZWFyID09PSAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoeWVhclRvVXNlLCAwLCBjb25maWcuX2RheU9mWWVhcik7XG4gICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgIGNvbmZpZy5fYVtEQVRFXSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgIC8vICogaWYgbm8geWVhciwgbW9udGgsIGRheSBvZiBtb250aCBhcmUgZ2l2ZW4sIGRlZmF1bHQgdG8gdG9kYXlcbiAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxuICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgLy8gKiBpZiB5ZWFyIGlzIGdpdmVuLCBkb24ndCBkZWZhdWx0IGFueXRoaW5nXG4gICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xuICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgIH1cblxuICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxuICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gKGNvbmZpZy5fYVtpXSA9PSBudWxsKSA/IChpID09PSAyID8gMSA6IDApIDogY29uZmlnLl9hW2ldO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICBpZiAoY29uZmlnLl9hW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW01JTlVURV0gPT09IDAgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICBjb25maWcuX2FbTUlMTElTRUNPTkRdID09PSAwKSB7XG4gICAgICAgIGNvbmZpZy5fbmV4dERheSA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgfVxuXG4gICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gY3JlYXRlVVRDRGF0ZSA6IGNyZWF0ZURhdGUpLmFwcGx5KG51bGwsIGlucHV0KTtcbiAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAvLyB3aXRoIHBhcnNlWm9uZS5cbiAgICBpZiAoY29uZmlnLl90em0gIT0gbnVsbCkge1xuICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuX25leHREYXkpIHtcbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgdmFyIHcsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSwgdGVtcCwgd2Vla2RheU92ZXJmbG93O1xuXG4gICAgdyA9IGNvbmZpZy5fdztcbiAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgIGRvdyA9IDE7XG4gICAgICAgIGRveSA9IDQ7XG5cbiAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcbiAgICAgICAgLy8gYSBub3cgdmVyc2lvbiBvZiBjdXJyZW50IGNvbmZpZyAodGFrZSBsb2NhbC91dGMvb2Zmc2V0IGZsYWdzLCBhbmRcbiAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5HRywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIDEsIDQpLnllYXIpO1xuICAgICAgICB3ZWVrID0gZGVmYXVsdHMody5XLCAxKTtcbiAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgIGlmICh3ZWVrZGF5IDwgMSB8fCB3ZWVrZGF5ID4gNykge1xuICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcbiAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgIHZhciBjdXJXZWVrID0gd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCBkb3csIGRveSk7XG5cbiAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LmdnLCBjb25maWcuX2FbWUVBUl0sIGN1cldlZWsueWVhcik7XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHdlZWsuXG4gICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIGN1cldlZWsud2Vlayk7XG5cbiAgICAgICAgaWYgKHcuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDAgfHwgd2Vla2RheSA+IDYpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHcuZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2luaW5nIG9mIHdlZWtcbiAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICBpZiAody5lIDwgMCB8fCB3LmUgPiA2KSB7XG4gICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla3MgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdGVtcC5kYXlPZlllYXI7XG4gICAgfVxufVxuXG4vLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgSVNPIHN0YW5kYXJkXG5ob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgUkZDIDI4MjIgZm9ybVxuaG9va3MuUkZDXzI4MjIgPSBmdW5jdGlvbiAoKSB7fTtcblxuLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcbiAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xuICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLklTT184NjAxKSB7XG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5SRkNfMjgyMikge1xuICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gdHJ1ZTtcblxuICAgIC8vIFRoaXMgYXJyYXkgaXMgdXNlZCB0byBtYWtlIGEgRGF0ZSwgZWl0aGVyIHdpdGggYG5ldyBEYXRlYCBvciBgRGF0ZS5VVENgXG4gICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICBpLCBwYXJzZWRJbnB1dCwgdG9rZW5zLCB0b2tlbiwgc2tpcHBlZCxcbiAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCA9IDA7XG5cbiAgICB0b2tlbnMgPSBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fCBbXSlbMF07XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd0b2tlbicsIHRva2VuLCAncGFyc2VkSW5wdXQnLCBwYXJzZWRJbnB1dCxcbiAgICAgICAgLy8gICAgICAgICAncmVnZXgnLCBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpO1xuICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkIHJlbWFpbmluZyB1bnBhcnNlZCBpbnB1dCBsZW5ndGggdG8gdGhlIHN0cmluZ1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmNoYXJzTGVmdE92ZXIgPSBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgfVxuXG4gICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcbiAgICBpZiAoY29uZmlnLl9hW0hPVVJdIDw9IDEyICYmXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPT09IHRydWUgJiZcbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMCkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnBhcnNlZERhdGVQYXJ0cyA9IGNvbmZpZy5fYS5zbGljZSgwKTtcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5tZXJpZGllbSA9IGNvbmZpZy5fbWVyaWRpZW07XG4gICAgLy8gaGFuZGxlIG1lcmlkaWVtXG4gICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKGNvbmZpZy5fbG9jYWxlLCBjb25maWcuX2FbSE9VUl0sIGNvbmZpZy5fbWVyaWRpZW0pO1xuXG4gICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgY2hlY2tPdmVyZmxvdyhjb25maWcpO1xufVxuXG5cbmZ1bmN0aW9uIG1lcmlkaWVtRml4V3JhcCAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgIHZhciBpc1BtO1xuXG4gICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICByZXR1cm4gaG91cjtcbiAgICB9XG4gICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLm1lcmlkaWVtSG91cihob3VyLCBtZXJpZGllbSk7XG4gICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgIGlzUG0gPSBsb2NhbGUuaXNQTShtZXJpZGllbSk7XG4gICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBob3VyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoaXMgaXMgbm90IHN1cHBvc2VkIHRvIGhhcHBlblxuICAgICAgICByZXR1cm4gaG91cjtcbiAgICB9XG59XG5cbi8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG5mdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgdmFyIHRlbXBDb25maWcsXG4gICAgICAgIGJlc3RNb21lbnQsXG5cbiAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgIGksXG4gICAgICAgIGN1cnJlbnRTY29yZTtcblxuICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAvL29yIHRva2Vuc1xuICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleHRlbmQoY29uZmlnLCBiZXN0TW9tZW50IHx8IHRlbXBDb25maWcpO1xufVxuXG5mdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xuICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKTtcbiAgICBjb25maWcuX2EgPSBtYXAoW2kueWVhciwgaS5tb250aCwgaS5kYXkgfHwgaS5kYXRlLCBpLmhvdXIsIGkubWludXRlLCBpLnNlY29uZCwgaS5taWxsaXNlY29uZF0sIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiBwYXJzZUludChvYmosIDEwKTtcbiAgICB9KTtcblxuICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnIChjb25maWcpIHtcbiAgICB2YXIgcmVzID0gbmV3IE1vbWVudChjaGVja092ZXJmbG93KHByZXBhcmVDb25maWcoY29uZmlnKSkpO1xuICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgIHJlcy5hZGQoMSwgJ2QnKTtcbiAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVDb25maWcgKGNvbmZpZykge1xuICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faSxcbiAgICAgICAgZm9ybWF0ID0gY29uZmlnLl9mO1xuXG4gICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBnZXRMb2NhbGUoY29uZmlnLl9sKTtcblxuICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCh7bnVsbElucHV0OiB0cnVlfSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uZmlnLl9pID0gaW5wdXQgPSBjb25maWcuX2xvY2FsZS5wcmVwYXJzZShpbnB1dCk7XG4gICAgfVxuXG4gICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudChjaGVja092ZXJmbG93KGlucHV0KSk7XG4gICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShmb3JtYXQpKSB7XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICB9ICBlbHNlIHtcbiAgICAgICAgY29uZmlnRnJvbUlucHV0KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1ZhbGlkKGNvbmZpZykpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uZmlnO1xufVxuXG5mdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XG4gICAgdmFyIGlucHV0ID0gY29uZmlnLl9pO1xuICAgIGlmIChpc1VuZGVmaW5lZChpbnB1dCkpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dC52YWx1ZU9mKCkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25maWdGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoaW5wdXQpKSB7XG4gICAgICAgIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgIHZhciBjID0ge307XG5cbiAgICBpZiAobG9jYWxlID09PSB0cnVlIHx8IGxvY2FsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgc3RyaWN0ID0gbG9jYWxlO1xuICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKChpc09iamVjdChpbnB1dCkgJiYgaXNPYmplY3RFbXB0eShpbnB1dCkpIHx8XG4gICAgICAgICAgICAoaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKSkge1xuICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XG4gICAgYy5fbCA9IGxvY2FsZTtcbiAgICBjLl9pID0gaW5wdXQ7XG4gICAgYy5fZiA9IGZvcm1hdDtcbiAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICByZXR1cm4gY3JlYXRlRnJvbUNvbmZpZyhjKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9jYWwgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbn1cblxudmFyIHByb3RvdHlwZU1pbiA9IGRlcHJlY2F0ZShcbiAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgIH1cbiAgICB9XG4pO1xuXG52YXIgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICdtb21lbnQoKS5tYXggaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5taW4gaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgfVxuICAgIH1cbik7XG5cbi8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4vLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4vL1xuLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbmZ1bmN0aW9uIHBpY2tCeShmbiwgbW9tZW50cykge1xuICAgIHZhciByZXMsIGk7XG4gICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgbW9tZW50cyA9IG1vbWVudHNbMF07XG4gICAgfVxuICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKCk7XG4gICAgfVxuICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgZm9yIChpID0gMTsgaSA8IG1vbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG5mdW5jdGlvbiBtaW4gKCkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbn1cblxuZnVuY3Rpb24gbWF4ICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbn1cblxudmFyIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogKyhuZXcgRGF0ZSgpKTtcbn07XG5cbnZhciBvcmRlcmluZyA9IFsneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsICdtaWxsaXNlY29uZCddO1xuXG5mdW5jdGlvbiBpc0R1cmF0aW9uVmFsaWQobSkge1xuICAgIGZvciAodmFyIGtleSBpbiBtKSB7XG4gICAgICAgIGlmICghKG9yZGVyaW5nLmluZGV4T2Yoa2V5KSAhPT0gLTEgJiYgKG1ba2V5XSA9PSBudWxsIHx8ICFpc05hTihtW2tleV0pKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bml0SGFzRGVjaW1hbCA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKG1bb3JkZXJpbmdbaV1dKSB7XG4gICAgICAgICAgICBpZiAodW5pdEhhc0RlY2ltYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG9ubHkgYWxsb3cgbm9uLWludGVnZXJzIGZvciBzbWFsbGVzdCB1bml0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyc2VGbG9hdChtW29yZGVyaW5nW2ldXSkgIT09IHRvSW50KG1bb3JkZXJpbmdbaV1dKSkge1xuICAgICAgICAgICAgICAgIHVuaXRIYXNEZWNpbWFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkJDEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVmFsaWQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWQkMSgpIHtcbiAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oTmFOKTtcbn1cblxuZnVuY3Rpb24gRHVyYXRpb24gKGR1cmF0aW9uKSB7XG4gICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICBxdWFydGVycyA9IG5vcm1hbGl6ZWRJbnB1dC5xdWFydGVyIHx8IDAsXG4gICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IDAsXG4gICAgICAgIGRheXMgPSBub3JtYWxpemVkSW5wdXQuZGF5IHx8IDAsXG4gICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5zZWNvbmQgfHwgMCxcbiAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICB0aGlzLl9pc1ZhbGlkID0gaXNEdXJhdGlvblZhbGlkKG5vcm1hbGl6ZWRJbnB1dCk7XG5cbiAgICAvLyByZXByZXNlbnRhdGlvbiBmb3IgZGF0ZUFkZFJlbW92ZVxuICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9ICttaWxsaXNlY29uZHMgK1xuICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxuICAgICAgICBtaW51dGVzICogNmU0ICsgLy8gMTAwMCAqIDYwXG4gICAgICAgIGhvdXJzICogMTAwMCAqIDYwICogNjA7IC8vdXNpbmcgMTAwMCAqIDYwICogNjAgaW5zdGVhZCBvZiAzNmU1IHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjk3OFxuICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxuICAgIC8vIGRheSB3aGVuIHdvcmtpbmcgYXJvdW5kIERTVCwgd2UgbmVlZCB0byBzdG9yZSB0aGVtIHNlcGFyYXRlbHlcbiAgICB0aGlzLl9kYXlzID0gK2RheXMgK1xuICAgICAgICB3ZWVrcyAqIDc7XG4gICAgLy8gSXQgaXMgaW1wb3NzaWJsZSB0cmFuc2xhdGUgbW9udGhzIGludG8gZGF5cyB3aXRob3V0IGtub3dpbmdcbiAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgdGhpcy5fbW9udGhzID0gK21vbnRocyArXG4gICAgICAgIHF1YXJ0ZXJzICogMyArXG4gICAgICAgIHllYXJzICogMTI7XG5cbiAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICB0aGlzLl9sb2NhbGUgPSBnZXRMb2NhbGUoKTtcblxuICAgIHRoaXMuX2J1YmJsZSgpO1xufVxuXG5mdW5jdGlvbiBpc0R1cmF0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG59XG5cbmZ1bmN0aW9uIGFic1JvdW5kIChudW1iZXIpIHtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgtMSAqIG51bWJlcikgKiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIpO1xuICAgIH1cbn1cblxuLy8gRk9STUFUVElOR1xuXG5mdW5jdGlvbiBvZmZzZXQgKHRva2VuLCBzZXBhcmF0b3IpIHtcbiAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgdmFyIHNpZ24gPSAnKyc7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2lnbiArIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgKyBzZXBhcmF0b3IgKyB6ZXJvRmlsbCh+fihvZmZzZXQpICUgNjAsIDIpO1xuICAgIH0pO1xufVxuXG5vZmZzZXQoJ1onLCAnOicpO1xub2Zmc2V0KCdaWicsICcnKTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdaJywgIG1hdGNoU2hvcnRPZmZzZXQpO1xuYWRkUmVnZXhUb2tlbignWlonLCBtYXRjaFNob3J0T2Zmc2V0KTtcbmFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICBjb25maWcuX3R6bSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuLy8gdGltZXpvbmUgY2h1bmtlclxuLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXG4vLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cbnZhciBjaHVua09mZnNldCA9IC8oW1xcK1xcLV18XFxkXFxkKS9naTtcblxuZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaGVyLCBzdHJpbmcpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoZXIpO1xuXG4gICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGNodW5rICAgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0gfHwgW107XG4gICAgdmFyIHBhcnRzICAgPSAoY2h1bmsgKyAnJykubWF0Y2goY2h1bmtPZmZzZXQpIHx8IFsnLScsIDAsIDBdO1xuICAgIHZhciBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcblxuICAgIHJldHVybiBtaW51dGVzID09PSAwID9cbiAgICAgIDAgOlxuICAgICAgcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbn1cblxuLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbmZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICB2YXIgcmVzLCBkaWZmO1xuICAgIGlmIChtb2RlbC5faXNVVEMpIHtcbiAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgZGlmZiA9IChpc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KSA/IGlucHV0LnZhbHVlT2YoKSA6IGNyZWF0ZUxvY2FsKGlucHV0KS52YWx1ZU9mKCkpIC0gcmVzLnZhbHVlT2YoKTtcbiAgICAgICAgLy8gVXNlIGxvdy1sZXZlbCBhcGksIGJlY2F1c2UgdGhpcyBmbiBpcyBsb3ctbGV2ZWwgYXBpLlxuICAgICAgICByZXMuX2Quc2V0VGltZShyZXMuX2QudmFsdWVPZigpICsgZGlmZik7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXREYXRlT2Zmc2V0IChtKSB7XG4gICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9wdWxsLzE4NzFcbiAgICByZXR1cm4gLU1hdGgucm91bmQobS5fZC5nZXRUaW1lem9uZU9mZnNldCgpIC8gMTUpICogMTU7XG59XG5cbi8vIEhPT0tTXG5cbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cbi8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuaG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbi8vIE1PTUVOVFNcblxuLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XG4vLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuLy8gNTozMToyNiArMDIwMCBJdCBpcyBwb3NzaWJsZSB0aGF0IDU6MzE6MjYgZG9lc24ndCBleGlzdCB3aXRoIG9mZnNldFxuLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxuLy9cbi8vIEtlZXBpbmcgdGhlIHRpbWUgYWN0dWFsbHkgYWRkcy9zdWJ0cmFjdHMgKG9uZSBob3VyKVxuLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XG4vLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4vLyBfY2hhbmdlSW5Qcm9ncmVzcyA9PSB0cnVlIGNhc2UsIHRoZW4gd2UgaGF2ZSB0byBhZGp1c3QsIGJlY2F1c2Vcbi8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXG5mdW5jdGlvbiBnZXRTZXRPZmZzZXQgKGlucHV0LCBrZWVwTG9jYWxUaW1lLCBrZWVwTWludXRlcykge1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgbG9jYWxBZGp1c3Q7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgfVxuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgICAgICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYgJiYgIWtlZXBNaW51dGVzKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pc1VUQyAmJiBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICBsb2NhbEFkanVzdCA9IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuX2lzVVRDID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxvY2FsQWRqdXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKGxvY2FsQWRqdXN0LCAnbScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIWtlZXBMb2NhbFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGNyZWF0ZUR1cmF0aW9uKGlucHV0IC0gb2Zmc2V0LCAnbScpLCAxLCBmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRTZXRab25lIChpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IC1pbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLXRoaXMudXRjT2Zmc2V0KCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyAoa2VlcExvY2FsVGltZSkge1xuICAgIHJldHVybiB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbn1cblxuZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbCAoa2VlcExvY2FsVGltZSkge1xuICAgIGlmICh0aGlzLl9pc1VUQykge1xuICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcblxuICAgICAgICBpZiAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdChnZXREYXRlT2Zmc2V0KHRoaXMpLCAnbScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCAoKSB7XG4gICAgaWYgKHRoaXMuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KHRoaXMuX3R6bSwgZmFsc2UsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciB0Wm9uZSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpO1xuICAgICAgICBpZiAodFpvbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodFpvbmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0IChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpbnB1dCA9IGlucHV0ID8gY3JlYXRlTG9jYWwoaW5wdXQpLnV0Y09mZnNldCgpIDogMDtcblxuICAgIHJldHVybiAodGhpcy51dGNPZmZzZXQoKSAtIGlucHV0KSAlIDYwID09PSAwO1xufVxuXG5mdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZSAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCgwKS51dGNPZmZzZXQoKSB8fFxuICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDUpLnV0Y09mZnNldCgpXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkICgpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX2lzRFNUU2hpZnRlZCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHt9O1xuXG4gICAgY29weUNvbmZpZyhjLCB0aGlzKTtcbiAgICBjID0gcHJlcGFyZUNvbmZpZyhjKTtcblxuICAgIGlmIChjLl9hKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGMuX2lzVVRDID8gY3JlYXRlVVRDKGMuX2EpIDogY3JlYXRlTG9jYWwoYy5fYSk7XG4gICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG59XG5cbmZ1bmN0aW9uIGlzTG9jYWwgKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1V0Y09mZnNldCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNVdGMgKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDICYmIHRoaXMuX29mZnNldCA9PT0gMCA6IGZhbHNlO1xufVxuXG4vLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbnZhciBhc3BOZXRSZWdleCA9IC9eKFxcLSk/KD86KFxcZCopWy4gXSk/KFxcZCspXFw6KFxcZCspKD86XFw6KFxcZCspKFxcLlxcZCopPyk/JC87XG5cbi8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4vLyBzb21ld2hhdCBtb3JlIGluIGxpbmUgd2l0aCA0LjQuMy4yIDIwMDQgc3BlYywgYnV0IGFsbG93cyBkZWNpbWFsIGFueXdoZXJlXG4vLyBhbmQgZnVydGhlciBtb2RpZmllZCB0byBhbGxvdyBmb3Igc3RyaW5ncyBjb250YWluaW5nIGJvdGggd2VlayBhbmQgZGF5XG52YXIgaXNvUmVnZXggPSAvXigtKT9QKD86KC0/WzAtOSwuXSopWSk/KD86KC0/WzAtOSwuXSopTSk/KD86KC0/WzAtOSwuXSopVyk/KD86KC0/WzAtOSwuXSopRCk/KD86VCg/OigtP1swLTksLl0qKUgpPyg/OigtP1swLTksLl0qKU0pPyg/OigtP1swLTksLl0qKVMpPyk/JC87XG5cbmZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uIChpbnB1dCwga2V5KSB7XG4gICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgc2lnbixcbiAgICAgICAgcmV0LFxuICAgICAgICBkaWZmUmVzO1xuXG4gICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgbXMgOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgIE0gIDogaW5wdXQuX21vbnRoc1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSBpbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgIHkgIDogMCxcbiAgICAgICAgICAgIGQgIDogdG9JbnQobWF0Y2hbREFURV0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIGggIDogdG9JbnQobWF0Y2hbSE9VUl0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIG0gIDogdG9JbnQobWF0Y2hbTUlOVVRFXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIHMgIDogdG9JbnQobWF0Y2hbU0VDT05EXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIG1zIDogdG9JbnQoYWJzUm91bmQobWF0Y2hbTUlMTElTRUNPTkRdICogMTAwMCkpICogc2lnbiAvLyB0aGUgbWlsbGlzZWNvbmQgZGVjaW1hbCBwb2ludCBpcyBpbmNsdWRlZCBpbiB0aGUgbWF0Y2hcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gaXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgeSA6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgIE0gOiBwYXJzZUlzbyhtYXRjaFszXSwgc2lnbiksXG4gICAgICAgICAgICB3IDogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxuICAgICAgICAgICAgZCA6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgIGggOiBwYXJzZUlzbyhtYXRjaFs2XSwgc2lnbiksXG4gICAgICAgICAgICBtIDogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxuICAgICAgICAgICAgcyA6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkgey8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ29iamVjdCcgJiYgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKSkge1xuICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UoY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKSk7XG5cbiAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgZHVyYXRpb24ubXMgPSBkaWZmUmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgIH1cblxuICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xuICAgICAgICByZXQuX2xvY2FsZSA9IGlucHV0Ll9sb2NhbGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn1cblxuY3JlYXRlRHVyYXRpb24uZm4gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5jcmVhdGVEdXJhdGlvbi5pbnZhbGlkID0gY3JlYXRlSW52YWxpZCQxO1xuXG5mdW5jdGlvbiBwYXJzZUlzbyAoaW5wLCBzaWduKSB7XG4gICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAvLyBpbnAgbWF5IGJlIHVuZGVmaW5lZCwgc28gY2FyZWZ1bCBjYWxsaW5nIHJlcGxhY2Ugb24gaXQuXG4gICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgIHJldHVybiAoaXNOYU4ocmVzKSA/IDAgOiByZXMpICogc2lnbjtcbn1cblxuZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgIHZhciByZXMgPSB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuXG4gICAgcmVzLm1vbnRocyA9IG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgK1xuICAgICAgICAob3RoZXIueWVhcigpIC0gYmFzZS55ZWFyKCkpICogMTI7XG4gICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xuICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgfVxuXG4gICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICsoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpKTtcblxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgdmFyIHJlcztcbiAgICBpZiAoIShiYXNlLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuICAgIH1cblxuICAgIG90aGVyID0gY2xvbmVXaXRoT2Zmc2V0KG90aGVyLCBiYXNlKTtcbiAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgcmVzLm1vbnRocyA9IC1yZXMubW9udGhzO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFRPRE86IHJlbW92ZSAnbmFtZScgYXJnIGFmdGVyIGRlcHJlY2F0aW9uIGlzIHJlbW92ZWRcbmZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBwZXJpb2QpIHtcbiAgICAgICAgdmFyIGR1ciwgdG1wO1xuICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgaWYgKHBlcmlvZCAhPT0gbnVsbCAmJiAhaXNOYU4oK3BlcmlvZCkpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCAnbW9tZW50KCkuJyArIG5hbWUgICsgJyhwZXJpb2QsIG51bWJlcikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb21lbnQoKS4nICsgbmFtZSArICcobnVtYmVyLCBwZXJpb2QpLiAnICtcbiAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9hZGQtaW52ZXJ0ZWQtcGFyYW0vIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICB0bXAgPSB2YWw7IHZhbCA9IHBlcmlvZDsgcGVyaW9kID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyArdmFsIDogdmFsO1xuICAgICAgICBkdXIgPSBjcmVhdGVEdXJhdGlvbih2YWwsIHBlcmlvZCk7XG4gICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gYWRkU3VidHJhY3QgKG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gZHVyYXRpb24uX21pbGxpc2Vjb25kcyxcbiAgICAgICAgZGF5cyA9IGFic1JvdW5kKGR1cmF0aW9uLl9kYXlzKSxcbiAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XG5cbiAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgIGlmIChtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgbW9tLl9kLnNldFRpbWUobW9tLl9kLnZhbHVlT2YoKSArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICB9XG4gICAgaWYgKGRheXMpIHtcbiAgICAgICAgc2V0JDEobW9tLCAnRGF0ZScsIGdldChtb20sICdEYXRlJykgKyBkYXlzICogaXNBZGRpbmcpO1xuICAgIH1cbiAgICBpZiAobW9udGhzKSB7XG4gICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgfVxuICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KG1vbSwgZGF5cyB8fCBtb250aHMpO1xuICAgIH1cbn1cblxudmFyIGFkZCAgICAgID0gY3JlYXRlQWRkZXIoMSwgJ2FkZCcpO1xudmFyIHN1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xuXG5mdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XG4gICAgdmFyIGRpZmYgPSBteU1vbWVudC5kaWZmKG5vdywgJ2RheXMnLCB0cnVlKTtcbiAgICByZXR1cm4gZGlmZiA8IC02ID8gJ3NhbWVFbHNlJyA6XG4gICAgICAgICAgICBkaWZmIDwgLTEgPyAnbGFzdFdlZWsnIDpcbiAgICAgICAgICAgIGRpZmYgPCAwID8gJ2xhc3REYXknIDpcbiAgICAgICAgICAgIGRpZmYgPCAxID8gJ3NhbWVEYXknIDpcbiAgICAgICAgICAgIGRpZmYgPCAyID8gJ25leHREYXknIDpcbiAgICAgICAgICAgIGRpZmYgPCA3ID8gJ25leHRXZWVrJyA6ICdzYW1lRWxzZSc7XG59XG5cbmZ1bmN0aW9uIGNhbGVuZGFyJDEgKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAvLyBXZSB3YW50IHRvIGNvbXBhcmUgdGhlIHN0YXJ0IG9mIHRvZGF5LCB2cyB0aGlzLlxuICAgIC8vIEdldHRpbmcgc3RhcnQtb2YtdG9kYXkgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIGxvY2FsL3V0Yy9vZmZzZXQgb3Igbm90LlxuICAgIHZhciBub3cgPSB0aW1lIHx8IGNyZWF0ZUxvY2FsKCksXG4gICAgICAgIHNvZCA9IGNsb25lV2l0aE9mZnNldChub3csIHRoaXMpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICBmb3JtYXQgPSBob29rcy5jYWxlbmRhckZvcm1hdCh0aGlzLCBzb2QpIHx8ICdzYW1lRWxzZSc7XG5cbiAgICB2YXIgb3V0cHV0ID0gZm9ybWF0cyAmJiAoaXNGdW5jdGlvbihmb3JtYXRzW2Zvcm1hdF0pID8gZm9ybWF0c1tmb3JtYXRdLmNhbGwodGhpcywgbm93KSA6IGZvcm1hdHNbZm9ybWF0XSk7XG5cbiAgICByZXR1cm4gdGhpcy5mb3JtYXQob3V0cHV0IHx8IHRoaXMubG9jYWxlRGF0YSgpLmNhbGVuZGFyKGZvcm1hdCwgdGhpcywgY3JlYXRlTG9jYWwobm93KSkpO1xufVxuXG5mdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBNb21lbnQodGhpcyk7XG59XG5cbmZ1bmN0aW9uIGlzQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID4gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsSW5wdXQudmFsdWVPZigpIDwgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHMoIWlzVW5kZWZpbmVkKHVuaXRzKSA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNCZXR3ZWVuIChmcm9tLCB0bywgdW5pdHMsIGluY2x1c2l2aXR5KSB7XG4gICAgaW5jbHVzaXZpdHkgPSBpbmNsdXNpdml0eSB8fCAnKCknO1xuICAgIHJldHVybiAoaW5jbHVzaXZpdHlbMF0gPT09ICcoJyA/IHRoaXMuaXNBZnRlcihmcm9tLCB1bml0cykgOiAhdGhpcy5pc0JlZm9yZShmcm9tLCB1bml0cykpICYmXG4gICAgICAgIChpbmNsdXNpdml0eVsxXSA9PT0gJyknID8gdGhpcy5pc0JlZm9yZSh0bywgdW5pdHMpIDogIXRoaXMuaXNBZnRlcih0bywgdW5pdHMpKTtcbn1cblxuZnVuY3Rpb24gaXNTYW1lIChpbnB1dCwgdW5pdHMpIHtcbiAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICBpbnB1dE1zO1xuICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMgfHwgJ21pbGxpc2Vjb25kJyk7XG4gICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA9PT0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKSA8PSBpbnB1dE1zICYmIGlucHV0TXMgPD0gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVPckFmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQWZ0ZXIoaW5wdXQsdW5pdHMpO1xufVxuXG5mdW5jdGlvbiBpc1NhbWVPckJlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0JlZm9yZShpbnB1dCx1bml0cyk7XG59XG5cbmZ1bmN0aW9uIGRpZmYgKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgIHZhciB0aGF0LFxuICAgICAgICB6b25lRGVsdGEsXG4gICAgICAgIGRlbHRhLCBvdXRwdXQ7XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyk7XG5cbiAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgaWYgKHVuaXRzID09PSAneWVhcicgfHwgdW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgLyAzO1xuICAgICAgICB9IGVsc2UgaWYgKHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCAvIDEyO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGVsdGEgPSB0aGlzIC0gdGhhdDtcbiAgICAgICAgb3V0cHV0ID0gdW5pdHMgPT09ICdzZWNvbmQnID8gZGVsdGEgLyAxZTMgOiAvLyAxMDAwXG4gICAgICAgICAgICB1bml0cyA9PT0gJ21pbnV0ZScgPyBkZWx0YSAvIDZlNCA6IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgdW5pdHMgPT09ICdob3VyJyA/IGRlbHRhIC8gMzZlNSA6IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgICAgICB1bml0cyA9PT0gJ2RheScgPyAoZGVsdGEgLSB6b25lRGVsdGEpIC8gODY0ZTUgOiAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICB1bml0cyA9PT0gJ3dlZWsnID8gKGRlbHRhIC0gem9uZURlbHRhKSAvIDYwNDhlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICBkZWx0YTtcbiAgICB9XG4gICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xufVxuXG5mdW5jdGlvbiBtb250aERpZmYgKGEsIGIpIHtcbiAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9ICgoYi55ZWFyKCkgLSBhLnllYXIoKSkgKiAxMikgKyAoYi5tb250aCgpIC0gYS5tb250aCgpKSxcbiAgICAgICAgLy8gYiBpcyBpbiAoYW5jaG9yIC0gMSBtb250aCwgYW5jaG9yICsgMSBtb250aClcbiAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICBhbmNob3IyLCBhZGp1c3Q7XG5cbiAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiArIDEsICdtb250aHMnKTtcbiAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgIH1cblxuICAgIC8vY2hlY2sgZm9yIG5lZ2F0aXZlIHplcm8sIHJldHVybiB6ZXJvIGlmIG5lZ2F0aXZlIHplcm9cbiAgICByZXR1cm4gLSh3aG9sZU1vbnRoRGlmZiArIGFkanVzdCkgfHwgMDtcbn1cblxuaG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG5ob29rcy5kZWZhdWx0Rm9ybWF0VXRjID0gJ1lZWVktTU0tRERUSEg6bW06c3NbWl0nO1xuXG5mdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sb2NhbGUoJ2VuJykuZm9ybWF0KCdkZGQgTU1NIEREIFlZWVkgSEg6bW06c3MgW0dNVF1aWicpO1xufVxuXG5mdW5jdGlvbiB0b0lTT1N0cmluZygpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbSA9IHRoaXMuY2xvbmUoKS51dGMoKTtcbiAgICBpZiAobS55ZWFyKCkgPCAwIHx8IG0ueWVhcigpID4gOTk5OSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nKTtcbiAgICB9XG4gICAgaWYgKGlzRnVuY3Rpb24oRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcpKSB7XG4gICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBodW1hbiByZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIG1vbWVudCB0aGF0IGNhblxuICogYWxzbyBiZSBldmFsdWF0ZWQgdG8gZ2V0IGEgbmV3IG1vbWVudCB3aGljaCBpcyB0aGUgc2FtZVxuICpcbiAqIEBsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC9kb2NzL2FwaS91dGlsLmh0bWwjdXRpbF9jdXN0b21faW5zcGVjdF9mdW5jdGlvbl9vbl9vYmplY3RzXG4gKi9cbmZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuICdtb21lbnQuaW52YWxpZCgvKiAnICsgdGhpcy5faSArICcgKi8pJztcbiAgICB9XG4gICAgdmFyIGZ1bmMgPSAnbW9tZW50JztcbiAgICB2YXIgem9uZSA9ICcnO1xuICAgIGlmICghdGhpcy5pc0xvY2FsKCkpIHtcbiAgICAgICAgZnVuYyA9IHRoaXMudXRjT2Zmc2V0KCkgPT09IDAgPyAnbW9tZW50LnV0YycgOiAnbW9tZW50LnBhcnNlWm9uZSc7XG4gICAgICAgIHpvbmUgPSAnWic7XG4gICAgfVxuICAgIHZhciBwcmVmaXggPSAnWycgKyBmdW5jICsgJyhcIl0nO1xuICAgIHZhciB5ZWFyID0gKDAgPD0gdGhpcy55ZWFyKCkgJiYgdGhpcy55ZWFyKCkgPD0gOTk5OSkgPyAnWVlZWScgOiAnWVlZWVlZJztcbiAgICB2YXIgZGF0ZXRpbWUgPSAnLU1NLUREW1RdSEg6bW06c3MuU1NTJztcbiAgICB2YXIgc3VmZml4ID0gem9uZSArICdbXCIpXSc7XG5cbiAgICByZXR1cm4gdGhpcy5mb3JtYXQocHJlZml4ICsgeWVhciArIGRhdGV0aW1lICsgc3VmZml4KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0IChpbnB1dFN0cmluZykge1xuICAgIGlmICghaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKCkgPyBob29rcy5kZWZhdWx0Rm9ybWF0VXRjIDogaG9va3MuZGVmYXVsdEZvcm1hdDtcbiAgICB9XG4gICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyk7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbn1cblxuZnVuY3Rpb24gZnJvbSAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcbiAgICAgICAgICAgICBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7dG86IHRoaXMsIGZyb206IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZnJvbU5vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgIHJldHVybiB0aGlzLmZyb20oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG59XG5cbmZ1bmN0aW9uIHRvICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHtmcm9tOiB0aGlzLCB0bzogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0b05vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgIHJldHVybiB0aGlzLnRvKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xufVxuXG4vLyBJZiBwYXNzZWQgYSBsb2NhbGUga2V5LCBpdCB3aWxsIHNldCB0aGUgbG9jYWxlIGZvciB0aGlzXG4vLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG5mdW5jdGlvbiBsb2NhbGUgKGtleSkge1xuICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbmV3TG9jYWxlRGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxudmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4pO1xuXG5mdW5jdGlvbiBsb2NhbGVEYXRhICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xufVxuXG5mdW5jdGlvbiBzdGFydE9mICh1bml0cykge1xuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgIC8vIHRoZSBmb2xsb3dpbmcgc3dpdGNoIGludGVudGlvbmFsbHkgb21pdHMgYnJlYWsga2V5d29yZHNcbiAgICAvLyB0byB1dGlsaXplIGZhbGxpbmcgdGhyb3VnaCB0aGUgY2FzZXMuXG4gICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgIHRoaXMubW9udGgoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICB0aGlzLmRhdGUoMSk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICB0aGlzLmhvdXJzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgIHRoaXMubWludXRlcygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kcygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgIHRoaXMubWlsbGlzZWNvbmRzKDApO1xuICAgIH1cblxuICAgIC8vIHdlZWtzIGFyZSBhIHNwZWNpYWwgY2FzZVxuICAgIGlmICh1bml0cyA9PT0gJ3dlZWsnKSB7XG4gICAgICAgIHRoaXMud2Vla2RheSgwKTtcbiAgICB9XG4gICAgaWYgKHVuaXRzID09PSAnaXNvV2VlaycpIHtcbiAgICAgICAgdGhpcy5pc29XZWVrZGF5KDEpO1xuICAgIH1cblxuICAgIC8vIHF1YXJ0ZXJzIGFyZSBhbHNvIHNwZWNpYWxcbiAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICB0aGlzLm1vbnRoKE1hdGguZmxvb3IodGhpcy5tb250aCgpIC8gMykgKiAzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZW5kT2YgKHVuaXRzKSB7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gJ2RhdGUnIGlzIGFuIGFsaWFzIGZvciAnZGF5Jywgc28gaXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgc3VjaC5cbiAgICBpZiAodW5pdHMgPT09ICdkYXRlJykge1xuICAgICAgICB1bml0cyA9ICdkYXknO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0YXJ0T2YodW5pdHMpLmFkZCgxLCAodW5pdHMgPT09ICdpc29XZWVrJyA/ICd3ZWVrJyA6IHVuaXRzKSkuc3VidHJhY3QoMSwgJ21zJyk7XG59XG5cbmZ1bmN0aW9uIHZhbHVlT2YgKCkge1xuICAgIHJldHVybiB0aGlzLl9kLnZhbHVlT2YoKSAtICgodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDApO1xufVxuXG5mdW5jdGlvbiB1bml4ICgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnZhbHVlT2YoKSAvIDEwMDApO1xufVxuXG5mdW5jdGlvbiB0b0RhdGUgKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkgKCkge1xuICAgIHZhciBtID0gdGhpcztcbiAgICByZXR1cm4gW20ueWVhcigpLCBtLm1vbnRoKCksIG0uZGF0ZSgpLCBtLmhvdXIoKSwgbS5taW51dGUoKSwgbS5zZWNvbmQoKSwgbS5taWxsaXNlY29uZCgpXTtcbn1cblxuZnVuY3Rpb24gdG9PYmplY3QgKCkge1xuICAgIHZhciBtID0gdGhpcztcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyczogbS55ZWFyKCksXG4gICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICBkYXRlOiBtLmRhdGUoKSxcbiAgICAgICAgaG91cnM6IG0uaG91cnMoKSxcbiAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxuICAgICAgICBtaWxsaXNlY29uZHM6IG0ubWlsbGlzZWNvbmRzKClcbiAgICB9O1xufVxuXG5mdW5jdGlvbiB0b0pTT04gKCkge1xuICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLnRvSVNPU3RyaW5nKCkgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkJDIgKCkge1xuICAgIHJldHVybiBpc1ZhbGlkKHRoaXMpO1xufVxuXG5mdW5jdGlvbiBwYXJzaW5nRmxhZ3MgKCkge1xuICAgIHJldHVybiBleHRlbmQoe30sIGdldFBhcnNpbmdGbGFncyh0aGlzKSk7XG59XG5cbmZ1bmN0aW9uIGludmFsaWRBdCAoKSB7XG4gICAgcmV0dXJuIGdldFBhcnNpbmdGbGFncyh0aGlzKS5vdmVyZmxvdztcbn1cblxuZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlucHV0OiB0aGlzLl9pLFxuICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICBpc1VUQzogdGhpcy5faXNVVEMsXG4gICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0XG4gICAgfTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ2dnJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnR0cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG59KTtcblxuZnVuY3Rpb24gYWRkV2Vla1llYXJGb3JtYXRUb2tlbiAodG9rZW4sIGdldHRlcikge1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgdG9rZW4ubGVuZ3RoXSwgMCwgZ2V0dGVyKTtcbn1cblxuYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZycsICAgICAnd2Vla1llYXInKTtcbmFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2dnJywgICAgJ3dlZWtZZWFyJyk7XG5hZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgICdpc29XZWVrWWVhcicpO1xuYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHR0cnLCAnaXNvV2Vla1llYXInKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3dlZWtZZWFyJywgJ2dnJyk7XG5hZGRVbml0QWxpYXMoJ2lzb1dlZWtZZWFyJywgJ0dHJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnd2Vla1llYXInLCAxKTtcbmFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla1llYXInLCAxKTtcblxuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ0cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ2cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ0dHJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ2dnJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ0dHR0cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbmFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbmFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbmFkZFJlZ2V4VG9rZW4oJ2dnZ2dnJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xufSk7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG59KTtcblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRTZXRXZWVrWWVhciAoaW5wdXQpIHtcbiAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICB0aGlzLndlZWsoKSxcbiAgICAgICAgICAgIHRoaXMud2Vla2RheSgpLFxuICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LFxuICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG95KTtcbn1cblxuZnVuY3Rpb24gZ2V0U2V0SVNPV2Vla1llYXIgKGlucHV0KSB7XG4gICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgIGlucHV0LCB0aGlzLmlzb1dlZWsoKSwgdGhpcy5pc29XZWVrZGF5KCksIDEsIDQpO1xufVxuXG5mdW5jdGlvbiBnZXRJU09XZWVrc0luWWVhciAoKSB7XG4gICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCAxLCA0KTtcbn1cblxuZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIgKCkge1xuICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRXZWVrWWVhckhlbHBlcihpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICB2YXIgd2Vla3NUYXJnZXQ7XG4gICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIodGhpcywgZG93LCBkb3kpLnllYXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xuICAgICAgICBpZiAod2VlayA+IHdlZWtzVGFyZ2V0KSB7XG4gICAgICAgICAgICB3ZWVrID0gd2Vla3NUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldFdlZWtBbGwuY2FsbCh0aGlzLCBpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0V2Vla0FsbCh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICB2YXIgZGF5T2ZZZWFyRGF0YSA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpLFxuICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcblxuICAgIHRoaXMueWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpO1xuICAgIHRoaXMubW9udGgoZGF0ZS5nZXRVVENNb250aCgpKTtcbiAgICB0aGlzLmRhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdRJywgMCwgJ1FvJywgJ3F1YXJ0ZXInKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ3F1YXJ0ZXInLCA3KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbmFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbn0pO1xuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIgKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMykgOiB0aGlzLm1vbnRoKChpbnB1dCAtIDEpICogMyArIHRoaXMubW9udGgoKSAlIDMpO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdEJywgWydERCcsIDJdLCAnRG8nLCAnZGF0ZScpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XG5cbi8vIFBSSU9ST0lUWVxuYWRkVW5pdFByaW9yaXR5KCdkYXRlJywgOSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignRCcsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignREQnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdEbycsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgIHJldHVybiBpc1N0cmljdCA/XG4gICAgICAobG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlIHx8IGxvY2FsZS5fb3JkaW5hbFBhcnNlKSA6XG4gICAgICBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50O1xufSk7XG5cbmFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbREFURV0gPSB0b0ludChpbnB1dC5tYXRjaChtYXRjaDF0bzIpWzBdLCAxMCk7XG59KTtcblxuLy8gTU9NRU5UU1xuXG52YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnZGF5T2ZZZWFyJywgJ0RERCcpO1xuXG4vLyBQUklPUklUWVxuYWRkVW5pdFByaW9yaXR5KCdkYXlPZlllYXInLCA0KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdEREQnLCAgbWF0Y2gxdG8zKTtcbmFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xuYWRkUGFyc2VUb2tlbihbJ0RERCcsICdEREREJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdG9JbnQoaW5wdXQpO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRTZXREYXlPZlllYXIgKGlucHV0KSB7XG4gICAgdmFyIGRheU9mWWVhciA9IE1hdGgucm91bmQoKHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKSAtIHRoaXMuY2xvbmUoKS5zdGFydE9mKCd5ZWFyJykpIC8gODY0ZTUpICsgMTtcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIGRheU9mWWVhciksICdkJyk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ20nLCBbJ21tJywgMl0sIDAsICdtaW51dGUnKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ21pbnV0ZScsICdtJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnbWludXRlJywgMTQpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ20nLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUGFyc2VUb2tlbihbJ20nLCAnbW0nXSwgTUlOVVRFKTtcblxuLy8gTU9NRU5UU1xuXG52YXIgZ2V0U2V0TWludXRlID0gbWFrZUdldFNldCgnTWludXRlcycsIGZhbHNlKTtcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbigncycsIFsnc3MnLCAyXSwgMCwgJ3NlY29uZCcpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnc2Vjb25kJywgJ3MnKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCdzZWNvbmQnLCAxNSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbigncycsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRQYXJzZVRva2VuKFsncycsICdzcyddLCBTRUNPTkQpO1xuXG4vLyBNT01FTlRTXG5cbnZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwO1xufSk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDAwO1xufSk7XG5cblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ21pbGxpc2Vjb25kJywgJ21zJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnbWlsbGlzZWNvbmQnLCAxNik7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignUycsICAgIG1hdGNoMXRvMywgbWF0Y2gxKTtcbmFkZFJlZ2V4VG9rZW4oJ1NTJywgICBtYXRjaDF0bzMsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdTU1MnLCAgbWF0Y2gxdG8zLCBtYXRjaDMpO1xuXG52YXIgdG9rZW47XG5mb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgYWRkUmVnZXhUb2tlbih0b2tlbiwgbWF0Y2hVbnNpZ25lZCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbTUlMTElTRUNPTkRdID0gdG9JbnQoKCcwLicgKyBpbnB1dCkgKiAxMDAwKTtcbn1cblxuZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIHBhcnNlTXMpO1xufVxuLy8gTU9NRU5UU1xuXG52YXIgZ2V0U2V0TWlsbGlzZWNvbmQgPSBtYWtlR2V0U2V0KCdNaWxsaXNlY29uZHMnLCBmYWxzZSk7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ3onLCAgMCwgMCwgJ3pvbmVBYmJyJyk7XG5hZGRGb3JtYXRUb2tlbignenonLCAwLCAwLCAnem9uZU5hbWUnKTtcblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRab25lQWJiciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0Wm9uZU5hbWUgKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZScgOiAnJztcbn1cblxudmFyIHByb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxucHJvdG8uYWRkICAgICAgICAgICAgICAgPSBhZGQ7XG5wcm90by5jYWxlbmRhciAgICAgICAgICA9IGNhbGVuZGFyJDE7XG5wcm90by5jbG9uZSAgICAgICAgICAgICA9IGNsb25lO1xucHJvdG8uZGlmZiAgICAgICAgICAgICAgPSBkaWZmO1xucHJvdG8uZW5kT2YgICAgICAgICAgICAgPSBlbmRPZjtcbnByb3RvLmZvcm1hdCAgICAgICAgICAgID0gZm9ybWF0O1xucHJvdG8uZnJvbSAgICAgICAgICAgICAgPSBmcm9tO1xucHJvdG8uZnJvbU5vdyAgICAgICAgICAgPSBmcm9tTm93O1xucHJvdG8udG8gICAgICAgICAgICAgICAgPSB0bztcbnByb3RvLnRvTm93ICAgICAgICAgICAgID0gdG9Ob3c7XG5wcm90by5nZXQgICAgICAgICAgICAgICA9IHN0cmluZ0dldDtcbnByb3RvLmludmFsaWRBdCAgICAgICAgID0gaW52YWxpZEF0O1xucHJvdG8uaXNBZnRlciAgICAgICAgICAgPSBpc0FmdGVyO1xucHJvdG8uaXNCZWZvcmUgICAgICAgICAgPSBpc0JlZm9yZTtcbnByb3RvLmlzQmV0d2VlbiAgICAgICAgID0gaXNCZXR3ZWVuO1xucHJvdG8uaXNTYW1lICAgICAgICAgICAgPSBpc1NhbWU7XG5wcm90by5pc1NhbWVPckFmdGVyICAgICA9IGlzU2FtZU9yQWZ0ZXI7XG5wcm90by5pc1NhbWVPckJlZm9yZSAgICA9IGlzU2FtZU9yQmVmb3JlO1xucHJvdG8uaXNWYWxpZCAgICAgICAgICAgPSBpc1ZhbGlkJDI7XG5wcm90by5sYW5nICAgICAgICAgICAgICA9IGxhbmc7XG5wcm90by5sb2NhbGUgICAgICAgICAgICA9IGxvY2FsZTtcbnByb3RvLmxvY2FsZURhdGEgICAgICAgID0gbG9jYWxlRGF0YTtcbnByb3RvLm1heCAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWF4O1xucHJvdG8ubWluICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNaW47XG5wcm90by5wYXJzaW5nRmxhZ3MgICAgICA9IHBhcnNpbmdGbGFncztcbnByb3RvLnNldCAgICAgICAgICAgICAgID0gc3RyaW5nU2V0O1xucHJvdG8uc3RhcnRPZiAgICAgICAgICAgPSBzdGFydE9mO1xucHJvdG8uc3VidHJhY3QgICAgICAgICAgPSBzdWJ0cmFjdDtcbnByb3RvLnRvQXJyYXkgICAgICAgICAgID0gdG9BcnJheTtcbnByb3RvLnRvT2JqZWN0ICAgICAgICAgID0gdG9PYmplY3Q7XG5wcm90by50b0RhdGUgICAgICAgICAgICA9IHRvRGF0ZTtcbnByb3RvLnRvSVNPU3RyaW5nICAgICAgID0gdG9JU09TdHJpbmc7XG5wcm90by5pbnNwZWN0ICAgICAgICAgICA9IGluc3BlY3Q7XG5wcm90by50b0pTT04gICAgICAgICAgICA9IHRvSlNPTjtcbnByb3RvLnRvU3RyaW5nICAgICAgICAgID0gdG9TdHJpbmc7XG5wcm90by51bml4ICAgICAgICAgICAgICA9IHVuaXg7XG5wcm90by52YWx1ZU9mICAgICAgICAgICA9IHZhbHVlT2Y7XG5wcm90by5jcmVhdGlvbkRhdGEgICAgICA9IGNyZWF0aW9uRGF0YTtcblxuLy8gWWVhclxucHJvdG8ueWVhciAgICAgICA9IGdldFNldFllYXI7XG5wcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcblxuLy8gV2VlayBZZWFyXG5wcm90by53ZWVrWWVhciAgICA9IGdldFNldFdlZWtZZWFyO1xucHJvdG8uaXNvV2Vla1llYXIgPSBnZXRTZXRJU09XZWVrWWVhcjtcblxuLy8gUXVhcnRlclxucHJvdG8ucXVhcnRlciA9IHByb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcblxuLy8gTW9udGhcbnByb3RvLm1vbnRoICAgICAgID0gZ2V0U2V0TW9udGg7XG5wcm90by5kYXlzSW5Nb250aCA9IGdldERheXNJbk1vbnRoO1xuXG4vLyBXZWVrXG5wcm90by53ZWVrICAgICAgICAgICA9IHByb3RvLndlZWtzICAgICAgICA9IGdldFNldFdlZWs7XG5wcm90by5pc29XZWVrICAgICAgICA9IHByb3RvLmlzb1dlZWtzICAgICA9IGdldFNldElTT1dlZWs7XG5wcm90by53ZWVrc0luWWVhciAgICA9IGdldFdlZWtzSW5ZZWFyO1xucHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcblxuLy8gRGF5XG5wcm90by5kYXRlICAgICAgID0gZ2V0U2V0RGF5T2ZNb250aDtcbnByb3RvLmRheSAgICAgICAgPSBwcm90by5kYXlzICAgICAgICAgICAgID0gZ2V0U2V0RGF5T2ZXZWVrO1xucHJvdG8ud2Vla2RheSAgICA9IGdldFNldExvY2FsZURheU9mV2VlaztcbnByb3RvLmlzb1dlZWtkYXkgPSBnZXRTZXRJU09EYXlPZldlZWs7XG5wcm90by5kYXlPZlllYXIgID0gZ2V0U2V0RGF5T2ZZZWFyO1xuXG4vLyBIb3VyXG5wcm90by5ob3VyID0gcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xuXG4vLyBNaW51dGVcbnByb3RvLm1pbnV0ZSA9IHByb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG5cbi8vIFNlY29uZFxucHJvdG8uc2Vjb25kID0gcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcblxuLy8gTWlsbGlzZWNvbmRcbnByb3RvLm1pbGxpc2Vjb25kID0gcHJvdG8ubWlsbGlzZWNvbmRzID0gZ2V0U2V0TWlsbGlzZWNvbmQ7XG5cbi8vIE9mZnNldFxucHJvdG8udXRjT2Zmc2V0ICAgICAgICAgICAgPSBnZXRTZXRPZmZzZXQ7XG5wcm90by51dGMgICAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvVVRDO1xucHJvdG8ubG9jYWwgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb0xvY2FsO1xucHJvdG8ucGFyc2Vab25lICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldDtcbnByb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG5wcm90by5pc0RTVCAgICAgICAgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xucHJvdG8uaXNMb2NhbCAgICAgICAgICAgICAgPSBpc0xvY2FsO1xucHJvdG8uaXNVdGNPZmZzZXQgICAgICAgICAgPSBpc1V0Y09mZnNldDtcbnByb3RvLmlzVXRjICAgICAgICAgICAgICAgID0gaXNVdGM7XG5wcm90by5pc1VUQyAgICAgICAgICAgICAgICA9IGlzVXRjO1xuXG4vLyBUaW1lem9uZVxucHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcbnByb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG5cbi8vIERlcHJlY2F0aW9uc1xucHJvdG8uZGF0ZXMgID0gZGVwcmVjYXRlKCdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsIGdldFNldERheU9mTW9udGgpO1xucHJvdG8ubW9udGhzID0gZGVwcmVjYXRlKCdtb250aHMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbnRoIGluc3RlYWQnLCBnZXRTZXRNb250aCk7XG5wcm90by55ZWFycyAgPSBkZXByZWNhdGUoJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLCBnZXRTZXRZZWFyKTtcbnByb3RvLnpvbmUgICA9IGRlcHJlY2F0ZSgnbW9tZW50KCkuem9uZSBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50KCkudXRjT2Zmc2V0IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3Mvem9uZS8nLCBnZXRTZXRab25lKTtcbnByb3RvLmlzRFNUU2hpZnRlZCA9IGRlcHJlY2F0ZSgnaXNEU1RTaGlmdGVkIGlzIGRlcHJlY2F0ZWQuIFNlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RzdC1zaGlmdGVkLyBmb3IgbW9yZSBpbmZvcm1hdGlvbicsIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVVuaXggKGlucHV0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluWm9uZSAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG59XG5cbmZ1bmN0aW9uIHByZVBhcnNlUG9zdEZvcm1hdCAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZztcbn1cblxudmFyIHByb3RvJDEgPSBMb2NhbGUucHJvdG90eXBlO1xuXG5wcm90byQxLmNhbGVuZGFyICAgICAgICA9IGNhbGVuZGFyO1xucHJvdG8kMS5sb25nRGF0ZUZvcm1hdCAgPSBsb25nRGF0ZUZvcm1hdDtcbnByb3RvJDEuaW52YWxpZERhdGUgICAgID0gaW52YWxpZERhdGU7XG5wcm90byQxLm9yZGluYWwgICAgICAgICA9IG9yZGluYWw7XG5wcm90byQxLnByZXBhcnNlICAgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbnByb3RvJDEucG9zdGZvcm1hdCAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xucHJvdG8kMS5yZWxhdGl2ZVRpbWUgICAgPSByZWxhdGl2ZVRpbWU7XG5wcm90byQxLnBhc3RGdXR1cmUgICAgICA9IHBhc3RGdXR1cmU7XG5wcm90byQxLnNldCAgICAgICAgICAgICA9IHNldDtcblxuLy8gTW9udGhcbnByb3RvJDEubW9udGhzICAgICAgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzO1xucHJvdG8kMS5tb250aHNTaG9ydCAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNTaG9ydDtcbnByb3RvJDEubW9udGhzUGFyc2UgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzUGFyc2U7XG5wcm90byQxLm1vbnRoc1JlZ2V4ICAgICAgID0gbW9udGhzUmVnZXg7XG5wcm90byQxLm1vbnRoc1Nob3J0UmVnZXggID0gbW9udGhzU2hvcnRSZWdleDtcblxuLy8gV2Vla1xucHJvdG8kMS53ZWVrID0gbG9jYWxlV2VlaztcbnByb3RvJDEuZmlyc3REYXlPZlllYXIgPSBsb2NhbGVGaXJzdERheU9mWWVhcjtcbnByb3RvJDEuZmlyc3REYXlPZldlZWsgPSBsb2NhbGVGaXJzdERheU9mV2VlaztcblxuLy8gRGF5IG9mIFdlZWtcbnByb3RvJDEud2Vla2RheXMgICAgICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXM7XG5wcm90byQxLndlZWtkYXlzTWluICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzTWluO1xucHJvdG8kMS53ZWVrZGF5c1Nob3J0ICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1Nob3J0O1xucHJvdG8kMS53ZWVrZGF5c1BhcnNlICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1BhcnNlO1xuXG5wcm90byQxLndlZWtkYXlzUmVnZXggICAgICAgPSAgICAgICAgd2Vla2RheXNSZWdleDtcbnByb3RvJDEud2Vla2RheXNTaG9ydFJlZ2V4ICA9ICAgICAgICB3ZWVrZGF5c1Nob3J0UmVnZXg7XG5wcm90byQxLndlZWtkYXlzTWluUmVnZXggICAgPSAgICAgICAgd2Vla2RheXNNaW5SZWdleDtcblxuLy8gSG91cnNcbnByb3RvJDEuaXNQTSA9IGxvY2FsZUlzUE07XG5wcm90byQxLm1lcmlkaWVtID0gbG9jYWxlTWVyaWRpZW07XG5cbmZ1bmN0aW9uIGdldCQxIChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgdmFyIGxvY2FsZSA9IGdldExvY2FsZSgpO1xuICAgIHZhciB1dGMgPSBjcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XG4gICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xufVxuXG5mdW5jdGlvbiBsaXN0TW9udGhzSW1wbCAoZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcblxuICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgaSwgZmllbGQsICdtb250aCcpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuXG4vLyAoKVxuLy8gKDUpXG4vLyAoZm10LCA1KVxuLy8gKGZtdClcbi8vICh0cnVlKVxuLy8gKHRydWUsIDUpXG4vLyAodHJ1ZSwgZm10LCA1KVxuLy8gKHRydWUsIGZtdClcbmZ1bmN0aW9uIGxpc3RXZWVrZGF5c0ltcGwgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICBpZiAodHlwZW9mIGxvY2FsZVNvcnRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3JtYXQgPSBsb2NhbGVTb3J0ZWQ7XG4gICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICBsb2NhbGVTb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgfVxuXG4gICAgdmFyIGxvY2FsZSA9IGdldExvY2FsZSgpLFxuICAgICAgICBzaGlmdCA9IGxvY2FsZVNvcnRlZCA/IGxvY2FsZS5fd2Vlay5kb3cgOiAwO1xuXG4gICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgKGluZGV4ICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIChpICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gbGlzdE1vbnRocyAoZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzJyk7XG59XG5cbmZ1bmN0aW9uIGxpc3RNb250aHNTaG9ydCAoZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnKTtcbn1cblxuZnVuY3Rpb24gbGlzdFdlZWtkYXlzIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5cycpO1xufVxuXG5mdW5jdGlvbiBsaXN0V2Vla2RheXNTaG9ydCAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcpO1xufVxuXG5mdW5jdGlvbiBsaXN0V2Vla2RheXNNaW4gKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJyk7XG59XG5cbmdldFNldEdsb2JhbExvY2FsZSgnZW4nLCB7XG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcbiAgICAgICAgICAgIG91dHB1dCA9ICh0b0ludChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxuICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgfVxufSk7XG5cbi8vIFNpZGUgZWZmZWN0IGltcG9ydHNcbmhvb2tzLmxhbmcgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJywgZ2V0U2V0R2xvYmFsTG9jYWxlKTtcbmhvb2tzLmxhbmdEYXRhID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZ0RhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGVEYXRhIGluc3RlYWQuJywgZ2V0TG9jYWxlKTtcblxudmFyIG1hdGhBYnMgPSBNYXRoLmFicztcblxuZnVuY3Rpb24gYWJzICgpIHtcbiAgICB2YXIgZGF0YSAgICAgICAgICAgPSB0aGlzLl9kYXRhO1xuXG4gICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgIHRoaXMuX2RheXMgICAgICAgICA9IG1hdGhBYnModGhpcy5fZGF5cyk7XG4gICAgdGhpcy5fbW9udGhzICAgICAgID0gbWF0aEFicyh0aGlzLl9tb250aHMpO1xuXG4gICAgZGF0YS5taWxsaXNlY29uZHMgID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgZGF0YS5zZWNvbmRzICAgICAgID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgIGRhdGEubWludXRlcyAgICAgICA9IG1hdGhBYnMoZGF0YS5taW51dGVzKTtcbiAgICBkYXRhLmhvdXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEuaG91cnMpO1xuICAgIGRhdGEubW9udGhzICAgICAgICA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgIGRhdGEueWVhcnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS55ZWFycyk7XG5cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gYWRkU3VidHJhY3QkMSAoZHVyYXRpb24sIGlucHV0LCB2YWx1ZSwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIG90aGVyID0gY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICBkdXJhdGlvbi5fZGF5cyAgICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9kYXlzO1xuICAgIGR1cmF0aW9uLl9tb250aHMgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XG59XG5cbi8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbmZ1bmN0aW9uIGFkZCQxIChpbnB1dCwgdmFsdWUpIHtcbiAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIDEpO1xufVxuXG4vLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuZnVuY3Rpb24gc3VidHJhY3QkMSAoaW5wdXQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG59XG5cbmZ1bmN0aW9uIGFic0NlaWwgKG51bWJlcikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuICAgIHZhciBkYXlzICAgICAgICAgPSB0aGlzLl9kYXlzO1xuICAgIHZhciBtb250aHMgICAgICAgPSB0aGlzLl9tb250aHM7XG4gICAgdmFyIGRhdGEgICAgICAgICA9IHRoaXMuX2RhdGE7XG4gICAgdmFyIHNlY29uZHMsIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycywgbW9udGhzRnJvbURheXM7XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgaWYgKCEoKG1pbGxpc2Vjb25kcyA+PSAwICYmIGRheXMgPj0gMCAmJiBtb250aHMgPj0gMCkgfHxcbiAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPD0gMCAmJiBkYXlzIDw9IDAgJiYgbW9udGhzIDw9IDApKSkge1xuICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgIGRheXMgPSAwO1xuICAgICAgICBtb250aHMgPSAwO1xuICAgIH1cblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcbiAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXG4gICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgc2Vjb25kcyAgICAgICAgICAgPSBhYnNGbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcbiAgICBkYXRhLnNlY29uZHMgICAgICA9IHNlY29uZHMgJSA2MDtcblxuICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICBkYXRhLm1pbnV0ZXMgICAgICA9IG1pbnV0ZXMgJSA2MDtcblxuICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICBkYXRhLmhvdXJzICAgICAgICA9IGhvdXJzICUgMjQ7XG5cbiAgICBkYXlzICs9IGFic0Zsb29yKGhvdXJzIC8gMjQpO1xuXG4gICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgIG1vbnRoc0Zyb21EYXlzID0gYWJzRmxvb3IoZGF5c1RvTW9udGhzKGRheXMpKTtcbiAgICBtb250aHMgKz0gbW9udGhzRnJvbURheXM7XG4gICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgIHllYXJzID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgIG1vbnRocyAlPSAxMjtcblxuICAgIGRhdGEuZGF5cyAgID0gZGF5cztcbiAgICBkYXRhLm1vbnRocyA9IG1vbnRocztcbiAgICBkYXRhLnllYXJzICA9IHllYXJzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGRheXNUb01vbnRocyAoZGF5cykge1xuICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxMiBtb250aHMgPT09IDQ4MDBcbiAgICByZXR1cm4gZGF5cyAqIDQ4MDAgLyAxNDYwOTc7XG59XG5cbmZ1bmN0aW9uIG1vbnRoc1RvRGF5cyAobW9udGhzKSB7XG4gICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgcmV0dXJuIG1vbnRocyAqIDE0NjA5NyAvIDQ4MDA7XG59XG5cbmZ1bmN0aW9uIGFzICh1bml0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgdmFyIGRheXM7XG4gICAgdmFyIG1vbnRocztcbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuXG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICBkYXlzICAgPSB0aGlzLl9kYXlzICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzICsgZGF5c1RvTW9udGhzKGRheXMpO1xuICAgICAgICByZXR1cm4gdW5pdHMgPT09ICdtb250aCcgPyBtb250aHMgOiBtb250aHMgLyAxMjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBoYW5kbGUgbWlsbGlzZWNvbmRzIHNlcGFyYXRlbHkgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAoaXNzdWUgIzE4NjcpXG4gICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnICAgOiByZXR1cm4gZGF5cyAvIDcgICAgICsgbWlsbGlzZWNvbmRzIC8gNjA0OGU1O1xuICAgICAgICAgICAgY2FzZSAnZGF5JyAgICA6IHJldHVybiBkYXlzICAgICAgICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInICAgOiByZXR1cm4gZGF5cyAqIDI0ICAgICsgbWlsbGlzZWNvbmRzIC8gMzZlNTtcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZScgOiByZXR1cm4gZGF5cyAqIDE0NDAgICsgbWlsbGlzZWNvbmRzIC8gNmU0O1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJyA6IHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXG4gICAgICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6IHJldHVybiBNYXRoLmZsb29yKGRheXMgKiA4NjRlNSkgKyBtaWxsaXNlY29uZHM7XG4gICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBUT0RPOiBVc2UgdGhpcy5hcygnbXMnKT9cbmZ1bmN0aW9uIHZhbHVlT2YkMSAoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgK1xuICAgICAgICB0aGlzLl9kYXlzICogODY0ZTUgK1xuICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcbiAgICAgICAgdG9JbnQodGhpcy5fbW9udGhzIC8gMTIpICogMzE1MzZlNlxuICAgICk7XG59XG5cbmZ1bmN0aW9uIG1ha2VBcyAoYWxpYXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgfTtcbn1cblxudmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpO1xudmFyIGFzU2Vjb25kcyAgICAgID0gbWFrZUFzKCdzJyk7XG52YXIgYXNNaW51dGVzICAgICAgPSBtYWtlQXMoJ20nKTtcbnZhciBhc0hvdXJzICAgICAgICA9IG1ha2VBcygnaCcpO1xudmFyIGFzRGF5cyAgICAgICAgID0gbWFrZUFzKCdkJyk7XG52YXIgYXNXZWVrcyAgICAgICAgPSBtYWtlQXMoJ3cnKTtcbnZhciBhc01vbnRocyAgICAgICA9IG1ha2VBcygnTScpO1xudmFyIGFzWWVhcnMgICAgICAgID0gbWFrZUFzKCd5Jyk7XG5cbmZ1bmN0aW9uIGdldCQyICh1bml0cykge1xuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXNbdW5pdHMgKyAncyddKCkgOiBOYU47XG59XG5cbmZ1bmN0aW9uIG1ha2VHZXR0ZXIobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2RhdGFbbmFtZV0gOiBOYU47XG4gICAgfTtcbn1cblxudmFyIG1pbGxpc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ21pbGxpc2Vjb25kcycpO1xudmFyIHNlY29uZHMgICAgICA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKTtcbnZhciBtaW51dGVzICAgICAgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyk7XG52YXIgaG91cnMgICAgICAgID0gbWFrZUdldHRlcignaG91cnMnKTtcbnZhciBkYXlzICAgICAgICAgPSBtYWtlR2V0dGVyKCdkYXlzJyk7XG52YXIgbW9udGhzICAgICAgID0gbWFrZUdldHRlcignbW9udGhzJyk7XG52YXIgeWVhcnMgICAgICAgID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuZnVuY3Rpb24gd2Vla3MgKCkge1xuICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xufVxuXG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xudmFyIHRocmVzaG9sZHMgPSB7XG4gICAgc3M6IDQ0LCAgICAgICAgIC8vIGEgZmV3IHNlY29uZHMgdG8gc2Vjb25kc1xuICAgIHMgOiA0NSwgICAgICAgICAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgIG0gOiA0NSwgICAgICAgICAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICBoIDogMjIsICAgICAgICAgLy8gaG91cnMgdG8gZGF5XG4gICAgZCA6IDI2LCAgICAgICAgIC8vIGRheXMgdG8gbW9udGhcbiAgICBNIDogMTEgICAgICAgICAgLy8gbW9udGhzIHRvIHllYXJcbn07XG5cbi8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXG5mdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xufVxuXG5mdW5jdGlvbiByZWxhdGl2ZVRpbWUkMSAocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIGxvY2FsZSkge1xuICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uKHBvc05lZ0R1cmF0aW9uKS5hYnMoKTtcbiAgICB2YXIgc2Vjb25kcyAgPSByb3VuZChkdXJhdGlvbi5hcygncycpKTtcbiAgICB2YXIgbWludXRlcyAgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKTtcbiAgICB2YXIgaG91cnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygnaCcpKTtcbiAgICB2YXIgZGF5cyAgICAgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKTtcbiAgICB2YXIgbW9udGhzICAgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKTtcbiAgICB2YXIgeWVhcnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygneScpKTtcblxuICAgIHZhciBhID0gc2Vjb25kcyA8PSB0aHJlc2hvbGRzLnNzICYmIFsncycsIHNlY29uZHNdICB8fFxuICAgICAgICAgICAgc2Vjb25kcyA8IHRocmVzaG9sZHMucyAgICYmIFsnc3MnLCBzZWNvbmRzXSB8fFxuICAgICAgICAgICAgbWludXRlcyA8PSAxICAgICAgICAgICAgICYmIFsnbSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgbWludXRlcyA8IHRocmVzaG9sZHMubSAgICYmIFsnbW0nLCBtaW51dGVzXSB8fFxuICAgICAgICAgICAgaG91cnMgICA8PSAxICAgICAgICAgICAgICYmIFsnaCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgaG91cnMgICA8IHRocmVzaG9sZHMuaCAgICYmIFsnaGgnLCBob3Vyc10gICB8fFxuICAgICAgICAgICAgZGF5cyAgICA8PSAxICAgICAgICAgICAgICYmIFsnZCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgZGF5cyAgICA8IHRocmVzaG9sZHMuZCAgICYmIFsnZGQnLCBkYXlzXSAgICB8fFxuICAgICAgICAgICAgbW9udGhzICA8PSAxICAgICAgICAgICAgICYmIFsnTSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgbW9udGhzICA8IHRocmVzaG9sZHMuTSAgICYmIFsnTU0nLCBtb250aHNdICB8fFxuICAgICAgICAgICAgeWVhcnMgICA8PSAxICAgICAgICAgICAgICYmIFsneSddICAgICAgICAgICB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XG4gICAgYVs0XSA9IGxvY2FsZTtcbiAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgdGhlIHJvdW5kaW5nIGZ1bmN0aW9uIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbmZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nIChyb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgaWYgKHJvdW5kaW5nRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcm91bmQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2Yocm91bmRpbmdGdW5jdGlvbikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcm91bmQgPSByb3VuZGluZ0Z1bmN0aW9uO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IGEgdGhyZXNob2xkIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbmZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCAodGhyZXNob2xkLCBsaW1pdCkge1xuICAgIGlmICh0aHJlc2hvbGRzW3RocmVzaG9sZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aHJlc2hvbGRzW3RocmVzaG9sZF07XG4gICAgfVxuICAgIHRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xuICAgIGlmICh0aHJlc2hvbGQgPT09ICdzJykge1xuICAgICAgICB0aHJlc2hvbGRzLnNzID0gbGltaXQgLSAxO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaHVtYW5pemUgKHdpdGhTdWZmaXgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgIH1cblxuICAgIHZhciBsb2NhbGUgPSB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICB2YXIgb3V0cHV0ID0gcmVsYXRpdmVUaW1lJDEodGhpcywgIXdpdGhTdWZmaXgsIGxvY2FsZSk7XG5cbiAgICBpZiAod2l0aFN1ZmZpeCkge1xuICAgICAgICBvdXRwdXQgPSBsb2NhbGUucGFzdEZ1dHVyZSgrdGhpcywgb3V0cHV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcbn1cblxudmFyIGFicyQxID0gTWF0aC5hYnM7XG5cbmZ1bmN0aW9uIHRvSVNPU3RyaW5nJDEoKSB7XG4gICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAvLyAgKiBtaWxsaXNlY29uZHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIGhvdXJzXG4gICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlcmUgaXMgbm8gY29udGV4dC1mcmVlIGNvbnZlcnNpb24gYmV0d2VlbiBob3VycyBhbmQgZGF5c1xuICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgc2Vjb25kcyA9IGFicyQxKHRoaXMuX21pbGxpc2Vjb25kcykgLyAxMDAwO1xuICAgIHZhciBkYXlzICAgICAgICAgPSBhYnMkMSh0aGlzLl9kYXlzKTtcbiAgICB2YXIgbW9udGhzICAgICAgID0gYWJzJDEodGhpcy5fbW9udGhzKTtcbiAgICB2YXIgbWludXRlcywgaG91cnMsIHllYXJzO1xuXG4gICAgLy8gMzYwMCBzZWNvbmRzIC0+IDYwIG1pbnV0ZXMgLT4gMSBob3VyXG4gICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICBzZWNvbmRzICU9IDYwO1xuICAgIG1pbnV0ZXMgJT0gNjA7XG5cbiAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgeWVhcnMgID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgIG1vbnRocyAlPSAxMjtcblxuXG4gICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcbiAgICB2YXIgWSA9IHllYXJzO1xuICAgIHZhciBNID0gbW9udGhzO1xuICAgIHZhciBEID0gZGF5cztcbiAgICB2YXIgaCA9IGhvdXJzO1xuICAgIHZhciBtID0gbWludXRlcztcbiAgICB2YXIgcyA9IHNlY29uZHM7XG4gICAgdmFyIHRvdGFsID0gdGhpcy5hc1NlY29uZHMoKTtcblxuICAgIGlmICghdG90YWwpIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXG4gICAgICAgIHJldHVybiAnUDBEJztcbiAgICB9XG5cbiAgICByZXR1cm4gKHRvdGFsIDwgMCA/ICctJyA6ICcnKSArXG4gICAgICAgICdQJyArXG4gICAgICAgIChZID8gWSArICdZJyA6ICcnKSArXG4gICAgICAgIChNID8gTSArICdNJyA6ICcnKSArXG4gICAgICAgIChEID8gRCArICdEJyA6ICcnKSArXG4gICAgICAgICgoaCB8fCBtIHx8IHMpID8gJ1QnIDogJycpICtcbiAgICAgICAgKGggPyBoICsgJ0gnIDogJycpICtcbiAgICAgICAgKG0gPyBtICsgJ00nIDogJycpICtcbiAgICAgICAgKHMgPyBzICsgJ1MnIDogJycpO1xufVxuXG52YXIgcHJvdG8kMiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxucHJvdG8kMi5pc1ZhbGlkICAgICAgICA9IGlzVmFsaWQkMTtcbnByb3RvJDIuYWJzICAgICAgICAgICAgPSBhYnM7XG5wcm90byQyLmFkZCAgICAgICAgICAgID0gYWRkJDE7XG5wcm90byQyLnN1YnRyYWN0ICAgICAgID0gc3VidHJhY3QkMTtcbnByb3RvJDIuYXMgICAgICAgICAgICAgPSBhcztcbnByb3RvJDIuYXNNaWxsaXNlY29uZHMgPSBhc01pbGxpc2Vjb25kcztcbnByb3RvJDIuYXNTZWNvbmRzICAgICAgPSBhc1NlY29uZHM7XG5wcm90byQyLmFzTWludXRlcyAgICAgID0gYXNNaW51dGVzO1xucHJvdG8kMi5hc0hvdXJzICAgICAgICA9IGFzSG91cnM7XG5wcm90byQyLmFzRGF5cyAgICAgICAgID0gYXNEYXlzO1xucHJvdG8kMi5hc1dlZWtzICAgICAgICA9IGFzV2Vla3M7XG5wcm90byQyLmFzTW9udGhzICAgICAgID0gYXNNb250aHM7XG5wcm90byQyLmFzWWVhcnMgICAgICAgID0gYXNZZWFycztcbnByb3RvJDIudmFsdWVPZiAgICAgICAgPSB2YWx1ZU9mJDE7XG5wcm90byQyLl9idWJibGUgICAgICAgID0gYnViYmxlO1xucHJvdG8kMi5nZXQgICAgICAgICAgICA9IGdldCQyO1xucHJvdG8kMi5taWxsaXNlY29uZHMgICA9IG1pbGxpc2Vjb25kcztcbnByb3RvJDIuc2Vjb25kcyAgICAgICAgPSBzZWNvbmRzO1xucHJvdG8kMi5taW51dGVzICAgICAgICA9IG1pbnV0ZXM7XG5wcm90byQyLmhvdXJzICAgICAgICAgID0gaG91cnM7XG5wcm90byQyLmRheXMgICAgICAgICAgID0gZGF5cztcbnByb3RvJDIud2Vla3MgICAgICAgICAgPSB3ZWVrcztcbnByb3RvJDIubW9udGhzICAgICAgICAgPSBtb250aHM7XG5wcm90byQyLnllYXJzICAgICAgICAgID0geWVhcnM7XG5wcm90byQyLmh1bWFuaXplICAgICAgID0gaHVtYW5pemU7XG5wcm90byQyLnRvSVNPU3RyaW5nICAgID0gdG9JU09TdHJpbmckMTtcbnByb3RvJDIudG9TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZyQxO1xucHJvdG8kMi50b0pTT04gICAgICAgICA9IHRvSVNPU3RyaW5nJDE7XG5wcm90byQyLmxvY2FsZSAgICAgICAgID0gbG9jYWxlO1xucHJvdG8kMi5sb2NhbGVEYXRhICAgICA9IGxvY2FsZURhdGE7XG5cbi8vIERlcHJlY2F0aW9uc1xucHJvdG8kMi50b0lzb1N0cmluZyA9IGRlcHJlY2F0ZSgndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLCB0b0lTT1N0cmluZyQxKTtcbnByb3RvJDIubGFuZyA9IGxhbmc7XG5cbi8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignWCcsIDAsIDAsICd1bml4Jyk7XG5hZGRGb3JtYXRUb2tlbigneCcsIDAsIDAsICd2YWx1ZU9mJyk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ1gnLCBtYXRjaFRpbWVzdGFtcCk7XG5hZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCwgMTApICogMTAwMCk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xufSk7XG5cbi8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuXG5ob29rcy52ZXJzaW9uID0gJzIuMTguMSc7XG5cbnNldEhvb2tDYWxsYmFjayhjcmVhdGVMb2NhbCk7XG5cbmhvb2tzLmZuICAgICAgICAgICAgICAgICAgICA9IHByb3RvO1xuaG9va3MubWluICAgICAgICAgICAgICAgICAgID0gbWluO1xuaG9va3MubWF4ICAgICAgICAgICAgICAgICAgID0gbWF4O1xuaG9va3Mubm93ICAgICAgICAgICAgICAgICAgID0gbm93O1xuaG9va3MudXRjICAgICAgICAgICAgICAgICAgID0gY3JlYXRlVVRDO1xuaG9va3MudW5peCAgICAgICAgICAgICAgICAgID0gY3JlYXRlVW5peDtcbmhvb2tzLm1vbnRocyAgICAgICAgICAgICAgICA9IGxpc3RNb250aHM7XG5ob29rcy5pc0RhdGUgICAgICAgICAgICAgICAgPSBpc0RhdGU7XG5ob29rcy5sb2NhbGUgICAgICAgICAgICAgICAgPSBnZXRTZXRHbG9iYWxMb2NhbGU7XG5ob29rcy5pbnZhbGlkICAgICAgICAgICAgICAgPSBjcmVhdGVJbnZhbGlkO1xuaG9va3MuZHVyYXRpb24gICAgICAgICAgICAgID0gY3JlYXRlRHVyYXRpb247XG5ob29rcy5pc01vbWVudCAgICAgICAgICAgICAgPSBpc01vbWVudDtcbmhvb2tzLndlZWtkYXlzICAgICAgICAgICAgICA9IGxpc3RXZWVrZGF5cztcbmhvb2tzLnBhcnNlWm9uZSAgICAgICAgICAgICA9IGNyZWF0ZUluWm9uZTtcbmhvb2tzLmxvY2FsZURhdGEgICAgICAgICAgICA9IGdldExvY2FsZTtcbmhvb2tzLmlzRHVyYXRpb24gICAgICAgICAgICA9IGlzRHVyYXRpb247XG5ob29rcy5tb250aHNTaG9ydCAgICAgICAgICAgPSBsaXN0TW9udGhzU2hvcnQ7XG5ob29rcy53ZWVrZGF5c01pbiAgICAgICAgICAgPSBsaXN0V2Vla2RheXNNaW47XG5ob29rcy5kZWZpbmVMb2NhbGUgICAgICAgICAgPSBkZWZpbmVMb2NhbGU7XG5ob29rcy51cGRhdGVMb2NhbGUgICAgICAgICAgPSB1cGRhdGVMb2NhbGU7XG5ob29rcy5sb2NhbGVzICAgICAgICAgICAgICAgPSBsaXN0TG9jYWxlcztcbmhvb2tzLndlZWtkYXlzU2hvcnQgICAgICAgICA9IGxpc3RXZWVrZGF5c1Nob3J0O1xuaG9va3Mubm9ybWFsaXplVW5pdHMgICAgICAgID0gbm9ybWFsaXplVW5pdHM7XG5ob29rcy5yZWxhdGl2ZVRpbWVSb3VuZGluZyA9IGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nO1xuaG9va3MucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuaG9va3MuY2FsZW5kYXJGb3JtYXQgICAgICAgID0gZ2V0Q2FsZW5kYXJGb3JtYXQ7XG5ob29rcy5wcm90b3R5cGUgICAgICAgICAgICAgPSBwcm90bztcblxucmV0dXJuIGhvb2tzO1xuXG59KSkpO1xuIiwiLyohIE5hdGl2ZSBQcm9taXNlIE9ubHlcbiAgICB2MC44LjEgKGMpIEt5bGUgU2ltcHNvblxuICAgIE1JVCBMaWNlbnNlOiBodHRwOi8vZ2V0aWZ5Lm1pdC1saWNlbnNlLm9yZ1xuKi9cblxuKGZ1bmN0aW9uIFVNRChuYW1lLGNvbnRleHQsZGVmaW5pdGlvbil7XG5cdC8vIHNwZWNpYWwgZm9ybSBvZiBVTUQgZm9yIHBvbHlmaWxsaW5nIGFjcm9zcyBldmlyb25tZW50c1xuXHRjb250ZXh0W25hbWVdID0gY29udGV4dFtuYW1lXSB8fCBkZWZpbml0aW9uKCk7XG5cdGlmICh0eXBlb2YgbW9kdWxlICE9IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMpIHsgbW9kdWxlLmV4cG9ydHMgPSBjb250ZXh0W25hbWVdOyB9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHsgZGVmaW5lKGZ1bmN0aW9uICRBTUQkKCl7IHJldHVybiBjb250ZXh0W25hbWVdOyB9KTsgfVxufSkoXCJQcm9taXNlXCIsdHlwZW9mIGdsb2JhbCAhPSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdGhpcyxmdW5jdGlvbiBERUYoKXtcblx0Lypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyIGJ1aWx0SW5Qcm9wLCBjeWNsZSwgc2NoZWR1bGluZ19xdWV1ZSxcblx0XHRUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG5cdFx0dGltZXIgPSAodHlwZW9mIHNldEltbWVkaWF0ZSAhPSBcInVuZGVmaW5lZFwiKSA/XG5cdFx0XHRmdW5jdGlvbiB0aW1lcihmbikgeyByZXR1cm4gc2V0SW1tZWRpYXRlKGZuKTsgfSA6XG5cdFx0XHRzZXRUaW1lb3V0XG5cdDtcblxuXHQvLyBkYW1taXQsIElFOC5cblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sXCJ4XCIse30pO1xuXHRcdGJ1aWx0SW5Qcm9wID0gZnVuY3Rpb24gYnVpbHRJblByb3Aob2JqLG5hbWUsdmFsLGNvbmZpZykge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosbmFtZSx7XG5cdFx0XHRcdHZhbHVlOiB2YWwsXG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IGNvbmZpZyAhPT0gZmFsc2Vcblx0XHRcdH0pO1xuXHRcdH07XG5cdH1cblx0Y2F0Y2ggKGVycikge1xuXHRcdGJ1aWx0SW5Qcm9wID0gZnVuY3Rpb24gYnVpbHRJblByb3Aob2JqLG5hbWUsdmFsKSB7XG5cdFx0XHRvYmpbbmFtZV0gPSB2YWw7XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH07XG5cdH1cblxuXHQvLyBOb3RlOiB1c2luZyBhIHF1ZXVlIGluc3RlYWQgb2YgYXJyYXkgZm9yIGVmZmljaWVuY3lcblx0c2NoZWR1bGluZ19xdWV1ZSA9IChmdW5jdGlvbiBRdWV1ZSgpIHtcblx0XHR2YXIgZmlyc3QsIGxhc3QsIGl0ZW07XG5cblx0XHRmdW5jdGlvbiBJdGVtKGZuLHNlbGYpIHtcblx0XHRcdHRoaXMuZm4gPSBmbjtcblx0XHRcdHRoaXMuc2VsZiA9IHNlbGY7XG5cdFx0XHR0aGlzLm5leHQgPSB2b2lkIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFkZDogZnVuY3Rpb24gYWRkKGZuLHNlbGYpIHtcblx0XHRcdFx0aXRlbSA9IG5ldyBJdGVtKGZuLHNlbGYpO1xuXHRcdFx0XHRpZiAobGFzdCkge1xuXHRcdFx0XHRcdGxhc3QubmV4dCA9IGl0ZW07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Zmlyc3QgPSBpdGVtO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxhc3QgPSBpdGVtO1xuXHRcdFx0XHRpdGVtID0gdm9pZCAwO1xuXHRcdFx0fSxcblx0XHRcdGRyYWluOiBmdW5jdGlvbiBkcmFpbigpIHtcblx0XHRcdFx0dmFyIGYgPSBmaXJzdDtcblx0XHRcdFx0Zmlyc3QgPSBsYXN0ID0gY3ljbGUgPSB2b2lkIDA7XG5cblx0XHRcdFx0d2hpbGUgKGYpIHtcblx0XHRcdFx0XHRmLmZuLmNhbGwoZi5zZWxmKTtcblx0XHRcdFx0XHRmID0gZi5uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSkoKTtcblxuXHRmdW5jdGlvbiBzY2hlZHVsZShmbixzZWxmKSB7XG5cdFx0c2NoZWR1bGluZ19xdWV1ZS5hZGQoZm4sc2VsZik7XG5cdFx0aWYgKCFjeWNsZSkge1xuXHRcdFx0Y3ljbGUgPSB0aW1lcihzY2hlZHVsaW5nX3F1ZXVlLmRyYWluKTtcblx0XHR9XG5cdH1cblxuXHQvLyBwcm9taXNlIGR1Y2sgdHlwaW5nXG5cdGZ1bmN0aW9uIGlzVGhlbmFibGUobykge1xuXHRcdHZhciBfdGhlbiwgb190eXBlID0gdHlwZW9mIG87XG5cblx0XHRpZiAobyAhPSBudWxsICYmXG5cdFx0XHQoXG5cdFx0XHRcdG9fdHlwZSA9PSBcIm9iamVjdFwiIHx8IG9fdHlwZSA9PSBcImZ1bmN0aW9uXCJcblx0XHRcdClcblx0XHQpIHtcblx0XHRcdF90aGVuID0gby50aGVuO1xuXHRcdH1cblx0XHRyZXR1cm4gdHlwZW9mIF90aGVuID09IFwiZnVuY3Rpb25cIiA/IF90aGVuIDogZmFsc2U7XG5cdH1cblxuXHRmdW5jdGlvbiBub3RpZnkoKSB7XG5cdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMuY2hhaW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdG5vdGlmeUlzb2xhdGVkKFxuXHRcdFx0XHR0aGlzLFxuXHRcdFx0XHQodGhpcy5zdGF0ZSA9PT0gMSkgPyB0aGlzLmNoYWluW2ldLnN1Y2Nlc3MgOiB0aGlzLmNoYWluW2ldLmZhaWx1cmUsXG5cdFx0XHRcdHRoaXMuY2hhaW5baV1cblx0XHRcdCk7XG5cdFx0fVxuXHRcdHRoaXMuY2hhaW4ubGVuZ3RoID0gMDtcblx0fVxuXG5cdC8vIE5PVEU6IFRoaXMgaXMgYSBzZXBhcmF0ZSBmdW5jdGlvbiB0byBpc29sYXRlXG5cdC8vIHRoZSBgdHJ5Li5jYXRjaGAgc28gdGhhdCBvdGhlciBjb2RlIGNhbiBiZVxuXHQvLyBvcHRpbWl6ZWQgYmV0dGVyXG5cdGZ1bmN0aW9uIG5vdGlmeUlzb2xhdGVkKHNlbGYsY2IsY2hhaW4pIHtcblx0XHR2YXIgcmV0LCBfdGhlbjtcblx0XHR0cnkge1xuXHRcdFx0aWYgKGNiID09PSBmYWxzZSkge1xuXHRcdFx0XHRjaGFpbi5yZWplY3Qoc2VsZi5tc2cpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmIChjYiA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdHJldCA9IHNlbGYubXNnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHJldCA9IGNiLmNhbGwodm9pZCAwLHNlbGYubXNnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChyZXQgPT09IGNoYWluLnByb21pc2UpIHtcblx0XHRcdFx0XHRjaGFpbi5yZWplY3QoVHlwZUVycm9yKFwiUHJvbWlzZS1jaGFpbiBjeWNsZVwiKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoX3RoZW4gPSBpc1RoZW5hYmxlKHJldCkpIHtcblx0XHRcdFx0XHRfdGhlbi5jYWxsKHJldCxjaGFpbi5yZXNvbHZlLGNoYWluLnJlamVjdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Y2hhaW4ucmVzb2x2ZShyZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdGNoYWluLnJlamVjdChlcnIpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlc29sdmUobXNnKSB7XG5cdFx0dmFyIF90aGVuLCBzZWxmID0gdGhpcztcblxuXHRcdC8vIGFscmVhZHkgdHJpZ2dlcmVkP1xuXHRcdGlmIChzZWxmLnRyaWdnZXJlZCkgeyByZXR1cm47IH1cblxuXHRcdHNlbGYudHJpZ2dlcmVkID0gdHJ1ZTtcblxuXHRcdC8vIHVud3JhcFxuXHRcdGlmIChzZWxmLmRlZikge1xuXHRcdFx0c2VsZiA9IHNlbGYuZGVmO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRpZiAoX3RoZW4gPSBpc1RoZW5hYmxlKG1zZykpIHtcblx0XHRcdFx0c2NoZWR1bGUoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHR2YXIgZGVmX3dyYXBwZXIgPSBuZXcgTWFrZURlZldyYXBwZXIoc2VsZik7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdF90aGVuLmNhbGwobXNnLFxuXHRcdFx0XHRcdFx0XHRmdW5jdGlvbiAkcmVzb2x2ZSQoKXsgcmVzb2x2ZS5hcHBseShkZWZfd3JhcHBlcixhcmd1bWVudHMpOyB9LFxuXHRcdFx0XHRcdFx0XHRmdW5jdGlvbiAkcmVqZWN0JCgpeyByZWplY3QuYXBwbHkoZGVmX3dyYXBwZXIsYXJndW1lbnRzKTsgfVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdFx0cmVqZWN0LmNhbGwoZGVmX3dyYXBwZXIsZXJyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c2VsZi5tc2cgPSBtc2c7XG5cdFx0XHRcdHNlbGYuc3RhdGUgPSAxO1xuXHRcdFx0XHRpZiAoc2VsZi5jaGFpbi5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0c2NoZWR1bGUobm90aWZ5LHNlbGYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdHJlamVjdC5jYWxsKG5ldyBNYWtlRGVmV3JhcHBlcihzZWxmKSxlcnIpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlamVjdChtc2cpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHQvLyBhbHJlYWR5IHRyaWdnZXJlZD9cblx0XHRpZiAoc2VsZi50cmlnZ2VyZWQpIHsgcmV0dXJuOyB9XG5cblx0XHRzZWxmLnRyaWdnZXJlZCA9IHRydWU7XG5cblx0XHQvLyB1bndyYXBcblx0XHRpZiAoc2VsZi5kZWYpIHtcblx0XHRcdHNlbGYgPSBzZWxmLmRlZjtcblx0XHR9XG5cblx0XHRzZWxmLm1zZyA9IG1zZztcblx0XHRzZWxmLnN0YXRlID0gMjtcblx0XHRpZiAoc2VsZi5jaGFpbi5sZW5ndGggPiAwKSB7XG5cdFx0XHRzY2hlZHVsZShub3RpZnksc2VsZik7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaXRlcmF0ZVByb21pc2VzKENvbnN0cnVjdG9yLGFycixyZXNvbHZlcixyZWplY3Rlcikge1xuXHRcdGZvciAodmFyIGlkeD0wOyBpZHg8YXJyLmxlbmd0aDsgaWR4KyspIHtcblx0XHRcdChmdW5jdGlvbiBJSUZFKGlkeCl7XG5cdFx0XHRcdENvbnN0cnVjdG9yLnJlc29sdmUoYXJyW2lkeF0pXG5cdFx0XHRcdC50aGVuKFxuXHRcdFx0XHRcdGZ1bmN0aW9uICRyZXNvbHZlciQobXNnKXtcblx0XHRcdFx0XHRcdHJlc29sdmVyKGlkeCxtc2cpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0cmVqZWN0ZXJcblx0XHRcdFx0KTtcblx0XHRcdH0pKGlkeCk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gTWFrZURlZldyYXBwZXIoc2VsZikge1xuXHRcdHRoaXMuZGVmID0gc2VsZjtcblx0XHR0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gTWFrZURlZihzZWxmKSB7XG5cdFx0dGhpcy5wcm9taXNlID0gc2VsZjtcblx0XHR0aGlzLnN0YXRlID0gMDtcblx0XHR0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xuXHRcdHRoaXMuY2hhaW4gPSBbXTtcblx0XHR0aGlzLm1zZyA9IHZvaWQgMDtcblx0fVxuXG5cdGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcblx0XHRpZiAodHlwZW9mIGV4ZWN1dG9yICE9IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX19OUE9fXyAhPT0gMCkge1xuXHRcdFx0dGhyb3cgVHlwZUVycm9yKFwiTm90IGEgcHJvbWlzZVwiKTtcblx0XHR9XG5cblx0XHQvLyBpbnN0YW5jZSBzaGFkb3dpbmcgdGhlIGluaGVyaXRlZCBcImJyYW5kXCJcblx0XHQvLyB0byBzaWduYWwgYW4gYWxyZWFkeSBcImluaXRpYWxpemVkXCIgcHJvbWlzZVxuXHRcdHRoaXMuX19OUE9fXyA9IDE7XG5cblx0XHR2YXIgZGVmID0gbmV3IE1ha2VEZWYodGhpcyk7XG5cblx0XHR0aGlzW1widGhlblwiXSA9IGZ1bmN0aW9uIHRoZW4oc3VjY2VzcyxmYWlsdXJlKSB7XG5cdFx0XHR2YXIgbyA9IHtcblx0XHRcdFx0c3VjY2VzczogdHlwZW9mIHN1Y2Nlc3MgPT0gXCJmdW5jdGlvblwiID8gc3VjY2VzcyA6IHRydWUsXG5cdFx0XHRcdGZhaWx1cmU6IHR5cGVvZiBmYWlsdXJlID09IFwiZnVuY3Rpb25cIiA/IGZhaWx1cmUgOiBmYWxzZVxuXHRcdFx0fTtcblx0XHRcdC8vIE5vdGU6IGB0aGVuKC4uKWAgaXRzZWxmIGNhbiBiZSBib3Jyb3dlZCB0byBiZSB1c2VkIGFnYWluc3Rcblx0XHRcdC8vIGEgZGlmZmVyZW50IHByb21pc2UgY29uc3RydWN0b3IgZm9yIG1ha2luZyB0aGUgY2hhaW5lZCBwcm9taXNlLFxuXHRcdFx0Ly8gYnkgc3Vic3RpdHV0aW5nIGEgZGlmZmVyZW50IGB0aGlzYCBiaW5kaW5nLlxuXHRcdFx0by5wcm9taXNlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZnVuY3Rpb24gZXh0cmFjdENoYWluKHJlc29sdmUscmVqZWN0KSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgcmVzb2x2ZSAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJlamVjdCAhPSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHR0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBmdW5jdGlvblwiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG8ucmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0XHRcdG8ucmVqZWN0ID0gcmVqZWN0O1xuXHRcdFx0fSk7XG5cdFx0XHRkZWYuY2hhaW4ucHVzaChvKTtcblxuXHRcdFx0aWYgKGRlZi5zdGF0ZSAhPT0gMCkge1xuXHRcdFx0XHRzY2hlZHVsZShub3RpZnksZGVmKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG8ucHJvbWlzZTtcblx0XHR9O1xuXHRcdHRoaXNbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uICRjYXRjaCQoZmFpbHVyZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMudGhlbih2b2lkIDAsZmFpbHVyZSk7XG5cdFx0fTtcblxuXHRcdHRyeSB7XG5cdFx0XHRleGVjdXRvci5jYWxsKFxuXHRcdFx0XHR2b2lkIDAsXG5cdFx0XHRcdGZ1bmN0aW9uIHB1YmxpY1Jlc29sdmUobXNnKXtcblx0XHRcdFx0XHRyZXNvbHZlLmNhbGwoZGVmLG1zZyk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIHB1YmxpY1JlamVjdChtc2cpIHtcblx0XHRcdFx0XHRyZWplY3QuY2FsbChkZWYsbXNnKTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9XG5cdFx0Y2F0Y2ggKGVycikge1xuXHRcdFx0cmVqZWN0LmNhbGwoZGVmLGVycik7XG5cdFx0fVxuXHR9XG5cblx0dmFyIFByb21pc2VQcm90b3R5cGUgPSBidWlsdEluUHJvcCh7fSxcImNvbnN0cnVjdG9yXCIsUHJvbWlzZSxcblx0XHQvKmNvbmZpZ3VyYWJsZT0qL2ZhbHNlXG5cdCk7XG5cblx0Ly8gTm90ZTogQW5kcm9pZCA0IGNhbm5vdCB1c2UgYE9iamVjdC5kZWZpbmVQcm9wZXJ0eSguLilgIGhlcmVcblx0UHJvbWlzZS5wcm90b3R5cGUgPSBQcm9taXNlUHJvdG90eXBlO1xuXG5cdC8vIGJ1aWx0LWluIFwiYnJhbmRcIiB0byBzaWduYWwgYW4gXCJ1bmluaXRpYWxpemVkXCIgcHJvbWlzZVxuXHRidWlsdEluUHJvcChQcm9taXNlUHJvdG90eXBlLFwiX19OUE9fX1wiLDAsXG5cdFx0Lypjb25maWd1cmFibGU9Ki9mYWxzZVxuXHQpO1xuXG5cdGJ1aWx0SW5Qcm9wKFByb21pc2UsXCJyZXNvbHZlXCIsZnVuY3Rpb24gUHJvbWlzZSRyZXNvbHZlKG1zZykge1xuXHRcdHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cblx0XHQvLyBzcGVjIG1hbmRhdGVkIGNoZWNrc1xuXHRcdC8vIG5vdGU6IGJlc3QgXCJpc1Byb21pc2VcIiBjaGVjayB0aGF0J3MgcHJhY3RpY2FsIGZvciBub3dcblx0XHRpZiAobXNnICYmIHR5cGVvZiBtc2cgPT0gXCJvYmplY3RcIiAmJiBtc2cuX19OUE9fXyA9PT0gMSkge1xuXHRcdFx0cmV0dXJuIG1zZztcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcblx0XHRcdGlmICh0eXBlb2YgcmVzb2x2ZSAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJlamVjdCAhPSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0dGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG5cdFx0XHR9XG5cblx0XHRcdHJlc29sdmUobXNnKTtcblx0XHR9KTtcblx0fSk7XG5cblx0YnVpbHRJblByb3AoUHJvbWlzZSxcInJlamVjdFwiLGZ1bmN0aW9uIFByb21pc2UkcmVqZWN0KG1zZykge1xuXHRcdHJldHVybiBuZXcgdGhpcyhmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG5cdFx0XHRpZiAodHlwZW9mIHJlc29sdmUgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByZWplY3QgIT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZWplY3QobXNnKTtcblx0XHR9KTtcblx0fSk7XG5cblx0YnVpbHRJblByb3AoUHJvbWlzZSxcImFsbFwiLGZ1bmN0aW9uIFByb21pc2UkYWxsKGFycikge1xuXHRcdHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cblx0XHQvLyBzcGVjIG1hbmRhdGVkIGNoZWNrc1xuXHRcdGlmIChUb1N0cmluZy5jYWxsKGFycikgIT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG5cdFx0XHRyZXR1cm4gQ29uc3RydWN0b3IucmVqZWN0KFR5cGVFcnJvcihcIk5vdCBhbiBhcnJheVwiKSk7XG5cdFx0fVxuXHRcdGlmIChhcnIubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gQ29uc3RydWN0b3IucmVzb2x2ZShbXSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG5cdFx0XHRpZiAodHlwZW9mIHJlc29sdmUgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByZWplY3QgIT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbGVuID0gYXJyLmxlbmd0aCwgbXNncyA9IEFycmF5KGxlbiksIGNvdW50ID0gMDtcblxuXHRcdFx0aXRlcmF0ZVByb21pc2VzKENvbnN0cnVjdG9yLGFycixmdW5jdGlvbiByZXNvbHZlcihpZHgsbXNnKSB7XG5cdFx0XHRcdG1zZ3NbaWR4XSA9IG1zZztcblx0XHRcdFx0aWYgKCsrY291bnQgPT09IGxlbikge1xuXHRcdFx0XHRcdHJlc29sdmUobXNncyk7XG5cdFx0XHRcdH1cblx0XHRcdH0scmVqZWN0KTtcblx0XHR9KTtcblx0fSk7XG5cblx0YnVpbHRJblByb3AoUHJvbWlzZSxcInJhY2VcIixmdW5jdGlvbiBQcm9taXNlJHJhY2UoYXJyKSB7XG5cdFx0dmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuXHRcdC8vIHNwZWMgbWFuZGF0ZWQgY2hlY2tzXG5cdFx0aWYgKFRvU3RyaW5nLmNhbGwoYXJyKSAhPSBcIltvYmplY3QgQXJyYXldXCIpIHtcblx0XHRcdHJldHVybiBDb25zdHJ1Y3Rvci5yZWplY3QoVHlwZUVycm9yKFwiTm90IGFuIGFycmF5XCIpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcblx0XHRcdGlmICh0eXBlb2YgcmVzb2x2ZSAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJlamVjdCAhPSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0dGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG5cdFx0XHR9XG5cblx0XHRcdGl0ZXJhdGVQcm9taXNlcyhDb25zdHJ1Y3RvcixhcnIsZnVuY3Rpb24gcmVzb2x2ZXIoaWR4LG1zZyl7XG5cdFx0XHRcdHJlc29sdmUobXNnKTtcblx0XHRcdH0scmVqZWN0KTtcblx0XHR9KTtcblx0fSk7XG5cblx0cmV0dXJuIFByb21pc2U7XG59KTtcbiIsIi8qISBAcHJlc2VydmVcbiAqIG51bWVyYWwuanNcbiAqIHZlcnNpb24gOiAyLjAuNlxuICogYXV0aG9yIDogQWRhbSBEcmFwZXJcbiAqIGxpY2Vuc2UgOiBNSVRcbiAqIGh0dHA6Ly9hZGFtd2RyYXBlci5naXRodWIuY29tL051bWVyYWwtanMvXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdsb2JhbC5udW1lcmFsID0gZmFjdG9yeSgpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgVmFyaWFibGVzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgdmFyIG51bWVyYWwsXG4gICAgICAgIF8sXG4gICAgICAgIFZFUlNJT04gPSAnMi4wLjYnLFxuICAgICAgICBmb3JtYXRzID0ge30sXG4gICAgICAgIGxvY2FsZXMgPSB7fSxcbiAgICAgICAgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBjdXJyZW50TG9jYWxlOiAnZW4nLFxuICAgICAgICAgICAgemVyb0Zvcm1hdDogbnVsbCxcbiAgICAgICAgICAgIG51bGxGb3JtYXQ6IG51bGwsXG4gICAgICAgICAgICBkZWZhdWx0Rm9ybWF0OiAnMCwwJyxcbiAgICAgICAgICAgIHNjYWxlUGVyY2VudEJ5MTAwOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBjdXJyZW50TG9jYWxlOiBkZWZhdWx0cy5jdXJyZW50TG9jYWxlLFxuICAgICAgICAgICAgemVyb0Zvcm1hdDogZGVmYXVsdHMuemVyb0Zvcm1hdCxcbiAgICAgICAgICAgIG51bGxGb3JtYXQ6IGRlZmF1bHRzLm51bGxGb3JtYXQsXG4gICAgICAgICAgICBkZWZhdWx0Rm9ybWF0OiBkZWZhdWx0cy5kZWZhdWx0Rm9ybWF0LFxuICAgICAgICAgICAgc2NhbGVQZXJjZW50QnkxMDA6IGRlZmF1bHRzLnNjYWxlUGVyY2VudEJ5MTAwXG4gICAgICAgIH07XG5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgQ29uc3RydWN0b3JzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLy8gTnVtZXJhbCBwcm90b3R5cGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gTnVtZXJhbChpbnB1dCwgbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cbiAgICAgICAgdGhpcy5fdmFsdWUgPSBudW1iZXI7XG4gICAgfVxuXG4gICAgbnVtZXJhbCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciB2YWx1ZSxcbiAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICB1bmZvcm1hdEZ1bmN0aW9uLFxuICAgICAgICAgICAgcmVnZXhwO1xuXG4gICAgICAgIGlmIChudW1lcmFsLmlzTnVtZXJhbChpbnB1dCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gaW5wdXQudmFsdWUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gMCB8fCB0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQgPT09IG51bGwgfHwgXy5pc05hTihpbnB1dCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy56ZXJvRm9ybWF0ICYmIGlucHV0ID09PSBvcHRpb25zLnplcm9Gb3JtYXQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMubnVsbEZvcm1hdCAmJiBpbnB1dCA9PT0gb3B0aW9ucy5udWxsRm9ybWF0IHx8ICFpbnB1dC5yZXBsYWNlKC9bXjAtOV0rL2csICcnKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoa2luZCBpbiBmb3JtYXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4cCA9IHR5cGVvZiBmb3JtYXRzW2tpbmRdLnJlZ2V4cHMudW5mb3JtYXQgPT09ICdmdW5jdGlvbicgPyBmb3JtYXRzW2tpbmRdLnJlZ2V4cHMudW5mb3JtYXQoKSA6IGZvcm1hdHNba2luZF0ucmVnZXhwcy51bmZvcm1hdDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVnZXhwICYmIGlucHV0Lm1hdGNoKHJlZ2V4cCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZm9ybWF0RnVuY3Rpb24gPSBmb3JtYXRzW2tpbmRdLnVuZm9ybWF0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHVuZm9ybWF0RnVuY3Rpb24gPSB1bmZvcm1hdEZ1bmN0aW9uIHx8IG51bWVyYWwuXy5zdHJpbmdUb051bWJlcjtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gdW5mb3JtYXRGdW5jdGlvbihpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IE51bWJlcihpbnB1dCl8fCBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBOdW1lcmFsKGlucHV0LCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIC8vIHZlcnNpb24gbnVtYmVyXG4gICAgbnVtZXJhbC52ZXJzaW9uID0gVkVSU0lPTjtcblxuICAgIC8vIGNvbXBhcmUgbnVtZXJhbCBvYmplY3RcbiAgICBudW1lcmFsLmlzTnVtZXJhbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgTnVtZXJhbDtcbiAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uc1xuICAgIG51bWVyYWwuXyA9IF8gPSB7XG4gICAgICAgIC8vIGZvcm1hdHMgbnVtYmVycyBzZXBhcmF0b3JzLCBkZWNpbWFscyBwbGFjZXMsIHNpZ25zLCBhYmJyZXZpYXRpb25zXG4gICAgICAgIG51bWJlclRvRm9ybWF0OiBmdW5jdGlvbih2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlID0gbG9jYWxlc1tudW1lcmFsLm9wdGlvbnMuY3VycmVudExvY2FsZV0sXG4gICAgICAgICAgICAgICAgbmVnUCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIG9wdERlYyA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxlYWRpbmdDb3VudCA9IDAsXG4gICAgICAgICAgICAgICAgYWJiciA9ICcnLFxuICAgICAgICAgICAgICAgIHRyaWxsaW9uID0gMTAwMDAwMDAwMDAwMCxcbiAgICAgICAgICAgICAgICBiaWxsaW9uID0gMTAwMDAwMDAwMCxcbiAgICAgICAgICAgICAgICBtaWxsaW9uID0gMTAwMDAwMCxcbiAgICAgICAgICAgICAgICB0aG91c2FuZCA9IDEwMDAsXG4gICAgICAgICAgICAgICAgZGVjaW1hbCA9ICcnLFxuICAgICAgICAgICAgICAgIG5lZyA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFiYnJGb3JjZSwgLy8gZm9yY2UgYWJicmV2aWF0aW9uXG4gICAgICAgICAgICAgICAgYWJzLFxuICAgICAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgICAgICBtYXgsXG4gICAgICAgICAgICAgICAgcG93ZXIsXG4gICAgICAgICAgICAgICAgaW50LFxuICAgICAgICAgICAgICAgIHByZWNpc2lvbixcbiAgICAgICAgICAgICAgICBzaWduZWQsXG4gICAgICAgICAgICAgICAgdGhvdXNhbmRzLFxuICAgICAgICAgICAgICAgIG91dHB1dDtcblxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIG5ldmVyIGZvcm1hdCBhIG51bGwgdmFsdWVcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgfHwgMDtcblxuICAgICAgICAgICAgYWJzID0gTWF0aC5hYnModmFsdWUpO1xuXG4gICAgICAgICAgICAvLyBzZWUgaWYgd2Ugc2hvdWxkIHVzZSBwYXJlbnRoZXNlcyBmb3IgbmVnYXRpdmUgbnVtYmVyIG9yIGlmIHdlIHNob3VsZCBwcmVmaXggd2l0aCBhIHNpZ25cbiAgICAgICAgICAgIC8vIGlmIGJvdGggYXJlIHByZXNlbnQgd2UgZGVmYXVsdCB0byBwYXJlbnRoZXNlc1xuICAgICAgICAgICAgaWYgKG51bWVyYWwuXy5pbmNsdWRlcyhmb3JtYXQsICcoJykpIHtcbiAgICAgICAgICAgICAgICBuZWdQID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvW1xcKHxcXCldL2csICcnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKGZvcm1hdCwgJysnKSB8fCBudW1lcmFsLl8uaW5jbHVkZXMoZm9ybWF0LCAnLScpKSB7XG4gICAgICAgICAgICAgICAgc2lnbmVkID0gbnVtZXJhbC5fLmluY2x1ZGVzKGZvcm1hdCwgJysnKSA/IGZvcm1hdC5pbmRleE9mKCcrJykgOiB2YWx1ZSA8IDAgPyBmb3JtYXQuaW5kZXhPZignLScpIDogLTE7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoL1tcXCt8XFwtXS9nLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNlZSBpZiBhYmJyZXZpYXRpb24gaXMgd2FudGVkXG4gICAgICAgICAgICBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKGZvcm1hdCwgJ2EnKSkge1xuICAgICAgICAgICAgICAgIGFiYnJGb3JjZSA9IGZvcm1hdC5tYXRjaCgvYShrfG18Ynx0KT8vKTtcblxuICAgICAgICAgICAgICAgIGFiYnJGb3JjZSA9IGFiYnJGb3JjZSA/IGFiYnJGb3JjZVsxXSA6IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZSBhYmJyZXZpYXRpb25cbiAgICAgICAgICAgICAgICBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKGZvcm1hdCwgJyBhJykpIHtcbiAgICAgICAgICAgICAgICAgICAgYWJiciA9ICcgJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShuZXcgUmVnRXhwKGFiYnIgKyAnYVtrbWJ0XT8nKSwgJycpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFicyA+PSB0cmlsbGlvbiAmJiAhYWJickZvcmNlIHx8IGFiYnJGb3JjZSA9PT0gJ3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyaWxsaW9uXG4gICAgICAgICAgICAgICAgICAgIGFiYnIgKz0gbG9jYWxlLmFiYnJldmlhdGlvbnMudHJpbGxpb247XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyB0cmlsbGlvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFicyA8IHRyaWxsaW9uICYmIGFicyA+PSBiaWxsaW9uICYmICFhYmJyRm9yY2UgfHwgYWJickZvcmNlID09PSAnYicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYmlsbGlvblxuICAgICAgICAgICAgICAgICAgICBhYmJyICs9IGxvY2FsZS5hYmJyZXZpYXRpb25zLmJpbGxpb247XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBiaWxsaW9uO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWJzIDwgYmlsbGlvbiAmJiBhYnMgPj0gbWlsbGlvbiAmJiAhYWJickZvcmNlIHx8IGFiYnJGb3JjZSA9PT0gJ20nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1pbGxpb25cbiAgICAgICAgICAgICAgICAgICAgYWJiciArPSBsb2NhbGUuYWJicmV2aWF0aW9ucy5taWxsaW9uO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gbWlsbGlvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFicyA8IG1pbGxpb24gJiYgYWJzID49IHRob3VzYW5kICYmICFhYmJyRm9yY2UgfHwgYWJickZvcmNlID09PSAnaycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhvdXNhbmRcbiAgICAgICAgICAgICAgICAgICAgYWJiciArPSBsb2NhbGUuYWJicmV2aWF0aW9ucy50aG91c2FuZDtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIHRob3VzYW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIG9wdGlvbmFsIGRlY2ltYWxzXG4gICAgICAgICAgICBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKGZvcm1hdCwgJ1suXScpKSB7XG4gICAgICAgICAgICAgICAgb3B0RGVjID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnWy5dJywgJy4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYnJlYWsgbnVtYmVyIGFuZCBmb3JtYXRcbiAgICAgICAgICAgIGludCA9IHZhbHVlLnRvU3RyaW5nKCkuc3BsaXQoJy4nKVswXTtcbiAgICAgICAgICAgIHByZWNpc2lvbiA9IGZvcm1hdC5zcGxpdCgnLicpWzFdO1xuICAgICAgICAgICAgdGhvdXNhbmRzID0gZm9ybWF0LmluZGV4T2YoJywnKTtcbiAgICAgICAgICAgIGxlYWRpbmdDb3VudCA9IChmb3JtYXQuc3BsaXQoJy4nKVswXS5zcGxpdCgnLCcpWzBdLm1hdGNoKC8wL2cpIHx8IFtdKS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChwcmVjaXNpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKHByZWNpc2lvbiwgJ1snKSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24ucmVwbGFjZSgnXScsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uLnNwbGl0KCdbJyk7XG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWwgPSBudW1lcmFsLl8udG9GaXhlZCh2YWx1ZSwgKHByZWNpc2lvblswXS5sZW5ndGggKyBwcmVjaXNpb25bMV0ubGVuZ3RoKSwgcm91bmRpbmdGdW5jdGlvbiwgcHJlY2lzaW9uWzFdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbCA9IG51bWVyYWwuXy50b0ZpeGVkKHZhbHVlLCBwcmVjaXNpb24ubGVuZ3RoLCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbnQgPSBkZWNpbWFsLnNwbGl0KCcuJylbMF07XG5cbiAgICAgICAgICAgICAgICBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKGRlY2ltYWwsICcuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbCA9IGxvY2FsZS5kZWxpbWl0ZXJzLmRlY2ltYWwgKyBkZWNpbWFsLnNwbGl0KCcuJylbMV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHREZWMgJiYgTnVtYmVyKGRlY2ltYWwuc2xpY2UoMSkpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWwgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGludCA9IG51bWVyYWwuXy50b0ZpeGVkKHZhbHVlLCAwLCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgYWJicmV2aWF0aW9uIGFnYWluIGFmdGVyIHJvdW5kaW5nXG4gICAgICAgICAgICBpZiAoYWJiciAmJiAhYWJickZvcmNlICYmIE51bWJlcihpbnQpID49IDEwMDAgJiYgYWJiciAhPT0gbG9jYWxlLmFiYnJldmlhdGlvbnMudHJpbGxpb24pIHtcbiAgICAgICAgICAgICAgICBpbnQgPSBTdHJpbmcoTnVtYmVyKGludCkgLyAxMDAwKTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYWJicikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGxvY2FsZS5hYmJyZXZpYXRpb25zLnRob3VzYW5kOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJiciA9IGxvY2FsZS5hYmJyZXZpYXRpb25zLm1pbGxpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBsb2NhbGUuYWJicmV2aWF0aW9ucy5taWxsaW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJiciA9IGxvY2FsZS5hYmJyZXZpYXRpb25zLmJpbGxpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBsb2NhbGUuYWJicmV2aWF0aW9ucy5iaWxsaW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJiciA9IGxvY2FsZS5hYmJyZXZpYXRpb25zLnRyaWxsaW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vIGZvcm1hdCBudW1iZXJcbiAgICAgICAgICAgIGlmIChudW1lcmFsLl8uaW5jbHVkZXMoaW50LCAnLScpKSB7XG4gICAgICAgICAgICAgICAgaW50ID0gaW50LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIG5lZyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbnQubGVuZ3RoIDwgbGVhZGluZ0NvdW50KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxlYWRpbmdDb3VudCAtIGludC5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ID0gJzAnICsgaW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRob3VzYW5kcyA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaW50ID0gaW50LnRvU3RyaW5nKCkucmVwbGFjZSgvKFxcZCkoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCAnJDEnICsgbG9jYWxlLmRlbGltaXRlcnMudGhvdXNhbmRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcuJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpbnQgPSAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3V0cHV0ID0gaW50ICsgZGVjaW1hbCArIChhYmJyID8gYWJiciA6ICcnKTtcblxuICAgICAgICAgICAgaWYgKG5lZ1ApIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAobmVnUCAmJiBuZWcgPyAnKCcgOiAnJykgKyBvdXRwdXQgKyAobmVnUCAmJiBuZWcgPyAnKScgOiAnJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzaWduZWQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBzaWduZWQgPT09IDAgPyAobmVnID8gJy0nIDogJysnKSArIG91dHB1dCA6IG91dHB1dCArIChuZWcgPyAnLScgOiAnKycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmVnKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9ICctJyArIG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHVuZm9ybWF0cyBudW1iZXJzIHNlcGFyYXRvcnMsIGRlY2ltYWxzIHBsYWNlcywgc2lnbnMsIGFiYnJldmlhdGlvbnNcbiAgICAgICAgc3RyaW5nVG9OdW1iZXI6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgdmFyIGxvY2FsZSA9IGxvY2FsZXNbb3B0aW9ucy5jdXJyZW50TG9jYWxlXSxcbiAgICAgICAgICAgICAgICBzdHJpbmdPcmlnaW5hbCA9IHN0cmluZyxcbiAgICAgICAgICAgICAgICBhYmJyZXZpYXRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICB0aG91c2FuZDogMyxcbiAgICAgICAgICAgICAgICAgICAgbWlsbGlvbjogNixcbiAgICAgICAgICAgICAgICAgICAgYmlsbGlvbjogOSxcbiAgICAgICAgICAgICAgICAgICAgdHJpbGxpb246IDEyXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhYmJyZXZpYXRpb24sXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICByZWdleHA7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnplcm9Gb3JtYXQgJiYgc3RyaW5nID09PSBvcHRpb25zLnplcm9Gb3JtYXQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMubnVsbEZvcm1hdCAmJiBzdHJpbmcgPT09IG9wdGlvbnMubnVsbEZvcm1hdCB8fCAhc3RyaW5nLnJlcGxhY2UoL1teMC05XSsvZywgJycpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZS5kZWxpbWl0ZXJzLmRlY2ltYWwgIT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXFwuL2csICcnKS5yZXBsYWNlKGxvY2FsZS5kZWxpbWl0ZXJzLmRlY2ltYWwsICcuJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChhYmJyZXZpYXRpb24gaW4gYWJicmV2aWF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICByZWdleHAgPSBuZXcgUmVnRXhwKCdbXmEtekEtWl0nICsgbG9jYWxlLmFiYnJldmlhdGlvbnNbYWJicmV2aWF0aW9uXSArICcoPzpcXFxcKXwoXFxcXCcgKyBsb2NhbGUuY3VycmVuY3kuc3ltYm9sICsgJyk/KD86XFxcXCkpPyk/JCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJpbmdPcmlnaW5hbC5tYXRjaChyZWdleHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAqPSBNYXRoLnBvdygxMCwgYWJicmV2aWF0aW9uc1thYmJyZXZpYXRpb25dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIG5lZ2F0aXZlIG51bWJlclxuICAgICAgICAgICAgICAgIHZhbHVlICo9IChzdHJpbmcuc3BsaXQoJy0nKS5sZW5ndGggKyBNYXRoLm1pbihzdHJpbmcuc3BsaXQoJygnKS5sZW5ndGggLSAxLCBzdHJpbmcuc3BsaXQoJyknKS5sZW5ndGggLSAxKSkgJSAyID8gMSA6IC0xO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG5vbiBudW1iZXJzXG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL1teMC05XFwuXSsvZywgJycpO1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgKj0gTnVtYmVyKHN0cmluZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNOYU46IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGluY2x1ZGVzOiBmdW5jdGlvbihzdHJpbmcsIHNlYXJjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5pbmRleE9mKHNlYXJjaCkgIT09IC0xO1xuICAgICAgICB9LFxuICAgICAgICBpbnNlcnQ6IGZ1bmN0aW9uKHN0cmluZywgc3ViU3RyaW5nLCBzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5zbGljZSgwLCBzdGFydCkgKyBzdWJTdHJpbmcgKyBzdHJpbmcuc2xpY2Uoc3RhcnQpO1xuICAgICAgICB9LFxuICAgICAgICByZWR1Y2U6IGZ1bmN0aW9uKGFycmF5LCBjYWxsYmFjayAvKiwgaW5pdGlhbFZhbHVlKi8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLnJlZHVjZSBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY2FsbGJhY2sgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0ID0gT2JqZWN0KGFycmF5KSxcbiAgICAgICAgICAgICAgICBsZW4gPSB0Lmxlbmd0aCA+Pj4gMCxcbiAgICAgICAgICAgICAgICBrID0gMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTtcblxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGsgPCBsZW4gJiYgIShrIGluIHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoayA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhbHVlID0gdFtrKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgICAgIGlmIChrIGluIHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjayh2YWx1ZSwgdFtrXSwgaywgdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcHV0ZXMgdGhlIG11bHRpcGxpZXIgbmVjZXNzYXJ5IHRvIG1ha2UgeCA+PSAxLFxuICAgICAgICAgKiBlZmZlY3RpdmVseSBlbGltaW5hdGluZyBtaXNjYWxjdWxhdGlvbnMgY2F1c2VkIGJ5XG4gICAgICAgICAqIGZpbml0ZSBwcmVjaXNpb24uXG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBsaWVyOiBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0geC50b1N0cmluZygpLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJ0cy5sZW5ndGggPCAyID8gMSA6IE1hdGgucG93KDEwLCBwYXJ0c1sxXS5sZW5ndGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYSB2YXJpYWJsZSBudW1iZXIgb2YgYXJndW1lbnRzLCByZXR1cm5zIHRoZSBtYXhpbXVtXG4gICAgICAgICAqIG11bHRpcGxpZXIgdGhhdCBtdXN0IGJlIHVzZWQgdG8gbm9ybWFsaXplIGFuIG9wZXJhdGlvbiBpbnZvbHZpbmdcbiAgICAgICAgICogYWxsIG9mIHRoZW0uXG4gICAgICAgICAqL1xuICAgICAgICBjb3JyZWN0aW9uRmFjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHJldHVybiBhcmdzLnJlZHVjZShmdW5jdGlvbihhY2N1bSwgbmV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBtbiA9IF8ubXVsdGlwbGllcihuZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW0gPiBtbiA/IGFjY3VtIDogbW47XG4gICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudGF0aW9uIG9mIHRvRml4ZWQoKSB0aGF0IHRyZWF0cyBmbG9hdHMgbW9yZSBsaWtlIGRlY2ltYWxzXG4gICAgICAgICAqXG4gICAgICAgICAqIEZpeGVzIGJpbmFyeSByb3VuZGluZyBpc3N1ZXMgKGVnLiAoMC42MTUpLnRvRml4ZWQoMikgPT09ICcwLjYxJykgdGhhdCBwcmVzZW50XG4gICAgICAgICAqIHByb2JsZW1zIGZvciBhY2NvdW50aW5nLSBhbmQgZmluYW5jZS1yZWxhdGVkIHNvZnR3YXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgdG9GaXhlZDogZnVuY3Rpb24odmFsdWUsIG1heERlY2ltYWxzLCByb3VuZGluZ0Z1bmN0aW9uLCBvcHRpb25hbHMpIHtcbiAgICAgICAgICAgIHZhciBzcGxpdFZhbHVlID0gdmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnLicpLFxuICAgICAgICAgICAgICAgIG1pbkRlY2ltYWxzID0gbWF4RGVjaW1hbHMgLSAob3B0aW9uYWxzIHx8IDApLFxuICAgICAgICAgICAgICAgIGJvdW5kZWRQcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgb3B0aW9uYWxzUmVnRXhwLFxuICAgICAgICAgICAgICAgIHBvd2VyLFxuICAgICAgICAgICAgICAgIG91dHB1dDtcblxuICAgICAgICAgICAgLy8gVXNlIHRoZSBzbWFsbGVzdCBwcmVjaXNpb24gdmFsdWUgcG9zc2libGUgdG8gYXZvaWQgZXJyb3JzIGZyb20gZmxvYXRpbmcgcG9pbnQgcmVwcmVzZW50YXRpb25cbiAgICAgICAgICAgIGlmIChzcGxpdFZhbHVlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICBib3VuZGVkUHJlY2lzaW9uID0gTWF0aC5taW4oTWF0aC5tYXgoc3BsaXRWYWx1ZVsxXS5sZW5ndGgsIG1pbkRlY2ltYWxzKSwgbWF4RGVjaW1hbHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYm91bmRlZFByZWNpc2lvbiA9IG1pbkRlY2ltYWxzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb3dlciA9IE1hdGgucG93KDEwLCBib3VuZGVkUHJlY2lzaW9uKTtcblxuICAgICAgICAgICAgLy8gTXVsdGlwbHkgdXAgYnkgcHJlY2lzaW9uLCByb3VuZCBhY2N1cmF0ZWx5LCB0aGVuIGRpdmlkZSBhbmQgdXNlIG5hdGl2ZSB0b0ZpeGVkKCk6XG4gICAgICAgICAgICBvdXRwdXQgPSAocm91bmRpbmdGdW5jdGlvbih2YWx1ZSArICdlKycgKyBib3VuZGVkUHJlY2lzaW9uKSAvIHBvd2VyKS50b0ZpeGVkKGJvdW5kZWRQcmVjaXNpb24pO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9uYWxzID4gbWF4RGVjaW1hbHMgLSBib3VuZGVkUHJlY2lzaW9uKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uYWxzUmVnRXhwID0gbmV3IFJlZ0V4cCgnXFxcXC4/MHsxLCcgKyAob3B0aW9uYWxzIC0gKG1heERlY2ltYWxzIC0gYm91bmRlZFByZWNpc2lvbikpICsgJ30kJyk7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2Uob3B0aW9uYWxzUmVnRXhwLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gYXZhbGlhYmxlIG9wdGlvbnNcbiAgICBudW1lcmFsLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgLy8gYXZhbGlhYmxlIGZvcm1hdHNcbiAgICBudW1lcmFsLmZvcm1hdHMgPSBmb3JtYXRzO1xuXG4gICAgLy8gYXZhbGlhYmxlIGZvcm1hdHNcbiAgICBudW1lcmFsLmxvY2FsZXMgPSBsb2NhbGVzO1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBzZXRzIHRoZSBjdXJyZW50IGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIG51bWVyYWwubG9jYWxlID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY3VycmVudExvY2FsZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuY3VycmVudExvY2FsZTtcbiAgICB9O1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGxvYWRlZCBsb2NhbGUgZGF0YS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudFxuICAgIC8vIGdsb2JhbCBsb2NhbGUgb2JqZWN0LlxuICAgIG51bWVyYWwubG9jYWxlRGF0YSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZXNbb3B0aW9ucy5jdXJyZW50TG9jYWxlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmICghbG9jYWxlc1trZXldKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbG9jYWxlIDogJyArIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9jYWxlc1trZXldO1xuICAgIH07XG5cbiAgICBudW1lcmFsLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIGRlZmF1bHRzKSB7XG4gICAgICAgICAgICBvcHRpb25zW3Byb3BlcnR5XSA9IGRlZmF1bHRzW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBudW1lcmFsLnplcm9Gb3JtYXQgPSBmdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgb3B0aW9ucy56ZXJvRm9ybWF0ID0gdHlwZW9mKGZvcm1hdCkgPT09ICdzdHJpbmcnID8gZm9ybWF0IDogbnVsbDtcbiAgICB9O1xuXG4gICAgbnVtZXJhbC5udWxsRm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICBvcHRpb25zLm51bGxGb3JtYXQgPSB0eXBlb2YoZm9ybWF0KSA9PT0gJ3N0cmluZycgPyBmb3JtYXQgOiBudWxsO1xuICAgIH07XG5cbiAgICBudW1lcmFsLmRlZmF1bHRGb3JtYXQgPSBmdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgb3B0aW9ucy5kZWZhdWx0Rm9ybWF0ID0gdHlwZW9mKGZvcm1hdCkgPT09ICdzdHJpbmcnID8gZm9ybWF0IDogJzAuMCc7XG4gICAgfTtcblxuICAgIG51bWVyYWwucmVnaXN0ZXIgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBmb3JtYXQpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAodGhpc1t0eXBlICsgJ3MnXVtuYW1lXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihuYW1lICsgJyAnICsgdHlwZSArICcgYWxyZWFkeSByZWdpc3RlcmVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc1t0eXBlICsgJ3MnXVtuYW1lXSA9IGZvcm1hdDtcblxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH07XG5cblxuICAgIG51bWVyYWwudmFsaWRhdGUgPSBmdW5jdGlvbih2YWwsIGN1bHR1cmUpIHtcbiAgICAgICAgdmFyIF9kZWNpbWFsU2VwLFxuICAgICAgICAgICAgX3Rob3VzYW5kU2VwLFxuICAgICAgICAgICAgX2N1cnJTeW1ib2wsXG4gICAgICAgICAgICBfdmFsQXJyYXksXG4gICAgICAgICAgICBfYWJick9iaixcbiAgICAgICAgICAgIF90aG91c2FuZFJlZ0V4LFxuICAgICAgICAgICAgbG9jYWxlRGF0YSxcbiAgICAgICAgICAgIHRlbXA7XG5cbiAgICAgICAgLy9jb2VyY2UgdmFsIHRvIHN0cmluZ1xuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbCArPSAnJztcblxuICAgICAgICAgICAgaWYgKGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTnVtZXJhbC5qczogVmFsdWUgaXMgbm90IHN0cmluZy4gSXQgaGFzIGJlZW4gY28tZXJjZWQgdG86ICcsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3RyaW0gd2hpdGVzcGFjZXMgZnJvbSBlaXRoZXIgc2lkZXNcbiAgICAgICAgdmFsID0gdmFsLnRyaW0oKTtcblxuICAgICAgICAvL2lmIHZhbCBpcyBqdXN0IGRpZ2l0cyByZXR1cm4gdHJ1ZVxuICAgICAgICBpZiAoISF2YWwubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgdmFsIGlzIGVtcHR5IHJldHVybiBmYWxzZVxuICAgICAgICBpZiAodmFsID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9nZXQgdGhlIGRlY2ltYWwgYW5kIHRob3VzYW5kcyBzZXBhcmF0b3IgZnJvbSBudW1lcmFsLmxvY2FsZURhdGFcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vY2hlY2sgaWYgdGhlIGN1bHR1cmUgaXMgdW5kZXJzdG9vZCBieSBudW1lcmFsLiBpZiBub3QsIGRlZmF1bHQgaXQgdG8gY3VycmVudCBsb2NhbGVcbiAgICAgICAgICAgIGxvY2FsZURhdGEgPSBudW1lcmFsLmxvY2FsZURhdGEoY3VsdHVyZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvY2FsZURhdGEgPSBudW1lcmFsLmxvY2FsZURhdGEobnVtZXJhbC5sb2NhbGUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL3NldHVwIHRoZSBkZWxpbWl0ZXJzIGFuZCBjdXJyZW5jeSBzeW1ib2wgYmFzZWQgb24gY3VsdHVyZS9sb2NhbGVcbiAgICAgICAgX2N1cnJTeW1ib2wgPSBsb2NhbGVEYXRhLmN1cnJlbmN5LnN5bWJvbDtcbiAgICAgICAgX2FiYnJPYmogPSBsb2NhbGVEYXRhLmFiYnJldmlhdGlvbnM7XG4gICAgICAgIF9kZWNpbWFsU2VwID0gbG9jYWxlRGF0YS5kZWxpbWl0ZXJzLmRlY2ltYWw7XG4gICAgICAgIGlmIChsb2NhbGVEYXRhLmRlbGltaXRlcnMudGhvdXNhbmRzID09PSAnLicpIHtcbiAgICAgICAgICAgIF90aG91c2FuZFNlcCA9ICdcXFxcLic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhvdXNhbmRTZXAgPSBsb2NhbGVEYXRhLmRlbGltaXRlcnMudGhvdXNhbmRzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWRhdGluZyBjdXJyZW5jeSBzeW1ib2xcbiAgICAgICAgdGVtcCA9IHZhbC5tYXRjaCgvXlteXFxkXSsvKTtcbiAgICAgICAgaWYgKHRlbXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbCA9IHZhbC5zdWJzdHIoMSk7XG4gICAgICAgICAgICBpZiAodGVtcFswXSAhPT0gX2N1cnJTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3ZhbGlkYXRpbmcgYWJicmV2aWF0aW9uIHN5bWJvbFxuICAgICAgICB0ZW1wID0gdmFsLm1hdGNoKC9bXlxcZF0rJC8pO1xuICAgICAgICBpZiAodGVtcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsID0gdmFsLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIGlmICh0ZW1wWzBdICE9PSBfYWJick9iai50aG91c2FuZCAmJiB0ZW1wWzBdICE9PSBfYWJick9iai5taWxsaW9uICYmIHRlbXBbMF0gIT09IF9hYmJyT2JqLmJpbGxpb24gJiYgdGVtcFswXSAhPT0gX2FiYnJPYmoudHJpbGxpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfdGhvdXNhbmRSZWdFeCA9IG5ldyBSZWdFeHAoX3Rob3VzYW5kU2VwICsgJ3syfScpO1xuXG4gICAgICAgIGlmICghdmFsLm1hdGNoKC9bXlxcZC4sXS9nKSkge1xuICAgICAgICAgICAgX3ZhbEFycmF5ID0gdmFsLnNwbGl0KF9kZWNpbWFsU2VwKTtcbiAgICAgICAgICAgIGlmIChfdmFsQXJyYXkubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKF92YWxBcnJheS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoICEhIF92YWxBcnJheVswXS5tYXRjaCgvXlxcZCsuKlxcZCQvKSAmJiAhX3ZhbEFycmF5WzBdLm1hdGNoKF90aG91c2FuZFJlZ0V4KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF92YWxBcnJheVswXS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoICEhIF92YWxBcnJheVswXS5tYXRjaCgvXlxcZCskLykgJiYgIV92YWxBcnJheVswXS5tYXRjaChfdGhvdXNhbmRSZWdFeCkgJiYgISEgX3ZhbEFycmF5WzFdLm1hdGNoKC9eXFxkKyQvKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCAhISBfdmFsQXJyYXlbMF0ubWF0Y2goL15cXGQrLipcXGQkLykgJiYgIV92YWxBcnJheVswXS5tYXRjaChfdGhvdXNhbmRSZWdFeCkgJiYgISEgX3ZhbEFycmF5WzFdLm1hdGNoKC9eXFxkKyQvKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBOdW1lcmFsIFByb3RvdHlwZVxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIG51bWVyYWwuZm4gPSBOdW1lcmFsLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWVyYWwodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdDogZnVuY3Rpb24oaW5wdXRTdHJpbmcsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3ZhbHVlLFxuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGlucHV0U3RyaW5nIHx8IG9wdGlvbnMuZGVmYXVsdEZvcm1hdCxcbiAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgICAgICBmb3JtYXRGdW5jdGlvbjtcblxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGhhdmUgYSByb3VuZGluZ0Z1bmN0aW9uXG4gICAgICAgICAgICByb3VuZGluZ0Z1bmN0aW9uID0gcm91bmRpbmdGdW5jdGlvbiB8fCBNYXRoLnJvdW5kO1xuXG4gICAgICAgICAgICAvLyBmb3JtYXQgYmFzZWQgb24gdmFsdWVcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMCAmJiBvcHRpb25zLnplcm9Gb3JtYXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvcHRpb25zLnplcm9Gb3JtYXQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsICYmIG9wdGlvbnMubnVsbEZvcm1hdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG9wdGlvbnMubnVsbEZvcm1hdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChraW5kIGluIGZvcm1hdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm1hdC5tYXRjaChmb3JtYXRzW2tpbmRdLnJlZ2V4cHMuZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb24gPSBmb3JtYXRzW2tpbmRdLmZvcm1hdDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3JtYXRGdW5jdGlvbiA9IGZvcm1hdEZ1bmN0aW9uIHx8IG51bWVyYWwuXy5udW1iZXJUb0Zvcm1hdDtcblxuICAgICAgICAgICAgICAgIG91dHB1dCA9IGZvcm1hdEZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9LFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGlucHV0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnB1dDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgYWRkOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNvcnJGYWN0b3IgPSBfLmNvcnJlY3Rpb25GYWN0b3IuY2FsbChudWxsLCB0aGlzLl92YWx1ZSwgdmFsdWUpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBjYmFjayhhY2N1bSwgY3VyciwgY3VyckksIE8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW0gKyBNYXRoLnJvdW5kKGNvcnJGYWN0b3IgKiBjdXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBfLnJlZHVjZShbdGhpcy5fdmFsdWUsIHZhbHVlXSwgY2JhY2ssIDApIC8gY29yckZhY3RvcjtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIHN1YnRyYWN0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNvcnJGYWN0b3IgPSBfLmNvcnJlY3Rpb25GYWN0b3IuY2FsbChudWxsLCB0aGlzLl92YWx1ZSwgdmFsdWUpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBjYmFjayhhY2N1bSwgY3VyciwgY3VyckksIE8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW0gLSBNYXRoLnJvdW5kKGNvcnJGYWN0b3IgKiBjdXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBfLnJlZHVjZShbdmFsdWVdLCBjYmFjaywgTWF0aC5yb3VuZCh0aGlzLl92YWx1ZSAqIGNvcnJGYWN0b3IpKSAvIGNvcnJGYWN0b3I7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBtdWx0aXBseTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNiYWNrKGFjY3VtLCBjdXJyLCBjdXJySSwgTykge1xuICAgICAgICAgICAgICAgIHZhciBjb3JyRmFjdG9yID0gXy5jb3JyZWN0aW9uRmFjdG9yKGFjY3VtLCBjdXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChhY2N1bSAqIGNvcnJGYWN0b3IpICogTWF0aC5yb3VuZChjdXJyICogY29yckZhY3RvcikgLyBNYXRoLnJvdW5kKGNvcnJGYWN0b3IgKiBjb3JyRmFjdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBfLnJlZHVjZShbdGhpcy5fdmFsdWUsIHZhbHVlXSwgY2JhY2ssIDEpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZGl2aWRlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgZnVuY3Rpb24gY2JhY2soYWNjdW0sIGN1cnIsIGN1cnJJLCBPKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvcnJGYWN0b3IgPSBfLmNvcnJlY3Rpb25GYWN0b3IoYWNjdW0sIGN1cnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGFjY3VtICogY29yckZhY3RvcikgLyBNYXRoLnJvdW5kKGN1cnIgKiBjb3JyRmFjdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBfLnJlZHVjZShbdGhpcy5fdmFsdWUsIHZhbHVlXSwgY2JhY2spO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZGlmZmVyZW5jZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhudW1lcmFsKHRoaXMuX3ZhbHVlKS5zdWJ0cmFjdCh2YWx1ZSkudmFsdWUoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBEZWZhdWx0IExvY2FsZSAmJiBGb3JtYXRcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBudW1lcmFsLnJlZ2lzdGVyKCdsb2NhbGUnLCAnZW4nLCB7XG4gICAgICAgIGRlbGltaXRlcnM6IHtcbiAgICAgICAgICAgIHRob3VzYW5kczogJywnLFxuICAgICAgICAgICAgZGVjaW1hbDogJy4nXG4gICAgICAgIH0sXG4gICAgICAgIGFiYnJldmlhdGlvbnM6IHtcbiAgICAgICAgICAgIHRob3VzYW5kOiAnaycsXG4gICAgICAgICAgICBtaWxsaW9uOiAnbScsXG4gICAgICAgICAgICBiaWxsaW9uOiAnYicsXG4gICAgICAgICAgICB0cmlsbGlvbjogJ3QnXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWw6IGZ1bmN0aW9uKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMDtcbiAgICAgICAgICAgIHJldHVybiAofn4obnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICB9LFxuICAgICAgICBjdXJyZW5jeToge1xuICAgICAgICAgICAgc3ltYm9sOiAnJCdcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgXG5cbihmdW5jdGlvbigpIHtcbiAgICAgICAgbnVtZXJhbC5yZWdpc3RlcignZm9ybWF0JywgJ2JwcycsIHtcbiAgICAgICAgICAgIHJlZ2V4cHM6IHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IC8oQlBTKS8sXG4gICAgICAgICAgICAgICAgdW5mb3JtYXQ6IC8oQlBTKS9cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2UgPSBudW1lcmFsLl8uaW5jbHVkZXMoZm9ybWF0LCAnIEJQUycpID8gJyAnIDogJycsXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKiAxMDAwMDtcblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmUgQlBTXG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoL1xccz9CUFMvLCAnJyk7XG5cbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBudW1lcmFsLl8ubnVtYmVyVG9Gb3JtYXQodmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG5cbiAgICAgICAgICAgICAgICBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKG91dHB1dCwgJyknKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuc3BsaXQoJycpO1xuXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zcGxpY2UoLTEsIDAsIHNwYWNlICsgJ0JQUycpO1xuXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgKyBzcGFjZSArICdCUFMnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5mb3JtYXQ6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiArKG51bWVyYWwuXy5zdHJpbmdUb051bWJlcihzdHJpbmcpICogMC4wMDAxKS50b0ZpeGVkKDE1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRlY2ltYWwgPSB7XG4gICAgICAgICAgICBiYXNlOiAxMDAwLFxuICAgICAgICAgICAgc3VmZml4ZXM6IFsnQicsICdLQicsICdNQicsICdHQicsICdUQicsICdQQicsICdFQicsICdaQicsICdZQiddXG4gICAgICAgIH0sXG4gICAgICAgIGJpbmFyeSA9IHtcbiAgICAgICAgICAgIGJhc2U6IDEwMjQsXG4gICAgICAgICAgICBzdWZmaXhlczogWydCJywgJ0tpQicsICdNaUInLCAnR2lCJywgJ1RpQicsICdQaUInLCAnRWlCJywgJ1ppQicsICdZaUInXVxuICAgICAgICB9O1xuXG4gICAgdmFyIGFsbFN1ZmZpeGVzID0gIGRlY2ltYWwuc3VmZml4ZXMuY29uY2F0KGJpbmFyeS5zdWZmaXhlcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNpbWFsLnN1ZmZpeGVzLmluZGV4T2YoaXRlbSkgPCAwO1xuICAgICAgICB9KSk7XG4gICAgICAgIHZhciB1bmZvcm1hdFJlZ2V4ID0gYWxsU3VmZml4ZXMuam9pbignfCcpO1xuICAgICAgICAvLyBBbGxvdyBzdXBwb3J0IGZvciBCUFMgKGh0dHA6Ly93d3cuaW52ZXN0b3BlZGlhLmNvbS90ZXJtcy9iL2Jhc2lzcG9pbnQuYXNwKVxuICAgICAgICB1bmZvcm1hdFJlZ2V4ID0gJygnICsgdW5mb3JtYXRSZWdleC5yZXBsYWNlKCdCJywgJ0IoPyFQUyknKSArICcpJztcblxuICAgIG51bWVyYWwucmVnaXN0ZXIoJ2Zvcm1hdCcsICdieXRlcycsIHtcbiAgICAgICAgcmVnZXhwczoge1xuICAgICAgICAgICAgZm9ybWF0OiAvKFswXFxzXWk/YikvLFxuICAgICAgICAgICAgdW5mb3JtYXQ6IG5ldyBSZWdFeHAodW5mb3JtYXRSZWdleClcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0LFxuICAgICAgICAgICAgICAgIGJ5dGVzID0gbnVtZXJhbC5fLmluY2x1ZGVzKGZvcm1hdCwgJ2liJykgPyBiaW5hcnkgOiBkZWNpbWFsLFxuICAgICAgICAgICAgICAgIHN1ZmZpeCA9IG51bWVyYWwuXy5pbmNsdWRlcyhmb3JtYXQsICcgYicpIHx8IG51bWVyYWwuXy5pbmNsdWRlcyhmb3JtYXQsICcgaWInKSA/ICcgJyA6ICcnLFxuICAgICAgICAgICAgICAgIHBvd2VyLFxuICAgICAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgICAgICBtYXg7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmVcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC9cXHM/aT9iLywgJycpO1xuXG4gICAgICAgICAgICBmb3IgKHBvd2VyID0gMDsgcG93ZXIgPD0gYnl0ZXMuc3VmZml4ZXMubGVuZ3RoOyBwb3dlcisrKSB7XG4gICAgICAgICAgICAgICAgbWluID0gTWF0aC5wb3coYnl0ZXMuYmFzZSwgcG93ZXIpO1xuICAgICAgICAgICAgICAgIG1heCA9IE1hdGgucG93KGJ5dGVzLmJhc2UsIHBvd2VyICsgMSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IDAgfHwgdmFsdWUgPj0gbWluICYmIHZhbHVlIDwgbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIHN1ZmZpeCArPSBieXRlcy5zdWZmaXhlc1twb3dlcl07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBtaW47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG91dHB1dCA9IG51bWVyYWwuXy5udW1iZXJUb0Zvcm1hdCh2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dCArIHN1ZmZpeDtcbiAgICAgICAgfSxcbiAgICAgICAgdW5mb3JtYXQ6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbnVtZXJhbC5fLnN0cmluZ1RvTnVtYmVyKHN0cmluZyksXG4gICAgICAgICAgICAgICAgcG93ZXIsXG4gICAgICAgICAgICAgICAgYnl0ZXNNdWx0aXBsaWVyO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHBvd2VyID0gZGVjaW1hbC5zdWZmaXhlcy5sZW5ndGggLSAxOyBwb3dlciA+PSAwOyBwb3dlci0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudW1lcmFsLl8uaW5jbHVkZXMoc3RyaW5nLCBkZWNpbWFsLnN1ZmZpeGVzW3Bvd2VyXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzTXVsdGlwbGllciA9IE1hdGgucG93KGRlY2ltYWwuYmFzZSwgcG93ZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChudW1lcmFsLl8uaW5jbHVkZXMoc3RyaW5nLCBiaW5hcnkuc3VmZml4ZXNbcG93ZXJdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNNdWx0aXBsaWVyID0gTWF0aC5wb3coYmluYXJ5LmJhc2UsIHBvd2VyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSAqPSAoYnl0ZXNNdWx0aXBsaWVyIHx8IDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuICAgICAgICBudW1lcmFsLnJlZ2lzdGVyKCdmb3JtYXQnLCAnY3VycmVuY3knLCB7XG4gICAgICAgIHJlZ2V4cHM6IHtcbiAgICAgICAgICAgIGZvcm1hdDogLyhcXCQpL1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUgPSBudW1lcmFsLmxvY2FsZXNbbnVtZXJhbC5vcHRpb25zLmN1cnJlbnRMb2NhbGVdLFxuICAgICAgICAgICAgICAgIHN5bWJvbHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZTogZm9ybWF0Lm1hdGNoKC9eKFtcXCt8XFwtfFxcKHxcXHN8XFwkXSopLylbMF0sXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyOiBmb3JtYXQubWF0Y2goLyhbXFwrfFxcLXxcXCl8XFxzfFxcJF0qKSQvKVswXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgICAgIHN5bWJvbCxcbiAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICAvLyBzdHJpcCBmb3JtYXQgb2Ygc3BhY2VzIGFuZCAkXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvXFxzP1xcJFxccz8vLCAnJyk7XG5cbiAgICAgICAgICAgIC8vIGZvcm1hdCB0aGUgbnVtYmVyXG4gICAgICAgICAgICBvdXRwdXQgPSBudW1lcmFsLl8ubnVtYmVyVG9Gb3JtYXQodmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgYmVmb3JlIGFuZCBhZnRlciBiYXNlZCBvbiB2YWx1ZVxuICAgICAgICAgICAgaWYgKHZhbHVlID49IDApIHtcbiAgICAgICAgICAgICAgICBzeW1ib2xzLmJlZm9yZSA9IHN5bWJvbHMuYmVmb3JlLnJlcGxhY2UoL1tcXC1cXChdLywgJycpO1xuICAgICAgICAgICAgICAgIHN5bWJvbHMuYWZ0ZXIgPSBzeW1ib2xzLmFmdGVyLnJlcGxhY2UoL1tcXC1cXCldLywgJycpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8IDAgJiYgKCFudW1lcmFsLl8uaW5jbHVkZXMoc3ltYm9scy5iZWZvcmUsICctJykgJiYgIW51bWVyYWwuXy5pbmNsdWRlcyhzeW1ib2xzLmJlZm9yZSwgJygnKSkpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2xzLmJlZm9yZSA9ICctJyArIHN5bWJvbHMuYmVmb3JlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggZWFjaCBiZWZvcmUgc3ltYm9sXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3ltYm9scy5iZWZvcmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBzeW1ib2xzLmJlZm9yZVtpXTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gbnVtZXJhbC5fLmluc2VydChvdXRwdXQsIGxvY2FsZS5jdXJyZW5jeS5zeW1ib2wsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gbnVtZXJhbC5fLmluc2VydChvdXRwdXQsICcgJywgaSArIGxvY2FsZS5jdXJyZW5jeS5zeW1ib2wubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBlYWNoIGFmdGVyIHN5bWJvbFxuICAgICAgICAgICAgZm9yIChpID0gc3ltYm9scy5hZnRlci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IHN5bWJvbHMuYWZ0ZXJbaV07XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICckJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGkgPT09IHN5bWJvbHMuYWZ0ZXIubGVuZ3RoIC0gMSA/IG91dHB1dCArIGxvY2FsZS5jdXJyZW5jeS5zeW1ib2wgOiBudW1lcmFsLl8uaW5zZXJ0KG91dHB1dCwgbG9jYWxlLmN1cnJlbmN5LnN5bWJvbCwgLShzeW1ib2xzLmFmdGVyLmxlbmd0aCAtICgxICsgaSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGkgPT09IHN5bWJvbHMuYWZ0ZXIubGVuZ3RoIC0gMSA/IG91dHB1dCArICcgJyA6IG51bWVyYWwuXy5pbnNlcnQob3V0cHV0LCAnICcsIC0oc3ltYm9scy5hZnRlci5sZW5ndGggLSAoMSArIGkpICsgbG9jYWxlLmN1cnJlbmN5LnN5bWJvbC5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG4gICAgICAgIG51bWVyYWwucmVnaXN0ZXIoJ2Zvcm1hdCcsICdleHBvbmVudGlhbCcsIHtcbiAgICAgICAgcmVnZXhwczoge1xuICAgICAgICAgICAgZm9ybWF0OiAvKGVcXCt8ZS0pLyxcbiAgICAgICAgICAgIHVuZm9ybWF0OiAvKGVcXCt8ZS0pL1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQsXG4gICAgICAgICAgICAgICAgZXhwb25lbnRpYWwgPSB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFudW1lcmFsLl8uaXNOYU4odmFsdWUpID8gdmFsdWUudG9FeHBvbmVudGlhbCgpIDogJzBlKzAnLFxuICAgICAgICAgICAgICAgIHBhcnRzID0gZXhwb25lbnRpYWwuc3BsaXQoJ2UnKTtcblxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoL2VbXFwrfFxcLV17MX0wLywgJycpO1xuXG4gICAgICAgICAgICBvdXRwdXQgPSBudW1lcmFsLl8ubnVtYmVyVG9Gb3JtYXQoTnVtYmVyKHBhcnRzWzBdKSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dCArICdlJyArIHBhcnRzWzFdO1xuICAgICAgICB9LFxuICAgICAgICB1bmZvcm1hdDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBudW1lcmFsLl8uaW5jbHVkZXMoc3RyaW5nLCAnZSsnKSA/IHN0cmluZy5zcGxpdCgnZSsnKSA6IHN0cmluZy5zcGxpdCgnZS0nKSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IE51bWJlcihwYXJ0c1swXSksXG4gICAgICAgICAgICAgICAgcG93ZXIgPSBOdW1iZXIocGFydHNbMV0pO1xuXG4gICAgICAgICAgICBwb3dlciA9IG51bWVyYWwuXy5pbmNsdWRlcyhzdHJpbmcsICdlLScpID8gcG93ZXIgKj0gLTEgOiBwb3dlcjtcblxuICAgICAgICAgICAgZnVuY3Rpb24gY2JhY2soYWNjdW0sIGN1cnIsIGN1cnJJLCBPKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvcnJGYWN0b3IgPSBudW1lcmFsLl8uY29ycmVjdGlvbkZhY3RvcihhY2N1bSwgY3VyciksXG4gICAgICAgICAgICAgICAgICAgIG51bSA9IChhY2N1bSAqIGNvcnJGYWN0b3IpICogKGN1cnIgKiBjb3JyRmFjdG9yKSAvIChjb3JyRmFjdG9yICogY29yckZhY3Rvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bWVyYWwuXy5yZWR1Y2UoW3ZhbHVlLCBNYXRoLnBvdygxMCwgcG93ZXIpXSwgY2JhY2ssIDEpO1xuICAgICAgICB9XG4gICAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgICAgICAgbnVtZXJhbC5yZWdpc3RlcignZm9ybWF0JywgJ29yZGluYWwnLCB7XG4gICAgICAgIHJlZ2V4cHM6IHtcbiAgICAgICAgICAgIGZvcm1hdDogLyhvKS9cbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlID0gbnVtZXJhbC5sb2NhbGVzW251bWVyYWwub3B0aW9ucy5jdXJyZW50TG9jYWxlXSxcbiAgICAgICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICAgICAgb3JkaW5hbCA9IG51bWVyYWwuXy5pbmNsdWRlcyhmb3JtYXQsICcgbycpID8gJyAnIDogJyc7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmVcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC9cXHM/by8sICcnKTtcblxuICAgICAgICAgICAgb3JkaW5hbCArPSBsb2NhbGUub3JkaW5hbCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIG91dHB1dCA9IG51bWVyYWwuXy5udW1iZXJUb0Zvcm1hdCh2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dCArIG9yZGluYWw7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuICAgICAgICBudW1lcmFsLnJlZ2lzdGVyKCdmb3JtYXQnLCAncGVyY2VudGFnZScsIHtcbiAgICAgICAgcmVnZXhwczoge1xuICAgICAgICAgICAgZm9ybWF0OiAvKCUpLyxcbiAgICAgICAgICAgIHVuZm9ybWF0OiAvKCUpL1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBzcGFjZSA9IG51bWVyYWwuXy5pbmNsdWRlcyhmb3JtYXQsICcgJScpID8gJyAnIDogJycsXG4gICAgICAgICAgICAgICAgb3V0cHV0O1xuXG4gICAgICAgICAgICBpZiAobnVtZXJhbC5vcHRpb25zLnNjYWxlUGVyY2VudEJ5MTAwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIDEwMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZSAlXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvXFxzP1xcJS8sICcnKTtcblxuICAgICAgICAgICAgb3V0cHV0ID0gbnVtZXJhbC5fLm51bWJlclRvRm9ybWF0KHZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuXG4gICAgICAgICAgICBpZiAobnVtZXJhbC5fLmluY2x1ZGVzKG91dHB1dCwgJyknKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5zcGxpdCgnJyk7XG5cbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BsaWNlKC0xLCAwLCBzcGFjZSArICclJyk7XG5cbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuam9pbignJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIHNwYWNlICsgJyUnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9LFxuICAgICAgICB1bmZvcm1hdDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgbnVtYmVyID0gbnVtZXJhbC5fLnN0cmluZ1RvTnVtYmVyKHN0cmluZyk7XG4gICAgICAgICAgICBpZiAobnVtZXJhbC5vcHRpb25zLnNjYWxlUGVyY2VudEJ5MTAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciAqIDAuMDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICB9XG4gICAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgICAgICAgbnVtZXJhbC5yZWdpc3RlcignZm9ybWF0JywgJ3RpbWUnLCB7XG4gICAgICAgIHJlZ2V4cHM6IHtcbiAgICAgICAgICAgIGZvcm1hdDogLyg6KS8sXG4gICAgICAgICAgICB1bmZvcm1hdDogLyg6KS9cbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgaG91cnMgPSBNYXRoLmZsb29yKHZhbHVlIC8gNjAgLyA2MCksXG4gICAgICAgICAgICAgICAgbWludXRlcyA9IE1hdGguZmxvb3IoKHZhbHVlIC0gKGhvdXJzICogNjAgKiA2MCkpIC8gNjApLFxuICAgICAgICAgICAgICAgIHNlY29uZHMgPSBNYXRoLnJvdW5kKHZhbHVlIC0gKGhvdXJzICogNjAgKiA2MCkgLSAobWludXRlcyAqIDYwKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBob3VycyArICc6JyArIChtaW51dGVzIDwgMTAgPyAnMCcgKyBtaW51dGVzIDogbWludXRlcykgKyAnOicgKyAoc2Vjb25kcyA8IDEwID8gJzAnICsgc2Vjb25kcyA6IHNlY29uZHMpO1xuICAgICAgICB9LFxuICAgICAgICB1bmZvcm1hdDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgdGltZUFycmF5ID0gc3RyaW5nLnNwbGl0KCc6JyksXG4gICAgICAgICAgICAgICAgc2Vjb25kcyA9IDA7XG5cbiAgICAgICAgICAgIC8vIHR1cm4gaG91cnMgYW5kIG1pbnV0ZXMgaW50byBzZWNvbmRzIGFuZCBhZGQgdGhlbSBhbGwgdXBcbiAgICAgICAgICAgIGlmICh0aW1lQXJyYXkubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgLy8gaG91cnNcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIChOdW1iZXIodGltZUFycmF5WzBdKSAqIDYwICogNjApO1xuICAgICAgICAgICAgICAgIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIChOdW1iZXIodGltZUFycmF5WzFdKSAqIDYwKTtcbiAgICAgICAgICAgICAgICAvLyBzZWNvbmRzXG4gICAgICAgICAgICAgICAgc2Vjb25kcyA9IHNlY29uZHMgKyBOdW1iZXIodGltZUFycmF5WzJdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGltZUFycmF5Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIChOdW1iZXIodGltZUFycmF5WzBdKSAqIDYwKTtcbiAgICAgICAgICAgICAgICAvLyBzZWNvbmRzXG4gICAgICAgICAgICAgICAgc2Vjb25kcyA9IHNlY29uZHMgKyBOdW1iZXIodGltZUFycmF5WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIoc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pKCk7XG5cbnJldHVybiBudW1lcmFsO1xufSkpO1xuIiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5yYW5nZXNsaWRlckpzPXQoKTplLnJhbmdlc2xpZGVySnM9dCgpfSh0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18oaSl7aWYodFtpXSlyZXR1cm4gdFtpXS5leHBvcnRzO3ZhciBuPXRbaV09e2k6aSxsOiExLGV4cG9ydHM6e319O3JldHVybiBlW2ldLmNhbGwobi5leHBvcnRzLG4sbi5leHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pLG4ubD0hMCxuLmV4cG9ydHN9dmFyIHQ9e307cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18ubT1lLF9fd2VicGFja19yZXF1aXJlX18uYz10LF9fd2VicGFja19yZXF1aXJlX18uaT1mdW5jdGlvbihlKXtyZXR1cm4gZX0sX193ZWJwYWNrX3JlcXVpcmVfXy5kPWZ1bmN0aW9uKGUsdCxpKXtfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7Y29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITAsZ2V0Oml9KX0sX193ZWJwYWNrX3JlcXVpcmVfXy5uPWZ1bmN0aW9uKGUpe3ZhciB0PWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fLmQodCxcImFcIix0KSx0fSxfX3dlYnBhY2tfcmVxdWlyZV9fLm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LF9fd2VicGFja19yZXF1aXJlX18ucD1cIlwiLF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zPTYpfShbZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD17TUlOX0RFRkFVTFQ6MCxNQVhfREVGQVVMVDoxMDAsUkFOR0VfQ0xBU1M6XCJyYW5nZXNsaWRlclwiLEZJTExfQ0xBU1M6XCJyYW5nZXNsaWRlcl9fZmlsbFwiLEZJTExfQkdfQ0xBU1M6XCJyYW5nZXNsaWRlcl9fZmlsbF9fYmdcIixIQU5ETEVfQ0xBU1M6XCJyYW5nZXNsaWRlcl9faGFuZGxlXCIsRElTQUJMRURfQ0xBU1M6XCJyYW5nZXNsaWRlci0tZGlzYWJsZWRcIixTVEVQX0RFRkFVTFQ6MSxTVEFSVF9FVkVOVFM6W1wibW91c2Vkb3duXCIsXCJ0b3VjaHN0YXJ0XCIsXCJwb2ludGVyZG93blwiXSxNT1ZFX0VWRU5UUzpbXCJtb3VzZW1vdmVcIixcInRvdWNobW92ZVwiLFwicG9pbnRlcm1vdmVcIl0sRU5EX0VWRU5UUzpbXCJtb3VzZXVwXCIsXCJ0b3VjaGVuZFwiLFwicG9pbnRlcnVwXCJdLFBMVUdJTl9OQU1FOlwicmFuZ2VzbGlkZXItanNcIn19LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBjbGFtcChlLHQsaSl7cmV0dXJuIHQ8aT9lPHQ/dDplPmk/aTplOmU8aT9pOmU+dD90OmV9ZnVuY3Rpb24gaXNIaWRkZW4oZSl7cmV0dXJuIDA9PT1lLm9mZnNldFdpZHRofHwwPT09ZS5vZmZzZXRIZWlnaHR8fCExPT09ZS5vcGVufWZ1bmN0aW9uIGlzTnVtYmVyTGlrZShlKXtyZXR1cm4gbyhwYXJzZUZsb2F0KGUpKXx8byhlKX1mdW5jdGlvbiBnZXRGaXJzdE51bWJlckxpa2UoKXtpZighYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbnVsbDtmb3IodmFyIGU9MCx0PWFyZ3VtZW50cy5sZW5ndGg7ZTx0O2UrKylpZihpc051bWJlckxpa2UoYXJndW1lbnRzW2VdKSlyZXR1cm4gYXJndW1lbnRzW2VdfWZ1bmN0aW9uIGdldEhpZGRlblBhcmVudE5vZGVzKGUpe2Zvcih2YXIgdD1bXSxpPWUucGFyZW50Tm9kZTtpJiZpc0hpZGRlbihpKTspdC5wdXNoKGkpLGk9aS5wYXJlbnROb2RlO3JldHVybiB0fWZ1bmN0aW9uIGdldERpbWVuc2lvbihlLHQpe2Z1bmN0aW9uIHRvZ2dsZU9wZW5Qcm9wZXJ0eShlKXt2b2lkIDAhPT1lLm9wZW4mJihlLm9wZW49IWUub3Blbil9dmFyIGk9Z2V0SGlkZGVuUGFyZW50Tm9kZXMoZSksbj1pLmxlbmd0aCxyPVtdLHM9ZVt0XSxvPTAsYT12b2lkIDA7aWYobil7Zm9yKG89MDtvPG47bysrKWE9aVtvXS5zdHlsZSxyW29dPWEuZGlzcGxheSxhLmRpc3BsYXk9XCJibG9ja1wiLGEuaGVpZ2h0PVwiMFwiLGEub3ZlcmZsb3c9XCJoaWRkZW5cIixhLnZpc2liaWxpdHk9XCJoaWRkZW5cIix0b2dnbGVPcGVuUHJvcGVydHkoaVtvXSk7Zm9yKHM9ZVt0XSxvPTA7bzxuO28rKylhPWlbb10uc3R5bGUsdG9nZ2xlT3BlblByb3BlcnR5KGlbb10pLGEuZGlzcGxheT1yW29dLGEuaGVpZ2h0PVwiXCIsYS5vdmVyZmxvdz1cIlwiLGEudmlzaWJpbGl0eT1cIlwifXJldHVybiBzfWZ1bmN0aW9uIGZvckVhY2hBbmNlc3RvcnNBbmRTZWxmKGUsdCl7Zm9yKHQoZSk7ZS5wYXJlbnROb2RlJiYhdChlKTspZT1lLnBhcmVudE5vZGU7cmV0dXJuIGV9ZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIoZSx0KXtlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHQsZS5uZXh0U2libGluZyl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49aSgzKSxyPWZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX0obik7d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZT13aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lO3ZhciBzPU51bWJlci5pc05hTnx8ZnVuY3Rpb24oZSl7cmV0dXJuIGUhPT1lfSxvPU51bWJlci5pc0Zpbml0ZXx8ZnVuY3Rpb24oZSl7cmV0dXJuIShcIm51bWJlclwiIT10eXBlb2YgZXx8cyhlKXx8ZT09PTEvMHx8ZT09PS0xLzApfSxhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gcmVzaXplKCl7dHx8KHQ9ITAsd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZT93aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJ1bkNhbGxiYWNrcyk6c2V0VGltZW91dChydW5DYWxsYmFja3MsNjYpKX1mdW5jdGlvbiBydW5DYWxsYmFja3MoKXtlLmZvckVhY2goZnVuY3Rpb24oZSl7ZSgpfSksdD0hMX1mdW5jdGlvbiBhZGRDYWxsYmFjayh0KXt0JiZlLnB1c2godCl9dmFyIGU9W10sdD0hMTtyZXR1cm57YWRkOmZ1bmN0aW9uKHQpeyFlLmxlbmd0aCYmd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIixyZXNpemUpLGFkZENhbGxiYWNrKHQpfX19KCk7dC5kZWZhdWx0PXtlbWl0OmZ1bmN0aW9uKGUsdCxpKXtlLmRpc3BhdGNoRXZlbnQobmV3IHIuZGVmYXVsdCh0LGkpKX0saXNGaW5pdGVOdW1iZXI6byxnZXRGaXJzdE51bWJlckxpa2U6Z2V0Rmlyc3ROdW1iZXJMaWtlLGdldERpbWVuc2lvbjpnZXREaW1lbnNpb24saW5zZXJ0QWZ0ZXI6aW5zZXJ0QWZ0ZXIsZm9yRWFjaEFuY2VzdG9yc0FuZFNlbGY6Zm9yRWFjaEFuY2VzdG9yc0FuZFNlbGYsY2xhbXA6Y2xhbXAsb3B0aW1pemVkUmVzaXplOmF9fSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX12YXIgbj1mdW5jdGlvbigpe2Z1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoZSx0KXtmb3IodmFyIGk9MDtpPHQubGVuZ3RoO2krKyl7dmFyIG49dFtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbi5rZXksbil9fXJldHVybiBmdW5jdGlvbihlLHQsaSl7cmV0dXJuIHQmJmRlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsdCksaSYmZGVmaW5lUHJvcGVydGllcyhlLGkpLGV9fSgpLHI9aSg0KSxzPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQociksbz1pKDEpLGE9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChvKSx1PWkoMCksbD1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHUpLGM9ZnVuY3Rpb24oZSl7dmFyIHQ9ZG9jdW1lbnQmJmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7cmV0dXJuIHQuY2xhc3NMaXN0LmFkZChlKSx0fSxkPWZ1bmN0aW9uKGUpe3JldHVybihcIlwiK2UpLnJlcGxhY2UoXCIuXCIsXCJcIikubGVuZ3RoLTF9LGg9ZnVuY3Rpb24oKXtmdW5jdGlvbiBSYW5nZVNsaWRlcihlLHQpe3ZhciBpPXRoaXM7X2NsYXNzQ2FsbENoZWNrKHRoaXMsUmFuZ2VTbGlkZXIpLHQ9dHx8e30sdGhpcy5lbGVtZW50PWUsdGhpcy5vcHRpb25zPXQsdGhpcy5vblNsaWRlRXZlbnRzQ291bnQ9LTEsdGhpcy5pc0ludGVyYWN0aW5nPSExLHRoaXMubmVlZFRyaWdnZXJFdmVudHM9ITEsdGhpcy5jb25zdHJ1Y3Rvci5jb3VudD10aGlzLmNvbnN0cnVjdG9yLmNvdW50fHwwLHRoaXMuaWRlbnRpZmllcj1cImpzLVwiK2wuZGVmYXVsdC5QTFVHSU5fTkFNRStcIi1cIit0aGlzLmNvbnN0cnVjdG9yLmNvdW50KyssdGhpcy5taW49YS5kZWZhdWx0LmdldEZpcnN0TnVtYmVyTGlrZSh0Lm1pbixwYXJzZUZsb2F0KGUuZ2V0QXR0cmlidXRlKFwibWluXCIpKSxsLmRlZmF1bHQuTUlOX0RFRkFVTFQpLHRoaXMubWF4PWEuZGVmYXVsdC5nZXRGaXJzdE51bWJlckxpa2UodC5tYXgscGFyc2VGbG9hdChlLmdldEF0dHJpYnV0ZShcIm1heFwiKSksbC5kZWZhdWx0Lk1BWF9ERUZBVUxUKSx0aGlzLnZhbHVlPWEuZGVmYXVsdC5nZXRGaXJzdE51bWJlckxpa2UodC52YWx1ZSxwYXJzZUZsb2F0KGUuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikpLHRoaXMubWluKyh0aGlzLm1heC10aGlzLm1pbikvMiksdGhpcy5zdGVwPWEuZGVmYXVsdC5nZXRGaXJzdE51bWJlckxpa2UodC5zdGVwLHBhcnNlRmxvYXQoZS5nZXRBdHRyaWJ1dGUoXCJzdGVwXCIpKSxsLmRlZmF1bHQuU1RFUF9ERUZBVUxUKSx0aGlzLnBlcmNlbnQ9bnVsbCx0aGlzLl91cGRhdGVQZXJjZW50RnJvbVZhbHVlKCksdGhpcy50b0ZpeGVkPWQodGhpcy5zdGVwKSx0aGlzLnJhbmdlPWMobC5kZWZhdWx0LlJBTkdFX0NMQVNTKSx0aGlzLnJhbmdlLmlkPXRoaXMuaWRlbnRpZmllcix0aGlzLmZpbGxCZz1jKGwuZGVmYXVsdC5GSUxMX0JHX0NMQVNTKSx0aGlzLmZpbGw9YyhsLmRlZmF1bHQuRklMTF9DTEFTUyksdGhpcy5oYW5kbGU9YyhsLmRlZmF1bHQuSEFORExFX0NMQVNTKSxbXCJmaWxsQmdcIixcImZpbGxcIixcImhhbmRsZVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBpLnJhbmdlLmFwcGVuZENoaWxkKGlbZV0pfSksW1wibWluXCIsXCJtYXhcIixcInN0ZXBcIl0uZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gZS5zZXRBdHRyaWJ1dGUodCxcIlwiK2lbdF0pfSksdGhpcy5fc2V0VmFsdWUodGhpcy52YWx1ZSksYS5kZWZhdWx0Lmluc2VydEFmdGVyKGUsdGhpcy5yYW5nZSksZS5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCIsZS5zdHlsZS53aWR0aD1cIjFweFwiLGUuc3R5bGUuaGVpZ2h0PVwiMXB4XCIsZS5zdHlsZS5vdmVyZmxvdz1cImhpZGRlblwiLGUuc3R5bGUub3BhY2l0eT1cIjBcIixbXCJfdXBkYXRlXCIsXCJfaGFuZGxlRG93blwiLFwiX2hhbmRsZU1vdmVcIixcIl9oYW5kbGVFbmRcIixcIl9zdGFydEV2ZW50TGlzdGVuZXJcIixcIl9jaGFuZ2VFdmVudExpc3RlbmVyXCJdLmZvckVhY2goZnVuY3Rpb24oZSl7aVtlXT1pW2VdLmJpbmQoaSl9KSx0aGlzLl9pbml0KCksYS5kZWZhdWx0Lm9wdGltaXplZFJlc2l6ZS5hZGQodGhpcy5fdXBkYXRlKSxsLmRlZmF1bHQuU1RBUlRfRVZFTlRTLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGkucmFuZ2UuYWRkRXZlbnRMaXN0ZW5lcihlLGkuX3N0YXJ0RXZlbnRMaXN0ZW5lcil9KSxlLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIix0aGlzLl9jaGFuZ2VFdmVudExpc3RlbmVyKX1yZXR1cm4gbihSYW5nZVNsaWRlcixbe2tleTpcIl9pbml0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl91cGRhdGUoKSx0aGlzLm9wdGlvbnMub25Jbml0JiZ0aGlzLm9wdGlvbnMub25Jbml0LmNhbGwodGhpcyx0aGlzLnZhbHVlLHRoaXMucGVyY2VudCx0aGlzLnBvc2l0aW9uKX19LHtrZXk6XCJfdXBkYXRlUGVyY2VudEZyb21WYWx1ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5wZXJjZW50PSh0aGlzLnZhbHVlLXRoaXMubWluKS8odGhpcy5tYXgtdGhpcy5taW4pfX0se2tleTpcIl9zdGFydEV2ZW50TGlzdGVuZXJcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1lLnRhcmdldCxpPXRoaXMuaWRlbnRpZmllcixuPSExO2EuZGVmYXVsdC5mb3JFYWNoQW5jZXN0b3JzQW5kU2VsZih0LGZ1bmN0aW9uKGUpe3JldHVybiBuPWUuaWQ9PT1pJiYhZS5jbGFzc0xpc3QuY29udGFpbnMobC5kZWZhdWx0LkRJU0FCTEVEX0NMQVNTKX0pLG4mJnRoaXMuX2hhbmRsZURvd24oZSl9fSx7a2V5OlwiX2NoYW5nZUV2ZW50TGlzdGVuZXJcIix2YWx1ZTpmdW5jdGlvbihlLHQpeyh0JiZ0Lm9yaWdpbikhPT10aGlzLmlkZW50aWZpZXImJnRoaXMuX3NldFBvc2l0aW9uKHRoaXMuX2dldFBvc2l0aW9uRnJvbVZhbHVlKGUudGFyZ2V0LnZhbHVlKSl9fSx7a2V5OlwiX3VwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5oYW5kbGVXaWR0aD1hLmRlZmF1bHQuZ2V0RGltZW5zaW9uKHRoaXMuaGFuZGxlLFwib2Zmc2V0V2lkdGhcIiksdGhpcy5yYW5nZVdpZHRoPWEuZGVmYXVsdC5nZXREaW1lbnNpb24odGhpcy5yYW5nZSxcIm9mZnNldFdpZHRoXCIpLHRoaXMubWF4SGFuZGxlWD10aGlzLnJhbmdlV2lkdGgtdGhpcy5oYW5kbGVXaWR0aCx0aGlzLmdyYWJYPXRoaXMuaGFuZGxlV2lkdGgvMix0aGlzLnBvc2l0aW9uPXRoaXMuX2dldFBvc2l0aW9uRnJvbVZhbHVlKHRoaXMudmFsdWUpLHRoaXMucmFuZ2UuY2xhc3NMaXN0W3RoaXMuZWxlbWVudC5kaXNhYmxlZD9cImFkZFwiOlwicmVtb3ZlXCJdKGwuZGVmYXVsdC5ESVNBQkxFRF9DTEFTUyksdGhpcy5fc2V0UG9zaXRpb24odGhpcy5wb3NpdGlvbiksdGhpcy5fdXBkYXRlUGVyY2VudEZyb21WYWx1ZSgpLHRoaXMuX2VtaXQoXCJjaGFuZ2VcIil9fSx7a2V5OlwiX2xpc3RlblwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsaT0oZT9cImFkZFwiOlwicmVtb3ZlXCIpK1wiRXZlbnRMaXN0ZW5lclwiO2wuZGVmYXVsdC5NT1ZFX0VWRU5UUy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBkb2N1bWVudCYmZG9jdW1lbnRbaV0oZSx0Ll9oYW5kbGVNb3ZlKX0pLGwuZGVmYXVsdC5FTkRfRVZFTlRTLmZvckVhY2goZnVuY3Rpb24oZSl7ZG9jdW1lbnQmJmRvY3VtZW50W2ldKGUsdC5faGFuZGxlRW5kKSx0LnJhbmdlW2ldKGUsdC5faGFuZGxlRW5kKX0pfX0se2tleTpcIl9oYW5kbGVEb3duXCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYoZS5wcmV2ZW50RGVmYXVsdCgpLHRoaXMuaXNJbnRlcmFjdGluZz0hMCx0aGlzLl9saXN0ZW4oITApLCFlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMobC5kZWZhdWx0LkhBTkRMRV9DTEFTUykpe3ZhciB0PSgwLHMuZGVmYXVsdCkoZSx0aGlzLnJhbmdlKS54LGk9dGhpcy5yYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0LG49dGhpcy5oYW5kbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdC1pO3RoaXMuX3NldFBvc2l0aW9uKHQtdGhpcy5ncmFiWCksdD49biYmdDxuK3RoaXMuaGFuZGxlV2lkdGgmJih0aGlzLmdyYWJYPXQtbiksdGhpcy5fdXBkYXRlUGVyY2VudEZyb21WYWx1ZSgpfX19LHtrZXk6XCJfaGFuZGxlTW92ZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuaXNJbnRlcmFjdGluZz0hMCxlLnByZXZlbnREZWZhdWx0KCk7dmFyIHQ9KDAscy5kZWZhdWx0KShlLHRoaXMucmFuZ2UpLng7dGhpcy5fc2V0UG9zaXRpb24odC10aGlzLmdyYWJYKX19LHtrZXk6XCJfaGFuZGxlRW5kXCIsdmFsdWU6ZnVuY3Rpb24oZSl7ZS5wcmV2ZW50RGVmYXVsdCgpLHRoaXMuX2xpc3RlbighMSksdGhpcy5fZW1pdChcImNoYW5nZVwiKSwodGhpcy5pc0ludGVyYWN0aW5nfHx0aGlzLm5lZWRUcmlnZ2VyRXZlbnRzKSYmdGhpcy5vcHRpb25zLm9uU2xpZGVFbmQmJnRoaXMub3B0aW9ucy5vblNsaWRlRW5kLmNhbGwodGhpcyx0aGlzLnZhbHVlLHRoaXMucGVyY2VudCx0aGlzLnBvc2l0aW9uKSx0aGlzLm9uU2xpZGVFdmVudHNDb3VudD0wLHRoaXMuaXNJbnRlcmFjdGluZz0hMX19LHtrZXk6XCJfc2V0UG9zaXRpb25cIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLmlzSW50ZXJhY3Rpbmc/dGhpcy5fZ2V0VmFsdWVGcm9tUG9zaXRpb24oYS5kZWZhdWx0LmNsYW1wKGUsMCx0aGlzLm1heEhhbmRsZVgpKTp0aGlzLnZhbHVlLGk9dGhpcy5fZ2V0UG9zaXRpb25Gcm9tVmFsdWUodCk7dGhpcy5maWxsLnN0eWxlLndpZHRoPWkrdGhpcy5ncmFiWCtcInB4XCIsdGhpcy5oYW5kbGUuc3R5bGUud2Via2l0VHJhbnNmb3JtPXRoaXMuaGFuZGxlLnN0eWxlLnRyYW5zZm9ybT1cInRyYW5zbGF0ZShcIitpK1wicHgsIC01MCUpXCIsdGhpcy5fc2V0VmFsdWUodCksdGhpcy5wb3NpdGlvbj1pLHRoaXMudmFsdWU9dCx0aGlzLl91cGRhdGVQZXJjZW50RnJvbVZhbHVlKCksKHRoaXMuaXNJbnRlcmFjdGluZ3x8dGhpcy5uZWVkVHJpZ2dlckV2ZW50cykmJih0aGlzLm9wdGlvbnMub25TbGlkZVN0YXJ0JiYwPT09dGhpcy5vblNsaWRlRXZlbnRzQ291bnQmJnRoaXMub3B0aW9ucy5vblNsaWRlU3RhcnQuY2FsbCh0aGlzLHRoaXMudmFsdWUsdGhpcy5wZXJjZW50LHRoaXMucG9zaXRpb24pLHRoaXMub3B0aW9ucy5vblNsaWRlJiZ0aGlzLm9wdGlvbnMub25TbGlkZS5jYWxsKHRoaXMsdGhpcy52YWx1ZSx0aGlzLnBlcmNlbnQsdGhpcy5wb3NpdGlvbikpLHRoaXMub25TbGlkZUV2ZW50c0NvdW50Kyt9fSx7a2V5OlwiX2dldFBvc2l0aW9uRnJvbVZhbHVlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuKGUtdGhpcy5taW4pLyh0aGlzLm1heC10aGlzLm1pbikqdGhpcy5tYXhIYW5kbGVYfX0se2tleTpcIl9nZXRWYWx1ZUZyb21Qb3NpdGlvblwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWUvKHRoaXMubWF4SGFuZGxlWHx8MSksaT10aGlzLnN0ZXAqTWF0aC5yb3VuZCh0Kih0aGlzLm1heC10aGlzLm1pbikvdGhpcy5zdGVwKSt0aGlzLm1pbjtyZXR1cm4gTnVtYmVyKGkudG9GaXhlZCh0aGlzLnRvRml4ZWQpKX19LHtrZXk6XCJfc2V0VmFsdWVcIix2YWx1ZTpmdW5jdGlvbihlKXsoZT1hLmRlZmF1bHQuY2xhbXAoZSx0aGlzLm1pbix0aGlzLm1heCkpPT09dGhpcy52YWx1ZSYmZT09PXRoaXMuZWxlbWVudC52YWx1ZXx8KHRoaXMudmFsdWU9dGhpcy5lbGVtZW50LnZhbHVlPWUsdGhpcy5fZW1pdChcImlucHV0XCIpKX19LHtrZXk6XCJfZW1pdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe2EuZGVmYXVsdC5lbWl0KHRoaXMuZWxlbWVudCxlLHtvcmlnaW46dGhpcy5pZGVudGlmaWVyfSl9fSx7a2V5OlwidXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT1lfHx7fSx0aGlzLm5lZWRUcmlnZ2VyRXZlbnRzPSEhdCxhLmRlZmF1bHQuaXNGaW5pdGVOdW1iZXIoZS5taW4pJiYodGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcIm1pblwiLFwiXCIrZS5taW4pLHRoaXMubWluPWUubWluKSxhLmRlZmF1bHQuaXNGaW5pdGVOdW1iZXIoZS5tYXgpJiYodGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcIm1heFwiLFwiXCIrZS5tYXgpLHRoaXMubWF4PWUubWF4KSxhLmRlZmF1bHQuaXNGaW5pdGVOdW1iZXIoZS5zdGVwKSYmKHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzdGVwXCIsXCJcIitlLnN0ZXApLHRoaXMuc3RlcD1lLnN0ZXAsdGhpcy50b0ZpeGVkPWQoZS5zdGVwKSksYS5kZWZhdWx0LmlzRmluaXRlTnVtYmVyKGUudmFsdWUpJiZ0aGlzLl9zZXRWYWx1ZShlLnZhbHVlKSx0aGlzLl91cGRhdGUoKSx0aGlzLm9uU2xpZGVFdmVudHNDb3VudD0wLHRoaXMubmVlZFRyaWdnZXJFdmVudHM9ITEsdGhpc319LHtrZXk6XCJkZXN0cm95XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO1widW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsdGhpcy5fdXBkYXRlLCExKSxsLmRlZmF1bHQuU1RBUlRfRVZFTlRTLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIGUucmFuZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LGUuX3N0YXJ0RXZlbnRMaXN0ZW5lcil9KSx0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLHRoaXMuX2NoYW5nZUV2ZW50TGlzdGVuZXIpLHRoaXMuZWxlbWVudC5zdHlsZS5jc3NUZXh0PVwiXCIsZGVsZXRlIHRoaXMuZWxlbWVudFtsLmRlZmF1bHQuUExVR0lOX05BTUVdLHRoaXMucmFuZ2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnJhbmdlKX19XSksUmFuZ2VTbGlkZXJ9KCk7ZS5leHBvcnRzPWh9LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjsoZnVuY3Rpb24odCl7dmFyIGk9dC5DdXN0b21FdmVudDtlLmV4cG9ydHM9ZnVuY3Rpb24oKXt0cnl7dmFyIGU9bmV3IGkoXCJjYXRcIix7ZGV0YWlsOntmb286XCJiYXJcIn19KTtyZXR1cm5cImNhdFwiPT09ZS50eXBlJiZcImJhclwiPT09ZS5kZXRhaWwuZm9vfWNhdGNoKGUpe31yZXR1cm4hMX0oKT9pOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmXCJmdW5jdGlvblwiPT10eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQ/ZnVuY3Rpb24oZSx0KXt2YXIgaT1kb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO3JldHVybiB0P2kuaW5pdEN1c3RvbUV2ZW50KGUsdC5idWJibGVzLHQuY2FuY2VsYWJsZSx0LmRldGFpbCk6aS5pbml0Q3VzdG9tRXZlbnQoZSwhMSwhMSx2b2lkIDApLGl9OmZ1bmN0aW9uKGUsdCl7dmFyIGk9ZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKTtyZXR1cm4gaS50eXBlPWUsdD8oaS5idWJibGVzPUJvb2xlYW4odC5idWJibGVzKSxpLmNhbmNlbGFibGU9Qm9vbGVhbih0LmNhbmNlbGFibGUpLGkuZGV0YWlsPXQuZGV0YWlsKTooaS5idWJibGVzPSExLGkuY2FuY2VsYWJsZT0hMSxpLmRldGFpbD12b2lkIDApLGl9fSkuY2FsbCh0LGkoNSkpfSxmdW5jdGlvbihlLHQsaSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49ZnVuY3Rpb24oZSl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIGUmJiFpc05hTihlKX0scj1mdW5jdGlvbihlLHQpe3Q9dHx8dC5jdXJyZW50VGFyZ2V0O3ZhciBpPXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkscj1lLm9yaWdpbmFsRXZlbnR8fGUscz1lLnRvdWNoZXMmJmUudG91Y2hlcy5sZW5ndGgsbz0wLGE9MDtyZXR1cm4gcz9uKGUudG91Y2hlc1swXS5wYWdlWCkmJm4oZS50b3VjaGVzWzBdLnBhZ2VZKT8obz1lLnRvdWNoZXNbMF0ucGFnZVgsYT1lLnRvdWNoZXNbMF0ucGFnZVkpOm4oZS50b3VjaGVzWzBdLmNsaWVudFgpJiZuKGUudG91Y2hlc1swXS5jbGllbnRZKSYmKG89ci50b3VjaGVzWzBdLmNsaWVudFgsYT1yLnRvdWNoZXNbMF0uY2xpZW50WSk6bihlLnBhZ2VYKSYmbihlLnBhZ2VZKT8obz1lLnBhZ2VYLGE9ZS5wYWdlWSk6ZS5jdXJyZW50UG9pbnQmJm4oZS5jdXJyZW50UG9pbnQueCkmJm4oZS5jdXJyZW50UG9pbnQueSkmJihvPWUuY3VycmVudFBvaW50LngsYT1lLmN1cnJlbnRQb2ludC55KSx7eDpvLWkubGVmdCx5OmEtaS50b3B9fTtlLmV4cG9ydHM9cn0sZnVuY3Rpb24oZSx0LGkpe1widXNlIHN0cmljdFwiO3ZhciBuLHI9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX07bj1mdW5jdGlvbigpe3JldHVybiB0aGlzfSgpO3RyeXtuPW58fEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKXx8KDAsZXZhbCkoXCJ0aGlzXCIpfWNhdGNoKGUpe1wib2JqZWN0XCI9PT0oXCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdz9cInVuZGVmaW5lZFwiOnIod2luZG93KSkmJihuPXdpbmRvdyl9ZS5leHBvcnRzPW59LGZ1bmN0aW9uKGUsdCxpKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX12YXIgbj1pKDEpLHI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChuKSxzPWkoMiksbz1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHMpLGE9aSgwKSx1PV9pbnRlcm9wUmVxdWlyZURlZmF1bHQoYSksbD17UmFuZ2VTbGlkZXI6by5kZWZhdWx0LHV0aWxzOnIuZGVmYXVsdCxjcmVhdGU6ZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShlKXtlW3UuZGVmYXVsdC5QTFVHSU5fTkFNRV09ZVt1LmRlZmF1bHQuUExVR0lOX05BTUVdfHxuZXcgby5kZWZhdWx0KGUsdCl9ZSYmKGUubGVuZ3RoP0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGNyZWF0ZUluc3RhbmNlKGUpfSk6Y3JlYXRlSW5zdGFuY2UoZSkpfX07ZS5leHBvcnRzPWx9XSl9KTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JykgcmV0dXJuIG9iajtcbiAgICBcbiAgICB2YXIgY29weTtcbiAgICBcbiAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoO1xuICAgICAgICBjb3B5ID0gQXJyYXkobGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29weVtpXSA9IG9ialtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKG9iaik7XG4gICAgICAgIGNvcHkgPSB7fTtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgY29weVtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gICAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8qIVxuICogU2lnbmF0dXJlIFBhZCB2Mi4zLjBcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvc2lnbmF0dXJlX3BhZFxuICpcbiAqIENvcHlyaWdodCAyMDE3IFN6eW1vbiBOb3dha1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKlxuICogVGhlIG1haW4gaWRlYSBhbmQgc29tZSBwYXJ0cyBvZiB0aGUgY29kZSAoZS5nLiBkcmF3aW5nIHZhcmlhYmxlIHdpZHRoIELDqXppZXIgY3VydmUpIGFyZSB0YWtlbiBmcm9tOlxuICogaHR0cDovL2Nvcm5lci5zcXVhcmV1cC5jb20vMjAxMi8wNy9zbW9vdGhlci1zaWduYXR1cmVzLmh0bWxcbiAqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBpbnRlcnBvbGF0aW9uIHVzaW5nIGN1YmljIELDqXppZXIgY3VydmVzIGlzIHRha2VuIGZyb206XG4gKiBodHRwOi8vYmVua25vd3Njb2RlLndvcmRwcmVzcy5jb20vMjAxMi8wOS8xNC9wYXRoLWludGVycG9sYXRpb24tdXNpbmctY3ViaWMtYmV6aWVyLWFuZC1jb250cm9sLXBvaW50LWVzdGltYXRpb24taW4tamF2YXNjcmlwdFxuICpcbiAqIEFsZ29yaXRobSBmb3IgYXBwcm94aW1hdGVkIGxlbmd0aCBvZiBhIELDqXppZXIgY3VydmUgaXMgdGFrZW4gZnJvbTpcbiAqIGh0dHA6Ly93d3cubGVtb2RhLm5ldC9tYXRocy9iZXppZXItbGVuZ3RoL2luZGV4Lmh0bWxcbiAqXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLlNpZ25hdHVyZVBhZCA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gUG9pbnQoeCwgeSwgdGltZSkge1xuICB0aGlzLnggPSB4O1xuICB0aGlzLnkgPSB5O1xuICB0aGlzLnRpbWUgPSB0aW1lIHx8IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufVxuXG5Qb2ludC5wcm90b3R5cGUudmVsb2NpdHlGcm9tID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gIHJldHVybiB0aGlzLnRpbWUgIT09IHN0YXJ0LnRpbWUgPyB0aGlzLmRpc3RhbmNlVG8oc3RhcnQpIC8gKHRoaXMudGltZSAtIHN0YXJ0LnRpbWUpIDogMTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kaXN0YW5jZVRvID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy54IC0gc3RhcnQueCwgMikgKyBNYXRoLnBvdyh0aGlzLnkgLSBzdGFydC55LCAyKSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIHJldHVybiB0aGlzLnggPT09IG90aGVyLnggJiYgdGhpcy55ID09PSBvdGhlci55ICYmIHRoaXMudGltZSA9PT0gb3RoZXIudGltZTtcbn07XG5cbmZ1bmN0aW9uIEJlemllcihzdGFydFBvaW50LCBjb250cm9sMSwgY29udHJvbDIsIGVuZFBvaW50KSB7XG4gIHRoaXMuc3RhcnRQb2ludCA9IHN0YXJ0UG9pbnQ7XG4gIHRoaXMuY29udHJvbDEgPSBjb250cm9sMTtcbiAgdGhpcy5jb250cm9sMiA9IGNvbnRyb2wyO1xuICB0aGlzLmVuZFBvaW50ID0gZW5kUG9pbnQ7XG59XG5cbi8vIFJldHVybnMgYXBwcm94aW1hdGVkIGxlbmd0aC5cbkJlemllci5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RlcHMgPSAxMDtcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciBweCA9IHZvaWQgMDtcbiAgdmFyIHB5ID0gdm9pZCAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IHN0ZXBzOyBpICs9IDEpIHtcbiAgICB2YXIgdCA9IGkgLyBzdGVwcztcbiAgICB2YXIgY3ggPSB0aGlzLl9wb2ludCh0LCB0aGlzLnN0YXJ0UG9pbnQueCwgdGhpcy5jb250cm9sMS54LCB0aGlzLmNvbnRyb2wyLngsIHRoaXMuZW5kUG9pbnQueCk7XG4gICAgdmFyIGN5ID0gdGhpcy5fcG9pbnQodCwgdGhpcy5zdGFydFBvaW50LnksIHRoaXMuY29udHJvbDEueSwgdGhpcy5jb250cm9sMi55LCB0aGlzLmVuZFBvaW50LnkpO1xuICAgIGlmIChpID4gMCkge1xuICAgICAgdmFyIHhkaWZmID0gY3ggLSBweDtcbiAgICAgIHZhciB5ZGlmZiA9IGN5IC0gcHk7XG4gICAgICBsZW5ndGggKz0gTWF0aC5zcXJ0KHhkaWZmICogeGRpZmYgKyB5ZGlmZiAqIHlkaWZmKTtcbiAgICB9XG4gICAgcHggPSBjeDtcbiAgICBweSA9IGN5O1xuICB9XG5cbiAgcmV0dXJuIGxlbmd0aDtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLW11bHRpLXNwYWNlcywgc3BhY2UtaW4tcGFyZW5zICovXG5CZXppZXIucHJvdG90eXBlLl9wb2ludCA9IGZ1bmN0aW9uICh0LCBzdGFydCwgYzEsIGMyLCBlbmQpIHtcbiAgcmV0dXJuIHN0YXJ0ICogKDEuMCAtIHQpICogKDEuMCAtIHQpICogKDEuMCAtIHQpICsgMy4wICogYzEgKiAoMS4wIC0gdCkgKiAoMS4wIC0gdCkgKiB0ICsgMy4wICogYzIgKiAoMS4wIC0gdCkgKiB0ICogdCArIGVuZCAqIHQgKiB0ICogdDtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI3MDc4NDAxLzgxNTUwN1xuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICB2YXIgdGltZW91dCA9IG51bGw7XG4gIHZhciBwcmV2aW91cyA9IDA7XG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICB2YXIgbGF0ZXIgPSBmdW5jdGlvbiBsYXRlcigpIHtcbiAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogRGF0ZS5ub3coKTtcbiAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICB9O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgIGNvbnRleHQgPSB0aGlzO1xuICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICB9XG4gICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gU2lnbmF0dXJlUGFkKGNhbnZhcywgb3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBvcHRzID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLnZlbG9jaXR5RmlsdGVyV2VpZ2h0ID0gb3B0cy52ZWxvY2l0eUZpbHRlcldlaWdodCB8fCAwLjc7XG4gIHRoaXMubWluV2lkdGggPSBvcHRzLm1pbldpZHRoIHx8IDAuNTtcbiAgdGhpcy5tYXhXaWR0aCA9IG9wdHMubWF4V2lkdGggfHwgMi41O1xuICB0aGlzLnRocm90dGxlID0gJ3Rocm90dGxlJyBpbiBvcHRzID8gb3B0cy50aHJvdHRsZSA6IDE2OyAvLyBpbiBtaWxpc2Vjb25kc1xuICB0aGlzLm1pbkRpc3RhbmNlID0gb3B0cy5taW5EaXN0YW5jZSB8fCA1O1xuXG4gIGlmICh0aGlzLnRocm90dGxlKSB7XG4gICAgdGhpcy5fc3Ryb2tlTW92ZVVwZGF0ZSA9IHRocm90dGxlKFNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX3N0cm9rZVVwZGF0ZSwgdGhpcy50aHJvdHRsZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fc3Ryb2tlTW92ZVVwZGF0ZSA9IFNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX3N0cm9rZVVwZGF0ZTtcbiAgfVxuXG4gIHRoaXMuZG90U2l6ZSA9IG9wdHMuZG90U2l6ZSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLm1pbldpZHRoICsgdGhpcy5tYXhXaWR0aCkgLyAyO1xuICB9O1xuICB0aGlzLnBlbkNvbG9yID0gb3B0cy5wZW5Db2xvciB8fCAnYmxhY2snO1xuICB0aGlzLmJhY2tncm91bmRDb2xvciA9IG9wdHMuYmFja2dyb3VuZENvbG9yIHx8ICdyZ2JhKDAsMCwwLDApJztcbiAgdGhpcy5vbkJlZ2luID0gb3B0cy5vbkJlZ2luO1xuICB0aGlzLm9uRW5kID0gb3B0cy5vbkVuZDtcblxuICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG4gIHRoaXMuX2N0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICB0aGlzLmNsZWFyKCk7XG5cbiAgLy8gV2UgbmVlZCBhZGQgdGhlc2UgaW5saW5lIHNvIHRoZXkgYXJlIGF2YWlsYWJsZSB0byB1bmJpbmQgd2hpbGUgc3RpbGwgaGF2aW5nXG4gIC8vIGFjY2VzcyB0byAnc2VsZicgd2UgY291bGQgdXNlIF8uYmluZCBidXQgaXQncyBub3Qgd29ydGggYWRkaW5nIGEgZGVwZW5kZW5jeS5cbiAgdGhpcy5faGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAxKSB7XG4gICAgICBzZWxmLl9tb3VzZUJ1dHRvbkRvd24gPSB0cnVlO1xuICAgICAgc2VsZi5fc3Ryb2tlQmVnaW4oZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLl9oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoc2VsZi5fbW91c2VCdXR0b25Eb3duKSB7XG4gICAgICBzZWxmLl9zdHJva2VNb3ZlVXBkYXRlKGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5faGFuZGxlTW91c2VVcCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC53aGljaCA9PT0gMSAmJiBzZWxmLl9tb3VzZUJ1dHRvbkRvd24pIHtcbiAgICAgIHNlbGYuX21vdXNlQnV0dG9uRG93biA9IGZhbHNlO1xuICAgICAgc2VsZi5fc3Ryb2tlRW5kKGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5faGFuZGxlVG91Y2hTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXRUb3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICBzZWxmLl9zdHJva2VCZWdpbih0b3VjaCk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuX2hhbmRsZVRvdWNoTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIFByZXZlbnQgc2Nyb2xsaW5nLlxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB2YXIgdG91Y2ggPSBldmVudC50YXJnZXRUb3VjaGVzWzBdO1xuICAgIHNlbGYuX3N0cm9rZU1vdmVVcGRhdGUodG91Y2gpO1xuICB9O1xuXG4gIHRoaXMuX2hhbmRsZVRvdWNoRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHdhc0NhbnZhc1RvdWNoZWQgPSBldmVudC50YXJnZXQgPT09IHNlbGYuX2NhbnZhcztcbiAgICBpZiAod2FzQ2FudmFzVG91Y2hlZCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHNlbGYuX3N0cm9rZUVuZChldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEVuYWJsZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnQgaGFuZGxlcnNcbiAgdGhpcy5vbigpO1xufVxuXG4vLyBQdWJsaWMgbWV0aG9kc1xuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcblxuICBjdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgdGhpcy5fZGF0YSA9IFtdO1xuICB0aGlzLl9yZXNldCgpO1xuICB0aGlzLl9pc0VtcHR5ID0gdHJ1ZTtcbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuZnJvbURhdGFVUkwgPSBmdW5jdGlvbiAoZGF0YVVybCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgdmFyIHJhdGlvID0gb3B0aW9ucy5yYXRpbyB8fCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoIHx8IHRoaXMuX2NhbnZhcy53aWR0aCAvIHJhdGlvO1xuICB2YXIgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgfHwgdGhpcy5fY2FudmFzLmhlaWdodCAvIHJhdGlvO1xuXG4gIHRoaXMuX3Jlc2V0KCk7XG4gIGltYWdlLnNyYyA9IGRhdGFVcmw7XG4gIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5fY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gIH07XG4gIHRoaXMuX2lzRW1wdHkgPSBmYWxzZTtcbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUudG9EYXRhVVJMID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgdmFyIF9jYW52YXM7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnaW1hZ2Uvc3ZnK3htbCc6XG4gICAgICByZXR1cm4gdGhpcy5fdG9TVkcoKTtcbiAgICBkZWZhdWx0OlxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG9wdGlvbnMgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIG9wdGlvbnNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKF9jYW52YXMgPSB0aGlzLl9jYW52YXMpLnRvRGF0YVVSTC5hcHBseShfY2FudmFzLCBbdHlwZV0uY29uY2F0KG9wdGlvbnMpKTtcbiAgfVxufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5faGFuZGxlTW91c2VFdmVudHMoKTtcbiAgdGhpcy5faGFuZGxlVG91Y2hFdmVudHMoKTtcbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5faGFuZGxlTW91c2VEb3duKTtcbiAgdGhpcy5fY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZU1vdXNlTW92ZSk7XG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9oYW5kbGVNb3VzZVVwKTtcblxuICB0aGlzLl9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX2hhbmRsZVRvdWNoU3RhcnQpO1xuICB0aGlzLl9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlVG91Y2hNb3ZlKTtcbiAgdGhpcy5fY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5faGFuZGxlVG91Y2hFbmQpO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5faXNFbXB0eTtcbn07XG5cbi8vIFByaXZhdGUgbWV0aG9kc1xuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fc3Ryb2tlQmVnaW4gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdGhpcy5fZGF0YS5wdXNoKFtdKTtcbiAgdGhpcy5fcmVzZXQoKTtcbiAgdGhpcy5fc3Ryb2tlVXBkYXRlKGV2ZW50KTtcblxuICBpZiAodHlwZW9mIHRoaXMub25CZWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMub25CZWdpbihldmVudCk7XG4gIH1cbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX3N0cm9rZVVwZGF0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgeCA9IGV2ZW50LmNsaWVudFg7XG4gIHZhciB5ID0gZXZlbnQuY2xpZW50WTtcblxuICB2YXIgcG9pbnQgPSB0aGlzLl9jcmVhdGVQb2ludCh4LCB5KTtcbiAgdmFyIGxhc3RQb2ludEdyb3VwID0gdGhpcy5fZGF0YVt0aGlzLl9kYXRhLmxlbmd0aCAtIDFdO1xuICB2YXIgbGFzdFBvaW50ID0gbGFzdFBvaW50R3JvdXAgJiYgbGFzdFBvaW50R3JvdXBbbGFzdFBvaW50R3JvdXAubGVuZ3RoIC0gMV07XG4gIHZhciBpc0xhc3RQb2ludFRvb0Nsb3NlID0gbGFzdFBvaW50ICYmIHBvaW50LmRpc3RhbmNlVG8obGFzdFBvaW50KSA8IHRoaXMubWluRGlzdGFuY2U7XG5cbiAgLy8gU2tpcCB0aGlzIHBvaW50IGlmIGl0J3MgdG9vIGNsb3NlIHRvIHRoZSBwcmV2aW91cyBvbmVcbiAgaWYgKCEobGFzdFBvaW50ICYmIGlzTGFzdFBvaW50VG9vQ2xvc2UpKSB7XG4gICAgdmFyIF9hZGRQb2ludCA9IHRoaXMuX2FkZFBvaW50KHBvaW50KSxcbiAgICAgICAgY3VydmUgPSBfYWRkUG9pbnQuY3VydmUsXG4gICAgICAgIHdpZHRocyA9IF9hZGRQb2ludC53aWR0aHM7XG5cbiAgICBpZiAoY3VydmUgJiYgd2lkdGhzKSB7XG4gICAgICB0aGlzLl9kcmF3Q3VydmUoY3VydmUsIHdpZHRocy5zdGFydCwgd2lkdGhzLmVuZCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGF0YVt0aGlzLl9kYXRhLmxlbmd0aCAtIDFdLnB1c2goe1xuICAgICAgeDogcG9pbnQueCxcbiAgICAgIHk6IHBvaW50LnksXG4gICAgICB0aW1lOiBwb2ludC50aW1lLFxuICAgICAgY29sb3I6IHRoaXMucGVuQ29sb3JcbiAgICB9KTtcbiAgfVxufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fc3Ryb2tlRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBjYW5EcmF3Q3VydmUgPSB0aGlzLnBvaW50cy5sZW5ndGggPiAyO1xuICB2YXIgcG9pbnQgPSB0aGlzLnBvaW50c1swXTsgLy8gUG9pbnQgaW5zdGFuY2VcblxuICBpZiAoIWNhbkRyYXdDdXJ2ZSAmJiBwb2ludCkge1xuICAgIHRoaXMuX2RyYXdEb3QocG9pbnQpO1xuICB9XG5cbiAgaWYgKHBvaW50KSB7XG4gICAgdmFyIGxhc3RQb2ludEdyb3VwID0gdGhpcy5fZGF0YVt0aGlzLl9kYXRhLmxlbmd0aCAtIDFdO1xuICAgIHZhciBsYXN0UG9pbnQgPSBsYXN0UG9pbnRHcm91cFtsYXN0UG9pbnRHcm91cC5sZW5ndGggLSAxXTsgLy8gcGxhaW4gb2JqZWN0XG5cbiAgICAvLyBXaGVuIGRyYXdpbmcgYSBkb3QsIHRoZXJlJ3Mgb25seSBvbmUgcG9pbnQgaW4gYSBncm91cCwgc28gd2l0aG91dCB0aGlzIGNoZWNrXG4gICAgLy8gc3VjaCBncm91cCB3b3VsZCBlbmQgdXAgd2l0aCBleGFjdGx5IHRoZSBzYW1lIDIgcG9pbnRzLlxuICAgIGlmICghcG9pbnQuZXF1YWxzKGxhc3RQb2ludCkpIHtcbiAgICAgIGxhc3RQb2ludEdyb3VwLnB1c2goe1xuICAgICAgICB4OiBwb2ludC54LFxuICAgICAgICB5OiBwb2ludC55LFxuICAgICAgICB0aW1lOiBwb2ludC50aW1lLFxuICAgICAgICBjb2xvcjogdGhpcy5wZW5Db2xvclxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0aGlzLm9uRW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5vbkVuZChldmVudCk7XG4gIH1cbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX2hhbmRsZU1vdXNlRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9tb3VzZUJ1dHRvbkRvd24gPSBmYWxzZTtcblxuICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5faGFuZGxlTW91c2VEb3duKTtcbiAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZU1vdXNlTW92ZSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9oYW5kbGVNb3VzZVVwKTtcbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX2hhbmRsZVRvdWNoRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAvLyBQYXNzIHRvdWNoIGV2ZW50cyB0byBjYW52YXMgZWxlbWVudCBvbiBtb2JpbGUgSUUxMSBhbmQgRWRnZS5cbiAgdGhpcy5fY2FudmFzLnN0eWxlLm1zVG91Y2hBY3Rpb24gPSAnbm9uZSc7XG4gIHRoaXMuX2NhbnZhcy5zdHlsZS50b3VjaEFjdGlvbiA9ICdub25lJztcblxuICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX2hhbmRsZVRvdWNoU3RhcnQpO1xuICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlVG91Y2hNb3ZlKTtcbiAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5faGFuZGxlVG91Y2hFbmQpO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucG9pbnRzID0gW107XG4gIHRoaXMuX2xhc3RWZWxvY2l0eSA9IDA7XG4gIHRoaXMuX2xhc3RXaWR0aCA9ICh0aGlzLm1pbldpZHRoICsgdGhpcy5tYXhXaWR0aCkgLyAyO1xuICB0aGlzLl9jdHguZmlsbFN0eWxlID0gdGhpcy5wZW5Db2xvcjtcbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX2NyZWF0ZVBvaW50ID0gZnVuY3Rpb24gKHgsIHksIHRpbWUpIHtcbiAgdmFyIHJlY3QgPSB0aGlzLl9jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgcmV0dXJuIG5ldyBQb2ludCh4IC0gcmVjdC5sZWZ0LCB5IC0gcmVjdC50b3AsIHRpbWUgfHwgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fYWRkUG9pbnQgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICB2YXIgdG1wID0gdm9pZCAwO1xuXG4gIHBvaW50cy5wdXNoKHBvaW50KTtcblxuICBpZiAocG9pbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAvLyBUbyByZWR1Y2UgdGhlIGluaXRpYWwgbGFnIG1ha2UgaXQgd29yayB3aXRoIDMgcG9pbnRzXG4gICAgLy8gYnkgY29weWluZyB0aGUgZmlyc3QgcG9pbnQgdG8gdGhlIGJlZ2lubmluZy5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMykgcG9pbnRzLnVuc2hpZnQocG9pbnRzWzBdKTtcblxuICAgIHRtcCA9IHRoaXMuX2NhbGN1bGF0ZUN1cnZlQ29udHJvbFBvaW50cyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdKTtcbiAgICB2YXIgYzIgPSB0bXAuYzI7XG4gICAgdG1wID0gdGhpcy5fY2FsY3VsYXRlQ3VydmVDb250cm9sUG9pbnRzKHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10pO1xuICAgIHZhciBjMyA9IHRtcC5jMTtcbiAgICB2YXIgY3VydmUgPSBuZXcgQmV6aWVyKHBvaW50c1sxXSwgYzIsIGMzLCBwb2ludHNbMl0pO1xuICAgIHZhciB3aWR0aHMgPSB0aGlzLl9jYWxjdWxhdGVDdXJ2ZVdpZHRocyhjdXJ2ZSk7XG5cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IGVsZW1lbnQgZnJvbSB0aGUgbGlzdCxcbiAgICAvLyBzbyB0aGF0IHdlIGFsd2F5cyBoYXZlIG5vIG1vcmUgdGhhbiA0IHBvaW50cyBpbiBwb2ludHMgYXJyYXkuXG4gICAgcG9pbnRzLnNoaWZ0KCk7XG5cbiAgICByZXR1cm4geyBjdXJ2ZTogY3VydmUsIHdpZHRoczogd2lkdGhzIH07XG4gIH1cblxuICByZXR1cm4ge307XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLl9jYWxjdWxhdGVDdXJ2ZUNvbnRyb2xQb2ludHMgPSBmdW5jdGlvbiAoczEsIHMyLCBzMykge1xuICB2YXIgZHgxID0gczEueCAtIHMyLng7XG4gIHZhciBkeTEgPSBzMS55IC0gczIueTtcbiAgdmFyIGR4MiA9IHMyLnggLSBzMy54O1xuICB2YXIgZHkyID0gczIueSAtIHMzLnk7XG5cbiAgdmFyIG0xID0geyB4OiAoczEueCArIHMyLngpIC8gMi4wLCB5OiAoczEueSArIHMyLnkpIC8gMi4wIH07XG4gIHZhciBtMiA9IHsgeDogKHMyLnggKyBzMy54KSAvIDIuMCwgeTogKHMyLnkgKyBzMy55KSAvIDIuMCB9O1xuXG4gIHZhciBsMSA9IE1hdGguc3FydChkeDEgKiBkeDEgKyBkeTEgKiBkeTEpO1xuICB2YXIgbDIgPSBNYXRoLnNxcnQoZHgyICogZHgyICsgZHkyICogZHkyKTtcblxuICB2YXIgZHhtID0gbTEueCAtIG0yLng7XG4gIHZhciBkeW0gPSBtMS55IC0gbTIueTtcblxuICB2YXIgayA9IGwyIC8gKGwxICsgbDIpO1xuICB2YXIgY20gPSB7IHg6IG0yLnggKyBkeG0gKiBrLCB5OiBtMi55ICsgZHltICogayB9O1xuXG4gIHZhciB0eCA9IHMyLnggLSBjbS54O1xuICB2YXIgdHkgPSBzMi55IC0gY20ueTtcblxuICByZXR1cm4ge1xuICAgIGMxOiBuZXcgUG9pbnQobTEueCArIHR4LCBtMS55ICsgdHkpLFxuICAgIGMyOiBuZXcgUG9pbnQobTIueCArIHR4LCBtMi55ICsgdHkpXG4gIH07XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLl9jYWxjdWxhdGVDdXJ2ZVdpZHRocyA9IGZ1bmN0aW9uIChjdXJ2ZSkge1xuICB2YXIgc3RhcnRQb2ludCA9IGN1cnZlLnN0YXJ0UG9pbnQ7XG4gIHZhciBlbmRQb2ludCA9IGN1cnZlLmVuZFBvaW50O1xuICB2YXIgd2lkdGhzID0geyBzdGFydDogbnVsbCwgZW5kOiBudWxsIH07XG5cbiAgdmFyIHZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eUZpbHRlcldlaWdodCAqIGVuZFBvaW50LnZlbG9jaXR5RnJvbShzdGFydFBvaW50KSArICgxIC0gdGhpcy52ZWxvY2l0eUZpbHRlcldlaWdodCkgKiB0aGlzLl9sYXN0VmVsb2NpdHk7XG5cbiAgdmFyIG5ld1dpZHRoID0gdGhpcy5fc3Ryb2tlV2lkdGgodmVsb2NpdHkpO1xuXG4gIHdpZHRocy5zdGFydCA9IHRoaXMuX2xhc3RXaWR0aDtcbiAgd2lkdGhzLmVuZCA9IG5ld1dpZHRoO1xuXG4gIHRoaXMuX2xhc3RWZWxvY2l0eSA9IHZlbG9jaXR5O1xuICB0aGlzLl9sYXN0V2lkdGggPSBuZXdXaWR0aDtcblxuICByZXR1cm4gd2lkdGhzO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fc3Ryb2tlV2lkdGggPSBmdW5jdGlvbiAodmVsb2NpdHkpIHtcbiAgcmV0dXJuIE1hdGgubWF4KHRoaXMubWF4V2lkdGggLyAodmVsb2NpdHkgKyAxKSwgdGhpcy5taW5XaWR0aCk7XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLl9kcmF3UG9pbnQgPSBmdW5jdGlvbiAoeCwgeSwgc2l6ZSkge1xuICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXG4gIGN0eC5tb3ZlVG8oeCwgeSk7XG4gIGN0eC5hcmMoeCwgeSwgc2l6ZSwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgdGhpcy5faXNFbXB0eSA9IGZhbHNlO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fZHJhd0N1cnZlID0gZnVuY3Rpb24gKGN1cnZlLCBzdGFydFdpZHRoLCBlbmRXaWR0aCkge1xuICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICB2YXIgd2lkdGhEZWx0YSA9IGVuZFdpZHRoIC0gc3RhcnRXaWR0aDtcbiAgdmFyIGRyYXdTdGVwcyA9IE1hdGguZmxvb3IoY3VydmUubGVuZ3RoKCkpO1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRyYXdTdGVwczsgaSArPSAxKSB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBCZXppZXIgKHgsIHkpIGNvb3JkaW5hdGUgZm9yIHRoaXMgc3RlcC5cbiAgICB2YXIgdCA9IGkgLyBkcmF3U3RlcHM7XG4gICAgdmFyIHR0ID0gdCAqIHQ7XG4gICAgdmFyIHR0dCA9IHR0ICogdDtcbiAgICB2YXIgdSA9IDEgLSB0O1xuICAgIHZhciB1dSA9IHUgKiB1O1xuICAgIHZhciB1dXUgPSB1dSAqIHU7XG5cbiAgICB2YXIgeCA9IHV1dSAqIGN1cnZlLnN0YXJ0UG9pbnQueDtcbiAgICB4ICs9IDMgKiB1dSAqIHQgKiBjdXJ2ZS5jb250cm9sMS54O1xuICAgIHggKz0gMyAqIHUgKiB0dCAqIGN1cnZlLmNvbnRyb2wyLng7XG4gICAgeCArPSB0dHQgKiBjdXJ2ZS5lbmRQb2ludC54O1xuXG4gICAgdmFyIHkgPSB1dXUgKiBjdXJ2ZS5zdGFydFBvaW50Lnk7XG4gICAgeSArPSAzICogdXUgKiB0ICogY3VydmUuY29udHJvbDEueTtcbiAgICB5ICs9IDMgKiB1ICogdHQgKiBjdXJ2ZS5jb250cm9sMi55O1xuICAgIHkgKz0gdHR0ICogY3VydmUuZW5kUG9pbnQueTtcblxuICAgIHZhciB3aWR0aCA9IHN0YXJ0V2lkdGggKyB0dHQgKiB3aWR0aERlbHRhO1xuICAgIHRoaXMuX2RyYXdQb2ludCh4LCB5LCB3aWR0aCk7XG4gIH1cblxuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5maWxsKCk7XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLl9kcmF3RG90ID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gIHZhciB3aWR0aCA9IHR5cGVvZiB0aGlzLmRvdFNpemUgPT09ICdmdW5jdGlvbicgPyB0aGlzLmRvdFNpemUoKSA6IHRoaXMuZG90U2l6ZTtcblxuICBjdHguYmVnaW5QYXRoKCk7XG4gIHRoaXMuX2RyYXdQb2ludChwb2ludC54LCBwb2ludC55LCB3aWR0aCk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmZpbGwoKTtcbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX2Zyb21EYXRhID0gZnVuY3Rpb24gKHBvaW50R3JvdXBzLCBkcmF3Q3VydmUsIGRyYXdEb3QpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludEdyb3Vwcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHZhciBncm91cCA9IHBvaW50R3JvdXBzW2ldO1xuXG4gICAgaWYgKGdyb3VwLmxlbmd0aCA+IDEpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ3JvdXAubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgdmFyIHJhd1BvaW50ID0gZ3JvdXBbal07XG4gICAgICAgIHZhciBwb2ludCA9IG5ldyBQb2ludChyYXdQb2ludC54LCByYXdQb2ludC55LCByYXdQb2ludC50aW1lKTtcbiAgICAgICAgdmFyIGNvbG9yID0gcmF3UG9pbnQuY29sb3I7XG5cbiAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICAvLyBGaXJzdCBwb2ludCBpbiBhIGdyb3VwLiBOb3RoaW5nIHRvIGRyYXcgeWV0LlxuICAgICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgICAgdGhpcy5fYWRkUG9pbnQocG9pbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGogIT09IGdyb3VwLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAvLyBNaWRkbGUgcG9pbnQgaW4gYSBncm91cC5cbiAgICAgICAgICB2YXIgX2FkZFBvaW50MiA9IHRoaXMuX2FkZFBvaW50KHBvaW50KSxcbiAgICAgICAgICAgICAgY3VydmUgPSBfYWRkUG9pbnQyLmN1cnZlLFxuICAgICAgICAgICAgICB3aWR0aHMgPSBfYWRkUG9pbnQyLndpZHRocztcblxuICAgICAgICAgIGlmIChjdXJ2ZSAmJiB3aWR0aHMpIHtcbiAgICAgICAgICAgIGRyYXdDdXJ2ZShjdXJ2ZSwgd2lkdGhzLCBjb2xvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIExhc3QgcG9pbnQgaW4gYSBncm91cC4gRG8gbm90aGluZy5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgdmFyIF9yYXdQb2ludCA9IGdyb3VwWzBdO1xuICAgICAgZHJhd0RvdChfcmF3UG9pbnQpO1xuICAgIH1cbiAgfVxufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fdG9TVkcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIHZhciBwb2ludEdyb3VwcyA9IHRoaXMuX2RhdGE7XG4gIHZhciBjYW52YXMgPSB0aGlzLl9jYW52YXM7XG4gIHZhciByYXRpbyA9IE1hdGgubWF4KHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsIDEpO1xuICB2YXIgbWluWCA9IDA7XG4gIHZhciBtaW5ZID0gMDtcbiAgdmFyIG1heFggPSBjYW52YXMud2lkdGggLyByYXRpbztcbiAgdmFyIG1heFkgPSBjYW52YXMuaGVpZ2h0IC8gcmF0aW87XG4gIHZhciBzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3N2ZycpO1xuXG4gIHN2Zy5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnd2lkdGgnLCBjYW52YXMud2lkdGgpO1xuICBzdmcuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2hlaWdodCcsIGNhbnZhcy5oZWlnaHQpO1xuXG4gIHRoaXMuX2Zyb21EYXRhKHBvaW50R3JvdXBzLCBmdW5jdGlvbiAoY3VydmUsIHdpZHRocywgY29sb3IpIHtcbiAgICB2YXIgcGF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnKTtcblxuICAgIC8vIE5lZWQgdG8gY2hlY2sgY3VydmUgZm9yIE5hTiB2YWx1ZXMsIHRoZXNlIHBvcCB1cCB3aGVuIGRyYXdpbmdcbiAgICAvLyBsaW5lcyBvbiB0aGUgY2FudmFzIHRoYXQgYXJlIG5vdCBjb250aW51b3VzLiBFLmcuIFNoYXJwIGNvcm5lcnNcbiAgICAvLyBvciBzdG9wcGluZyBtaWQtc3Ryb2tlIGFuZCB0aGFuIGNvbnRpbnVpbmcgd2l0aG91dCBsaWZ0aW5nIG1vdXNlLlxuICAgIGlmICghaXNOYU4oY3VydmUuY29udHJvbDEueCkgJiYgIWlzTmFOKGN1cnZlLmNvbnRyb2wxLnkpICYmICFpc05hTihjdXJ2ZS5jb250cm9sMi54KSAmJiAhaXNOYU4oY3VydmUuY29udHJvbDIueSkpIHtcbiAgICAgIHZhciBhdHRyID0gJ00gJyArIGN1cnZlLnN0YXJ0UG9pbnQueC50b0ZpeGVkKDMpICsgJywnICsgY3VydmUuc3RhcnRQb2ludC55LnRvRml4ZWQoMykgKyAnICcgKyAoJ0MgJyArIGN1cnZlLmNvbnRyb2wxLngudG9GaXhlZCgzKSArICcsJyArIGN1cnZlLmNvbnRyb2wxLnkudG9GaXhlZCgzKSArICcgJykgKyAoY3VydmUuY29udHJvbDIueC50b0ZpeGVkKDMpICsgJywnICsgY3VydmUuY29udHJvbDIueS50b0ZpeGVkKDMpICsgJyAnKSArIChjdXJ2ZS5lbmRQb2ludC54LnRvRml4ZWQoMykgKyAnLCcgKyBjdXJ2ZS5lbmRQb2ludC55LnRvRml4ZWQoMykpO1xuXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZCcsIGF0dHIpO1xuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsICh3aWR0aHMuZW5kICogMi4yNSkudG9GaXhlZCgzKSk7XG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgY29sb3IpO1xuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnbm9uZScpO1xuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgJ3JvdW5kJyk7XG5cbiAgICAgIHN2Zy5hcHBlbmRDaGlsZChwYXRoKTtcbiAgICB9XG4gIH0sIGZ1bmN0aW9uIChyYXdQb2ludCkge1xuICAgIHZhciBjaXJjbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjaXJjbGUnKTtcbiAgICB2YXIgZG90U2l6ZSA9IHR5cGVvZiBfdGhpczIuZG90U2l6ZSA9PT0gJ2Z1bmN0aW9uJyA/IF90aGlzMi5kb3RTaXplKCkgOiBfdGhpczIuZG90U2l6ZTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKCdyJywgZG90U2l6ZSk7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZSgnY3gnLCByYXdQb2ludC54KTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKCdjeScsIHJhd1BvaW50LnkpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCByYXdQb2ludC5jb2xvcik7XG5cbiAgICBzdmcuYXBwZW5kQ2hpbGQoY2lyY2xlKTtcbiAgfSk7XG5cbiAgdmFyIHByZWZpeCA9ICdkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LCc7XG4gIHZhciBoZWFkZXIgPSAnPHN2ZycgKyAnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIicgKyAnIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiJyArICgnIHZpZXdCb3g9XCInICsgbWluWCArICcgJyArIG1pblkgKyAnICcgKyBtYXhYICsgJyAnICsgbWF4WSArICdcIicpICsgKCcgd2lkdGg9XCInICsgbWF4WCArICdcIicpICsgKCcgaGVpZ2h0PVwiJyArIG1heFkgKyAnXCInKSArICc+JztcbiAgdmFyIGJvZHkgPSBzdmcuaW5uZXJIVE1MO1xuXG4gIC8vIElFIGhhY2sgZm9yIG1pc3NpbmcgaW5uZXJIVE1MIHByb3BlcnR5IG9uIFNWR0VsZW1lbnRcbiAgaWYgKGJvZHkgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBkdW1teSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2R1bW15Jyk7XG4gICAgdmFyIG5vZGVzID0gc3ZnLmNoaWxkTm9kZXM7XG4gICAgZHVtbXkuaW5uZXJIVE1MID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBkdW1teS5hcHBlbmRDaGlsZChub2Rlc1tpXS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIH1cblxuICAgIGJvZHkgPSBkdW1teS5pbm5lckhUTUw7XG4gIH1cblxuICB2YXIgZm9vdGVyID0gJzwvc3ZnPic7XG4gIHZhciBkYXRhID0gaGVhZGVyICsgYm9keSArIGZvb3RlcjtcblxuICByZXR1cm4gcHJlZml4ICsgYnRvYShkYXRhKTtcbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuZnJvbURhdGEgPSBmdW5jdGlvbiAocG9pbnRHcm91cHMpIHtcbiAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgdGhpcy5jbGVhcigpO1xuXG4gIHRoaXMuX2Zyb21EYXRhKHBvaW50R3JvdXBzLCBmdW5jdGlvbiAoY3VydmUsIHdpZHRocykge1xuICAgIHJldHVybiBfdGhpczMuX2RyYXdDdXJ2ZShjdXJ2ZSwgd2lkdGhzLnN0YXJ0LCB3aWR0aHMuZW5kKTtcbiAgfSwgZnVuY3Rpb24gKHJhd1BvaW50KSB7XG4gICAgcmV0dXJuIF90aGlzMy5fZHJhd0RvdChyYXdQb2ludCk7XG4gIH0pO1xuXG4gIHRoaXMuX2RhdGEgPSBwb2ludEdyb3Vwcztcbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUudG9EYXRhID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fZGF0YTtcbn07XG5cbnJldHVybiBTaWduYXR1cmVQYWQ7XG5cbn0pKSk7XG4iLCIhZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLmNyZWF0ZU51bWJlck1hc2s9dCgpOmUuY3JlYXRlTnVtYmVyTWFzaz10KCl9KHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChuKXtpZihvW25dKXJldHVybiBvW25dLmV4cG9ydHM7dmFyIGk9b1tuXT17ZXhwb3J0czp7fSxpZDpuLGxvYWRlZDohMX07cmV0dXJuIGVbbl0uY2FsbChpLmV4cG9ydHMsaSxpLmV4cG9ydHMsdCksaS5sb2FkZWQ9ITAsaS5leHBvcnRzfXZhciBvPXt9O3JldHVybiB0Lm09ZSx0LmM9byx0LnA9XCJcIix0KDApfShbZnVuY3Rpb24oZSx0LG8pe2UuZXhwb3J0cz1vKDIpfSwsZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBvKCl7ZnVuY3Rpb24gZSgpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpsLHQ9ZS5sZW5ndGg7aWYoZT09PWx8fGVbMF09PT15WzBdJiYxPT09dClyZXR1cm4geS5zcGxpdChsKS5jb25jYXQoW3ZdKS5jb25jYXQoaC5zcGxpdChsKSk7aWYoZT09PWsmJk0pcmV0dXJuIHkuc3BsaXQobCkuY29uY2F0KFtcIjBcIixrLHZdKS5jb25jYXQoaC5zcGxpdChsKSk7dmFyIG89ZS5sYXN0SW5kZXhPZihrKSxjPW8hPT0tMSx1PWVbMF09PT1zJiZxLGE9dm9pZCAwLGI9dm9pZCAwLGc9dm9pZCAwO2lmKGUuc2xpY2UoVCotMSk9PT1oJiYoZT1lLnNsaWNlKDAsVCotMSkpLGMmJihNfHwkKT8oYT1lLnNsaWNlKGUuc2xpY2UoMCxSKT09PXk/UjowLG8pLGI9ZS5zbGljZShvKzEsdCksYj1uKGIucmVwbGFjZShmLGwpKSk6YT1lLnNsaWNlKDAsUik9PT15P2Uuc2xpY2UoUik6ZSxQJiYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFA/XCJ1bmRlZmluZWRcIjpyKFApKT09PXApe3ZhciBTPVwiLlwiPT09aj9cIlsuXVwiOlwiXCIraix3PShhLm1hdGNoKG5ldyBSZWdFeHAoUyxcImdcIikpfHxbXSkubGVuZ3RoO2E9YS5zbGljZSgwLFArdypaKX1yZXR1cm4gYT1hLnJlcGxhY2UoZixsKSxFfHwoYT1hLnJlcGxhY2UoL14wKygwJHxbXjBdKS8sXCIkMVwiKSksYT14P2koYSxqKTphLGc9bihhKSwoYyYmTXx8JD09PSEwKSYmKGVbby0xXSE9PWsmJmcucHVzaChtKSxnLnB1c2goayxtKSxiJiYoKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBMP1widW5kZWZpbmVkXCI6cihMKSk9PT1wJiYoYj1iLnNsaWNlKDAsTCkpLGc9Zy5jb25jYXQoYikpLCQ9PT0hMCYmZVtvLTFdPT09ayYmZy5wdXNoKHYpKSxSPjAmJihnPXkuc3BsaXQobCkuY29uY2F0KGcpKSx1JiYoZy5sZW5ndGg9PT1SJiZnLnB1c2godiksZz1bZF0uY29uY2F0KGcpKSxoLmxlbmd0aD4wJiYoZz1nLmNvbmNhdChoLnNwbGl0KGwpKSksZ312YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sbz10LnByZWZpeCx5PXZvaWQgMD09PW8/YzpvLGI9dC5zdWZmaXgsaD12b2lkIDA9PT1iP2w6YixnPXQuaW5jbHVkZVRob3VzYW5kc1NlcGFyYXRvcix4PXZvaWQgMD09PWd8fGcsUz10LnRob3VzYW5kc1NlcGFyYXRvclN5bWJvbCxqPXZvaWQgMD09PVM/dTpTLHc9dC5hbGxvd0RlY2ltYWwsTT12b2lkIDAhPT13JiZ3LE49dC5kZWNpbWFsU3ltYm9sLGs9dm9pZCAwPT09Tj9hOk4sRD10LmRlY2ltYWxMaW1pdCxMPXZvaWQgMD09PUQ/MjpELE89dC5yZXF1aXJlRGVjaW1hbCwkPXZvaWQgMCE9PU8mJk8sXz10LmFsbG93TmVnYXRpdmUscT12b2lkIDAhPT1fJiZfLEI9dC5hbGxvd0xlYWRpbmdaZXJvZXMsRT12b2lkIDAhPT1CJiZCLEk9dC5pbnRlZ2VyTGltaXQsUD12b2lkIDA9PT1JP251bGw6SSxSPXkmJnkubGVuZ3RofHwwLFQ9aCYmaC5sZW5ndGh8fDAsWj1qJiZqLmxlbmd0aHx8MDtyZXR1cm4gZS5pbnN0YW5jZU9mPVwiY3JlYXRlTnVtYmVyTWFza1wiLGV9ZnVuY3Rpb24gbihlKXtyZXR1cm4gZS5zcGxpdChsKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHYudGVzdChlKT92OmV9KX1mdW5jdGlvbiBpKGUsdCl7cmV0dXJuIGUucmVwbGFjZSgvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZyx0KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfTt0LmRlZmF1bHQ9bzt2YXIgYz1cIiRcIixsPVwiXCIsdT1cIixcIixhPVwiLlwiLHM9XCItXCIsZD0vLS8sZj0vXFxEKy9nLHA9XCJudW1iZXJcIix2PS9cXGQvLG09XCJbXVwifV0pfSk7IiwiIWZ1bmN0aW9uKGUscil7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9cigpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10scik6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy52YW5pbGxhVGV4dE1hc2s9cigpOmUudmFuaWxsYVRleHRNYXNrPXIoKX0odGhpcyxmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXtmdW5jdGlvbiByKG4pe2lmKHRbbl0pcmV0dXJuIHRbbl0uZXhwb3J0czt2YXIgbz10W25dPXtleHBvcnRzOnt9LGlkOm4sbG9hZGVkOiExfTtyZXR1cm4gZVtuXS5jYWxsKG8uZXhwb3J0cyxvLG8uZXhwb3J0cyxyKSxvLmxvYWRlZD0hMCxvLmV4cG9ydHN9dmFyIHQ9e307cmV0dXJuIHIubT1lLHIuYz10LHIucD1cIlwiLHIoMCl9KFtmdW5jdGlvbihlLHIsdCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gbyhlKXt2YXIgcj1lLmlucHV0RWxlbWVudCx0PSgwLHUuZGVmYXVsdCkoZSksbj1mdW5jdGlvbihlKXt2YXIgcj1lLnRhcmdldC52YWx1ZTtyZXR1cm4gdC51cGRhdGUocil9O3JldHVybiByLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLG4pLHQudXBkYXRlKHIudmFsdWUpLHt0ZXh0TWFza0lucHV0RWxlbWVudDp0LGRlc3Ryb3k6ZnVuY3Rpb24oKXtyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLG4pfX19T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksci5jb25mb3JtVG9NYXNrPXZvaWQgMCxyLm1hc2tJbnB1dD1vO3ZhciBpPXQoMik7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJjb25mb3JtVG9NYXNrXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG4oaSkuZGVmYXVsdH19KTt2YXIgYT10KDUpLHU9bihhKTtyLmRlZmF1bHQ9b30sZnVuY3Rpb24oZSxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyLnBsYWNlaG9sZGVyQ2hhcj1cIl9cIn0sZnVuY3Rpb24oZSxyLHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06YSxyPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTphLHQ9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnt9LG49dC5ndWlkZSx1PXZvaWQgMD09PW58fG4sbD10LnByZXZpb3VzQ29uZm9ybWVkVmFsdWUscz12b2lkIDA9PT1sP2E6bCxmPXQucGxhY2Vob2xkZXJDaGFyLGQ9dm9pZCAwPT09Zj9pLnBsYWNlaG9sZGVyQ2hhcjpmLGM9dC5wbGFjZWhvbGRlcix2PXZvaWQgMD09PWM/KDAsby5jb252ZXJ0TWFza1RvUGxhY2Vob2xkZXIpKHIsZCk6YyxwPXQuY3VycmVudENhcmV0UG9zaXRpb24saD10LmtlZXBDaGFyUG9zaXRpb25zLGc9dT09PSExJiZ2b2lkIDAhPT1zLG09ZS5sZW5ndGgseT1zLmxlbmd0aCxiPXYubGVuZ3RoLEM9ci5sZW5ndGgsUD1tLXkseD1QPjAsaz1wKyh4Py1QOjApLE89aytNYXRoLmFicyhQKTtpZihoPT09ITAmJiF4KXtmb3IodmFyIE09YSxUPWs7VDxPO1QrKyl2W1RdPT09ZCYmKE0rPWQpO2U9ZS5zbGljZSgwLGspK00rZS5zbGljZShrLG0pfWZvcih2YXIgdz1lLnNwbGl0KGEpLm1hcChmdW5jdGlvbihlLHIpe3JldHVybntjaGFyOmUsaXNOZXc6cj49ayYmcjxPfX0pLF89bS0xO18+PTA7Xy0tKXt2YXIgaj13W19dLmNoYXI7aWYoaiE9PWQpe3ZhciBWPV8+PWsmJnk9PT1DO2o9PT12W1Y/Xy1QOl9dJiZ3LnNwbGljZShfLDEpfX12YXIgUz1hLEU9ITE7ZTpmb3IodmFyIE49MDtOPGI7TisrKXt2YXIgQT12W05dO2lmKEE9PT1kKXtpZih3Lmxlbmd0aD4wKWZvcig7dy5sZW5ndGg+MDspe3ZhciBJPXcuc2hpZnQoKSxMPUkuY2hhcixSPUkuaXNOZXc7aWYoTD09PWQmJmchPT0hMCl7Uys9ZDtjb250aW51ZSBlfWlmKHJbTl0udGVzdChMKSl7aWYoaD09PSEwJiZSIT09ITEmJnMhPT1hJiZ1IT09ITEmJngpe2Zvcih2YXIgSj13Lmxlbmd0aCxxPW51bGwsRj0wO0Y8SjtGKyspe3ZhciBXPXdbRl07aWYoVy5jaGFyIT09ZCYmVy5pc05ldz09PSExKWJyZWFrO2lmKFcuY2hhcj09PWQpe3E9RjticmVha319bnVsbCE9PXE/KFMrPUwsdy5zcGxpY2UocSwxKSk6Ti0tfWVsc2UgUys9TDtjb250aW51ZSBlfUU9ITB9Zz09PSExJiYoUys9di5zdWJzdHIoTixiKSk7YnJlYWt9Uys9QX1pZihnJiZ4PT09ITEpe2Zvcih2YXIgej1udWxsLEI9MDtCPFMubGVuZ3RoO0IrKyl2W0JdPT09ZCYmKHo9Qik7Uz1udWxsIT09ej9TLnN1YnN0cigwLHorMSk6YX1yZXR1cm57Y29uZm9ybWVkVmFsdWU6UyxtZXRhOntzb21lQ2hhcnNSZWplY3RlZDpFfX19T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksci5kZWZhdWx0PW47dmFyIG89dCgzKSxpPXQoMSksYT1cIlwifSxmdW5jdGlvbihlLHIsdCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpsLHI9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnUucGxhY2Vob2xkZXJDaGFyO2lmKGUuaW5kZXhPZihyKSE9PS0xKXRocm93IG5ldyBFcnJvcihcIlBsYWNlaG9sZGVyIGNoYXJhY3RlciBtdXN0IG5vdCBiZSB1c2VkIGFzIHBhcnQgb2YgdGhlIG1hc2suIFBsZWFzZSBzcGVjaWZ5IGEgY2hhcmFjdGVyIHRoYXQgaXMgbm90IHByZXNlbnQgaW4geW91ciBtYXNrIGFzIHlvdXIgcGxhY2Vob2xkZXIgY2hhcmFjdGVyLlxcblxcblwiKyhcIlRoZSBwbGFjZWhvbGRlciBjaGFyYWN0ZXIgdGhhdCB3YXMgcmVjZWl2ZWQgaXM6IFwiK0pTT04uc3RyaW5naWZ5KHIpK1wiXFxuXFxuXCIpKyhcIlRoZSBtYXNrIHRoYXQgd2FzIHJlY2VpdmVkIGlzOiBcIitKU09OLnN0cmluZ2lmeShlKSkpO3JldHVybiBlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIFJlZ0V4cD9yOmV9KS5qb2luKFwiXCIpfWZ1bmN0aW9uIG8oZSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGV8fGUgaW5zdGFuY2VvZiBTdHJpbmd9ZnVuY3Rpb24gaShlKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgZSYmdm9pZCAwPT09ZS5sZW5ndGgmJiFpc05hTihlKX1mdW5jdGlvbiBhKGUpe2Zvcih2YXIgcj1bXSx0PXZvaWQgMDt0PWUuaW5kZXhPZihzKSx0IT09LTE7KXIucHVzaCh0KSxlLnNwbGljZSh0LDEpO3JldHVybnttYXNrV2l0aG91dENhcmV0VHJhcHM6ZSxpbmRleGVzOnJ9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHIuY29udmVydE1hc2tUb1BsYWNlaG9sZGVyPW4sci5pc1N0cmluZz1vLHIuaXNOdW1iZXI9aSxyLnByb2Nlc3NDYXJldFRyYXBzPWE7dmFyIHU9dCgxKSxsPVtdLHM9XCJbXVwifSxmdW5jdGlvbihlLHIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHQoZSl7dmFyIHI9ZS5wcmV2aW91c0NvbmZvcm1lZFZhbHVlLHQ9dm9pZCAwPT09cj9vOnIsaT1lLnByZXZpb3VzUGxhY2Vob2xkZXIsYT12b2lkIDA9PT1pP286aSx1PWUuY3VycmVudENhcmV0UG9zaXRpb24sbD12b2lkIDA9PT11PzA6dSxzPWUuY29uZm9ybWVkVmFsdWUsZj1lLnJhd1ZhbHVlLGQ9ZS5wbGFjZWhvbGRlckNoYXIsYz1lLnBsYWNlaG9sZGVyLHY9ZS5pbmRleGVzT2ZQaXBlZENoYXJzLHA9dm9pZCAwPT09dj9uOnYsaD1lLmNhcmV0VHJhcEluZGV4ZXMsZz12b2lkIDA9PT1oP246aDtpZigwPT09bClyZXR1cm4gMDt2YXIgbT1mLmxlbmd0aCx5PXQubGVuZ3RoLGI9Yy5sZW5ndGgsQz1zLmxlbmd0aCxQPW0teSx4PVA+MCxrPTA9PT15LE89UD4xJiYheCYmIWs7aWYoTylyZXR1cm4gbDt2YXIgTT14JiYodD09PXN8fHM9PT1jKSxUPTAsdz12b2lkIDAsXz12b2lkIDA7aWYoTSlUPWwtUDtlbHNle3ZhciBqPXMudG9Mb3dlckNhc2UoKSxWPWYudG9Mb3dlckNhc2UoKSxTPVYuc3Vic3RyKDAsbCkuc3BsaXQobyksRT1TLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gai5pbmRleE9mKGUpIT09LTF9KTtfPUVbRS5sZW5ndGgtMV07dmFyIE49YS5zdWJzdHIoMCxFLmxlbmd0aCkuc3BsaXQobykuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlIT09ZH0pLmxlbmd0aCxBPWMuc3Vic3RyKDAsRS5sZW5ndGgpLnNwbGl0KG8pLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZSE9PWR9KS5sZW5ndGgsST1BIT09TixMPXZvaWQgMCE9PWFbRS5sZW5ndGgtMV0mJnZvaWQgMCE9PWNbRS5sZW5ndGgtMl0mJmFbRS5sZW5ndGgtMV0hPT1kJiZhW0UubGVuZ3RoLTFdIT09Y1tFLmxlbmd0aC0xXSYmYVtFLmxlbmd0aC0xXT09PWNbRS5sZW5ndGgtMl07IXgmJihJfHxMKSYmTj4wJiZjLmluZGV4T2YoXyk+LTEmJnZvaWQgMCE9PWZbbF0mJih3PSEwLF89ZltsXSk7Zm9yKHZhciBSPXAubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBqW2VdfSksSj1SLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZT09PV99KS5sZW5ndGgscT1FLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZT09PV99KS5sZW5ndGgsRj1jLnN1YnN0cigwLGMuaW5kZXhPZihkKSkuc3BsaXQobykuZmlsdGVyKGZ1bmN0aW9uKGUscil7cmV0dXJuIGU9PT1fJiZmW3JdIT09ZX0pLmxlbmd0aCxXPUYrcStKKyh3PzE6MCksej0wLEI9MDtCPEM7QisrKXt2YXIgRD1qW0JdO2lmKFQ9QisxLEQ9PT1fJiZ6Kyssej49VylicmVha319aWYoeCl7Zm9yKHZhciBHPVQsSD1UO0g8PWI7SCsrKWlmKGNbSF09PT1kJiYoRz1IKSxjW0hdPT09ZHx8Zy5pbmRleE9mKEgpIT09LTF8fEg9PT1iKXJldHVybiBHfWVsc2UgaWYodyl7Zm9yKHZhciBLPVQtMTtLPj0wO0stLSlpZihzW0tdPT09X3x8Zy5pbmRleE9mKEspIT09LTF8fDA9PT1LKXJldHVybiBLfWVsc2UgZm9yKHZhciBRPVQ7UT49MDtRLS0paWYoY1tRLTFdPT09ZHx8Zy5pbmRleE9mKFEpIT09LTF8fDA9PT1RKXJldHVybiBRfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHIuZGVmYXVsdD10O3ZhciBuPVtdLG89XCJcIn0sZnVuY3Rpb24oZSxyLHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIG8oZSl7dmFyIHI9e3ByZXZpb3VzQ29uZm9ybWVkVmFsdWU6dm9pZCAwLHByZXZpb3VzUGxhY2Vob2xkZXI6dm9pZCAwfTtyZXR1cm57c3RhdGU6cix1cGRhdGU6ZnVuY3Rpb24odCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOmUsbz1uLmlucHV0RWxlbWVudCxzPW4ubWFzayxkPW4uZ3VpZGUsbT1uLnBpcGUsYj1uLnBsYWNlaG9sZGVyQ2hhcixDPXZvaWQgMD09PWI/cC5wbGFjZWhvbGRlckNoYXI6YixQPW4ua2VlcENoYXJQb3NpdGlvbnMseD12b2lkIDAhPT1QJiZQLGs9bi5zaG93TWFzayxPPXZvaWQgMCE9PWsmJms7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHQmJih0PW8udmFsdWUpLHQhPT1yLnByZXZpb3VzQ29uZm9ybWVkVmFsdWUpeyhcInVuZGVmaW5lZFwiPT10eXBlb2Ygcz9cInVuZGVmaW5lZFwiOmwocykpPT09eSYmdm9pZCAwIT09cy5waXBlJiZ2b2lkIDAhPT1zLm1hc2smJihtPXMucGlwZSxzPXMubWFzayk7dmFyIE09dm9pZCAwLFQ9dm9pZCAwO2lmKHMgaW5zdGFuY2VvZiBBcnJheSYmKE09KDAsdi5jb252ZXJ0TWFza1RvUGxhY2Vob2xkZXIpKHMsQykpLHMhPT0hMSl7dmFyIHc9YSh0KSxfPW8uc2VsZWN0aW9uRW5kLGo9ci5wcmV2aW91c0NvbmZvcm1lZFZhbHVlLFY9ci5wcmV2aW91c1BsYWNlaG9sZGVyLFM9dm9pZCAwO2lmKChcInVuZGVmaW5lZFwiPT10eXBlb2Ygcz9cInVuZGVmaW5lZFwiOmwocykpPT09aCl7aWYoVD1zKHcse2N1cnJlbnRDYXJldFBvc2l0aW9uOl8scHJldmlvdXNDb25mb3JtZWRWYWx1ZTpqLHBsYWNlaG9sZGVyQ2hhcjpDfSksVD09PSExKXJldHVybjt2YXIgRT0oMCx2LnByb2Nlc3NDYXJldFRyYXBzKShUKSxOPUUubWFza1dpdGhvdXRDYXJldFRyYXBzLEE9RS5pbmRleGVzO1Q9TixTPUEsTT0oMCx2LmNvbnZlcnRNYXNrVG9QbGFjZWhvbGRlcikoVCxDKX1lbHNlIFQ9czt2YXIgST17cHJldmlvdXNDb25mb3JtZWRWYWx1ZTpqLGd1aWRlOmQscGxhY2Vob2xkZXJDaGFyOkMscGlwZTptLHBsYWNlaG9sZGVyOk0sY3VycmVudENhcmV0UG9zaXRpb246XyxrZWVwQ2hhclBvc2l0aW9uczp4fSxMPSgwLGMuZGVmYXVsdCkodyxULEkpLFI9TC5jb25mb3JtZWRWYWx1ZSxKPShcInVuZGVmaW5lZFwiPT10eXBlb2YgbT9cInVuZGVmaW5lZFwiOmwobSkpPT09aCxxPXt9O0omJihxPW0oUix1KHtyYXdWYWx1ZTp3fSxJKSkscT09PSExP3E9e3ZhbHVlOmoscmVqZWN0ZWQ6ITB9OigwLHYuaXNTdHJpbmcpKHEpJiYocT17dmFsdWU6cX0pKTt2YXIgRj1KP3EudmFsdWU6UixXPSgwLGYuZGVmYXVsdCkoe3ByZXZpb3VzQ29uZm9ybWVkVmFsdWU6aixwcmV2aW91c1BsYWNlaG9sZGVyOlYsY29uZm9ybWVkVmFsdWU6RixwbGFjZWhvbGRlcjpNLHJhd1ZhbHVlOncsY3VycmVudENhcmV0UG9zaXRpb246XyxwbGFjZWhvbGRlckNoYXI6QyxpbmRleGVzT2ZQaXBlZENoYXJzOnEuaW5kZXhlc09mUGlwZWRDaGFycyxjYXJldFRyYXBJbmRleGVzOlN9KSx6PUY9PT1NJiYwPT09VyxCPU8/TTpnLEQ9ej9COkY7ci5wcmV2aW91c0NvbmZvcm1lZFZhbHVlPUQsci5wcmV2aW91c1BsYWNlaG9sZGVyPU0sby52YWx1ZSE9PUQmJihvLnZhbHVlPUQsaShvLFcpKX19fX19ZnVuY3Rpb24gaShlLHIpe2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQ9PT1lJiYoYj9DKGZ1bmN0aW9uKCl7cmV0dXJuIGUuc2V0U2VsZWN0aW9uUmFuZ2UocixyLG0pfSwwKTplLnNldFNlbGVjdGlvblJhbmdlKHIscixtKSl9ZnVuY3Rpb24gYShlKXtpZigoMCx2LmlzU3RyaW5nKShlKSlyZXR1cm4gZTtpZigoMCx2LmlzTnVtYmVyKShlKSlyZXR1cm4gU3RyaW5nKGUpO2lmKHZvaWQgMD09PWV8fG51bGw9PT1lKXJldHVybiBnO3Rocm93IG5ldyBFcnJvcihcIlRoZSAndmFsdWUnIHByb3ZpZGVkIHRvIFRleHQgTWFzayBuZWVkcyB0byBiZSBhIHN0cmluZyBvciBhIG51bWJlci4gVGhlIHZhbHVlIHJlY2VpdmVkIHdhczpcXG5cXG4gXCIrSlNPTi5zdHJpbmdpZnkoZSkpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB1PU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspe3ZhciB0PWFyZ3VtZW50c1tyXTtmb3IodmFyIG4gaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmKGVbbl09dFtuXSl9cmV0dXJuIGV9LGw9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX07ci5kZWZhdWx0PW87dmFyIHM9dCg0KSxmPW4ocyksZD10KDIpLGM9bihkKSx2PXQoMykscD10KDEpLGg9XCJmdW5jdGlvblwiLGc9XCJcIixtPVwibm9uZVwiLHk9XCJvYmplY3RcIixiPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBuYXZpZ2F0b3ImJi9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxDPVwidW5kZWZpbmVkXCIhPXR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWU/cmVxdWVzdEFuaW1hdGlvbkZyYW1lOnNldFRpbWVvdXR9XSl9KTsiLCIoZnVuY3Rpb24oc2VsZikge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHNlbGYuZmV0Y2gpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdXBwb3J0ID0ge1xuICAgIHNlYXJjaFBhcmFtczogJ1VSTFNlYXJjaFBhcmFtcycgaW4gc2VsZixcbiAgICBpdGVyYWJsZTogJ1N5bWJvbCcgaW4gc2VsZiAmJiAnaXRlcmF0b3InIGluIFN5bWJvbCxcbiAgICBibG9iOiAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJiAnQmxvYicgaW4gc2VsZiAmJiAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQmxvYigpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfVxuXG4gIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gICAgdmFyIHZpZXdDbGFzc2VzID0gW1xuICAgICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nXG4gICAgXVxuXG4gICAgdmFyIGlzRGF0YVZpZXcgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxuICAgIH1cblxuICAgIHZhciBpc0FycmF5QnVmZmVyVmlldyA9IEFycmF5QnVmZmVyLmlzVmlldyB8fCBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSlcbiAgICB9XG4gICAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXFxeX2B8fl0vaS50ZXN0KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZScpXG4gICAgfVxuICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KClcbiAgICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICAgIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9XG5cbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICAgIH0sIHRoaXMpXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKVxuICAgICAgfSwgdGhpcylcbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKVxuICAgICAgfSwgdGhpcylcbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXVxuICAgIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSsnLCcrdmFsdWUgOiB2YWx1ZVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gICAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW11cbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHsgaXRlbXMucHVzaChuYW1lKSB9KVxuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7IGl0ZW1zLnB1c2godmFsdWUpIH0pXG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSkgfSlcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH1cblxuICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgIEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzXG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdClcbiAgICAgIH1cbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgICByZWFkZXIucmVhZEFzVGV4dChibG9iKVxuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQXJyYXlCdWZmZXJBc1RleHQoYnVmKSB7XG4gICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodmlld1tpXSlcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpXG4gIH1cblxuICBmdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHtcbiAgICBpZiAoYnVmLnNsaWNlKSB7XG4gICAgICByZXR1cm4gYnVmLnNsaWNlKDApXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ5dGVMZW5ndGgpXG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKVxuICAgICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gQm9keSgpIHtcbiAgICB0aGlzLmJvZHlVc2VkID0gZmFsc2VcblxuICAgIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgdGhpcy5fYm9keUluaXQgPSBib2R5XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJ1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keS50b1N0cmluZygpXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keS5idWZmZXIpXG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgKEFycmF5QnVmZmVyLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpIHx8IGlzQXJyYXlCdWZmZXJWaWV3KGJvZHkpKSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBCb2R5SW5pdCB0eXBlJylcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpXG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04JylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnN1bWVkKHRoaXMpIHx8IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gIHZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddXG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICAgIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICByZXR1cm4gKG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xKSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5XG5cbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJylcbiAgICAgIH1cbiAgICAgIHRoaXMudXJsID0gaW5wdXQudXJsXG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHNcbiAgICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpXG4gICAgICB9XG4gICAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZFxuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZVxuICAgICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXRcbiAgICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXJsID0gU3RyaW5nKGlucHV0KVxuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ29taXQnXG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbFxuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgfVxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpXG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7IGJvZHk6IHRoaXMuX2JvZHlJbml0IH0pXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICAgIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgICBib2R5LnRyaW0oKS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpXG4gICAgcmF3SGVhZGVycy5zcGxpdCgvXFxyP1xcbi8pLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOicpXG4gICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKClcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKVxuICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSlcblxuICBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnXG4gICAgdGhpcy5zdGF0dXMgPSAnc3RhdHVzJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXMgOiAyMDBcbiAgICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwXG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJ3N0YXR1c1RleHQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiAnT0snXG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJydcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdClcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpXG5cbiAgUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgICB1cmw6IHRoaXMudXJsXG4gICAgfSlcbiAgfVxuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSlcbiAgICByZXNwb25zZS50eXBlID0gJ2Vycm9yJ1xuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cbiAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbiAgfVxuXG4gIHNlbGYuSGVhZGVycyA9IEhlYWRlcnNcbiAgc2VsZi5SZXF1ZXN0ID0gUmVxdWVzdFxuICBzZWxmLlJlc3BvbnNlID0gUmVzcG9uc2VcblxuICBzZWxmLmZldGNoID0gZnVuY3Rpb24oaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KVxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG5cbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpXG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKVxuICAgICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dFxuICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKVxuICAgICAgfVxuXG4gICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC51cmwsIHRydWUpXG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhociAmJiBzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJ1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgIH0pXG5cbiAgICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpXG4gICAgfSlcbiAgfVxuICBzZWxmLmZldGNoLnBvbHlmaWxsID0gdHJ1ZVxufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMpO1xuIl19
